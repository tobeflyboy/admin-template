Object.defineProperty(exports, '__esModule', { value: true });
const require_chunk = require('./chunk-CUT6urMc.cjs');
const require_helper = require('./helper-Dwzt-HKi.cjs');
const require_server = require('./server-CZwOQzgC.cjs');
const __pengzhanbo_utils = require_chunk.__toESM(require("@pengzhanbo/utils"));
const picocolors = require_chunk.__toESM(require("picocolors"));
const node_fs = require_chunk.__toESM(require("node:fs"));
const node_fs_promises = require_chunk.__toESM(require("node:fs/promises"));
const node_path = require_chunk.__toESM(require("node:path"));
const node_process = require_chunk.__toESM(require("node:process"));
const __rollup_pluginutils = require_chunk.__toESM(require("@rollup/pluginutils"));
const fast_glob = require_chunk.__toESM(require("fast-glob"));
const is_core_module = require_chunk.__toESM(require("is-core-module"));
const node_url = require_chunk.__toESM(require("node:url"));
const esbuild = require_chunk.__toESM(require("esbuild"));
const json5 = require_chunk.__toESM(require("json5"));
const path_to_regexp = require_chunk.__toESM(require("path-to-regexp"));
const cors = require_chunk.__toESM(require("cors"));
const node_events = require_chunk.__toESM(require("node:events"));
const chokidar = require_chunk.__toESM(require("chokidar"));

//#region src/core/compiler.ts
const externalizeDeps = {
	name: "externalize-deps",
	setup(build$1) {
		build$1.onResolve({ filter: /.*/ }, ({ path: id }) => {
			if (id[0] !== "." && !node_path.default.isAbsolute(id)) return { external: true };
		});
	}
};
const json5Loader = {
	name: "json5-loader",
	setup(build$1) {
		build$1.onLoad({ filter: /\.json5$/ }, async ({ path: path$2 }) => {
			const content = await node_fs.promises.readFile(path$2, "utf-8");
			return {
				contents: `export default ${JSON.stringify(json5.default.parse(content))}`,
				loader: "js"
			};
		});
	}
};
const jsonLoader = {
	name: "json-loader",
	setup(build$1) {
		build$1.onLoad({ filter: /\.json$/ }, async ({ path: path$2 }) => {
			const content = await node_fs.promises.readFile(path$2, "utf-8");
			return {
				contents: `export default ${content}`,
				loader: "js"
			};
		});
	}
};
const renamePlugin = {
	name: "rename-plugin",
	setup(build$1) {
		build$1.onResolve({ filter: /.*/ }, ({ path: id }) => {
			if (id === "vite-plugin-mock-dev-server") return {
				path: "vite-plugin-mock-dev-server/helper",
				external: true
			};
			return null;
		});
	}
};
function aliasPlugin(alias) {
	return {
		name: "alias-plugin",
		setup(build$1) {
			build$1.onResolve({ filter: /.*/ }, async ({ path: id }) => {
				const matchedEntry = alias.find(({ find: find$1 }) => aliasMatches(find$1, id));
				if (!matchedEntry) return null;
				const { find, replacement } = matchedEntry;
				const result = await build$1.resolve(id.replace(find, replacement), {
					kind: "import-statement",
					resolveDir: replacement,
					namespace: "file"
				});
				return {
					path: result.path,
					external: false
				};
			});
		}
	};
}
function aliasMatches(pattern, importee) {
	if (pattern instanceof RegExp) return pattern.test(importee);
	if (importee.length < pattern.length) return false;
	if (importee === pattern) return true;
	return importee.startsWith(`${pattern}/`);
}
async function transformWithEsbuild(entryPoint, options) {
	const { isESM = true, define, alias, cwd = node_process.default.cwd() } = options;
	const filepath = node_path.default.resolve(cwd, entryPoint);
	const filename = node_path.default.basename(entryPoint);
	const dirname = node_path.default.dirname(filepath);
	try {
		const result = await (0, esbuild.build)({
			entryPoints: [entryPoint],
			outfile: "out.js",
			write: false,
			target: ["node18"],
			platform: "node",
			bundle: true,
			metafile: true,
			format: isESM ? "esm" : "cjs",
			define: {
				...define,
				__dirname: JSON.stringify(dirname),
				__filename: JSON.stringify(filename),
				...isESM ? {} : { "import.meta.url": JSON.stringify((0, node_url.pathToFileURL)(filepath)) }
			},
			plugins: [
				aliasPlugin(alias),
				renamePlugin,
				externalizeDeps,
				jsonLoader,
				json5Loader
			],
			absWorkingDir: cwd
		});
		return {
			code: result.outputFiles[0].text,
			deps: result.metafile?.inputs || {}
		};
	} catch (e) {
		console.error(e);
	}
	return {
		code: "",
		deps: {}
	};
}
async function loadFromCode({ filepath, code, isESM, cwd }) {
	filepath = node_path.default.resolve(cwd, filepath);
	const ext = isESM ? ".mjs" : ".cjs";
	const filepathTmp = `${filepath}.timestamp-${Date.now()}${ext}`;
	const file = (0, node_url.pathToFileURL)(filepathTmp).toString();
	await node_fs.promises.writeFile(filepathTmp, code, "utf8");
	try {
		const mod = await import(file);
		return mod.default || mod;
	} finally {
		try {
			node_fs.default.unlinkSync(filepathTmp);
		} catch {}
	}
}

//#endregion
//#region src/core/build.ts
async function generateMockServer(ctx, options) {
	const include = (0, __pengzhanbo_utils.toArray)(options.include);
	const exclude = (0, __pengzhanbo_utils.toArray)(options.exclude);
	const cwd = options.cwd || node_process.default.cwd();
	let pkg = {};
	try {
		const pkgStr = require_server.lookupFile(options.context, ["package.json"]);
		if (pkgStr) pkg = JSON.parse(pkgStr);
	} catch {}
	const outputDir = options.build.dist;
	const content = await generateMockEntryCode(cwd, include, exclude);
	const mockEntry = node_path.default.join(cwd, `mock-data-${Date.now()}.js`);
	await node_fs_promises.default.writeFile(mockEntry, content, "utf-8");
	const { code, deps } = await transformWithEsbuild(mockEntry, options);
	const mockDeps = getMockDependencies(deps, options.alias);
	await node_fs_promises.default.unlink(mockEntry);
	const outputList = [
		{
			filename: node_path.default.join(outputDir, "mock-data.js"),
			source: code
		},
		{
			filename: node_path.default.join(outputDir, "index.js"),
			source: generatorServerEntryCode(options)
		},
		{
			filename: node_path.default.join(outputDir, "package.json"),
			source: generatePackageJson(pkg, mockDeps)
		}
	];
	try {
		if (node_path.default.isAbsolute(outputDir)) {
			for (const { filename } of outputList) if (node_fs.default.existsSync(filename)) await node_fs_promises.default.rm(filename);
			options.logger.info(`${picocolors.default.green("✓")} generate mock server in ${picocolors.default.cyan(outputDir)}`);
			for (const { filename, source } of outputList) {
				node_fs.default.mkdirSync(node_path.default.dirname(filename), { recursive: true });
				await node_fs_promises.default.writeFile(filename, source, "utf-8");
				const sourceSize = (source.length / 1024).toFixed(2);
				const name = node_path.default.relative(outputDir, filename);
				const space = name.length < 30 ? " ".repeat(30 - name.length) : "";
				options.logger.info(`  ${picocolors.default.green(name)}${space}${picocolors.default.bold(picocolors.default.dim(`${sourceSize} kB`))}`);
			}
		} else for (const { filename, source } of outputList) ctx.emitFile({
			type: "asset",
			fileName: filename,
			source
		});
	} catch (e) {
		console.error(e);
	}
}
function getMockDependencies(deps, alias) {
	const list = /* @__PURE__ */ new Set();
	const excludeDeps = [
		__PACKAGE_NAME__,
		"connect",
		"cors"
	];
	const isAlias = (p) => alias.find(({ find }) => aliasMatches(find, p));
	Object.keys(deps).forEach((mPath) => {
		const imports = deps[mPath].imports.filter((_) => _.external && !_.path.startsWith("<define:") && !isAlias(_.path)).map((_) => _.path);
		imports.forEach((dep) => {
			const name = normalizePackageName(dep);
			if (!excludeDeps.includes(name) && !(0, is_core_module.default)(name)) list.add(name);
		});
	});
	return Array.from(list);
}
function normalizePackageName(dep) {
	const [scope, name] = dep.split("/");
	if (scope[0] === "@") return `${scope}/${name}`;
	return scope;
}
function generatePackageJson(pkg, mockDeps) {
	const { dependencies = {}, devDependencies = {} } = pkg;
	const dependents = {
		...dependencies,
		...devDependencies
	};
	const mockPkg = {
		name: "mock-server",
		type: "module",
		scripts: { start: "node index.js" },
		dependencies: {
			connect: "^3.7.0",
			[__PACKAGE_NAME__]: `^${__PACKAGE_VERSION__}`,
			cors: "^2.8.5"
		},
		pnpm: { peerDependencyRules: { ignoreMissing: ["vite"] } }
	};
	mockDeps.forEach((dep) => {
		mockPkg.dependencies[dep] = dependents[dep] || "latest";
	});
	return JSON.stringify(mockPkg, null, 2);
}
function generatorServerEntryCode({ proxies, wsProxies, cookiesOptions, bodyParserOptions, priority, build: build$1 }) {
	const { serverPort, log } = build$1;
	return `import { createServer } from 'node:http';
import connect from 'connect';
import corsMiddleware from 'cors';
import { baseMiddleware, createLogger, mockWebSocket } from 'vite-plugin-mock-dev-server/server';
import mockData from './mock-data.js';

const app = connect();
const server = createServer(app);
const logger = createLogger('mock-server', '${log}');
const proxies = ${JSON.stringify(proxies)};
const wsProxies = ${JSON.stringify(wsProxies)};
const cookiesOptions = ${JSON.stringify(cookiesOptions)};
const bodyParserOptions = ${JSON.stringify(bodyParserOptions)};
const priority = ${JSON.stringify(priority)};
const compiler = { mockData }

mockWebSocket(compiler, server, { wsProxies, cookiesOptions, logger });

app.use(corsMiddleware());
app.use(baseMiddleware(compiler, {
  formidableOptions: { multiples: true },
  proxies,
  priority,
  cookiesOptions,
  bodyParserOptions,
  logger,
}));

server.listen(${serverPort});

console.log('listen: http://localhost:${serverPort}');
`;
}
async function generateMockEntryCode(cwd, include, exclude) {
	const includePaths = await (0, fast_glob.default)(include, { cwd });
	const includeFilter = (0, __rollup_pluginutils.createFilter)(include, exclude, { resolve: false });
	const mockFiles = includePaths.filter(includeFilter);
	let importers = "";
	const exporters = [];
	mockFiles.forEach((filepath, index) => {
		const file = require_server.normalizePath(node_path.default.join(cwd, filepath));
		importers += `import * as m${index} from '${file}';\n`;
		exporters.push(`[m${index}, '${filepath}']`);
	});
	return `import { transformMockData, transformRawData } from 'vite-plugin-mock-dev-server/server';
${importers}
const exporters = [\n  ${exporters.join(",\n  ")}\n];
const mockList = exporters.map(([mod, filepath]) => {
  const raw = mod.default || mod;
  return transformRawData(raw, filepath);
});
export default transformMockData(mockList);`;
}

//#endregion
//#region src/core/mockCompiler.ts
function createMockCompiler(options) {
	return new MockCompiler(options);
}
/**
* mock配置加载器
*/
var MockCompiler = class extends node_events.default {
	moduleCache = /* @__PURE__ */ new Map();
	moduleDeps = /* @__PURE__ */ new Map();
	cwd;
	mockWatcher;
	depsWatcher;
	moduleType = "cjs";
	_mockData = {};
	constructor(options) {
		super();
		this.options = options;
		this.cwd = options.cwd || node_process.default.cwd();
		try {
			const pkg = require_server.lookupFile(this.cwd, ["package.json"]);
			this.moduleType = !!pkg && JSON.parse(pkg).type === "module" ? "esm" : "cjs";
		} catch {}
	}
	get mockData() {
		return this._mockData;
	}
	run() {
		const { include, exclude } = this.options;
		/**
		* 使用 rollup 提供的 include/exclude 规则，
		* 过滤包含文件
		*/
		const includeFilter = (0, __rollup_pluginutils.createFilter)(include, exclude, { resolve: false });
		(0, fast_glob.default)(include, { cwd: this.cwd }).then((files) => files.filter(includeFilter).map((file) => () => this.loadMock(file))).then((loadList) => (0, __pengzhanbo_utils.promiseParallel)(loadList, 10)).then(() => this.updateMockList());
		this.watchMockEntry();
		this.watchDeps();
		let timer = null;
		this.on("mock:update", async (filepath) => {
			if (!includeFilter(filepath)) return;
			await this.loadMock(filepath);
			if (timer) clearImmediate(timer);
			timer = setImmediate(() => {
				this.updateMockList();
				this.emit("mock:update-end", filepath);
				timer = null;
			});
		});
		this.on("mock:unlink", async (filepath) => {
			if (!includeFilter(filepath)) return;
			this.moduleCache.delete(filepath);
			this.updateMockList();
			this.emit("mock:update-end", filepath);
		});
	}
	watchMockEntry() {
		const { include } = this.options;
		const [firstGlob, ...otherGlob] = (0, __pengzhanbo_utils.toArray)(include);
		const watcher = this.mockWatcher = chokidar.default.watch(firstGlob, {
			ignoreInitial: true,
			cwd: this.cwd
		});
		if (otherGlob.length > 0) otherGlob.forEach((glob) => watcher.add(glob));
		watcher.on("add", async (filepath) => {
			filepath = require_server.normalizePath(filepath);
			this.emit("mock:update", filepath);
			require_server.debug("watcher:add", filepath);
		});
		watcher.on("change", async (filepath) => {
			filepath = require_server.normalizePath(filepath);
			this.emit("mock:update", filepath);
			require_server.debug("watcher:change", filepath);
		});
		watcher.on("unlink", async (filepath) => {
			filepath = require_server.normalizePath(filepath);
			this.emit("mock:unlink", filepath);
			require_server.debug("watcher:unlink", filepath);
		});
	}
	/**
	* 监听 mock文件依赖的本地文件变动，
	* mock依赖文件更新，mock文件也一并更新
	*/
	watchDeps() {
		const oldDeps = [];
		this.depsWatcher = chokidar.default.watch([], {
			ignoreInitial: true,
			cwd: this.cwd
		});
		this.depsWatcher.on("change", (filepath) => {
			filepath = require_server.normalizePath(filepath);
			const mockFiles = this.moduleDeps.get(filepath);
			mockFiles?.forEach((file) => {
				this.emit("mock:update", file);
			});
		});
		this.depsWatcher.on("unlink", (filepath) => {
			filepath = require_server.normalizePath(filepath);
			this.moduleDeps.delete(filepath);
		});
		this.on("update:deps", () => {
			const deps = [];
			for (const [dep] of this.moduleDeps.entries()) deps.push(dep);
			const exactDeps = deps.filter((dep) => !oldDeps.includes(dep));
			if (exactDeps.length > 0) this.depsWatcher.add(exactDeps);
		});
	}
	close() {
		this.mockWatcher?.close();
		this.depsWatcher?.close();
	}
	updateMockList() {
		this._mockData = require_server.transformMockData(this.moduleCache);
	}
	updateModuleDeps(filepath, deps) {
		Object.keys(deps).forEach((mPath) => {
			const imports = deps[mPath].imports.map((_) => _.path);
			imports.forEach((dep) => {
				if (!this.moduleDeps.has(dep)) this.moduleDeps.set(dep, /* @__PURE__ */ new Set());
				const cur = this.moduleDeps.get(dep);
				cur.add(filepath);
			});
		});
		this.emit("update:deps");
	}
	async loadMock(filepath) {
		if (!filepath) return;
		let isESM = false;
		if (/\.m[jt]s$/.test(filepath)) isESM = true;
		else if (/\.c[jt]s$/.test(filepath)) isESM = false;
		else isESM = this.moduleType === "esm";
		const { define, alias } = this.options;
		const { code, deps } = await transformWithEsbuild(filepath, {
			isESM,
			define,
			alias,
			cwd: this.cwd
		});
		try {
			const raw = await loadFromCode({
				filepath,
				code,
				isESM,
				cwd: this.cwd
			}) || {};
			this.moduleCache.set(filepath, require_server.transformRawData(raw, filepath));
			this.updateModuleDeps(filepath, deps);
		} catch (e) {
			console.error(e);
		}
	}
};

//#endregion
//#region src/core/mockMiddleware.ts
function mockServerMiddleware(options, server, ws) {
	/**
	* 加载 mock 文件, 包括监听 mock 文件的依赖文件变化，
	* 并注入 vite  `define` / `alias`
	*/
	const compiler = createMockCompiler(options);
	compiler.run();
	/**
	* 监听 mock 文件是否发生变更，如何配置了 reload 为 true，
	* 当发生变更时，通知当前页面进行重新加载
	*/
	compiler.on("mock:update-end", () => {
		if (options.reload) ws?.send({ type: "full-reload" });
	});
	server?.on("close", () => compiler.close());
	/**
	* 虽然 config.server.proxy 中有关于 ws 的代理配置，
	* 但是由于 vite 内部在启动时，直接对 ws相关的请求，通过 upgrade 事件，发送给 http-proxy
	* 的 ws 代理方法。如果插件直接使用 config.server.proxy 中的 ws 配置，
	* 就会导致两次 upgrade 事件 对 wss 实例的冲突。
	* 由于 vite 内部并没有提供其他的方式跳过 内部 upgrade 的方式，（个人认为也没有必要提供此类方式）
	* 所以插件选择了通过插件的配置项 `wsPrefix` 来做 判断的首要条件。
	* 当前插件默认会将已配置在 wsPrefix 的值，从 config.server.proxy 的删除，避免发生冲突问题。
	*/
	require_server.mockWebSocket(compiler, server, options);
	const middlewares = [];
	middlewares.push(
		/**
		* 在 vite 的开发服务中，由于插件 的 enforce 为 `pre`，
		* mock 中间件的执行顺序 早于 vite 内部的 cors 中间件执行,
		* 这导致了 vite 默认开启的 cors 对 mock 请求不生效。
		* 在一些比如 微前端项目、或者联合项目中，会由于端口不一致而导致跨域问题。
		* 所以在这里，使用 cors 中间件 来解决这个问题。
		*
		* 同时为了使 插件内的 cors 和 vite 的 cors 不产生冲突，并拥有一致的默认行为，
		* 也会使用 viteConfig.server.cors 配置，并支持 用户可以对 mock 中的 cors 中间件进行配置。
		* 而用户的配置也仅对 mock 的接口生效。
		*/
		corsMiddleware(compiler, options),
		require_server.baseMiddleware(compiler, options)
	);
	return middlewares.filter(Boolean);
}
function corsMiddleware(compiler, { proxies, cors: corsOptions }) {
	return !corsOptions ? void 0 : function(req, res, next) {
		const { pathname } = require_server.urlParse(req.url);
		if (!pathname || proxies.length === 0 || !proxies.some((context) => require_server.doesProxyContextMatchUrl(context, req.url))) return next();
		const mockData = compiler.mockData;
		const mockUrl = Object.keys(mockData).find((key) => (0, path_to_regexp.pathToRegexp)(key).test(pathname));
		if (!mockUrl) return next();
		(0, cors.default)(corsOptions)(req, res, next);
	};
}

//#endregion
//#region src/core/define.ts
function viteDefine(config) {
	const processNodeEnv = {};
	const nodeEnv = node_process.default.env.NODE_ENV || config.mode;
	Object.assign(processNodeEnv, {
		"process.env.NODE_ENV": JSON.stringify(nodeEnv),
		"global.process.env.NODE_ENV": JSON.stringify(nodeEnv),
		"globalThis.process.env.NODE_ENV": JSON.stringify(nodeEnv)
	});
	const userDefine = {};
	const userDefineEnv = {};
	for (const key in config.define) {
		const val = config.define[key];
		const isMetaEnv = key.startsWith("import.meta.env.");
		if (typeof val === "string") {
			if (canJsonParse(val)) {
				userDefine[key] = val;
				if (isMetaEnv) userDefineEnv[key.slice(16)] = val;
			}
		} else {
			userDefine[key] = handleDefineValue(val);
			if (isMetaEnv) userDefineEnv[key.slice(16)] = val;
		}
	}
	const importMetaKeys = {};
	const importMetaEnvKeys = {};
	const importMetaFallbackKeys = {};
	importMetaKeys["import.meta.hot"] = `undefined`;
	for (const key in config.env) {
		const val = JSON.stringify(config.env[key]);
		importMetaKeys[`import.meta.env.${key}`] = val;
		importMetaEnvKeys[key] = val;
	}
	importMetaFallbackKeys["import.meta.env"] = `undefined`;
	const define = {
		...processNodeEnv,
		...importMetaKeys,
		...userDefine,
		...importMetaFallbackKeys
	};
	if ("import.meta.env" in define) define["import.meta.env"] = serializeDefine({
		...importMetaEnvKeys,
		...userDefineEnv
	});
	return define;
}
/**
* Like `JSON.stringify` but keeps raw string values as a literal
* in the generated code. For example: `"window"` would refer to
* the global `window` object directly.
*/
function serializeDefine(define) {
	let res = `{`;
	const keys = Object.keys(define);
	for (let i = 0; i < keys.length; i++) {
		const key = keys[i];
		const val = define[key];
		res += `${JSON.stringify(key)}: ${handleDefineValue(val)}`;
		if (i !== keys.length - 1) res += `, `;
	}
	return `${res}}`;
}
function handleDefineValue(value) {
	if (typeof value === "undefined") return "undefined";
	if (typeof value === "string") return value;
	return JSON.stringify(value);
}
function canJsonParse(value) {
	try {
		JSON.parse(value);
		return true;
	} catch {
		return false;
	}
}

//#endregion
//#region src/core/resolvePluginOptions.ts
function resolvePluginOptions({ prefix = [], wsPrefix = [], cwd, include = ["mock/**/*.mock.{js,ts,cjs,mjs,json,json5}"], exclude = [
	"**/node_modules/**",
	"**/.vscode/**",
	"**/.git/**"
], reload = false, log = "info", cors: cors$2 = true, formidableOptions = {}, build: build$1 = false, cookiesOptions = {}, bodyParserOptions = {}, priority = {} }, config) {
	const logger = require_server.createLogger("vite:mock", (0, __pengzhanbo_utils.isBoolean)(log) ? log ? "info" : "error" : log);
	const { httpProxies } = require_server.ensureProxies(config.server.proxy || {});
	const proxies = (0, __pengzhanbo_utils.uniq)([...(0, __pengzhanbo_utils.toArray)(prefix), ...httpProxies]);
	const wsProxies = (0, __pengzhanbo_utils.toArray)(wsPrefix);
	if (!proxies.length && !wsProxies.length) logger.warn(`No proxy was configured, mock server will not work. See ${picocolors.default.cyan("https://vite-plugin-mock-dev-server.netlify.app/guide/usage")}`);
	const enabled = cors$2 === false ? false : config.server.cors !== false;
	let corsOptions = {};
	if (enabled && config.server.cors !== false) corsOptions = {
		...corsOptions,
		...typeof config.server.cors === "boolean" ? {} : config.server.cors
	};
	if (enabled && cors$2 !== false) corsOptions = {
		...corsOptions,
		...typeof cors$2 === "boolean" ? {} : cors$2
	};
	const alias = [];
	const aliasConfig = config.resolve.alias || [];
	if ((0, __pengzhanbo_utils.isArray)(aliasConfig)) alias.push(...aliasConfig);
	else Object.entries(aliasConfig).forEach(([find, replacement]) => {
		alias.push({
			find,
			replacement
		});
	});
	return {
		cwd: cwd || node_process.default.cwd(),
		include,
		exclude,
		context: config.root,
		reload,
		cors: enabled ? corsOptions : false,
		cookiesOptions,
		log,
		formidableOptions: {
			multiples: true,
			...formidableOptions
		},
		bodyParserOptions,
		priority,
		build: build$1 ? Object.assign({
			serverPort: 8080,
			dist: "mockServer",
			log: "error"
		}, typeof build$1 === "object" ? build$1 : {}) : false,
		proxies,
		wsProxies,
		logger,
		alias,
		define: viteDefine(config)
	};
}

//#endregion
//#region src/plugin.ts
function mockDevServerPlugin(options = {}) {
	const plugins = [serverPlugin(options)];
	if (options.build) plugins.push(buildPlugin(options));
	return plugins;
}
function buildPlugin(options) {
	let viteConfig = {};
	let resolvedOptions;
	return {
		name: "vite-plugin-mock-dev-server-generator",
		enforce: "post",
		apply: "build",
		configResolved(config) {
			viteConfig = config;
			resolvedOptions = resolvePluginOptions(options, config);
			config.logger.warn("");
		},
		async buildEnd(error) {
			if (error || viteConfig.command !== "build") return;
			await generateMockServer(this, resolvedOptions);
		}
	};
}
function serverPlugin(options) {
	let resolvedOptions;
	return {
		name: "vite-plugin-mock-dev-server",
		enforce: "pre",
		apply: "serve",
		config(config) {
			const wsPrefix = (0, __pengzhanbo_utils.toArray)(options.wsPrefix);
			if (wsPrefix.length && config.server?.proxy) {
				const proxy = {};
				Object.keys(config.server.proxy).forEach((key) => {
					if (!wsPrefix.includes(key)) proxy[key] = config.server.proxy[key];
				});
				config.server.proxy = proxy;
			}
			require_server.recoverRequest(config);
		},
		configResolved(config) {
			resolvedOptions = resolvePluginOptions(options, config);
			config.logger.warn("");
		},
		configureServer({ middlewares, httpServer, ws }) {
			const middlewareList = mockServerMiddleware(resolvedOptions, httpServer, ws);
			middlewareList.forEach((middleware) => middlewares.use(middleware));
		},
		configurePreviewServer({ middlewares, httpServer }) {
			const middlewareList = mockServerMiddleware(resolvedOptions, httpServer);
			middlewareList.forEach((middleware) => middlewares.use(middleware));
		}
	};
}

//#endregion
//#region src/index.ts
/**
* @deprecated use named export instead
*/
function mockDevServerPluginWithDefaultExportWasDeprecated(options = {}) {
	console.warn(`${picocolors.default.yellow("[vite-plugin-mock-dev-server]")} ${picocolors.default.yellow(picocolors.default.bold("WARNING:"))} The plugin default export is ${picocolors.default.bold("deprecated")}, it will be removed in next major version, use ${picocolors.default.bold("named export")} instead:\n\n    ${picocolors.default.green("import { mockDevServerPlugin } from \"vite-plugin-mock-dev-server\"")}\n`);
	return mockDevServerPlugin(options);
}

//#endregion
exports.baseMiddleware = require_server.baseMiddleware;
exports.createDefineMock = require_helper.createDefineMock;
exports.createLogger = require_server.createLogger;
exports.createSSEStream = require_helper.createSSEStream;
exports.default = mockDevServerPluginWithDefaultExportWasDeprecated;
exports.defineMock = require_helper.defineMock;
exports.defineMockData = require_helper.defineMockData;
exports.logLevels = require_server.logLevels;
exports.mockDevServerPlugin = mockDevServerPlugin;
exports.mockWebSocket = require_server.mockWebSocket;
exports.sortByValidator = require_server.sortByValidator;
exports.transformMockData = require_server.transformMockData;
exports.transformRawData = require_server.transformRawData;