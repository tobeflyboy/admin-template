import {
  Teleport,
  TransitionGroup,
  computed,
  createApp,
  createCommentVNode,
  defineComponent,
  getCurrentInstance,
  h,
  inject,
  nextTick,
  onActivated,
  onBeforeUnmount,
  onDeactivated,
  onMounted,
  onUnmounted,
  provide,
  reactive,
  ref,
  resolveComponent,
  watch
} from "./chunk-GUB7NKQY.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-PR4QN5HX.js";

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/setupDefaults.js
var require_setupDefaults = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/setupDefaults.js"(exports, module) {
    "use strict";
    var setupDefaults = {
      keyId: 1,
      cookies: {
        path: "/"
      },
      treeOptions: {
        parentKey: "parentId",
        key: "id",
        children: "children"
      },
      parseDateFormat: "yyyy-MM-dd HH:mm:ss",
      firstDayOfWeek: 1
    };
    module.exports = setupDefaults;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/arrayEach.js"(exports, module) {
    function arrayEach(list, iterate, context) {
      if (list) {
        if (list.forEach) {
          list.forEach(iterate, context);
        } else {
          for (var index = 0, len = list.length; index < len; index++) {
            iterate.call(context, list[index], index, list);
          }
        }
      }
    }
    module.exports = arrayEach;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticObjectToString.js
var require_staticObjectToString = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticObjectToString.js"(exports, module) {
    var objectToString = Object.prototype.toString;
    module.exports = objectToString;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateInInObjectString.js
var require_helperCreateInInObjectString = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateInInObjectString.js"(exports, module) {
    var objectToString = require_staticObjectToString();
    function helperCreateInInObjectString(type) {
      return function(obj) {
        return "[object " + type + "]" === objectToString.call(obj);
      };
    }
    module.exports = helperCreateInInObjectString;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isArray.js
var require_isArray = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isArray.js"(exports, module) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isArray = Array.isArray || helperCreateInInObjectString("Array");
    module.exports = isArray;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/hasOwnProp.js
var require_hasOwnProp = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/hasOwnProp.js"(exports, module) {
    function hasOwnProp(obj, key) {
      return obj && obj.hasOwnProperty ? obj.hasOwnProperty(key) : false;
    }
    module.exports = hasOwnProp;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/objectEach.js
var require_objectEach = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/objectEach.js"(exports, module) {
    var hasOwnProp = require_hasOwnProp();
    function objectEach(obj, iterate, context) {
      if (obj) {
        for (var key in obj) {
          if (hasOwnProp(obj, key)) {
            iterate.call(context, obj[key], key, obj);
          }
        }
      }
    }
    module.exports = objectEach;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/each.js
var require_each = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/each.js"(exports, module) {
    var isArray = require_isArray();
    var arrayEach = require_arrayEach();
    var objectEach = require_objectEach();
    function each(obj, iterate, context) {
      if (obj) {
        return (isArray(obj) ? arrayEach : objectEach)(obj, iterate, context);
      }
      return obj;
    }
    module.exports = each;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateInTypeof.js
var require_helperCreateInTypeof = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateInTypeof.js"(exports, module) {
    function helperCreateInTypeof(type) {
      return function(obj) {
        return typeof obj === type;
      };
    }
    module.exports = helperCreateInTypeof;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isFunction.js"(exports, module) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isFunction = helperCreateInTypeof("function");
    module.exports = isFunction;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateGetObjects.js
var require_helperCreateGetObjects = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateGetObjects.js"(exports, module) {
    var each = require_each();
    function helperCreateGetObjects(name, getIndex) {
      var proMethod = Object[name];
      return function(obj) {
        var result = [];
        if (obj) {
          if (proMethod) {
            return proMethod(obj);
          }
          each(obj, getIndex > 1 ? function(key) {
            result.push(["" + key, obj[key]]);
          } : function() {
            result.push(arguments[getIndex]);
          });
        }
        return result;
      };
    }
    module.exports = helperCreateGetObjects;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/keys.js
var require_keys = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/keys.js"(exports, module) {
    var helperCreateGetObjects = require_helperCreateGetObjects();
    var keys = helperCreateGetObjects("keys", 1);
    module.exports = keys;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/clone.js
var require_clone = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/clone.js"(exports, module) {
    var objectToString = require_staticObjectToString();
    var objectEach = require_objectEach();
    var arrayEach = require_arrayEach();
    function getCativeCtor(val, args) {
      var Ctor = val.__proto__.constructor;
      return args ? new Ctor(args) : new Ctor();
    }
    function handleValueClone(item, isDeep) {
      return isDeep ? copyValue(item, isDeep) : item;
    }
    function copyValue(val, isDeep) {
      if (val) {
        switch (objectToString.call(val)) {
          case "[object Object]": {
            var restObj = Object.create(Object.getPrototypeOf(val));
            objectEach(val, function(item, key) {
              restObj[key] = handleValueClone(item, isDeep);
            });
            return restObj;
          }
          case "[object Date]":
          case "[object RegExp]": {
            return getCativeCtor(val, val.valueOf());
          }
          case "[object Array]":
          case "[object Arguments]": {
            var restArr = [];
            arrayEach(val, function(item) {
              restArr.push(handleValueClone(item, isDeep));
            });
            return restArr;
          }
          case "[object Set]": {
            var restSet = getCativeCtor(val);
            restSet.forEach(function(item) {
              restSet.add(handleValueClone(item, isDeep));
            });
            return restSet;
          }
          case "[object Map]": {
            var restMap = getCativeCtor(val);
            restMap.forEach(function(item, key) {
              restMap.set(key, handleValueClone(item, isDeep));
            });
            return restMap;
          }
        }
      }
      return val;
    }
    function clone(obj, deep) {
      if (obj) {
        return copyValue(obj, deep);
      }
      return obj;
    }
    module.exports = clone;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/assign.js
var require_assign = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/assign.js"(exports, module) {
    var arrayEach = require_arrayEach();
    var keys = require_keys();
    var isArray = require_isArray();
    var clone = require_clone();
    var objectAssignFns = Object.assign;
    function handleAssign(destination, args, isClone) {
      var len = args.length;
      for (var source, index = 1; index < len; index++) {
        source = args[index];
        arrayEach(keys(args[index]), isClone ? function(key) {
          destination[key] = clone(source[key], isClone);
        } : function(key) {
          destination[key] = source[key];
        });
      }
      return destination;
    }
    var assign = function(target) {
      if (target) {
        var args = arguments;
        if (target === true) {
          if (args.length > 1) {
            target = isArray(target[1]) ? [] : {};
            return handleAssign(target, args, true);
          }
        } else {
          return objectAssignFns ? objectAssignFns.apply(Object, args) : handleAssign(target, args);
        }
      }
      return target;
    };
    module.exports = assign;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/ctor.js
var require_ctor = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/ctor.js"(exports, module) {
    "use strict";
    var setupDefaults = require_setupDefaults();
    var arrayEach = require_arrayEach();
    var each = require_each();
    var isFunction = require_isFunction();
    var assign = require_assign();
    var XEUtils63 = function() {
    };
    function mixin() {
      arrayEach(arguments, function(methods) {
        each(methods, function(fn, name) {
          XEUtils63[name] = isFunction(fn) ? function() {
            var result = fn.apply(XEUtils63.$context, arguments);
            XEUtils63.$context = null;
            return result;
          } : fn;
        });
      });
    }
    function setConfig2(options) {
      return assign(setupDefaults, options);
    }
    function getConfig() {
      return setupDefaults;
    }
    var version2 = "3.7.4";
    XEUtils63.VERSION = version2;
    XEUtils63.version = version2;
    XEUtils63.mixin = mixin;
    XEUtils63.setup = setConfig2;
    XEUtils63.setConfig = setConfig2;
    XEUtils63.getConfig = getConfig;
    module.exports = XEUtils63;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastArrayEach.js
var require_lastArrayEach = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastArrayEach.js"(exports, module) {
    function lastArrayEach(obj, iterate, context) {
      for (var len = obj.length - 1; len >= 0; len--) {
        iterate.call(context, obj[len], len, obj);
      }
    }
    module.exports = lastArrayEach;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastObjectEach.js
var require_lastObjectEach = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastObjectEach.js"(exports, module) {
    var lastArrayEach = require_lastArrayEach();
    var keys = require_keys();
    function lastObjectEach(obj, iterate, context) {
      lastArrayEach(keys(obj), function(key) {
        iterate.call(context, obj[key], key, obj);
      });
    }
    module.exports = lastObjectEach;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isNull.js
var require_isNull = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isNull.js"(exports, module) {
    function isNull(obj) {
      return obj === null;
    }
    module.exports = isNull;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/property.js
var require_property = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/property.js"(exports, module) {
    var isNull = require_isNull();
    function property(name, defs) {
      return function(obj) {
        return isNull(obj) ? defs : obj[name];
      };
    }
    module.exports = property;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/objectMap.js
var require_objectMap = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/objectMap.js"(exports, module) {
    var each = require_each();
    var isFunction = require_isFunction();
    var property = require_property();
    function objectMap(obj, iterate, context) {
      var result = {};
      if (obj) {
        if (iterate) {
          if (!isFunction(iterate)) {
            iterate = property(iterate);
          }
          each(obj, function(val, index) {
            result[index] = iterate.call(context, val, index, obj);
          });
        } else {
          return obj;
        }
      }
      return result;
    }
    module.exports = objectMap;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isPlainObject.js"(exports, module) {
    function isPlainObject(obj) {
      return obj ? obj.constructor === Object : false;
    }
    module.exports = isPlainObject;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCheckCopyKey.js
var require_helperCheckCopyKey = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCheckCopyKey.js"(exports, module) {
    function helperCheckCopyKey(key) {
      return key !== "__proto__" && key !== "constructor";
    }
    module.exports = helperCheckCopyKey;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/merge.js
var require_merge = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/merge.js"(exports, module) {
    var isArray = require_isArray();
    var isPlainObject = require_isPlainObject();
    var isFunction = require_isFunction();
    var each = require_each();
    var helperCheckCopyKey = require_helperCheckCopyKey();
    function handleMerge(target, source) {
      if (isPlainObject(target) && isPlainObject(source) || isArray(target) && isArray(source)) {
        each(source, function(val, key) {
          if (helperCheckCopyKey(key)) {
            target[key] = isFunction(source) ? val : handleMerge(target[key], val);
          }
        });
        return target;
      }
      return source;
    }
    var merge = function(target) {
      if (!target) {
        target = {};
      }
      var args = arguments;
      var len = args.length;
      for (var source, index = 1; index < len; index++) {
        source = args[index];
        if (source) {
          handleMerge(target, source);
        }
      }
      return target;
    };
    module.exports = merge;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/map.js
var require_map = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/map.js"(exports, module) {
    var each = require_each();
    function map(obj, iterate, context) {
      var result = [];
      if (obj && arguments.length > 1) {
        if (obj.map) {
          return obj.map(iterate, context);
        } else {
          each(obj, function() {
            result.push(iterate.apply(context, arguments));
          });
        }
      }
      return result;
    }
    module.exports = map;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateIterateHandle.js
var require_helperCreateIterateHandle = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateIterateHandle.js"(exports, module) {
    var hasOwnProp = require_hasOwnProp();
    var isArray = require_isArray();
    function helperCreateIterateHandle(prop, useArray, restIndex, matchValue, defaultValue) {
      return function(obj, iterate, context) {
        if (obj && iterate) {
          if (prop && obj[prop]) {
            return obj[prop](iterate, context);
          } else {
            if (useArray && isArray(obj)) {
              for (var index = 0, len = obj.length; index < len; index++) {
                if (!!iterate.call(context, obj[index], index, obj) === matchValue) {
                  return [true, false, index, obj[index]][restIndex];
                }
              }
            } else {
              for (var key in obj) {
                if (hasOwnProp(obj, key)) {
                  if (!!iterate.call(context, obj[key], key, obj) === matchValue) {
                    return [true, false, key, obj[key]][restIndex];
                  }
                }
              }
            }
          }
        }
        return defaultValue;
      };
    }
    module.exports = helperCreateIterateHandle;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/some.js
var require_some = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/some.js"(exports, module) {
    var helperCreateIterateHandle = require_helperCreateIterateHandle();
    var some = helperCreateIterateHandle("some", 1, 0, true, false);
    module.exports = some;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/every.js
var require_every = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/every.js"(exports, module) {
    var helperCreateIterateHandle = require_helperCreateIterateHandle();
    var every = helperCreateIterateHandle("every", 1, 1, false, true);
    module.exports = every;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/includes.js
var require_includes = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/includes.js"(exports, module) {
    var hasOwnProp = require_hasOwnProp();
    function includes(obj, val) {
      if (obj) {
        if (obj.includes) {
          return obj.includes(val);
        }
        for (var key in obj) {
          if (hasOwnProp(obj, key)) {
            if (val === obj[key]) {
              return true;
            }
          }
        }
      }
      return false;
    }
    module.exports = includes;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/includeArrays.js
var require_includeArrays = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/includeArrays.js"(exports, module) {
    var isArray = require_isArray();
    var includes = require_includes();
    function includeArrays(array1, array2) {
      var len;
      var index = 0;
      if (isArray(array1) && isArray(array2)) {
        for (len = array2.length; index < len; index++) {
          if (!includes(array1, array2[index])) {
            return false;
          }
        }
        return true;
      }
      return includes(array1, array2);
    }
    module.exports = includeArrays;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/uniq.js
var require_uniq = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/uniq.js"(exports, module) {
    var each = require_each();
    var includes = require_includes();
    var isFunction = require_isFunction();
    var property = require_property();
    function uniq(array, iterate, context) {
      var result = [];
      if (iterate) {
        if (!isFunction(iterate)) {
          iterate = property(iterate);
        }
        var val, valMap = {};
        each(array, function(item, key) {
          val = iterate.call(context, item, key, array);
          if (!valMap[val]) {
            valMap[val] = 1;
            result.push(item);
          }
        });
      } else {
        each(array, function(value) {
          if (!includes(result, value)) {
            result.push(value);
          }
        });
      }
      return result;
    }
    module.exports = uniq;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toArray.js
var require_toArray = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toArray.js"(exports, module) {
    var map = require_map();
    function toArray(list) {
      return map(list, function(item) {
        return item;
      });
    }
    module.exports = toArray;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/union.js
var require_union = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/union.js"(exports, module) {
    var uniq = require_uniq();
    var toArray = require_toArray();
    function union() {
      var args = arguments;
      var result = [];
      var index = 0;
      var len = args.length;
      for (; index < len; index++) {
        result = result.concat(toArray(args[index]));
      }
      return uniq(result);
    }
    module.exports = union;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticStrUndefined.js
var require_staticStrUndefined = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticStrUndefined.js"(exports, module) {
    var staticStrUndefined = "undefined";
    module.exports = staticStrUndefined;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isUndefined.js
var require_isUndefined = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isUndefined.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isUndefined = helperCreateInTypeof(staticStrUndefined);
    module.exports = isUndefined;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/eqNull.js
var require_eqNull = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/eqNull.js"(exports, module) {
    var isNull = require_isNull();
    var isUndefined = require_isUndefined();
    function eqNull(obj) {
      return isNull(obj) || isUndefined(obj);
    }
    module.exports = eqNull;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticHGKeyRE.js
var require_staticHGKeyRE = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticHGKeyRE.js"(exports, module) {
    var staticHGKeyRE = /(.+)?\[(\d+)\]$/;
    module.exports = staticHGKeyRE;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetHGSKeys.js
var require_helperGetHGSKeys = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetHGSKeys.js"(exports, module) {
    function helperGetHGSKeys(property) {
      return property ? property.splice && property.join ? property : ("" + property).replace(/(\[\d+\])\.?/g, "$1.").replace(/\.$/, "").split(".") : [];
    }
    module.exports = helperGetHGSKeys;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/get.js
var require_get = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/get.js"(exports, module) {
    var staticHGKeyRE = require_staticHGKeyRE();
    var helperGetHGSKeys = require_helperGetHGSKeys();
    var hasOwnProp = require_hasOwnProp();
    var isUndefined = require_isUndefined();
    var eqNull = require_eqNull();
    function get(obj, property, defaultValue) {
      if (eqNull(obj)) {
        return defaultValue;
      }
      var result = getValueByPath(obj, property);
      return isUndefined(result) ? defaultValue : result;
    }
    function getDeepProps(obj, key) {
      var matchs = key ? key.match(staticHGKeyRE) : "";
      return matchs ? matchs[1] ? obj[matchs[1]] ? obj[matchs[1]][matchs[2]] : void 0 : obj[matchs[2]] : obj[key];
    }
    function getValueByPath(obj, property) {
      if (obj) {
        var rest, props, len;
        var index = 0;
        if (obj[property] || hasOwnProp(obj, property)) {
          return obj[property];
        } else {
          props = helperGetHGSKeys(property);
          len = props.length;
          if (len) {
            for (rest = obj; index < len; index++) {
              rest = getDeepProps(rest, props[index]);
              if (eqNull(rest)) {
                if (index === len - 1) {
                  return rest;
                }
                return;
              }
            }
          }
          return rest;
        }
      }
    }
    module.exports = get;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/orderBy.js
var require_orderBy = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/orderBy.js"(exports, module) {
    var arrayEach = require_arrayEach();
    var toArray = require_toArray();
    var map = require_map();
    var isArray = require_isArray();
    var isFunction = require_isFunction();
    var isPlainObject = require_isPlainObject();
    var isUndefined = require_isUndefined();
    var isNull = require_isNull();
    var eqNull = require_eqNull();
    var get = require_get();
    var property = require_property();
    var ORDER_PROP_ASC = "asc";
    var ORDER_PROP_DESC = "desc";
    function handleSort(v1, v2) {
      if (isUndefined(v1)) {
        return 1;
      }
      if (isNull(v1)) {
        return isUndefined(v2) ? -1 : 1;
      }
      return v1 && v1.localeCompare ? v1.localeCompare(v2) : v1 > v2 ? 1 : -1;
    }
    function buildMultiOrders(name, confs, compares) {
      return function(item1, item2) {
        var v1 = item1[name];
        var v2 = item2[name];
        if (v1 === v2) {
          return compares ? compares(item1, item2) : 0;
        }
        return confs.order === ORDER_PROP_DESC ? handleSort(v2, v1) : handleSort(v1, v2);
      };
    }
    function getSortConfs(arr, list, fieldConfs, context) {
      var sortConfs = [];
      fieldConfs = isArray(fieldConfs) ? fieldConfs : [fieldConfs];
      arrayEach(fieldConfs, function(handle, index) {
        if (handle) {
          var field = handle;
          var order;
          if (isArray(handle)) {
            field = handle[0];
            order = handle[1];
          } else if (isPlainObject(handle)) {
            field = handle.field;
            order = handle.order;
          }
          sortConfs.push({
            field,
            order: order || ORDER_PROP_ASC
          });
          arrayEach(list, isFunction(field) ? function(item, key) {
            item[index] = field.call(context, item.data, key, arr);
          } : function(item) {
            item[index] = field ? get(item.data, field) : item.data;
          });
        }
      });
      return sortConfs;
    }
    function orderBy(arr, fieldConfs, context) {
      if (arr) {
        if (eqNull(fieldConfs)) {
          return toArray(arr).sort(handleSort);
        }
        var compares;
        var list = map(arr, function(item) {
          return { data: item };
        });
        var sortConfs = getSortConfs(arr, list, fieldConfs, context);
        var len = sortConfs.length - 1;
        while (len >= 0) {
          compares = buildMultiOrders(len, sortConfs[len], compares);
          len--;
        }
        if (compares) {
          list = list.sort(compares);
        }
        return map(list, property("data"));
      }
      return [];
    }
    module.exports = orderBy;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/sortBy.js
var require_sortBy = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/sortBy.js"(exports, module) {
    var orderBy = require_orderBy();
    var sortBy = orderBy;
    module.exports = sortBy;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/random.js
var require_random = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/random.js"(exports, module) {
    function random(minVal, maxVal) {
      return minVal >= maxVal ? minVal : (minVal = minVal >> 0) + Math.round(Math.random() * ((maxVal || 9) - minVal));
    }
    module.exports = random;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/values.js
var require_values = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/values.js"(exports, module) {
    var helperCreateGetObjects = require_helperCreateGetObjects();
    var values = helperCreateGetObjects("values", 0);
    module.exports = values;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/shuffle.js
var require_shuffle = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/shuffle.js"(exports, module) {
    var random = require_random();
    var values = require_values();
    function shuffle(array) {
      var index;
      var result = [];
      var list = values(array);
      var len = list.length - 1;
      for (; len >= 0; len--) {
        index = len > 0 ? random(0, len) : 0;
        result.push(list[index]);
        list.splice(index, 1);
      }
      return result;
    }
    module.exports = shuffle;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/sample.js
var require_sample = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/sample.js"(exports, module) {
    var shuffle = require_shuffle();
    function sample(array, number) {
      var result = shuffle(array);
      if (arguments.length <= 1) {
        return result[0];
      }
      if (number < result.length) {
        result.length = number || 0;
      }
      return result;
    }
    module.exports = sample;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateToNumber.js
var require_helperCreateToNumber = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateToNumber.js"(exports, module) {
    function helperCreateToNumber(handle) {
      return function(str) {
        if (str) {
          var num = handle(str && str.replace ? str.replace(/,/g, "") : str);
          if (!isNaN(num)) {
            return num;
          }
        }
        return 0;
      };
    }
    module.exports = helperCreateToNumber;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toNumber.js"(exports, module) {
    var helperCreateToNumber = require_helperCreateToNumber();
    var toNumber = helperCreateToNumber(parseFloat);
    module.exports = toNumber;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/slice.js
var require_slice = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/slice.js"(exports, module) {
    var toNumber = require_toNumber();
    function slice(array, startIndex, endIndex) {
      var result = [];
      var argsSize = arguments.length;
      if (array) {
        startIndex = argsSize >= 2 ? toNumber(startIndex) : 0;
        endIndex = argsSize >= 3 ? toNumber(endIndex) : array.length;
        if (array.slice) {
          return array.slice(startIndex, endIndex);
        }
        for (; startIndex < endIndex; startIndex++) {
          result.push(array[startIndex]);
        }
      }
      return result;
    }
    module.exports = slice;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/filter.js
var require_filter = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/filter.js"(exports, module) {
    var each = require_each();
    function filter(obj, iterate, context) {
      var result = [];
      if (obj && iterate) {
        if (obj.filter) {
          return obj.filter(iterate, context);
        }
        each(obj, function(val, key) {
          if (iterate.call(context, val, key, obj)) {
            result.push(val);
          }
        });
      }
      return result;
    }
    module.exports = filter;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findKey.js
var require_findKey = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findKey.js"(exports, module) {
    var helperCreateIterateHandle = require_helperCreateIterateHandle();
    var findKey = helperCreateIterateHandle("", 0, 2, true);
    module.exports = findKey;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/find.js
var require_find = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/find.js"(exports, module) {
    var helperCreateIterateHandle = require_helperCreateIterateHandle();
    var find = helperCreateIterateHandle("find", 1, 3, true);
    module.exports = find;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findLast.js
var require_findLast = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findLast.js"(exports, module) {
    var isArray = require_isArray();
    var values = require_values();
    function findLast(obj, iterate, context) {
      if (obj) {
        if (!isArray(obj)) {
          obj = values(obj);
        }
        for (var len = obj.length - 1; len >= 0; len--) {
          if (iterate.call(context, obj[len], len, obj)) {
            return obj[len];
          }
        }
      }
    }
    module.exports = findLast;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/reduce.js
var require_reduce = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/reduce.js"(exports, module) {
    var keys = require_keys();
    function reduce(array, callback, initialValue) {
      if (array) {
        var len, reduceMethod;
        var index = 0;
        var context = null;
        var previous = initialValue;
        var isInitialVal = arguments.length > 2;
        var keyList = keys(array);
        if (array.length && array.reduce) {
          reduceMethod = function() {
            return callback.apply(context, arguments);
          };
          if (isInitialVal) {
            return array.reduce(reduceMethod, previous);
          }
          return array.reduce(reduceMethod);
        }
        if (isInitialVal) {
          index = 1;
          previous = array[keyList[0]];
        }
        for (len = keyList.length; index < len; index++) {
          previous = callback.call(context, previous, array[keyList[index]], index, array);
        }
        return previous;
      }
    }
    module.exports = reduce;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/copyWithin.js
var require_copyWithin = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/copyWithin.js"(exports, module) {
    var isArray = require_isArray();
    function copyWithin(array, target, start, end) {
      if (isArray(array) && array.copyWithin) {
        return array.copyWithin(target, start, end);
      }
      var replaceIndex, replaceArray;
      var targetIndex = target >> 0;
      var startIndex = start >> 0;
      var len = array.length;
      var endIndex = arguments.length > 3 ? end >> 0 : len;
      if (targetIndex < len) {
        targetIndex = targetIndex >= 0 ? targetIndex : len + targetIndex;
        if (targetIndex >= 0) {
          startIndex = startIndex >= 0 ? startIndex : len + startIndex;
          endIndex = endIndex >= 0 ? endIndex : len + endIndex;
          if (startIndex < endIndex) {
            for (replaceIndex = 0, replaceArray = array.slice(startIndex, endIndex); targetIndex < len; targetIndex++) {
              if (replaceArray.length <= replaceIndex) {
                break;
              }
              array[targetIndex] = replaceArray[replaceIndex++];
            }
          }
        }
      }
      return array;
    }
    module.exports = copyWithin;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/chunk.js
var require_chunk = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/chunk.js"(exports, module) {
    var isArray = require_isArray();
    function chunk(array, size) {
      var index;
      var result = [];
      var arrLen = size >> 0 || 1;
      if (isArray(array)) {
        if (arrLen >= 0 && array.length > arrLen) {
          index = 0;
          while (index < array.length) {
            result.push(array.slice(index, index + arrLen));
            index += arrLen;
          }
        } else {
          result = array.length ? [array] : array;
        }
      }
      return result;
    }
    module.exports = chunk;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/pluck.js
var require_pluck = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/pluck.js"(exports, module) {
    var map = require_map();
    var property = require_property();
    function pluck(obj, key) {
      return map(obj, property(key));
    }
    module.exports = pluck;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateMinMax.js
var require_helperCreateMinMax = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateMinMax.js"(exports, module) {
    var isFunction = require_isFunction();
    var eqNull = require_eqNull();
    var get = require_get();
    var arrayEach = require_arrayEach();
    function helperCreateMinMax(handle) {
      return function(arr, iterate) {
        if (arr && arr.length) {
          var rest, itemIndex;
          arrayEach(arr, function(itemVal, index) {
            if (iterate) {
              itemVal = isFunction(iterate) ? iterate(itemVal, index, arr) : get(itemVal, iterate);
            }
            if (!eqNull(itemVal) && (eqNull(rest) || handle(rest, itemVal))) {
              itemIndex = index;
              rest = itemVal;
            }
          });
          return arr[itemIndex];
        }
        return rest;
      };
    }
    module.exports = helperCreateMinMax;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/max.js
var require_max = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/max.js"(exports, module) {
    var helperCreateMinMax = require_helperCreateMinMax();
    var max = helperCreateMinMax(function(rest, itemVal) {
      return rest < itemVal;
    });
    module.exports = max;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/unzip.js
var require_unzip = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/unzip.js"(exports, module) {
    var pluck = require_pluck();
    var max = require_max();
    function unzip(arrays) {
      var index, maxItem, len;
      var result = [];
      if (arrays && arrays.length) {
        index = 0;
        maxItem = max(arrays, function(item) {
          return item ? item.length : 0;
        });
        for (len = maxItem ? maxItem.length : 0; index < len; index++) {
          result.push(pluck(arrays, index));
        }
      }
      return result;
    }
    module.exports = unzip;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/zip.js
var require_zip = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/zip.js"(exports, module) {
    var unzip = require_unzip();
    function zip() {
      return unzip(arguments);
    }
    module.exports = zip;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/zipObject.js
var require_zipObject = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/zipObject.js"(exports, module) {
    var values = require_values();
    var each = require_each();
    function zipObject(props, arr) {
      var result = {};
      arr = arr || [];
      each(values(props), function(val, key) {
        result[val] = arr[key];
      });
      return result;
    }
    module.exports = zipObject;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/flatten.js
var require_flatten = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/flatten.js"(exports, module) {
    var isArray = require_isArray();
    var arrayEach = require_arrayEach();
    function flattenDeep(array, deep) {
      var result = [];
      arrayEach(array, function(vals) {
        result = result.concat(isArray(vals) ? deep ? flattenDeep(vals, deep) : vals : [vals]);
      });
      return result;
    }
    function flatten(array, deep) {
      if (isArray(array)) {
        return flattenDeep(array, deep);
      }
      return [];
    }
    module.exports = flatten;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/invoke.js
var require_invoke = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/invoke.js"(exports, module) {
    var map = require_map();
    var isArray = require_isArray();
    function deepGetObj(obj, path) {
      var index = 0;
      var len = path.length;
      while (obj && index < len) {
        obj = obj[path[index++]];
      }
      return len && obj ? obj : 0;
    }
    function invoke(list, path) {
      var func;
      var args = arguments;
      var params = [];
      var paths = [];
      var index = 2;
      var len = args.length;
      for (; index < len; index++) {
        params.push(args[index]);
      }
      if (isArray(path)) {
        len = path.length - 1;
        for (index = 0; index < len; index++) {
          paths.push(path[index]);
        }
        path = path[len];
      }
      return map(list, function(context) {
        if (paths.length) {
          context = deepGetObj(context, paths);
        }
        func = context[path] || path;
        if (func && func.apply) {
          return func.apply(context, params);
        }
      });
    }
    module.exports = invoke;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperDeleteProperty.js
var require_helperDeleteProperty = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperDeleteProperty.js"(exports, module) {
    function helperDeleteProperty(obj, property) {
      try {
        delete obj[property];
      } catch (e) {
        obj[property] = void 0;
      }
    }
    module.exports = helperDeleteProperty;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastEach.js
var require_lastEach = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastEach.js"(exports, module) {
    var isArray = require_isArray();
    var lastArrayEach = require_lastArrayEach();
    var lastObjectEach = require_lastObjectEach();
    function lastEach(obj, iterate, context) {
      if (obj) {
        return (isArray(obj) ? lastArrayEach : lastObjectEach)(obj, iterate, context);
      }
      return obj;
    }
    module.exports = lastEach;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isObject.js
var require_isObject = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isObject.js"(exports, module) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isObject = helperCreateInTypeof("object");
    module.exports = isObject;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/clear.js
var require_clear = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/clear.js"(exports, module) {
    var helperDeleteProperty = require_helperDeleteProperty();
    var isPlainObject = require_isPlainObject();
    var isObject = require_isObject();
    var isArray = require_isArray();
    var isNull = require_isNull();
    var assign = require_assign();
    var objectEach = require_objectEach();
    function clear(obj, defs, assigns) {
      if (obj) {
        var len;
        var isDefs = arguments.length > 1 && (isNull(defs) || !isObject(defs));
        var extds = isDefs ? assigns : defs;
        if (isPlainObject(obj)) {
          objectEach(obj, isDefs ? function(val, key) {
            obj[key] = defs;
          } : function(val, key) {
            helperDeleteProperty(obj, key);
          });
          if (extds) {
            assign(obj, extds);
          }
        } else if (isArray(obj)) {
          if (isDefs) {
            len = obj.length;
            while (len > 0) {
              len--;
              obj[len] = defs;
            }
          } else {
            obj.length = 0;
          }
          if (extds) {
            obj.push.apply(obj, extds);
          }
        }
      }
      return obj;
    }
    module.exports = clear;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/remove.js
var require_remove = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/remove.js"(exports, module) {
    var helperDeleteProperty = require_helperDeleteProperty();
    var isFunction = require_isFunction();
    var isArray = require_isArray();
    var each = require_each();
    var arrayEach = require_arrayEach();
    var lastEach = require_lastEach();
    var clear = require_clear();
    var eqNull = require_eqNull();
    function pluckProperty(name) {
      return function(obj, key) {
        return key === name;
      };
    }
    function remove(obj, iterate, context) {
      if (obj) {
        if (!eqNull(iterate)) {
          var removeKeys = [];
          var rest = [];
          if (!isFunction(iterate)) {
            iterate = pluckProperty(iterate);
          }
          each(obj, function(item, index, rest2) {
            if (iterate.call(context, item, index, rest2)) {
              removeKeys.push(index);
            }
          });
          if (isArray(obj)) {
            lastEach(removeKeys, function(item, key) {
              rest.push(obj[item]);
              obj.splice(item, 1);
            });
          } else {
            rest = {};
            arrayEach(removeKeys, function(key) {
              rest[key] = obj[key];
              helperDeleteProperty(obj, key);
            });
          }
          return rest;
        }
        return clear(obj);
      }
      return obj;
    }
    module.exports = remove;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toArrayTree.js
var require_toArrayTree = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toArrayTree.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var map = require_map();
    var orderBy = require_orderBy();
    var clone = require_clone();
    var eqNull = require_eqNull();
    var each = require_each();
    var remove = require_remove();
    var assign = require_assign();
    function strictTree(array, optChildren) {
      each(array, function(item) {
        if (item[optChildren] && !item[optChildren].length) {
          remove(item, optChildren);
        }
      });
    }
    function toArrayTree(array, options) {
      var opts = assign({}, setupDefaults.treeOptions, options);
      var optStrict = opts.strict;
      var optKey = opts.key;
      var optParentKey = opts.parentKey;
      var optChildren = opts.children;
      var optMapChildren = opts.mapChildren;
      var optSortKey = opts.sortKey;
      var optReverse = opts.reverse;
      var optData = opts.data;
      var result = [];
      var treeMap = {};
      var idsMap = {};
      var id, treeData, parentId;
      if (optSortKey) {
        array = orderBy(clone(array), optSortKey);
        if (optReverse) {
          array = array.reverse();
        }
      }
      each(array, function(item) {
        id = item[optKey];
        idsMap[id] = true;
      });
      each(array, function(item) {
        id = item[optKey];
        if (optData) {
          treeData = {};
          treeData[optData] = item;
        } else {
          treeData = item;
        }
        parentId = item[optParentKey];
        treeMap[id] = treeMap[id] || [];
        treeData[optKey] = id;
        treeData[optParentKey] = parentId;
        if (id === parentId) {
          parentId = null;
          console.log("Fix infinite Loop.", item);
        }
        treeMap[parentId] = treeMap[parentId] || [];
        treeMap[parentId].push(treeData);
        treeData[optChildren] = treeMap[id];
        if (optMapChildren) {
          treeData[optMapChildren] = treeMap[id];
        }
        if (!optStrict || optStrict && eqNull(parentId)) {
          if (!idsMap[parentId]) {
            result.push(treeData);
          }
        }
      });
      if (optStrict) {
        strictTree(array, optChildren);
      }
      return result;
    }
    module.exports = toArrayTree;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toTreeArray.js
var require_toTreeArray = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toTreeArray.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var arrayEach = require_arrayEach();
    var assign = require_assign();
    function unTreeList(result, parentItem, array, opts) {
      var optKey = opts.key;
      var optParentKey = opts.parentKey;
      var optChildren = opts.children;
      var optData = opts.data;
      var optUpdated = opts.updated;
      var optClear = opts.clear;
      arrayEach(array, function(item) {
        var childList = item[optChildren];
        if (optData) {
          item = item[optData];
        }
        if (optUpdated !== false) {
          item[optParentKey] = parentItem ? parentItem[optKey] : null;
        }
        result.push(item);
        if (childList && childList.length) {
          unTreeList(result, item, childList, opts);
        }
        if (optClear) {
          delete item[optChildren];
        }
      });
      return result;
    }
    function toTreeArray(array, options) {
      return unTreeList([], null, array, assign({}, setupDefaults.treeOptions, options));
    }
    module.exports = toTreeArray;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateTreeFunc.js
var require_helperCreateTreeFunc = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateTreeFunc.js"(exports, module) {
    function helperCreateTreeFunc(handle) {
      return function(obj, iterate, options, context) {
        var opts = options || {};
        var optChildren = opts.children || "children";
        return handle(null, obj, iterate, context, [], [], optChildren, opts);
      };
    }
    module.exports = helperCreateTreeFunc;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findTree.js
var require_findTree = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findTree.js"(exports, module) {
    var helperCreateTreeFunc = require_helperCreateTreeFunc();
    function findTreeItem(parent, obj, iterate, context, path, node, parseChildren, opts) {
      if (obj) {
        var item, index, len, paths, nodes, match;
        for (index = 0, len = obj.length; index < len; index++) {
          item = obj[index];
          paths = path.concat(["" + index]);
          nodes = node.concat([item]);
          if (iterate.call(context, item, index, obj, paths, parent, nodes)) {
            return { index, item, path: paths, items: obj, parent, nodes };
          }
          if (parseChildren && item) {
            match = findTreeItem(item, item[parseChildren], iterate, context, paths.concat([parseChildren]), nodes, parseChildren, opts);
            if (match) {
              return match;
            }
          }
        }
      }
    }
    var findTree = helperCreateTreeFunc(findTreeItem);
    module.exports = findTree;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/eachTree.js
var require_eachTree = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/eachTree.js"(exports, module) {
    var helperCreateTreeFunc = require_helperCreateTreeFunc();
    var each = require_each();
    function eachTreeItem(parent, obj, iterate, context, path, node, parseChildren, opts) {
      var paths, nodes;
      each(obj, function(item, index) {
        paths = path.concat(["" + index]);
        nodes = node.concat([item]);
        iterate.call(context, item, index, obj, paths, parent, nodes);
        if (item && parseChildren) {
          paths.push(parseChildren);
          eachTreeItem(item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
        }
      });
    }
    var eachTree = helperCreateTreeFunc(eachTreeItem);
    module.exports = eachTree;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/mapTree.js
var require_mapTree = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/mapTree.js"(exports, module) {
    var helperCreateTreeFunc = require_helperCreateTreeFunc();
    var map = require_map();
    function mapTreeItem(parent, obj, iterate, context, path, node, parseChildren, opts) {
      var paths, nodes, rest;
      var mapChildren = opts.mapChildren || parseChildren;
      return map(obj, function(item, index) {
        paths = path.concat(["" + index]);
        nodes = node.concat([item]);
        rest = iterate.call(context, item, index, obj, paths, parent, nodes);
        if (rest && item && parseChildren && item[parseChildren]) {
          rest[mapChildren] = mapTreeItem(item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
        }
        return rest;
      });
    }
    var mapTree = helperCreateTreeFunc(mapTreeItem);
    module.exports = mapTree;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/filterTree.js
var require_filterTree = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/filterTree.js"(exports, module) {
    var eachTree = require_eachTree();
    function filterTree(obj, iterate, options, context) {
      var result = [];
      if (obj && iterate) {
        eachTree(obj, function(item, index, items, path, parent, nodes) {
          if (iterate.call(context, item, index, items, path, parent, nodes)) {
            result.push(item);
          }
        }, options);
      }
      return result;
    }
    module.exports = filterTree;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/searchTree.js
var require_searchTree = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/searchTree.js"(exports, module) {
    var helperCreateTreeFunc = require_helperCreateTreeFunc();
    var arrayEach = require_arrayEach();
    var assign = require_assign();
    function searchTreeItem(matchParent, parent, obj, iterate, context, path, node, parseChildren, opts) {
      var paths, nodes, rest, isMatch, hasChild;
      var rests = [];
      var hasOriginal = opts.original;
      var sourceData = opts.data;
      var mapChildren = opts.mapChildren || parseChildren;
      var isEvery = opts.isEvery;
      arrayEach(obj, function(item, index) {
        paths = path.concat(["" + index]);
        nodes = node.concat([item]);
        isMatch = matchParent && !isEvery || iterate.call(context, item, index, obj, paths, parent, nodes);
        hasChild = parseChildren && item[parseChildren];
        if (isMatch || hasChild) {
          if (hasOriginal) {
            rest = item;
          } else {
            rest = assign({}, item);
            if (sourceData) {
              rest[sourceData] = item;
            }
          }
          rest[mapChildren] = searchTreeItem(isMatch, item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
          if (isMatch || rest[mapChildren].length) {
            rests.push(rest);
          }
        } else if (isMatch) {
          rests.push(rest);
        }
      });
      return rests;
    }
    var searchTree = helperCreateTreeFunc(function(parent, obj, iterate, context, path, nodes, parseChildren, opts) {
      return searchTreeItem(0, parent, obj, iterate, context, path, nodes, parseChildren, opts);
    });
    module.exports = searchTree;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/arrayIndexOf.js
var require_arrayIndexOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/arrayIndexOf.js"(exports, module) {
    function arrayIndexOf(list, val) {
      if (list.indexOf) {
        return list.indexOf(val);
      }
      for (var index = 0, len = list.length; index < len; index++) {
        if (val === list[index]) {
          return index;
        }
      }
    }
    module.exports = arrayIndexOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/arrayLastIndexOf.js
var require_arrayLastIndexOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/arrayLastIndexOf.js"(exports, module) {
    function arrayLastIndexOf(list, val) {
      if (list.lastIndexOf) {
        return list.lastIndexOf(val);
      }
      for (var len = list.length - 1; len >= 0; len--) {
        if (val === list[len]) {
          return len;
        }
      }
      return -1;
    }
    module.exports = arrayLastIndexOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isNumber.js"(exports, module) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isNumber = helperCreateInTypeof("number");
    module.exports = isNumber;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isNaN.js"(exports, module) {
    var isNumber = require_isNumber();
    function isNumberNaN(obj) {
      return isNumber(obj) && isNaN(obj);
    }
    module.exports = isNumberNaN;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isString.js
var require_isString = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isString.js"(exports, module) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isString = helperCreateInTypeof("string");
    module.exports = isString;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isDate.js
var require_isDate = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isDate.js"(exports, module) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isDate = helperCreateInInObjectString("Date");
    module.exports = isDate;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticParseInt.js
var require_staticParseInt = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticParseInt.js"(exports, module) {
    var staticParseInt = parseInt;
    module.exports = staticParseInt;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetUTCDateTime.js
var require_helperGetUTCDateTime = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetUTCDateTime.js"(exports, module) {
    function helperGetUTCDateTime(resMaps) {
      return Date.UTC(resMaps.y, resMaps.M || 0, resMaps.d || 1, resMaps.H || 0, resMaps.m || 0, resMaps.s || 0, resMaps.S || 0);
    }
    module.exports = helperGetUTCDateTime;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetDateTime.js
var require_helperGetDateTime = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetDateTime.js"(exports, module) {
    function helperGetDateTime(date) {
      return date.getTime();
    }
    module.exports = helperGetDateTime;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toStringDate.js
var require_toStringDate = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toStringDate.js"(exports, module) {
    var staticParseInt = require_staticParseInt();
    var helperGetUTCDateTime = require_helperGetUTCDateTime();
    var helperGetDateTime = require_helperGetDateTime();
    var isString = require_isString();
    var isDate = require_isDate();
    function getParseRule(txt) {
      return "(\\d{" + txt + "})";
    }
    function toParseMs(num) {
      if (num < 10) {
        return num * 100;
      } else if (num < 100) {
        return num * 10;
      }
      return num;
    }
    function toParseNum(num) {
      return isNaN(num) ? num : staticParseInt(num);
    }
    var d2 = getParseRule(2);
    var d1or2 = getParseRule("1,2");
    var d1or7 = getParseRule("1,7");
    var d3or4 = getParseRule("3,4");
    var place = ".{1}";
    var d1Or2RE = place + d1or2;
    var dzZ = "(([zZ])|([-+]\\d{2}:?\\d{2}))";
    var defaulParseStrs = [d3or4, d1Or2RE, d1Or2RE, d1Or2RE, d1Or2RE, d1Or2RE, place + d1or7, dzZ];
    var defaulParseREs = [];
    for (len = defaulParseStrs.length - 1; len >= 0; len--) {
      rule = "";
      for (i = 0; i < len + 1; i++) {
        rule += defaulParseStrs[i];
      }
      defaulParseREs.push(new RegExp("^" + rule + "$"));
    }
    var rule;
    var i;
    var len;
    function parseDefaultRules(str) {
      var matchRest, resMaps = {};
      for (var i2 = 0, dfrLen = defaulParseREs.length; i2 < dfrLen; i2++) {
        matchRest = str.match(defaulParseREs[i2]);
        if (matchRest) {
          resMaps.y = matchRest[1];
          resMaps.M = matchRest[2];
          resMaps.d = matchRest[3];
          resMaps.H = matchRest[4];
          resMaps.m = matchRest[5];
          resMaps.s = matchRest[6];
          resMaps.S = matchRest[7];
          resMaps.Z = matchRest[8];
          break;
        }
      }
      return resMaps;
    }
    var customParseStrs = [
      ["yyyy", d3or4],
      ["yy", d2],
      ["MM", d2],
      ["M", d1or2],
      ["dd", d2],
      ["d", d1or2],
      ["HH", d2],
      ["H", d1or2],
      ["mm", d2],
      ["m", d1or2],
      ["ss", d2],
      ["s", d1or2],
      ["SSS", getParseRule(3)],
      ["S", d1or7],
      ["Z", dzZ]
    ];
    var parseRuleMaps = {};
    var parseRuleKeys = ["\\[([^\\]]+)\\]"];
    for (i = 0; i < customParseStrs.length; i++) {
      itemRule = customParseStrs[i];
      parseRuleMaps[itemRule[0]] = itemRule[1] + "?";
      parseRuleKeys.push(itemRule[0]);
    }
    var itemRule;
    var i;
    var customParseRes = new RegExp(parseRuleKeys.join("|"), "g");
    var cacheFormatMaps = {};
    function parseCustomRules(str, format) {
      var cacheItem = cacheFormatMaps[format];
      if (!cacheItem) {
        var posIndexs = [];
        var re = format.replace(/([$(){}*+.?\\^|])/g, "\\$1").replace(customParseRes, function(text, val) {
          var firstChar = text.charAt(0);
          if (firstChar === "[") {
            return val;
          }
          posIndexs.push(firstChar);
          return parseRuleMaps[text];
        });
        cacheItem = cacheFormatMaps[format] = {
          _i: posIndexs,
          _r: new RegExp(re)
        };
      }
      var resMaps = {};
      var matchRest = str.match(cacheItem._r);
      if (matchRest) {
        var _i = cacheItem._i;
        for (var i2 = 1, len2 = matchRest.length; i2 < len2; i2++) {
          resMaps[_i[i2 - 1]] = matchRest[i2];
        }
        return resMaps;
      }
      return resMaps;
    }
    function parseTimeZone(resMaps) {
      if (/^[zZ]/.test(resMaps.Z)) {
        return new Date(helperGetUTCDateTime(resMaps));
      } else {
        var matchRest = resMaps.Z.match(/([-+])(\d{2}):?(\d{2})/);
        if (matchRest) {
          return new Date(helperGetUTCDateTime(resMaps) - (matchRest[1] === "-" ? -1 : 1) * staticParseInt(matchRest[2]) * 36e5 + staticParseInt(matchRest[3]) * 6e4);
        }
      }
      return /* @__PURE__ */ new Date("");
    }
    function toStringDate(str, format) {
      if (str) {
        var isDType = isDate(str);
        if (isDType || !format && /^[0-9]{11,15}$/.test(str)) {
          return new Date(isDType ? helperGetDateTime(str) : staticParseInt(str));
        }
        if (isString(str)) {
          var resMaps = format ? parseCustomRules(str, format) : parseDefaultRules(str);
          if (resMaps.y) {
            if (resMaps.M) {
              resMaps.M = toParseNum(resMaps.M) - 1;
            }
            if (resMaps.S) {
              resMaps.S = toParseMs(toParseNum(resMaps.S.substring(0, 3)));
            }
            if (resMaps.Z) {
              return parseTimeZone(resMaps);
            } else {
              return new Date(resMaps.y, resMaps.M || 0, resMaps.d || 1, resMaps.H || 0, resMaps.m || 0, resMaps.s || 0, resMaps.S || 0);
            }
          }
        }
      }
      return /* @__PURE__ */ new Date("");
    }
    module.exports = toStringDate;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNewDate.js
var require_helperNewDate = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNewDate.js"(exports, module) {
    function helperNewDate() {
      return /* @__PURE__ */ new Date();
    }
    module.exports = helperNewDate;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isLeapYear.js
var require_isLeapYear = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isLeapYear.js"(exports, module) {
    var isDate = require_isDate();
    var toStringDate = require_toStringDate();
    var helperNewDate = require_helperNewDate();
    function isLeapYear(date) {
      var year;
      var currentDate = date ? toStringDate(date) : helperNewDate();
      if (isDate(currentDate)) {
        year = currentDate.getFullYear();
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      return false;
    }
    module.exports = isLeapYear;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/forOf.js
var require_forOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/forOf.js"(exports, module) {
    var isArray = require_isArray();
    var hasOwnProp = require_hasOwnProp();
    function forOf(obj, iterate, context) {
      if (obj) {
        if (isArray(obj)) {
          for (var index = 0, len = obj.length; index < len; index++) {
            if (iterate.call(context, obj[index], index, obj) === false) {
              break;
            }
          }
        } else {
          for (var key in obj) {
            if (hasOwnProp(obj, key)) {
              if (iterate.call(context, obj[key], key, obj) === false) {
                break;
              }
            }
          }
        }
      }
    }
    module.exports = forOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastForOf.js
var require_lastForOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastForOf.js"(exports, module) {
    var isArray = require_isArray();
    var keys = require_hasOwnProp();
    function lastForOf(obj, iterate, context) {
      if (obj) {
        var len, list;
        if (isArray(obj)) {
          for (len = obj.length - 1; len >= 0; len--) {
            if (iterate.call(context, obj[len], len, obj) === false) {
              break;
            }
          }
        } else {
          list = keys(obj);
          for (len = list.length - 1; len >= 0; len--) {
            if (iterate.call(context, obj[list[len]], list[len], obj) === false) {
              break;
            }
          }
        }
      }
    }
    module.exports = lastForOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateIndexOf.js
var require_helperCreateIndexOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateIndexOf.js"(exports, module) {
    var isArray = require_isArray();
    var isString = require_isString();
    var hasOwnProp = require_hasOwnProp();
    function helperCreateIndexOf(name, callback) {
      return function(obj, val) {
        if (obj) {
          if (obj[name]) {
            return obj[name](val);
          }
          if (isString(obj) || isArray(obj)) {
            return callback(obj, val);
          }
          for (var key in obj) {
            if (hasOwnProp(obj, key)) {
              if (val === obj[key]) {
                return key;
              }
            }
          }
        }
        return -1;
      };
    }
    module.exports = helperCreateIndexOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/indexOf.js
var require_indexOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/indexOf.js"(exports, module) {
    var helperCreateIndexOf = require_helperCreateIndexOf();
    var arrayIndexOf = require_arrayIndexOf();
    var indexOf = helperCreateIndexOf("indexOf", arrayIndexOf);
    module.exports = indexOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastIndexOf.js
var require_lastIndexOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastIndexOf.js"(exports, module) {
    var helperCreateIndexOf = require_helperCreateIndexOf();
    var arrayLastIndexOf = require_arrayLastIndexOf();
    var lastIndexOf = helperCreateIndexOf("lastIndexOf", arrayLastIndexOf);
    module.exports = lastIndexOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getSize.js
var require_getSize = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getSize.js"(exports, module) {
    var isArray = require_isArray();
    var isString = require_isString();
    var each = require_each();
    function getSize(obj) {
      var len = 0;
      if (isString(obj) || isArray(obj)) {
        return obj.length;
      }
      each(obj, function() {
        len++;
      });
      return len;
    }
    module.exports = getSize;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isFinite.js
var require_isFinite = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isFinite.js"(exports, module) {
    var isNumber = require_isNumber();
    function isNumberFinite(obj) {
      return isNumber(obj) && isFinite(obj);
    }
    module.exports = isNumberFinite;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isInteger.js
var require_isInteger = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isInteger.js"(exports, module) {
    var isArray = require_isArray();
    var isNull = require_isNull();
    var isInteger = function(obj) {
      return !isNull(obj) && !isNaN(obj) && !isArray(obj) && obj % 1 === 0;
    };
    module.exports = isInteger;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isFloat.js
var require_isFloat = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isFloat.js"(exports, module) {
    var isArray = require_isArray();
    var isInteger = require_isInteger();
    var isNull = require_isNull();
    function isFloat(obj) {
      return !isNull(obj) && !isNaN(obj) && !isArray(obj) && !isInteger(obj);
    }
    module.exports = isFloat;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isBoolean.js
var require_isBoolean = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isBoolean.js"(exports, module) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isBoolean = helperCreateInTypeof("boolean");
    module.exports = isBoolean;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isRegExp.js
var require_isRegExp = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isRegExp.js"(exports, module) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isRegExp = helperCreateInInObjectString("RegExp");
    module.exports = isRegExp;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isError.js
var require_isError = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isError.js"(exports, module) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isError = helperCreateInInObjectString("Error");
    module.exports = isError;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isTypeError.js
var require_isTypeError = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isTypeError.js"(exports, module) {
    function isTypeError(obj) {
      return obj ? obj.constructor === TypeError : false;
    }
    module.exports = isTypeError;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isEmpty.js"(exports, module) {
    function isEmpty(obj) {
      for (var key in obj) {
        return false;
      }
      return true;
    }
    module.exports = isEmpty;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isSymbol.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportSymbol = typeof Symbol !== staticStrUndefined;
    function isSymbol(obj) {
      return supportSymbol && Symbol.isSymbol ? Symbol.isSymbol(obj) : typeof obj === "symbol";
    }
    module.exports = isSymbol;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isArguments.js"(exports, module) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isArguments = helperCreateInInObjectString("Arguments");
    module.exports = isArguments;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isElement.js
var require_isElement = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isElement.js"(exports, module) {
    var isString = require_isString();
    var isNumber = require_isNumber();
    function isElement(obj) {
      return !!(obj && isString(obj.nodeName) && isNumber(obj.nodeType));
    }
    module.exports = isElement;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticDocument.js
var require_staticDocument = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticDocument.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var staticDocument = typeof document === staticStrUndefined ? 0 : document;
    module.exports = staticDocument;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isDocument.js
var require_isDocument = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isDocument.js"(exports, module) {
    var staticDocument = require_staticDocument();
    function isDocument(obj) {
      return !!(obj && staticDocument && obj.nodeType === 9);
    }
    module.exports = isDocument;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticWindow.js
var require_staticWindow = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticWindow.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var staticWindow = typeof window === staticStrUndefined ? 0 : window;
    module.exports = staticWindow;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isWindow.js
var require_isWindow = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isWindow.js"(exports, module) {
    var staticWindow = require_staticWindow();
    function isWindow(obj) {
      return !!(staticWindow && !!(obj && obj === obj.window));
    }
    module.exports = isWindow;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isFormData.js
var require_isFormData = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isFormData.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportFormData = typeof FormData !== staticStrUndefined;
    function isFormData(obj) {
      return supportFormData && obj instanceof FormData;
    }
    module.exports = isFormData;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isMap.js
var require_isMap = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isMap.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportMap = typeof Map !== staticStrUndefined;
    function isMap(obj) {
      return supportMap && obj instanceof Map;
    }
    module.exports = isMap;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isWeakMap.js
var require_isWeakMap = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isWeakMap.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportWeakMap = typeof WeakMap !== staticStrUndefined;
    function isWeakMap(obj) {
      return supportWeakMap && obj instanceof WeakMap;
    }
    module.exports = isWeakMap;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isSet.js
var require_isSet = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isSet.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportSet = typeof Set !== staticStrUndefined;
    function isSet(obj) {
      return supportSet && obj instanceof Set;
    }
    module.exports = isSet;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isWeakSet.js
var require_isWeakSet = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isWeakSet.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportWeakSet = typeof WeakSet !== staticStrUndefined;
    function isWeakSet(obj) {
      return supportWeakSet && obj instanceof WeakSet;
    }
    module.exports = isWeakSet;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateiterateIndexOf.js
var require_helperCreateiterateIndexOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateiterateIndexOf.js"(exports, module) {
    var isFunction = require_isFunction();
    var isString = require_isString();
    var isArray = require_isArray();
    var hasOwnProp = require_hasOwnProp();
    function helperCreateiterateIndexOf(callback) {
      return function(obj, iterate, context) {
        if (obj && isFunction(iterate)) {
          if (isArray(obj) || isString(obj)) {
            return callback(obj, iterate, context);
          }
          for (var key in obj) {
            if (hasOwnProp(obj, key)) {
              if (iterate.call(context, obj[key], key, obj)) {
                return key;
              }
            }
          }
        }
        return -1;
      };
    }
    module.exports = helperCreateiterateIndexOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findIndexOf.js
var require_findIndexOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findIndexOf.js"(exports, module) {
    var helperCreateiterateIndexOf = require_helperCreateiterateIndexOf();
    var findIndexOf = helperCreateiterateIndexOf(function(obj, iterate, context) {
      for (var index = 0, len = obj.length; index < len; index++) {
        if (iterate.call(context, obj[index], index, obj)) {
          return index;
        }
      }
      return -1;
    });
    module.exports = findIndexOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperEqualCompare.js
var require_helperEqualCompare = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperEqualCompare.js"(exports, module) {
    var isNumber = require_isNumber();
    var isArray = require_isArray();
    var isString = require_isString();
    var isRegExp = require_isRegExp();
    var isDate = require_isDate();
    var isBoolean = require_isBoolean();
    var isUndefined = require_isUndefined();
    var keys = require_keys();
    var every = require_every();
    function helperEqualCompare(val1, val2, compare, func, key, obj1, obj2) {
      if (val1 === val2) {
        return true;
      }
      if (val1 && val2 && !isNumber(val1) && !isNumber(val2) && !isString(val1) && !isString(val2)) {
        if (isRegExp(val1)) {
          return compare("" + val1, "" + val2, key, obj1, obj2);
        }
        if (isDate(val1) || isBoolean(val1)) {
          return compare(+val1, +val2, key, obj1, obj2);
        } else {
          var result, val1Keys, val2Keys;
          var isObj1Arr = isArray(val1);
          var isObj2Arr = isArray(val2);
          if (isObj1Arr || isObj2Arr ? isObj1Arr && isObj2Arr : val1.constructor === val2.constructor) {
            val1Keys = keys(val1);
            val2Keys = keys(val2);
            if (func) {
              result = func(val1, val2, key);
            }
            if (val1Keys.length === val2Keys.length) {
              return isUndefined(result) ? every(val1Keys, function(key2, index) {
                return key2 === val2Keys[index] && helperEqualCompare(val1[key2], val2[val2Keys[index]], compare, func, isObj1Arr || isObj2Arr ? index : key2, val1, val2);
              }) : !!result;
            }
            return false;
          }
        }
      }
      return compare(val1, val2, key, obj1, obj2);
    }
    module.exports = helperEqualCompare;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperDefaultCompare.js
var require_helperDefaultCompare = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperDefaultCompare.js"(exports, module) {
    function helperDefaultCompare(v1, v2) {
      return v1 === v2;
    }
    module.exports = helperDefaultCompare;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isEqual.js"(exports, module) {
    var helperEqualCompare = require_helperEqualCompare();
    var helperDefaultCompare = require_helperDefaultCompare();
    function isEqual(obj1, obj2) {
      return helperEqualCompare(obj1, obj2, helperDefaultCompare);
    }
    module.exports = isEqual;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isMatch.js
var require_isMatch = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isMatch.js"(exports, module) {
    var keys = require_keys();
    var findIndexOf = require_findIndexOf();
    var isEqual = require_isEqual();
    var some = require_some();
    var includeArrays = require_includeArrays();
    function isMatch(obj, source) {
      var objKeys = keys(obj);
      var sourceKeys = keys(source);
      if (sourceKeys.length) {
        if (includeArrays(objKeys, sourceKeys)) {
          return some(sourceKeys, function(key2) {
            return findIndexOf(objKeys, function(key1) {
              return key1 === key2 && isEqual(obj[key1], source[key2]);
            }) > -1;
          });
        }
      } else {
        return true;
      }
      return isEqual(obj, source);
    }
    module.exports = isMatch;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isEqualWith.js
var require_isEqualWith = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isEqualWith.js"(exports, module) {
    var helperEqualCompare = require_helperEqualCompare();
    var helperDefaultCompare = require_helperDefaultCompare();
    var isFunction = require_isFunction();
    var isUndefined = require_isUndefined();
    function isEqualWith(obj1, obj2, func) {
      if (isFunction(func)) {
        return helperEqualCompare(obj1, obj2, function(v1, v2, key, obj12, obj22) {
          var result = func(v1, v2, key, obj12, obj22);
          return isUndefined(result) ? helperDefaultCompare(v1, v2) : !!result;
        }, func);
      }
      return helperEqualCompare(obj1, obj2, helperDefaultCompare);
    }
    module.exports = isEqualWith;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getType.js
var require_getType = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getType.js"(exports, module) {
    var isSymbol = require_isSymbol();
    var isDate = require_isDate();
    var isArray = require_isArray();
    var isRegExp = require_isRegExp();
    var isError = require_isError();
    var isNull = require_isNull();
    function getType(obj) {
      if (isNull(obj)) {
        return "null";
      }
      if (isSymbol(obj)) {
        return "symbol";
      }
      if (isDate(obj)) {
        return "date";
      }
      if (isArray(obj)) {
        return "array";
      }
      if (isRegExp(obj)) {
        return "regexp";
      }
      if (isError(obj)) {
        return "error";
      }
      return typeof obj;
    }
    module.exports = getType;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/uniqueId.js
var require_uniqueId = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/uniqueId.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var eqNull = require_eqNull();
    function uniqueId(prefix) {
      return "" + (eqNull(prefix) ? "" : prefix) + setupDefaults.keyId++;
    }
    module.exports = uniqueId;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findLastIndexOf.js
var require_findLastIndexOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findLastIndexOf.js"(exports, module) {
    var helperCreateiterateIndexOf = require_helperCreateiterateIndexOf();
    var findLastIndexOf = helperCreateiterateIndexOf(function(obj, iterate, context) {
      for (var len = obj.length - 1; len >= 0; len--) {
        if (iterate.call(context, obj[len], len, obj)) {
          return len;
        }
      }
      return -1;
    });
    module.exports = findLastIndexOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toStringJSON.js
var require_toStringJSON = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toStringJSON.js"(exports, module) {
    var isPlainObject = require_isPlainObject();
    var isString = require_isString();
    function toStringJSON(str) {
      if (isPlainObject(str)) {
        return str;
      } else if (isString(str)) {
        try {
          return JSON.parse(str);
        } catch (e) {
        }
      }
      return {};
    }
    module.exports = toStringJSON;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toJSONString.js
var require_toJSONString = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toJSONString.js"(exports, module) {
    var eqNull = require_eqNull();
    function toJSONString(obj) {
      return eqNull(obj) ? "" : JSON.stringify(obj);
    }
    module.exports = toJSONString;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/entries.js
var require_entries = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/entries.js"(exports, module) {
    var helperCreateGetObjects = require_helperCreateGetObjects();
    var entries = helperCreateGetObjects("entries", 2);
    module.exports = entries;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreatePickOmit.js
var require_helperCreatePickOmit = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreatePickOmit.js"(exports, module) {
    var isFunction = require_isFunction();
    var isArray = require_isArray();
    var each = require_each();
    var findIndexOf = require_findIndexOf();
    function helperCreatePickOmit(case1, case2) {
      return function(obj, callback) {
        var item, index;
        var rest = {};
        var result = [];
        var context = this;
        var args = arguments;
        var len = args.length;
        if (!isFunction(callback)) {
          for (index = 1; index < len; index++) {
            item = args[index];
            result.push.apply(result, isArray(item) ? item : [item]);
          }
          callback = 0;
        }
        each(obj, function(val, key) {
          if ((callback ? callback.call(context, val, key, obj) : findIndexOf(result, function(name) {
            return name === key;
          }) > -1) ? case1 : case2) {
            rest[key] = val;
          }
        });
        return rest;
      };
    }
    module.exports = helperCreatePickOmit;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/pick.js
var require_pick = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/pick.js"(exports, module) {
    var helperCreatePickOmit = require_helperCreatePickOmit();
    var pick = helperCreatePickOmit(1, 0);
    module.exports = pick;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/omit.js
var require_omit = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/omit.js"(exports, module) {
    var helperCreatePickOmit = require_helperCreatePickOmit();
    var omit = helperCreatePickOmit(0, 1);
    module.exports = omit;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/first.js
var require_first = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/first.js"(exports, module) {
    var values = require_values();
    function first(obj) {
      return values(obj)[0];
    }
    module.exports = first;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/last.js
var require_last = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/last.js"(exports, module) {
    var values = require_values();
    function last(obj) {
      var list = values(obj);
      return list[list.length - 1];
    }
    module.exports = last;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/has.js
var require_has = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/has.js"(exports, module) {
    var staticHGKeyRE = require_staticHGKeyRE();
    var helperGetHGSKeys = require_helperGetHGSKeys();
    var hasOwnProp = require_hasOwnProp();
    function has(obj, property) {
      if (obj) {
        if (hasOwnProp(obj, property)) {
          return true;
        } else {
          var prop, arrIndex, objProp, matchs, rest, isHas;
          var props = helperGetHGSKeys(property);
          var index = 0;
          var len = props.length;
          for (rest = obj; index < len; index++) {
            isHas = false;
            prop = props[index];
            matchs = prop ? prop.match(staticHGKeyRE) : "";
            if (matchs) {
              arrIndex = matchs[1];
              objProp = matchs[2];
              if (arrIndex) {
                if (rest[arrIndex]) {
                  if (hasOwnProp(rest[arrIndex], objProp)) {
                    isHas = true;
                    rest = rest[arrIndex][objProp];
                  }
                }
              } else {
                if (hasOwnProp(rest, objProp)) {
                  isHas = true;
                  rest = rest[objProp];
                }
              }
            } else {
              if (hasOwnProp(rest, prop)) {
                isHas = true;
                rest = rest[prop];
              }
            }
            if (isHas) {
              if (index === len - 1) {
                return true;
              }
            } else {
              break;
            }
          }
        }
      }
      return false;
    }
    module.exports = has;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/set.js
var require_set = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/set.js"(exports, module) {
    var staticParseInt = require_staticParseInt();
    var helperGetHGSKeys = require_helperGetHGSKeys();
    var helperCheckCopyKey = require_helperCheckCopyKey();
    var hasOwnProp = require_hasOwnProp();
    var sKeyRE = /(.+)?\[(\d+)\]$/;
    function setDeepProps(obj, key, isEnd, nextKey, value) {
      if (obj[key]) {
        if (isEnd) {
          obj[key] = value;
        }
      } else {
        var index;
        var rest;
        var currMatchs = key ? key.match(sKeyRE) : null;
        if (isEnd) {
          rest = value;
        } else {
          var nextMatchs = nextKey ? nextKey.match(sKeyRE) : null;
          if (nextMatchs && !nextMatchs[1]) {
            rest = new Array(staticParseInt(nextMatchs[2]) + 1);
          } else {
            rest = {};
          }
        }
        if (currMatchs) {
          if (currMatchs[1]) {
            index = staticParseInt(currMatchs[2]);
            if (obj[currMatchs[1]]) {
              if (isEnd) {
                obj[currMatchs[1]][index] = rest;
              } else {
                if (obj[currMatchs[1]][index]) {
                  rest = obj[currMatchs[1]][index];
                } else {
                  obj[currMatchs[1]][index] = rest;
                }
              }
            } else {
              obj[currMatchs[1]] = new Array(index + 1);
              obj[currMatchs[1]][index] = rest;
            }
          } else {
            obj[currMatchs[2]] = rest;
          }
        } else {
          obj[key] = rest;
        }
        return rest;
      }
      return obj[key];
    }
    function set(obj, property, value) {
      if (obj && helperCheckCopyKey(property)) {
        if ((obj[property] || hasOwnProp(obj, property)) && !isPrototypePolluted(property)) {
          obj[property] = value;
        } else {
          var rest = obj;
          var props = helperGetHGSKeys(property);
          var len = props.length;
          for (var index = 0; index < len; index++) {
            if (isPrototypePolluted(props[index])) {
              continue;
            }
            var isEnd = index === len - 1;
            rest = setDeepProps(rest, props[index], isEnd, isEnd ? null : props[index + 1], value);
          }
        }
      }
      return obj;
    }
    function isPrototypePolluted(key) {
      return key === "__proto__" || key === "constructor" || key === "prototype";
    }
    module.exports = set;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/groupBy.js"(exports, module) {
    var isEmpty = require_isEmpty();
    var isObject = require_isObject();
    var isFunction = require_isFunction();
    var property = require_property();
    var each = require_each();
    function createiterateEmpty(iterate) {
      return function() {
        return isEmpty(iterate);
      };
    }
    function groupBy(obj, iterate, context) {
      var groupKey;
      var result = {};
      if (obj) {
        if (iterate && isObject(iterate)) {
          iterate = createiterateEmpty(iterate);
        } else if (!isFunction(iterate)) {
          iterate = property(iterate);
        }
        each(obj, function(val, key) {
          groupKey = iterate ? iterate.call(context, val, key, obj) : val;
          if (result[groupKey]) {
            result[groupKey].push(val);
          } else {
            result[groupKey] = [val];
          }
        });
      }
      return result;
    }
    module.exports = groupBy;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/countBy.js
var require_countBy = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/countBy.js"(exports, module) {
    var groupBy = require_groupBy();
    var objectEach = require_objectEach();
    function countBy(obj, iterate, context) {
      var result = groupBy(obj, iterate, context || this);
      objectEach(result, function(item, key) {
        result[key] = item.length;
      });
      return result;
    }
    module.exports = countBy;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/range.js
var require_range = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/range.js"(exports, module) {
    function range(start, stop, step) {
      var index, len;
      var result = [];
      var args = arguments;
      if (args.length < 2) {
        stop = args[0];
        start = 0;
      }
      index = start >> 0;
      len = stop >> 0;
      if (index < stop) {
        step = step >> 0 || 1;
        for (; index < len; index += step) {
          result.push(index);
        }
      }
      return result;
    }
    module.exports = range;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/destructuring.js
var require_destructuring = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/destructuring.js"(exports, module) {
    var keys = require_keys();
    var slice = require_slice();
    var includes = require_includes();
    var arrayEach = require_arrayEach();
    var assign = require_assign();
    function destructuring(destination, sources) {
      if (destination && sources) {
        var rest = assign.apply(this, [{}].concat(slice(arguments, 1)));
        var restKeys = keys(rest);
        arrayEach(keys(destination), function(key) {
          if (includes(restKeys, key)) {
            destination[key] = rest[key];
          }
        });
      }
      return destination;
    }
    module.exports = destructuring;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/min.js
var require_min = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/min.js"(exports, module) {
    var helperCreateMinMax = require_helperCreateMinMax();
    var min = helperCreateMinMax(function(rest, itemVal) {
      return rest > itemVal;
    });
    module.exports = min;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNumberDecimal.js
var require_helperNumberDecimal = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNumberDecimal.js"(exports, module) {
    function helperNumberDecimal(numStr) {
      return (numStr.split(".")[1] || "").length;
    }
    module.exports = helperNumberDecimal;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperStringRepeat.js
var require_helperStringRepeat = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperStringRepeat.js"(exports, module) {
    var staticParseInt = require_staticParseInt();
    function helperStringRepeat(str, count) {
      if (str.repeat) {
        return str.repeat(count);
      }
      var list = isNaN(count) ? [] : new Array(staticParseInt(count));
      return list.join(str) + (list.length > 0 ? str : "");
    }
    module.exports = helperStringRepeat;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNumberOffsetPoint.js
var require_helperNumberOffsetPoint = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNumberOffsetPoint.js"(exports, module) {
    function helperNumberOffsetPoint(str, offsetIndex) {
      return str.substring(0, offsetIndex) + "." + str.substring(offsetIndex, str.length);
    }
    module.exports = helperNumberOffsetPoint;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toNumberString.js
var require_toNumberString = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toNumberString.js"(exports, module) {
    var helperStringRepeat = require_helperStringRepeat();
    var helperNumberOffsetPoint = require_helperNumberOffsetPoint();
    function toNumberString(num) {
      var rest = "" + num;
      var scienceMatchs = rest.match(/^([-+]?)((\d+)|((\d+)?[.](\d+)?))e([-+]{1})([0-9]+)$/);
      if (scienceMatchs) {
        var isNegative = num < 0;
        var absFlag = isNegative ? "-" : "";
        var intNumStr = scienceMatchs[3] || "";
        var dIntNumStr = scienceMatchs[5] || "";
        var dFloatNumStr = scienceMatchs[6] || "";
        var sciencFlag = scienceMatchs[7];
        var scienceNumStr = scienceMatchs[8];
        var floatOffsetIndex = scienceNumStr - dFloatNumStr.length;
        var intOffsetIndex = scienceNumStr - intNumStr.length;
        var dIntOffsetIndex = scienceNumStr - dIntNumStr.length;
        if (sciencFlag === "+") {
          if (intNumStr) {
            return absFlag + intNumStr + helperStringRepeat("0", scienceNumStr);
          }
          if (floatOffsetIndex > 0) {
            return absFlag + dIntNumStr + dFloatNumStr + helperStringRepeat("0", floatOffsetIndex);
          }
          return absFlag + dIntNumStr + helperNumberOffsetPoint(dFloatNumStr, scienceNumStr);
        }
        if (intNumStr) {
          if (intOffsetIndex > 0) {
            return absFlag + "0." + helperStringRepeat("0", Math.abs(intOffsetIndex)) + intNumStr;
          }
          return absFlag + helperNumberOffsetPoint(intNumStr, intOffsetIndex);
        }
        if (dIntOffsetIndex > 0) {
          return absFlag + "0." + helperStringRepeat("0", Math.abs(dIntOffsetIndex)) + dIntNumStr + dFloatNumStr;
        }
        return absFlag + helperNumberOffsetPoint(dIntNumStr, dIntOffsetIndex) + dFloatNumStr;
      }
      return rest;
    }
    module.exports = toNumberString;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperMultiply.js
var require_helperMultiply = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperMultiply.js"(exports, module) {
    var helperNumberDecimal = require_helperNumberDecimal();
    var toNumberString = require_toNumberString();
    function helperMultiply(multiplier, multiplicand) {
      var str1 = toNumberString(multiplier);
      var str2 = toNumberString(multiplicand);
      return parseInt(str1.replace(".", "")) * parseInt(str2.replace(".", "")) / Math.pow(10, helperNumberDecimal(str1) + helperNumberDecimal(str2));
    }
    module.exports = helperMultiply;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateMathNumber.js
var require_helperCreateMathNumber = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateMathNumber.js"(exports, module) {
    var helperMultiply = require_helperMultiply();
    var toNumber = require_toNumber();
    var toNumberString = require_toNumberString();
    function helperCreateMathNumber(name) {
      return function(num, digits) {
        var numRest = toNumber(num);
        var rest = numRest;
        if (numRest) {
          digits = digits >> 0;
          var numStr = toNumberString(numRest);
          var nums = numStr.split(".");
          var intStr = nums[0];
          var floatStr = nums[1] || "";
          var fStr = floatStr.substring(0, digits + 1);
          var subRest = intStr + (fStr ? "." + fStr : "");
          if (digits >= floatStr.length) {
            return toNumber(subRest);
          }
          subRest = numRest;
          if (digits > 0) {
            var ratio = Math.pow(10, digits);
            rest = Math[name](helperMultiply(subRest, ratio)) / ratio;
          } else {
            rest = Math[name](subRest);
          }
        }
        return rest;
      };
    }
    module.exports = helperCreateMathNumber;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/round.js
var require_round = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/round.js"(exports, module) {
    var helperCreateMathNumber = require_helperCreateMathNumber();
    var round = helperCreateMathNumber("round");
    module.exports = round;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/ceil.js
var require_ceil = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/ceil.js"(exports, module) {
    var helperCreateMathNumber = require_helperCreateMathNumber();
    var ceil = helperCreateMathNumber("ceil");
    module.exports = ceil;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/floor.js
var require_floor = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/floor.js"(exports, module) {
    var helperCreateMathNumber = require_helperCreateMathNumber();
    var floor = helperCreateMathNumber("floor");
    module.exports = floor;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toValueString.js
var require_toValueString = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toValueString.js"(exports, module) {
    var eqNull = require_eqNull();
    var isNumber = require_isNumber();
    var toNumberString = require_toNumberString();
    function toValueString(obj) {
      if (isNumber(obj)) {
        return toNumberString(obj);
      }
      return "" + (eqNull(obj) ? "" : obj);
    }
    module.exports = toValueString;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toFixed.js
var require_toFixed = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toFixed.js"(exports, module) {
    var round = require_round();
    var toValueString = require_toValueString();
    var helperStringRepeat = require_helperStringRepeat();
    var helperNumberOffsetPoint = require_helperNumberOffsetPoint();
    function toFixed(num, digits) {
      digits = digits >> 0;
      var str = toValueString(round(num, digits));
      var nums = str.split(".");
      var intStr = nums[0];
      var floatStr = nums[1] || "";
      var digitOffsetIndex = digits - floatStr.length;
      if (digits) {
        if (digitOffsetIndex > 0) {
          return intStr + "." + floatStr + helperStringRepeat("0", digitOffsetIndex);
        }
        return intStr + helperNumberOffsetPoint(floatStr, Math.abs(digitOffsetIndex));
      }
      return intStr;
    }
    module.exports = toFixed;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/commafy.js
var require_commafy = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/commafy.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var round = require_round();
    var ceil = require_ceil();
    var floor = require_floor();
    var isNumber = require_isNumber();
    var toValueString = require_toValueString();
    var toFixed = require_toFixed();
    var toNumberString = require_toNumberString();
    var assign = require_assign();
    function commafy(num, options) {
      var opts = assign({}, setupDefaults.commafyOptions, options);
      var optDigits = opts.digits;
      var isNum = isNumber(num);
      var rest, result, isNegative, intStr, floatStr;
      if (isNum) {
        rest = (opts.ceil ? ceil : opts.floor ? floor : round)(num, optDigits);
        result = toNumberString(optDigits ? toFixed(rest, optDigits) : rest).split(".");
        intStr = result[0];
        floatStr = result[1];
        isNegative = intStr && rest < 0;
        if (isNegative) {
          intStr = intStr.substring(1, intStr.length);
        }
      } else {
        rest = toValueString(num).replace(/,/g, "");
        result = rest ? [rest] : [];
        intStr = result[0];
      }
      if (result.length) {
        return (isNegative ? "-" : "") + intStr.replace(new RegExp("(?=(?!(\\b))(.{" + (opts.spaceNumber || 3) + "})+$)", "g"), opts.separator || ",") + (floatStr ? "." + floatStr : "");
      }
      return rest;
    }
    module.exports = commafy;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toInteger.js"(exports, module) {
    var staticParseInt = require_staticParseInt();
    var helperCreateToNumber = require_helperCreateToNumber();
    var toInteger = helperCreateToNumber(staticParseInt);
    module.exports = toInteger;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/multiply.js
var require_multiply = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/multiply.js"(exports, module) {
    var helperMultiply = require_helperMultiply();
    var toNumber = require_toNumber();
    function multiply(num1, num2) {
      var multiplier = toNumber(num1);
      var multiplicand = toNumber(num2);
      return helperMultiply(multiplier, multiplicand);
    }
    module.exports = multiply;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNumberAdd.js
var require_helperNumberAdd = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNumberAdd.js"(exports, module) {
    var helperNumberDecimal = require_helperNumberDecimal();
    var toNumberString = require_toNumberString();
    var multiply = require_multiply();
    function helperNumberAdd(addend, augend) {
      var str1 = toNumberString(addend);
      var str2 = toNumberString(augend);
      var ratio = Math.pow(10, Math.max(helperNumberDecimal(str1), helperNumberDecimal(str2)));
      return (multiply(addend, ratio) + multiply(augend, ratio)) / ratio;
    }
    module.exports = helperNumberAdd;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/add.js
var require_add = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/add.js"(exports, module) {
    var helperNumberAdd = require_helperNumberAdd();
    var toNumber = require_toNumber();
    function add(num1, num2) {
      return helperNumberAdd(toNumber(num1), toNumber(num2));
    }
    module.exports = add;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/subtract.js
var require_subtract = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/subtract.js"(exports, module) {
    var helperNumberDecimal = require_helperNumberDecimal();
    var toNumberString = require_toNumberString();
    var toNumber = require_toNumber();
    var toFixed = require_toFixed();
    function subtract(num1, num2) {
      var subtrahend = toNumber(num1);
      var minuend = toNumber(num2);
      var str1 = toNumberString(subtrahend);
      var str2 = toNumberString(minuend);
      var digit1 = helperNumberDecimal(str1);
      var digit2 = helperNumberDecimal(str2);
      var ratio = Math.pow(10, Math.max(digit1, digit2));
      var precision = digit1 >= digit2 ? digit1 : digit2;
      return parseFloat(toFixed((subtrahend * ratio - minuend * ratio) / ratio, precision));
    }
    module.exports = subtract;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNumberDivide.js
var require_helperNumberDivide = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNumberDivide.js"(exports, module) {
    var helperNumberDecimal = require_helperNumberDecimal();
    var toNumberString = require_toNumberString();
    var multiply = require_multiply();
    function helperNumberDivide(divisor, dividend) {
      var str1 = toNumberString(divisor);
      var str2 = toNumberString(dividend);
      var divisorDecimal = helperNumberDecimal(str1);
      var dividendDecimal = helperNumberDecimal(str2);
      var powY = dividendDecimal - divisorDecimal;
      var isMinus = powY < 0;
      var multiplicand = Math.pow(10, isMinus ? Math.abs(powY) : powY);
      return multiply(str1.replace(".", "") / str2.replace(".", ""), isMinus ? 1 / multiplicand : multiplicand);
    }
    module.exports = helperNumberDivide;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/divide.js
var require_divide = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/divide.js"(exports, module) {
    var helperNumberDivide = require_helperNumberDivide();
    var toNumber = require_toNumber();
    function divide(num1, num2) {
      return helperNumberDivide(toNumber(num1), toNumber(num2));
    }
    module.exports = divide;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/sum.js
var require_sum = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/sum.js"(exports, module) {
    var helperNumberAdd = require_helperNumberAdd();
    var isFunction = require_isFunction();
    var isArray = require_isArray();
    var each = require_each();
    var get = require_get();
    function sum(array, iterate, context) {
      var result = 0;
      each(array && array.length > 2 && isArray(array) ? array.sort() : array, iterate ? isFunction(iterate) ? function() {
        result = helperNumberAdd(result, iterate.apply(context, arguments));
      } : function(val) {
        result = helperNumberAdd(result, get(val, iterate));
      } : function(val) {
        result = helperNumberAdd(result, val);
      });
      return result;
    }
    module.exports = sum;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/mean.js
var require_mean = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/mean.js"(exports, module) {
    var helperNumberDivide = require_helperNumberDivide();
    var getSize = require_getSize();
    var sum = require_sum();
    function mean(array, iterate, context) {
      return helperNumberDivide(sum(array, iterate, context), getSize(array));
    }
    module.exports = mean;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticStrFirst.js
var require_staticStrFirst = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticStrFirst.js"(exports, module) {
    var staticStrFirst = "first";
    module.exports = staticStrFirst;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticStrLast.js
var require_staticStrLast = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticStrLast.js"(exports, module) {
    var staticStrLast = "last";
    module.exports = staticStrLast;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetDateFullYear.js
var require_helperGetDateFullYear = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetDateFullYear.js"(exports, module) {
    function helperGetDateFullYear(date) {
      return date.getFullYear();
    }
    module.exports = helperGetDateFullYear;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticDayTime.js
var require_staticDayTime = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticDayTime.js"(exports, module) {
    var staticDayTime = 864e5;
    module.exports = staticDayTime;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetDateMonth.js
var require_helperGetDateMonth = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetDateMonth.js"(exports, module) {
    function helperGetDateMonth(date) {
      return date.getMonth();
    }
    module.exports = helperGetDateMonth;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isValidDate.js
var require_isValidDate = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isValidDate.js"(exports, module) {
    var isDate = require_isDate();
    var helperGetDateTime = require_helperGetDateTime();
    function isValidDate(val) {
      return isDate(val) && !isNaN(helperGetDateTime(val));
    }
    module.exports = isValidDate;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatMonth.js
var require_getWhatMonth = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatMonth.js"(exports, module) {
    var staticStrFirst = require_staticStrFirst();
    var staticStrLast = require_staticStrLast();
    var staticDayTime = require_staticDayTime();
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var helperGetDateTime = require_helperGetDateTime();
    var helperGetDateMonth = require_helperGetDateMonth();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var isNumber = require_isNumber();
    function getWhatMonth(date, offsetMonth, offsetDay) {
      var monthNum = offsetMonth && !isNaN(offsetMonth) ? offsetMonth : 0;
      date = toStringDate(date);
      if (isValidDate(date)) {
        if (offsetDay === staticStrFirst) {
          return new Date(helperGetDateFullYear(date), helperGetDateMonth(date) + monthNum, 1);
        } else if (offsetDay === staticStrLast) {
          return new Date(helperGetDateTime(getWhatMonth(date, monthNum + 1, staticStrFirst)) - 1);
        } else if (isNumber(offsetDay)) {
          date.setDate(offsetDay);
        }
        if (monthNum) {
          var currDate = date.getDate();
          date.setMonth(helperGetDateMonth(date) + monthNum);
          if (currDate !== date.getDate()) {
            date.setDate(1);
            return new Date(helperGetDateTime(date) - staticDayTime);
          }
        }
      }
      return date;
    }
    module.exports = getWhatMonth;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatYear.js
var require_getWhatYear = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatYear.js"(exports, module) {
    var staticStrFirst = require_staticStrFirst();
    var staticStrLast = require_staticStrLast();
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var getWhatMonth = require_getWhatMonth();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getWhatYear(date, offset, month) {
      var number;
      date = toStringDate(date);
      if (isValidDate(date)) {
        if (offset) {
          number = offset && !isNaN(offset) ? offset : 0;
          date.setFullYear(helperGetDateFullYear(date) + number);
        }
        if (month || !isNaN(month)) {
          if (month === staticStrFirst) {
            return new Date(helperGetDateFullYear(date), 0, 1);
          } else if (month === staticStrLast) {
            date.setMonth(11);
            return getWhatMonth(date, 0, staticStrLast);
          } else {
            date.setMonth(month);
          }
        }
      }
      return date;
    }
    module.exports = getWhatYear;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatQuarter.js
var require_getWhatQuarter = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatQuarter.js"(exports, module) {
    var getWhatMonth = require_getWhatMonth();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getQuarterNumber(date) {
      var month = date.getMonth();
      if (month < 3) {
        return 1;
      } else if (month < 6) {
        return 2;
      } else if (month < 9) {
        return 3;
      }
      return 4;
    }
    function getWhatQuarter(date, offset, day) {
      var currMonth, monthOffset = offset && !isNaN(offset) ? offset * 3 : 0;
      date = toStringDate(date);
      if (isValidDate(date)) {
        currMonth = (getQuarterNumber(date) - 1) * 3;
        date.setMonth(currMonth);
        return getWhatMonth(date, monthOffset, day);
      }
      return date;
    }
    module.exports = getWhatQuarter;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatDay.js
var require_getWhatDay = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatDay.js"(exports, module) {
    var staticStrFirst = require_staticStrFirst();
    var staticStrLast = require_staticStrLast();
    var staticParseInt = require_staticParseInt();
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var helperGetDateMonth = require_helperGetDateMonth();
    var helperGetDateTime = require_helperGetDateTime();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getWhatDay(date, offset, mode) {
      date = toStringDate(date);
      if (isValidDate(date) && !isNaN(offset)) {
        date.setDate(date.getDate() + staticParseInt(offset));
        if (mode === staticStrFirst) {
          return new Date(helperGetDateFullYear(date), helperGetDateMonth(date), date.getDate());
        } else if (mode === staticStrLast) {
          return new Date(helperGetDateTime(getWhatDay(date, 1, staticStrFirst)) - 1);
        }
      }
      return date;
    }
    module.exports = getWhatDay;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperStringUpperCase.js
var require_helperStringUpperCase = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperStringUpperCase.js"(exports, module) {
    function helperStringUpperCase(str) {
      return str.toUpperCase();
    }
    module.exports = helperStringUpperCase;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticWeekTime.js
var require_staticWeekTime = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticWeekTime.js"(exports, module) {
    var staticDayTime = require_staticDayTime();
    var staticWeekTime = staticDayTime * 7;
    module.exports = staticWeekTime;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatWeek.js
var require_getWhatWeek = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatWeek.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var staticDayTime = require_staticDayTime();
    var staticWeekTime = require_staticWeekTime();
    var helperGetDateTime = require_helperGetDateTime();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var isNumber = require_isNumber();
    function getWhatWeek(date, offsetWeek, offsetDay, firstDay) {
      date = toStringDate(date);
      if (isValidDate(date)) {
        var hasCustomDay = isNumber(offsetDay);
        var hasStartDay = isNumber(firstDay);
        var whatDayTime = helperGetDateTime(date);
        if (hasCustomDay || hasStartDay) {
          var viewStartDay = hasStartDay ? firstDay : setupDefaults.firstDayOfWeek;
          var currentDay = date.getDay();
          var customDay = hasCustomDay ? offsetDay : currentDay;
          if (currentDay !== customDay) {
            var offsetNum = 0;
            if (viewStartDay > currentDay) {
              offsetNum = -(7 - viewStartDay + currentDay);
            } else if (viewStartDay < currentDay) {
              offsetNum = viewStartDay - currentDay;
            }
            if (customDay > viewStartDay) {
              whatDayTime += ((customDay === 0 ? 7 : customDay) - viewStartDay + offsetNum) * staticDayTime;
            } else if (customDay < viewStartDay) {
              whatDayTime += (7 - viewStartDay + customDay + offsetNum) * staticDayTime;
            } else {
              whatDayTime += offsetNum * staticDayTime;
            }
          }
        }
        if (offsetWeek && !isNaN(offsetWeek)) {
          whatDayTime += offsetWeek * staticWeekTime;
        }
        return new Date(whatDayTime);
      }
      return date;
    }
    module.exports = getWhatWeek;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateGetDateWeek.js
var require_helperCreateGetDateWeek = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateGetDateWeek.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var staticDayTime = require_staticDayTime();
    var staticWeekTime = require_staticWeekTime();
    var isNumber = require_isNumber();
    var includes = require_includes();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var getWhatWeek = require_getWhatWeek();
    var range = require_range();
    var map = require_map();
    var helperGetDateTime = require_helperGetDateTime();
    var nextStartMaps = map(range(0, 7), function(day) {
      return [(day + 1) % 7, (day + 2) % 7, (day + 3) % 7];
    });
    function matchWeekStartDay(time, viewStartDay) {
      var day = new Date(time).getDay();
      return includes(nextStartMaps[viewStartDay], day);
    }
    function helperCreateGetDateWeek(getStartDate, checkCrossDate) {
      return function(date, firstDay) {
        var viewStartDay = isNumber(firstDay) ? firstDay : setupDefaults.firstDayOfWeek;
        var targetDate = toStringDate(date);
        if (isValidDate(targetDate)) {
          var targetWeekStartDate = getWhatWeek(targetDate, 0, viewStartDay, viewStartDay);
          var firstDate = getStartDate(targetWeekStartDate);
          var firstTime = helperGetDateTime(firstDate);
          var targetWeekStartTime = helperGetDateTime(targetWeekStartDate);
          var targetWeekEndTime = targetWeekStartTime + staticDayTime * 6;
          var targetWeekEndDate = new Date(targetWeekEndTime);
          var firstWeekStartDate = getWhatWeek(firstDate, 0, viewStartDay, viewStartDay);
          var firstWeekStartTime = helperGetDateTime(firstWeekStartDate);
          var tempTime;
          if (targetWeekStartTime === firstWeekStartTime) {
            return 1;
          }
          if (checkCrossDate(targetWeekStartDate, targetWeekEndDate)) {
            tempTime = helperGetDateTime(getStartDate(targetWeekEndDate));
            for (; tempTime < targetWeekEndTime; tempTime += staticDayTime) {
              if (matchWeekStartDay(tempTime, viewStartDay)) {
                return 1;
              }
            }
          }
          var firstWeekEndTime = firstWeekStartTime + staticDayTime * 6;
          var firstWeekEndDate = new Date(targetWeekEndTime);
          var offsetNum = 1;
          if (checkCrossDate(firstWeekStartDate, firstWeekEndDate)) {
            offsetNum = 0;
            tempTime = firstTime;
            for (; tempTime < firstWeekEndTime; tempTime += staticDayTime) {
              if (matchWeekStartDay(tempTime, viewStartDay)) {
                offsetNum++;
                break;
              }
            }
          }
          return Math.floor((targetWeekStartTime - firstWeekStartTime) / staticWeekTime) + offsetNum;
        }
        return NaN;
      };
    }
    module.exports = helperCreateGetDateWeek;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getYearWeek.js
var require_getYearWeek = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getYearWeek.js"(exports, module) {
    var helperCreateGetDateWeek = require_helperCreateGetDateWeek();
    var getYearWeek = helperCreateGetDateWeek(function(targetDate) {
      return new Date(targetDate.getFullYear(), 0, 1);
    }, function(date1, date2) {
      return date1.getFullYear() !== date2.getFullYear();
    });
    module.exports = getYearWeek;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetYMD.js
var require_helperGetYMD = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetYMD.js"(exports, module) {
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var helperGetDateMonth = require_helperGetDateMonth();
    function helperGetYMD(date) {
      return new Date(helperGetDateFullYear(date), helperGetDateMonth(date), date.getDate());
    }
    module.exports = helperGetYMD;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetYMDTime.js
var require_helperGetYMDTime = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetYMDTime.js"(exports, module) {
    var helperGetDateTime = require_helperGetDateTime();
    var helperGetYMD = require_helperGetYMD();
    function helperGetYMDTime(date) {
      return helperGetDateTime(helperGetYMD(date));
    }
    module.exports = helperGetYMDTime;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getYearDay.js
var require_getYearDay = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getYearDay.js"(exports, module) {
    var staticDayTime = require_staticDayTime();
    var staticStrFirst = require_staticStrFirst();
    var helperGetYMDTime = require_helperGetYMDTime();
    var getWhatYear = require_getWhatYear();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getYearDay(date) {
      date = toStringDate(date);
      if (isValidDate(date)) {
        return Math.floor((helperGetYMDTime(date) - helperGetYMDTime(getWhatYear(date, 0, staticStrFirst))) / staticDayTime) + 1;
      }
      return NaN;
    }
    module.exports = getYearDay;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/padStart.js
var require_padStart = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/padStart.js"(exports, module) {
    var toValueString = require_toValueString();
    var isUndefined = require_isUndefined();
    var helperStringRepeat = require_helperStringRepeat();
    function padStart(str, targetLength, padString) {
      var rest = toValueString(str);
      targetLength = targetLength >> 0;
      padString = isUndefined(padString) ? " " : "" + padString;
      if (rest.padStart) {
        return rest.padStart(targetLength, padString);
      }
      if (targetLength > rest.length) {
        targetLength -= rest.length;
        if (targetLength > padString.length) {
          padString += helperStringRepeat(padString, targetLength / padString.length);
        }
        return padString.slice(0, targetLength) + rest;
      }
      return rest;
    }
    module.exports = padStart;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toDateString.js
var require_toDateString = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toDateString.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var helperStringUpperCase = require_helperStringUpperCase();
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var helperGetDateMonth = require_helperGetDateMonth();
    var toStringDate = require_toStringDate();
    var getYearWeek = require_getYearWeek();
    var getYearDay = require_getYearDay();
    var assign = require_assign();
    var isValidDate = require_isValidDate();
    var isFunction = require_isFunction();
    var padStart = require_padStart();
    function handleCustomTemplate(date, formats2, match, value) {
      var format = formats2[match];
      if (format) {
        if (isFunction(format)) {
          return format(value, match, date);
        } else {
          return format[value];
        }
      }
      return value;
    }
    var dateFormatRE = /\[([^\]]+)]|y{2,4}|M{1,2}|d{1,2}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|S{1,3}|Z{1,2}|W{1,2}|D{1,3}|[aAeEq]/g;
    function toDateString(date, format, options) {
      if (date) {
        date = toStringDate(date);
        if (isValidDate(date)) {
          var result = format || setupDefaults.parseDateFormat || setupDefaults.formatString;
          var hours = date.getHours();
          var apm = hours < 12 ? "am" : "pm";
          var formats2 = assign({}, setupDefaults.parseDateRules || setupDefaults.formatStringMatchs, options ? options.formats : null);
          var fy = function(match, length) {
            return ("" + helperGetDateFullYear(date)).substr(4 - length);
          };
          var fM = function(match, length) {
            return padStart(helperGetDateMonth(date) + 1, length, "0");
          };
          var fd = function(match, length) {
            return padStart(date.getDate(), length, "0");
          };
          var fH = function(match, length) {
            return padStart(hours, length, "0");
          };
          var fh = function(match, length) {
            return padStart(hours <= 12 ? hours : hours - 12, length, "0");
          };
          var fm = function(match, length) {
            return padStart(date.getMinutes(), length, "0");
          };
          var fs = function(match, length) {
            return padStart(date.getSeconds(), length, "0");
          };
          var fS = function(match, length) {
            return padStart(date.getMilliseconds(), length, "0");
          };
          var fZ = function(match, length) {
            var zoneHours = date.getTimezoneOffset() / 60 * -1;
            return handleCustomTemplate(date, formats2, match, (zoneHours >= 0 ? "+" : "-") + padStart(zoneHours, 2, "0") + (length === 1 ? ":" : "") + "00");
          };
          var fW = function(match, length) {
            return padStart(handleCustomTemplate(date, formats2, match, getYearWeek(date, (options ? options.firstDay : null) || setupDefaults.firstDayOfWeek)), length, "0");
          };
          var fD = function(match, length) {
            return padStart(handleCustomTemplate(date, formats2, match, getYearDay(date)), length, "0");
          };
          var parseDates = {
            yyyy: fy,
            yy: fy,
            MM: fM,
            M: fM,
            dd: fd,
            d: fd,
            HH: fH,
            H: fH,
            hh: fh,
            h: fh,
            mm: fm,
            m: fm,
            ss: fs,
            s: fs,
            SSS: fS,
            S: fS,
            ZZ: fZ,
            Z: fZ,
            WW: fW,
            W: fW,
            DDD: fD,
            D: fD,
            a: function(match) {
              return handleCustomTemplate(date, formats2, match, apm);
            },
            A: function(match) {
              return handleCustomTemplate(date, formats2, match, helperStringUpperCase(apm));
            },
            e: function(match) {
              return handleCustomTemplate(date, formats2, match, date.getDay());
            },
            E: function(match) {
              return handleCustomTemplate(date, formats2, match, date.getDay());
            },
            q: function(match) {
              return handleCustomTemplate(date, formats2, match, Math.floor((helperGetDateMonth(date) + 3) / 3));
            }
          };
          return result.replace(dateFormatRE, function(match, skip) {
            return skip || (parseDates[match] ? parseDates[match](match, match.length) : match);
          });
        }
        return "Invalid Date";
      }
      return "";
    }
    module.exports = toDateString;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/now.js
var require_now = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/now.js"(exports, module) {
    var helperGetDateTime = require_helperGetDateTime();
    var helperNewDate = require_helperNewDate();
    var now = Date.now || function() {
      return helperGetDateTime(helperNewDate());
    };
    module.exports = now;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/timestamp.js"(exports, module) {
    var helperGetDateTime = require_helperGetDateTime();
    var now = require_now();
    var toStringDate = require_toStringDate();
    var isDate = require_isDate();
    var timestamp = function(str, format) {
      if (str) {
        var date = toStringDate(str, format);
        return isDate(date) ? helperGetDateTime(date) : date;
      }
      return now();
    };
    module.exports = timestamp;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isDateSame.js
var require_isDateSame = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isDateSame.js"(exports, module) {
    var toDateString = require_toDateString();
    function isDateSame(date1, date2, format) {
      if (date1 && date2) {
        date1 = toDateString(date1, format);
        return date1 !== "Invalid Date" && date1 === toDateString(date2, format);
      }
      return false;
    }
    module.exports = isDateSame;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getMonthWeek.js
var require_getMonthWeek = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getMonthWeek.js"(exports, module) {
    var helperCreateGetDateWeek = require_helperCreateGetDateWeek();
    var getMonthWeek = helperCreateGetDateWeek(function(targetDate) {
      return new Date(targetDate.getFullYear(), targetDate.getMonth(), 1);
    }, function(date1, date2) {
      return date1.getMonth() !== date2.getMonth();
    });
    module.exports = getMonthWeek;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getDayOfYear.js
var require_getDayOfYear = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getDayOfYear.js"(exports, module) {
    var getWhatYear = require_getWhatYear();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var isLeapYear = require_isLeapYear();
    function getDayOfYear(date, year) {
      date = toStringDate(date);
      if (isValidDate(date)) {
        return isLeapYear(getWhatYear(date, year)) ? 366 : 365;
      }
      return NaN;
    }
    module.exports = getDayOfYear;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getDayOfMonth.js
var require_getDayOfMonth = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getDayOfMonth.js"(exports, module) {
    var staticDayTime = require_staticDayTime();
    var staticStrFirst = require_staticStrFirst();
    var staticStrLast = require_staticStrLast();
    var helperGetDateTime = require_helperGetDateTime();
    var getWhatMonth = require_getWhatMonth();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getDayOfMonth(date, month) {
      date = toStringDate(date);
      if (isValidDate(date)) {
        return Math.floor((helperGetDateTime(getWhatMonth(date, month, staticStrLast)) - helperGetDateTime(getWhatMonth(date, month, staticStrFirst))) / staticDayTime) + 1;
      }
      return NaN;
    }
    module.exports = getDayOfMonth;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getDateDiff.js
var require_getDateDiff = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getDateDiff.js"(exports, module) {
    var helperGetDateTime = require_helperGetDateTime();
    var helperNewDate = require_helperNewDate();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var dateDiffRules = [
      ["yyyy", 31536e6],
      ["MM", 2592e6],
      ["dd", 864e5],
      ["HH", 36e5],
      ["mm", 6e4],
      ["ss", 1e3],
      ["S", 0]
    ];
    function getDateDiff(startDate, endDate) {
      var startTime, endTime, item, diffTime, len, index;
      var result = { done: false, time: 0 };
      startDate = toStringDate(startDate);
      endDate = endDate ? toStringDate(endDate) : helperNewDate();
      if (isValidDate(startDate) && isValidDate(endDate)) {
        startTime = helperGetDateTime(startDate);
        endTime = helperGetDateTime(endDate);
        if (startTime < endTime) {
          diffTime = result.time = endTime - startTime;
          result.done = true;
          for (index = 0, len = dateDiffRules.length; index < len; index++) {
            item = dateDiffRules[index];
            if (diffTime >= item[1]) {
              if (index === len - 1) {
                result[item[0]] = diffTime || 0;
              } else {
                result[item[0]] = Math.floor(diffTime / item[1]);
                diffTime -= result[item[0]] * item[1];
              }
            } else {
              result[item[0]] = 0;
            }
          }
        }
      }
      return result;
    }
    module.exports = getDateDiff;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/padEnd.js
var require_padEnd = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/padEnd.js"(exports, module) {
    var toValueString = require_toValueString();
    var isUndefined = require_isUndefined();
    var helperStringRepeat = require_helperStringRepeat();
    function padEnd(str, targetLength, padString) {
      var rest = toValueString(str);
      targetLength = targetLength >> 0;
      padString = isUndefined(padString) ? " " : "" + padString;
      if (rest.padEnd) {
        return rest.padEnd(targetLength, padString);
      }
      if (targetLength > rest.length) {
        targetLength -= rest.length;
        if (targetLength > padString.length) {
          padString += helperStringRepeat(padString, targetLength / padString.length);
        }
        return rest + padString.slice(0, targetLength);
      }
      return rest;
    }
    module.exports = padEnd;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/repeat.js
var require_repeat = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/repeat.js"(exports, module) {
    var toValueString = require_toValueString();
    var helperStringRepeat = require_helperStringRepeat();
    function repeat(str, count) {
      return helperStringRepeat(toValueString(str), count);
    }
    module.exports = repeat;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/trimRight.js
var require_trimRight = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/trimRight.js"(exports, module) {
    var toValueString = require_toValueString();
    function trimRight(str) {
      return str && str.trimRight ? str.trimRight() : toValueString(str).replace(/[\s\uFEFF\xA0]+$/g, "");
    }
    module.exports = trimRight;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/trimLeft.js
var require_trimLeft = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/trimLeft.js"(exports, module) {
    var toValueString = require_toValueString();
    function trimLeft(str) {
      return str && str.trimLeft ? str.trimLeft() : toValueString(str).replace(/^[\s\uFEFF\xA0]+/g, "");
    }
    module.exports = trimLeft;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/trim.js
var require_trim = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/trim.js"(exports, module) {
    var trimRight = require_trimRight();
    var trimLeft = require_trimLeft();
    function trim(str) {
      return str && str.trim ? str.trim() : trimRight(trimLeft(str));
    }
    module.exports = trim;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticEscapeMap.js
var require_staticEscapeMap = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticEscapeMap.js"(exports, module) {
    var staticEscapeMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;"
    };
    module.exports = staticEscapeMap;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperFormatEscaper.js
var require_helperFormatEscaper = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperFormatEscaper.js"(exports, module) {
    var toValueString = require_toValueString();
    var keys = require_keys();
    function helperFormatEscaper(dataMap) {
      var replaceRegexp = new RegExp("(?:" + keys(dataMap).join("|") + ")", "g");
      return function(str) {
        return toValueString(str).replace(replaceRegexp, function(match) {
          return dataMap[match];
        });
      };
    }
    module.exports = helperFormatEscaper;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/escape.js
var require_escape = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/escape.js"(exports, module) {
    var staticEscapeMap = require_staticEscapeMap();
    var helperFormatEscaper = require_helperFormatEscaper();
    var escape = helperFormatEscaper(staticEscapeMap);
    module.exports = escape;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/unescape.js
var require_unescape = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/unescape.js"(exports, module) {
    var staticEscapeMap = require_staticEscapeMap();
    var helperFormatEscaper = require_helperFormatEscaper();
    var each = require_each();
    var unescapeMap = {};
    each(staticEscapeMap, function(item, key) {
      unescapeMap[staticEscapeMap[key]] = key;
    });
    var unescape = helperFormatEscaper(unescapeMap);
    module.exports = unescape;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperStringSubstring.js
var require_helperStringSubstring = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperStringSubstring.js"(exports, module) {
    function helperStringSubstring(str, start, end) {
      return str.substring(start, end);
    }
    module.exports = helperStringSubstring;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperStringLowerCase.js
var require_helperStringLowerCase = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperStringLowerCase.js"(exports, module) {
    function helperStringLowerCase(str) {
      return str.toLowerCase();
    }
    module.exports = helperStringLowerCase;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/camelCase.js
var require_camelCase = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/camelCase.js"(exports, module) {
    var toValueString = require_toValueString();
    var helperStringSubstring = require_helperStringSubstring();
    var helperStringUpperCase = require_helperStringUpperCase();
    var helperStringLowerCase = require_helperStringLowerCase();
    var camelCacheMaps = {};
    function camelCase(str) {
      str = toValueString(str);
      if (camelCacheMaps[str]) {
        return camelCacheMaps[str];
      }
      var strLen = str.length;
      var rest = str.replace(/([-]+)/g, function(text, flag, index) {
        return index && index + flag.length < strLen ? "-" : "";
      });
      strLen = rest.length;
      rest = rest.replace(/([A-Z]+)/g, function(text, upper, index) {
        var upperLen = upper.length;
        upper = helperStringLowerCase(upper);
        if (index) {
          if (upperLen > 2 && index + upperLen < strLen) {
            return helperStringUpperCase(helperStringSubstring(upper, 0, 1)) + helperStringSubstring(upper, 1, upperLen - 1) + helperStringUpperCase(helperStringSubstring(upper, upperLen - 1, upperLen));
          }
          return helperStringUpperCase(helperStringSubstring(upper, 0, 1)) + helperStringSubstring(upper, 1, upperLen);
        } else {
          if (upperLen > 1 && index + upperLen < strLen) {
            return helperStringSubstring(upper, 0, upperLen - 1) + helperStringUpperCase(helperStringSubstring(upper, upperLen - 1, upperLen));
          }
        }
        return upper;
      }).replace(/(-[a-zA-Z])/g, function(text, upper) {
        return helperStringUpperCase(helperStringSubstring(upper, 1, upper.length));
      });
      camelCacheMaps[str] = rest;
      return rest;
    }
    module.exports = camelCase;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/kebabCase.js
var require_kebabCase = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/kebabCase.js"(exports, module) {
    var toValueString = require_toValueString();
    var helperStringSubstring = require_helperStringSubstring();
    var helperStringLowerCase = require_helperStringLowerCase();
    var kebabCacheMaps = {};
    function kebabCase(str) {
      str = toValueString(str);
      if (kebabCacheMaps[str]) {
        return kebabCacheMaps[str];
      }
      if (/^[A-Z]+$/.test(str)) {
        return helperStringLowerCase(str);
      }
      var rest = str.replace(/^([a-z])([A-Z]+)([a-z]+)$/, function(text, prevLower, upper, nextLower) {
        var upperLen = upper.length;
        if (upperLen > 1) {
          return prevLower + "-" + helperStringLowerCase(helperStringSubstring(upper, 0, upperLen - 1)) + "-" + helperStringLowerCase(helperStringSubstring(upper, upperLen - 1, upperLen)) + nextLower;
        }
        return helperStringLowerCase(prevLower + "-" + upper + nextLower);
      }).replace(/^([A-Z]+)([a-z]+)?$/, function(text, upper, nextLower) {
        var upperLen = upper.length;
        return helperStringLowerCase(helperStringSubstring(upper, 0, upperLen - 1) + "-" + helperStringSubstring(upper, upperLen - 1, upperLen) + (nextLower || ""));
      }).replace(/([a-z]?)([A-Z]+)([a-z]?)/g, function(text, prevLower, upper, nextLower, index) {
        var upperLen = upper.length;
        if (upperLen > 1) {
          if (prevLower) {
            prevLower += "-";
          }
          if (nextLower) {
            return (prevLower || "") + helperStringLowerCase(helperStringSubstring(upper, 0, upperLen - 1)) + "-" + helperStringLowerCase(helperStringSubstring(upper, upperLen - 1, upperLen)) + nextLower;
          }
        }
        return (prevLower || "") + (index ? "-" : "") + helperStringLowerCase(upper) + (nextLower || "");
      });
      rest = rest.replace(/([-]+)/g, function(text, flag, index) {
        return index && index + flag.length < rest.length ? "-" : "";
      });
      kebabCacheMaps[str] = rest;
      return rest;
    }
    module.exports = kebabCase;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/startsWith.js
var require_startsWith = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/startsWith.js"(exports, module) {
    var toValueString = require_toValueString();
    function startsWith(str, val, startIndex) {
      var rest = toValueString(str);
      return (arguments.length === 1 ? rest : rest.substring(startIndex)).indexOf(val) === 0;
    }
    module.exports = startsWith;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/endsWith.js
var require_endsWith = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/endsWith.js"(exports, module) {
    var toValueString = require_toValueString();
    function endsWith(str, val, startIndex) {
      var rest = toValueString(str);
      var argsLen = arguments.length;
      return argsLen > 1 && (argsLen > 2 ? rest.substring(0, startIndex).indexOf(val) === startIndex - 1 : rest.indexOf(val) === rest.length - 1);
    }
    module.exports = endsWith;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/template.js
var require_template = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/template.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var toValueString = require_toValueString();
    var trim = require_trim();
    var get = require_get();
    function template(str, args, options) {
      return toValueString(str).replace((options || setupDefaults).tmplRE || /\{{2}([.\w[\]\s]+)\}{2}/g, function(match, key) {
        return get(args, trim(key));
      });
    }
    module.exports = template;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toFormatString.js
var require_toFormatString = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toFormatString.js"(exports, module) {
    var template = require_template();
    function toFormatString(str, obj) {
      return template(str, obj, { tmplRE: /\{([.\w[\]\s]+)\}/g });
    }
    module.exports = toFormatString;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/noop.js
var require_noop = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/noop.js"(exports, module) {
    function noop() {
    }
    module.exports = noop;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/bind.js
var require_bind = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/bind.js"(exports, module) {
    var slice = require_slice();
    function bind(callback, context) {
      var args = slice(arguments, 2);
      return function() {
        return callback.apply(context, slice(arguments).concat(args));
      };
    }
    module.exports = bind;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/once.js
var require_once = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/once.js"(exports, module) {
    var slice = require_slice();
    function once(callback, context) {
      var done = false;
      var rest = null;
      var args = slice(arguments, 2);
      return function() {
        if (done) {
          return rest;
        }
        rest = callback.apply(context, slice(arguments).concat(args));
        done = true;
        return rest;
      };
    }
    module.exports = once;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/after.js
var require_after = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/after.js"(exports, module) {
    var slice = require_slice();
    function after(count, callback, context) {
      var runCount = 0;
      var rests = [];
      return function() {
        var args = arguments;
        runCount++;
        if (runCount <= count) {
          rests.push(args[0]);
        }
        if (runCount >= count) {
          callback.apply(context, [rests].concat(slice(args)));
        }
      };
    }
    module.exports = after;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/before.js
var require_before = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/before.js"(exports, module) {
    var slice = require_slice();
    function before(count, callback, context) {
      var runCount = 0;
      var rests = [];
      context = context || this;
      return function() {
        var args = arguments;
        runCount++;
        if (runCount < count) {
          rests.push(args[0]);
          callback.apply(context, [rests].concat(slice(args)));
        }
      };
    }
    module.exports = before;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/throttle.js
var require_throttle = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/throttle.js"(exports, module) {
    function throttle(callback, wait, options) {
      var args = null;
      var context = null;
      var opts = options || {};
      var runFlag = false;
      var timeout = null;
      var optLeading = "leading" in opts ? opts.leading : true;
      var optTrailing = "trailing" in opts ? opts.trailing : false;
      var gcFn = function() {
        args = null;
        context = null;
      };
      var runFn = function() {
        runFlag = true;
        callback.apply(context, args);
        timeout = setTimeout(endFn, wait);
        gcFn();
      };
      var endFn = function() {
        timeout = null;
        if (!runFlag && optTrailing === true) {
          runFn();
        }
      };
      var cancelFn = function() {
        var rest = timeout !== null;
        if (rest) {
          clearTimeout(timeout);
        }
        gcFn();
        timeout = null;
        runFlag = false;
        return rest;
      };
      var throttled = function() {
        args = arguments;
        context = this;
        runFlag = false;
        if (timeout === null) {
          if (optLeading === true) {
            runFn();
          } else if (optTrailing === true) {
            timeout = setTimeout(endFn, wait);
          }
        }
      };
      throttled.cancel = cancelFn;
      return throttled;
    }
    module.exports = throttle;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/debounce.js
var require_debounce = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/debounce.js"(exports, module) {
    function debounce(callback, wait, options) {
      var args = null;
      var context = null;
      var opts = options || {};
      var runFlag = false;
      var timeout = null;
      var isLeading = typeof options === "boolean";
      var optLeading = "leading" in opts ? opts.leading : isLeading;
      var optTrailing = "trailing" in opts ? opts.trailing : !isLeading;
      var gcFn = function() {
        args = null;
        context = null;
      };
      var runFn = function() {
        runFlag = true;
        callback.apply(context, args);
        gcFn();
      };
      var endFn = function() {
        if (optLeading === true) {
          timeout = null;
        }
        if (!runFlag && optTrailing === true) {
          runFn();
        }
      };
      var cancelFn = function() {
        var rest = timeout !== null;
        if (rest) {
          clearTimeout(timeout);
        }
        gcFn();
        timeout = null;
        runFlag = false;
        return rest;
      };
      var debounced = function() {
        runFlag = false;
        args = arguments;
        context = this;
        if (timeout === null) {
          if (optLeading === true) {
            runFn();
          }
        } else {
          clearTimeout(timeout);
        }
        timeout = setTimeout(endFn, wait);
      };
      debounced.cancel = cancelFn;
      return debounced;
    }
    module.exports = debounce;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/delay.js
var require_delay = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/delay.js"(exports, module) {
    var slice = require_slice();
    function delay(callback, wait) {
      var args = slice(arguments, 2);
      var context = this;
      return setTimeout(function() {
        callback.apply(context, args);
      }, wait);
    }
    module.exports = delay;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticDecodeURIComponent.js
var require_staticDecodeURIComponent = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticDecodeURIComponent.js"(exports, module) {
    var staticDecodeURIComponent = decodeURIComponent;
    module.exports = staticDecodeURIComponent;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/unserialize.js
var require_unserialize = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/unserialize.js"(exports, module) {
    var staticDecodeURIComponent = require_staticDecodeURIComponent();
    var arrayEach = require_arrayEach();
    var isString = require_isString();
    function unserialize(str) {
      var items;
      var result = {};
      if (str && isString(str)) {
        arrayEach(str.split("&"), function(param) {
          items = param.split("=");
          result[staticDecodeURIComponent(items[0])] = staticDecodeURIComponent(items[1] || "");
        });
      }
      return result;
    }
    module.exports = unserialize;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticEncodeURIComponent.js
var require_staticEncodeURIComponent = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticEncodeURIComponent.js"(exports, module) {
    var staticEncodeURIComponent = encodeURIComponent;
    module.exports = staticEncodeURIComponent;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/serialize.js
var require_serialize = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/serialize.js"(exports, module) {
    var staticEncodeURIComponent = require_staticEncodeURIComponent();
    var each = require_each();
    var isArray = require_isArray();
    var isNull = require_isNull();
    var isUndefined = require_isUndefined();
    var isPlainObject = require_isPlainObject();
    function stringifyParams(resultVal, resultKey, isArr) {
      var _arr;
      var result = [];
      each(resultVal, function(item, key) {
        _arr = isArray(item);
        if (isPlainObject(item) || _arr) {
          result = result.concat(stringifyParams(item, resultKey + "[" + key + "]", _arr));
        } else {
          result.push(staticEncodeURIComponent(resultKey + "[" + (isArr ? "" : key) + "]") + "=" + staticEncodeURIComponent(isNull(item) ? "" : item));
        }
      });
      return result;
    }
    function serialize(query) {
      var _arr;
      var params = [];
      each(query, function(item, key) {
        if (!isUndefined(item)) {
          _arr = isArray(item);
          if (isPlainObject(item) || _arr) {
            params = params.concat(stringifyParams(item, key, _arr));
          } else {
            params.push(staticEncodeURIComponent(key) + "=" + staticEncodeURIComponent(isNull(item) ? "" : item));
          }
        }
      });
      return params.join("&").replace(/%20/g, "+");
    }
    module.exports = serialize;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticLocation.js
var require_staticLocation = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticLocation.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var staticLocation = typeof location === staticStrUndefined ? 0 : location;
    module.exports = staticLocation;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetLocatOrigin.js
var require_helperGetLocatOrigin = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetLocatOrigin.js"(exports, module) {
    var staticLocation = require_staticLocation();
    function helperGetLocatOrigin() {
      return staticLocation ? staticLocation.origin || staticLocation.protocol + "//" + staticLocation.host : "";
    }
    module.exports = helperGetLocatOrigin;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/parseUrl.js
var require_parseUrl = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/parseUrl.js"(exports, module) {
    var staticLocation = require_staticLocation();
    var unserialize = require_unserialize();
    var helperGetLocatOrigin = require_helperGetLocatOrigin();
    function parseURLQuery(uri) {
      return unserialize(uri.split("?")[1] || "");
    }
    function parseUrl(url) {
      var hashs, portText, searchs, parsed;
      var href = "" + url;
      if (href.indexOf("//") === 0) {
        href = (staticLocation ? staticLocation.protocol : "") + href;
      } else if (href.indexOf("/") === 0) {
        href = helperGetLocatOrigin() + href;
      }
      searchs = href.replace(/#.*/, "").match(/(\?.*)/);
      parsed = {
        href,
        hash: "",
        host: "",
        hostname: "",
        protocol: "",
        port: "",
        search: searchs && searchs[1] && searchs[1].length > 1 ? searchs[1] : ""
      };
      parsed.path = href.replace(/^([a-z0-9.+-]*:)\/\//, function(text, protocol) {
        parsed.protocol = protocol;
        return "";
      }).replace(/^([a-z0-9.+-]*)(:\d+)?\/?/, function(text, hostname, port) {
        portText = port || "";
        parsed.port = portText.replace(":", "");
        parsed.hostname = hostname;
        parsed.host = hostname + portText;
        return "/";
      }).replace(/(#.*)/, function(text, hash) {
        parsed.hash = hash.length > 1 ? hash : "";
        return "";
      });
      hashs = parsed.hash.match(/#((.*)\?|(.*))/);
      parsed.pathname = parsed.path.replace(/(\?|#.*).*/, "");
      parsed.origin = parsed.protocol + "//" + parsed.host;
      parsed.hashKey = hashs ? hashs[2] || hashs[1] || "" : "";
      parsed.hashQuery = parseURLQuery(parsed.hash);
      parsed.searchQuery = parseURLQuery(parsed.search);
      return parsed;
    }
    module.exports = parseUrl;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getBaseURL.js
var require_getBaseURL = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getBaseURL.js"(exports, module) {
    var staticLocation = require_staticLocation();
    var helperGetLocatOrigin = require_helperGetLocatOrigin();
    var lastIndexOf = require_lastIndexOf();
    function getBaseURL() {
      if (staticLocation) {
        var pathname = staticLocation.pathname;
        var lastIndex = lastIndexOf(pathname, "/") + 1;
        return helperGetLocatOrigin() + (lastIndex === pathname.length ? pathname : pathname.substring(0, lastIndex));
      }
      return "";
    }
    module.exports = getBaseURL;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/locat.js
var require_locat = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/locat.js"(exports, module) {
    var staticLocation = require_staticLocation();
    var parseUrl = require_parseUrl();
    function locat() {
      return staticLocation ? parseUrl(staticLocation.href) : {};
    }
    module.exports = locat;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/cookie.js
var require_cookie = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/cookie.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var staticDocument = require_staticDocument();
    var staticDecodeURIComponent = require_staticDecodeURIComponent();
    var staticEncodeURIComponent = require_staticEncodeURIComponent();
    var isArray = require_isArray();
    var isObject = require_isObject();
    var isDate = require_isDate();
    var isUndefined = require_isUndefined();
    var includes = require_includes();
    var keys = require_keys();
    var assign = require_assign();
    var arrayEach = require_arrayEach();
    var helperNewDate = require_helperNewDate();
    var helperGetDateTime = require_helperGetDateTime();
    var getWhatYear = require_getWhatYear();
    var getWhatMonth = require_getWhatMonth();
    var getWhatDay = require_getWhatDay();
    function toCookieUnitTime(unit, expires) {
      var num = parseFloat(expires);
      var nowdate = helperNewDate();
      var time = helperGetDateTime(nowdate);
      switch (unit) {
        case "y":
          return helperGetDateTime(getWhatYear(nowdate, num));
        case "M":
          return helperGetDateTime(getWhatMonth(nowdate, num));
        case "d":
          return helperGetDateTime(getWhatDay(nowdate, num));
        case "h":
        case "H":
          return time + num * 60 * 60 * 1e3;
        case "m":
          return time + num * 60 * 1e3;
        case "s":
          return time + num * 1e3;
      }
      return time;
    }
    function toCookieUTCString(date) {
      return (isDate(date) ? date : new Date(date)).toUTCString();
    }
    function cookie(name, value, options) {
      if (staticDocument) {
        var opts, expires, values, result, cookies, keyIndex;
        var inserts = [];
        var args = arguments;
        if (isArray(name)) {
          inserts = name;
        } else if (args.length > 1) {
          inserts = [assign({ name, value }, options)];
        } else if (isObject(name)) {
          inserts = [name];
        }
        if (inserts.length > 0) {
          arrayEach(inserts, function(obj) {
            opts = assign({}, setupDefaults.cookies, obj);
            values = [];
            if (opts.name) {
              expires = opts.expires;
              values.push(staticEncodeURIComponent(opts.name) + "=" + staticEncodeURIComponent(isObject(opts.value) ? JSON.stringify(opts.value) : opts.value));
              if (expires) {
                if (isNaN(expires)) {
                  expires = expires.replace(/^([0-9]+)(y|M|d|H|h|m|s)$/, function(text, num, unit) {
                    return toCookieUTCString(toCookieUnitTime(unit, num));
                  });
                } else if (/^[0-9]{11,13}$/.test(expires) || isDate(expires)) {
                  expires = toCookieUTCString(expires);
                } else {
                  expires = toCookieUTCString(toCookieUnitTime("d", expires));
                }
                opts.expires = expires;
              }
              arrayEach(["expires", "path", "domain", "secure"], function(key) {
                if (!isUndefined(opts[key])) {
                  values.push(opts[key] && key === "secure" ? key : key + "=" + opts[key]);
                }
              });
            }
            staticDocument.cookie = values.join("; ");
          });
          return true;
        } else {
          result = {};
          cookies = staticDocument.cookie;
          if (cookies) {
            arrayEach(cookies.split("; "), function(val) {
              keyIndex = val.indexOf("=");
              result[staticDecodeURIComponent(val.substring(0, keyIndex))] = staticDecodeURIComponent(val.substring(keyIndex + 1) || "");
            });
          }
          return args.length === 1 ? result[name] : result;
        }
      }
      return false;
    }
    function hasCookieItem(value) {
      return includes(cookieKeys(), value);
    }
    function getCookieItem(name) {
      return cookie(name);
    }
    function setCookieItem(name, value, options) {
      cookie(name, value, options);
      return cookie;
    }
    function removeCookieItem(name, options) {
      cookie(name, "", assign({ expires: -1 }, setupDefaults.cookies, options));
    }
    function cookieKeys() {
      return keys(cookie());
    }
    function cookieJson() {
      return cookie();
    }
    assign(cookie, {
      has: hasCookieItem,
      set: setCookieItem,
      setItem: setCookieItem,
      get: getCookieItem,
      getItem: getCookieItem,
      remove: removeCookieItem,
      removeItem: removeCookieItem,
      keys: cookieKeys,
      getJSON: cookieJson
    });
    module.exports = cookie;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/browse.js
var require_browse = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/browse.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var staticDocument = require_staticDocument();
    var staticWindow = require_staticWindow();
    var assign = require_assign();
    var arrayEach = require_arrayEach();
    function isBrowseStorage(storage) {
      try {
        var testKey = "__xe_t";
        storage.setItem(testKey, 1);
        storage.removeItem(testKey);
        return true;
      } catch (e) {
        return false;
      }
    }
    function isBrowseType(type) {
      return navigator.userAgent.indexOf(type) > -1;
    }
    function browse2() {
      var $body, isChrome, isEdge;
      var isMobile = false;
      var isLocalStorage = false;
      var isSessionStorage = false;
      var result = {
        isNode: false,
        isMobile,
        isPC: false,
        isDoc: !!staticDocument
      };
      if (!staticWindow && typeof process !== staticStrUndefined) {
        result.isNode = true;
      } else {
        isEdge = isBrowseType("Edge");
        isChrome = isBrowseType("Chrome");
        isMobile = /(Android|webOS|iPhone|iPad|iPod|SymbianOS|BlackBerry|Windows Phone)/.test(navigator.userAgent);
        if (result.isDoc) {
          $body = staticDocument.body || staticDocument.documentElement;
          arrayEach(["webkit", "khtml", "moz", "ms", "o"], function(core) {
            result["-" + core] = !!$body[core + "MatchesSelector"];
          });
        }
        try {
          isLocalStorage = isBrowseStorage(staticWindow.localStorage);
        } catch (e) {
        }
        try {
          isSessionStorage = isBrowseStorage(staticWindow.sessionStorage);
        } catch (e) {
        }
        assign(result, {
          edge: isEdge,
          firefox: isBrowseType("Firefox"),
          msie: !isEdge && result["-ms"],
          safari: !isChrome && !isEdge && isBrowseType("Safari"),
          isMobile,
          isPC: !isMobile,
          isLocalStorage,
          isSessionStorage
        });
      }
      return result;
    }
    module.exports = browse2;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/index.js
var require_xe_utils = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/index.js"(exports, module) {
    "use strict";
    var XEUtils63 = require_ctor();
    var assign = require_assign();
    var objectEach = require_objectEach();
    var lastObjectEach = require_lastObjectEach();
    var objectMap = require_objectMap();
    var merge = require_merge();
    var map = require_map();
    var some = require_some();
    var every = require_every();
    var includeArrays = require_includeArrays();
    var arrayEach = require_arrayEach();
    var lastArrayEach = require_lastArrayEach();
    var uniq = require_uniq();
    var union = require_union();
    var toArray = require_toArray();
    var sortBy = require_sortBy();
    var orderBy = require_orderBy();
    var shuffle = require_shuffle();
    var sample = require_sample();
    var slice = require_slice();
    var filter = require_filter();
    var findKey = require_findKey();
    var includes = require_includes();
    var find = require_find();
    var findLast = require_findLast();
    var reduce = require_reduce();
    var copyWithin = require_copyWithin();
    var chunk = require_chunk();
    var zip = require_zip();
    var unzip = require_unzip();
    var zipObject = require_zipObject();
    var flatten = require_flatten();
    var pluck = require_pluck();
    var invoke = require_invoke();
    var toArrayTree = require_toArrayTree();
    var toTreeArray = require_toTreeArray();
    var findTree = require_findTree();
    var eachTree = require_eachTree();
    var mapTree = require_mapTree();
    var filterTree = require_filterTree();
    var searchTree = require_searchTree();
    var arrayIndexOf = require_arrayIndexOf();
    var arrayLastIndexOf = require_arrayLastIndexOf();
    var hasOwnProp = require_hasOwnProp();
    var isArray = require_isArray();
    var isNull = require_isNull();
    var isNumberNaN = require_isNaN();
    var isUndefined = require_isUndefined();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var isString = require_isString();
    var isPlainObject = require_isPlainObject();
    var isLeapYear = require_isLeapYear();
    var isDate = require_isDate();
    var eqNull = require_eqNull();
    var each = require_each();
    var forOf = require_forOf();
    var lastForOf = require_lastForOf();
    var indexOf = require_indexOf();
    var lastIndexOf = require_lastIndexOf();
    var keys = require_keys();
    var values = require_values();
    var clone = require_clone();
    var getSize = require_getSize();
    var lastEach = require_lastEach();
    var remove = require_remove();
    var clear = require_clear();
    var isNumberFinite = require_isFinite();
    var isFloat = require_isFloat();
    var isInteger = require_isInteger();
    var isBoolean = require_isBoolean();
    var isNumber = require_isNumber();
    var isRegExp = require_isRegExp();
    var isError = require_isError();
    var isTypeError = require_isTypeError();
    var isEmpty = require_isEmpty();
    var isSymbol = require_isSymbol();
    var isArguments = require_isArguments();
    var isElement = require_isElement();
    var isDocument = require_isDocument();
    var isWindow = require_isWindow();
    var isFormData = require_isFormData();
    var isMap = require_isMap();
    var isWeakMap = require_isWeakMap();
    var isSet = require_isSet();
    var isWeakSet = require_isWeakSet();
    var isMatch = require_isMatch();
    var isEqual = require_isEqual();
    var isEqualWith = require_isEqualWith();
    var getType = require_getType();
    var uniqueId = require_uniqueId();
    var findIndexOf = require_findIndexOf();
    var findLastIndexOf = require_findLastIndexOf();
    var toStringJSON = require_toStringJSON();
    var toJSONString = require_toJSONString();
    var entries = require_entries();
    var pick = require_pick();
    var omit = require_omit();
    var first = require_first();
    var last = require_last();
    var has = require_has();
    var get = require_get();
    var set = require_set();
    var groupBy = require_groupBy();
    var countBy = require_countBy();
    var range = require_range();
    var destructuring = require_destructuring();
    var random = require_random();
    var max = require_max();
    var min = require_min();
    var commafy = require_commafy();
    var round = require_round();
    var ceil = require_ceil();
    var floor = require_floor();
    var toFixed = require_toFixed();
    var toInteger = require_toInteger();
    var toNumber = require_toNumber();
    var toNumberString = require_toNumberString();
    var add = require_add();
    var subtract = require_subtract();
    var multiply = require_multiply();
    var divide = require_divide();
    var sum = require_sum();
    var mean = require_mean();
    var getWhatYear = require_getWhatYear();
    var getWhatQuarter = require_getWhatQuarter();
    var getWhatMonth = require_getWhatMonth();
    var getWhatDay = require_getWhatDay();
    var toStringDate = require_toStringDate();
    var toDateString = require_toDateString();
    var now = require_now();
    var timestamp = require_timestamp();
    var isValidDate = require_isValidDate();
    var isDateSame = require_isDateSame();
    var getWhatWeek = require_getWhatWeek();
    var getYearDay = require_getYearDay();
    var getYearWeek = require_getYearWeek();
    var getMonthWeek = require_getMonthWeek();
    var getDayOfYear = require_getDayOfYear();
    var getDayOfMonth = require_getDayOfMonth();
    var getDateDiff = require_getDateDiff();
    var padEnd = require_padEnd();
    var padStart = require_padStart();
    var repeat = require_repeat();
    var trim = require_trim();
    var trimRight = require_trimRight();
    var trimLeft = require_trimLeft();
    var escape = require_escape();
    var unescape = require_unescape();
    var camelCase = require_camelCase();
    var kebabCase = require_kebabCase();
    var startsWith = require_startsWith();
    var endsWith = require_endsWith();
    var template = require_template();
    var toFormatString = require_toFormatString();
    var toValueString = require_toValueString();
    var noop = require_noop();
    var property = require_property();
    var bind = require_bind();
    var once = require_once();
    var after = require_after();
    var before = require_before();
    var throttle = require_throttle();
    var debounce = require_debounce();
    var delay = require_delay();
    var unserialize = require_unserialize();
    var serialize = require_serialize();
    var parseUrl = require_parseUrl();
    var getBaseURL = require_getBaseURL();
    var locat = require_locat();
    var cookie = require_cookie();
    var browse2 = require_browse();
    assign(XEUtils63, {
      // object
      assign,
      objectEach,
      lastObjectEach,
      objectMap,
      merge,
      // array
      uniq,
      union,
      sortBy,
      orderBy,
      shuffle,
      sample,
      some,
      every,
      slice,
      filter,
      find,
      findLast,
      findKey,
      includes,
      arrayIndexOf,
      arrayLastIndexOf,
      map,
      reduce,
      copyWithin,
      chunk,
      zip,
      unzip,
      zipObject,
      flatten,
      toArray,
      includeArrays,
      pluck,
      invoke,
      arrayEach,
      lastArrayEach,
      toArrayTree,
      toTreeArray,
      findTree,
      eachTree,
      mapTree,
      filterTree,
      searchTree,
      // base
      hasOwnProp,
      eqNull,
      isNaN: isNumberNaN,
      isFinite: isNumberFinite,
      isUndefined,
      isArray,
      isFloat,
      isInteger,
      isFunction,
      isBoolean,
      isString,
      isNumber,
      isRegExp,
      isObject,
      isPlainObject,
      isDate,
      isError,
      isTypeError,
      isEmpty,
      isNull,
      isSymbol,
      isArguments,
      isElement,
      isDocument,
      isWindow,
      isFormData,
      isMap,
      isWeakMap,
      isSet,
      isWeakSet,
      isLeapYear,
      isMatch,
      isEqual,
      isEqualWith,
      getType,
      uniqueId,
      getSize,
      indexOf,
      lastIndexOf,
      findIndexOf,
      findLastIndexOf,
      toStringJSON,
      toJSONString,
      keys,
      values,
      entries,
      pick,
      omit,
      first,
      last,
      each,
      forOf,
      lastForOf,
      lastEach,
      has,
      get,
      set,
      groupBy,
      countBy,
      clone,
      clear,
      remove,
      range,
      destructuring,
      // number
      random,
      min,
      max,
      commafy,
      round,
      ceil,
      floor,
      toFixed,
      toNumber,
      toNumberString,
      toInteger,
      add,
      subtract,
      multiply,
      divide,
      sum,
      mean,
      // date
      now,
      timestamp,
      isValidDate,
      isDateSame,
      toStringDate,
      toDateString,
      getWhatYear,
      getWhatQuarter,
      getWhatMonth,
      getWhatWeek,
      getWhatDay,
      getYearDay,
      getYearWeek,
      getMonthWeek,
      getDayOfYear,
      getDayOfMonth,
      getDateDiff,
      // string
      trim,
      trimLeft,
      trimRight,
      escape,
      unescape,
      camelCase,
      kebabCase,
      repeat,
      padStart,
      padEnd,
      startsWith,
      endsWith,
      template,
      toFormatString,
      toString: toValueString,
      toValueString,
      // function
      noop,
      property,
      bind,
      once,
      after,
      before,
      throttle,
      debounce,
      delay,
      // url
      unserialize,
      serialize,
      parseUrl,
      // web
      getBaseURL,
      locat,
      browse: browse2,
      cookie
    });
    module.exports = XEUtils63;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/all.js
var all_exports = {};
__export(all_exports, {
  Button: () => Button,
  ButtonGroup: () => ButtonGroup,
  Checkbox: () => Checkbox,
  CheckboxGroup: () => CheckboxGroup,
  Colgroup: () => Colgroup,
  Column: () => Column,
  Custom: () => Custom,
  Drawer: () => Drawer,
  Edit: () => Edit,
  Export: () => Export,
  Filter: () => Filter,
  Form: () => Form,
  FormGather: () => FormGather,
  FormItem: () => FormItem,
  Grid: () => Grid,
  Icon: () => Icon,
  Input: () => Input,
  Keyboard: () => Keyboard,
  List: () => List,
  Menu: () => Menu,
  Modal: () => Modal,
  Optgroup: () => Optgroup,
  Option: () => Option,
  Pager: () => Pager,
  Pulldown: () => Pulldown,
  Radio: () => Radio,
  RadioButton: () => RadioButton,
  RadioGroup: () => RadioGroup,
  Select: () => Select,
  Switch: () => Switch,
  Table: () => Table,
  Textarea: () => Textarea,
  Toolbar: () => Toolbar,
  Tooltip: () => Tooltip,
  VXETable: () => VXETable,
  Validator: () => Validator,
  VxeButton: () => VxeButton,
  VxeButtonGroup: () => VxeButtonGroup,
  VxeCheckbox: () => VxeCheckbox,
  VxeCheckboxGroup: () => VxeCheckboxGroup,
  VxeColgroup: () => VxeColgroup,
  VxeColumn: () => VxeColumn,
  VxeDrawer: () => VxeDrawer,
  VxeForm: () => VxeForm,
  VxeFormGather: () => VxeFormGather,
  VxeFormItem: () => VxeFormItem,
  VxeGrid: () => VxeGrid,
  VxeIcon: () => VxeIcon,
  VxeInput: () => VxeInput,
  VxeList: () => VxeList,
  VxeModal: () => VxeModal,
  VxeOptgroup: () => VxeOptgroup,
  VxeOption: () => VxeOption,
  VxePager: () => VxePager,
  VxePulldown: () => VxePulldown,
  VxeRadio: () => VxeRadio,
  VxeRadioButton: () => VxeRadioButton,
  VxeRadioGroup: () => VxeRadioGroup,
  VxeSelect: () => VxeSelect,
  VxeSwitch: () => VxeSwitch,
  VxeTable: () => VxeTable,
  VxeTableCustomModule: () => VxeTableCustomModule,
  VxeTableEditModule: () => VxeTableEditModule,
  VxeTableExportModule: () => VxeTableExportModule,
  VxeTableFilterModule: () => VxeTableFilterModule,
  VxeTableKeyboardModule: () => VxeTableKeyboardModule,
  VxeTableMenuModule: () => VxeTableMenuModule,
  VxeTableValidatorModule: () => VxeTableValidatorModule,
  VxeTextarea: () => VxeTextarea,
  VxeToolbar: () => VxeToolbar,
  VxeTooltip: () => VxeTooltip,
  VxeUI: () => VxeUI,
  _t: () => _t,
  commands: () => commands,
  component: () => component,
  config: () => config,
  drawer: () => drawer,
  formats: () => formats,
  getComponent: () => getComponent,
  globalConfs: () => globalConfs,
  globalStore: () => globalStore,
  hooks: () => hooks,
  install: () => install,
  interceptor: () => interceptor,
  menus: () => menus,
  modal: () => modal,
  print: () => print,
  readFile: () => readLocalFile,
  renderer: () => renderer,
  saveFile: () => saveLocalFile,
  setConfig: () => setConfig,
  setIcon: () => setIcon,
  setup: () => setup,
  t: () => t,
  tableVersion: () => tableVersion,
  use: () => use,
  v: () => v,
  validators: () => validators,
  version: () => version
});
var import_xe_utils62 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/index.js
var import_xe_utils12 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/conf.js
var iconPrefix = "vxe-icon-";
var GlobalConfig = {
  size: null,
  zIndex: 999,
  version: 0,
  // resizeInterval: 500,
  emptyCell: "",
  // loadingText: null, // loadingnull
  table: {
    fit: true,
    showHeader: true,
    animat: true,
    delayHover: 250,
    autoResize: true,
    minHeight: 144,
    // keepSource: false,
    // showOverflow: null,
    // showHeaderOverflow: null,
    // showFooterOverflow: null,
    // resizeInterval: 500,
    // size: null,
    // zIndex: null,
    // stripe: false,
    // border: false,
    // round: false,
    // emptyText: '',
    // emptyRender: {
    //   name: ''
    // },
    // rowConfig: {
    //   keyField: '_X_ROW_KEY' // 
    // },
    resizeConfig: {
      refreshDelay: 250
    },
    radioConfig: {
      // trigger: 'default'
      strict: true
    },
    checkboxConfig: {
      // trigger: 'default',
      strict: true
    },
    tooltipConfig: {
      enterable: true
    },
    validConfig: {
      showMessage: true,
      autoClear: true,
      autoPos: true,
      message: "inline",
      msgMode: "single"
    },
    columnConfig: {
      maxFixedSize: 4
    },
    // menuConfig: {
    //   visibleMethod () {}
    // },
    customConfig: {
      allowFixed: true,
      showFooter: true
      //  storage: false,
      //  checkMethod () {}
    },
    sortConfig: {
      // remote: false,
      // trigger: 'default',
      // orders: ['asc', 'desc', null],
      // sortMethod: null,
      showIcon: true,
      iconLayout: "vertical"
    },
    filterConfig: {
      // remote: false,
      // filterMethod: null,
      showIcon: true
    },
    treeConfig: {
      rowField: "id",
      parentField: "parentId",
      childrenField: "children",
      hasChildField: "hasChild",
      mapChildrenField: "_X_ROW_CHILD",
      indent: 20,
      showIcon: true
    },
    expandConfig: {
      // trigger: 'default',
      showIcon: true
    },
    editConfig: {
      // mode: 'cell',
      showIcon: true,
      showAsterisk: true
    },
    importConfig: {
      _typeMaps: {},
      modes: ["insert", "covering"]
    },
    exportConfig: {
      _typeMaps: {
        csv: 1,
        html: 1,
        xml: 1,
        txt: 1
      },
      modes: ["current", "selected"]
    },
    printConfig: {
      modes: ["current", "selected"]
    },
    mouseConfig: {
      extension: true
    },
    keyboardConfig: {
      isEsc: true
    },
    areaConfig: {
      autoClear: true,
      selectCellByHeader: true
    },
    clipConfig: {
      isCopy: true,
      isCut: true,
      isPaste: true
    },
    fnrConfig: {
      isFind: true,
      isReplace: true
    },
    scrollX: {
      // enabled: false,
      gt: 60
      // oSize: 0
    },
    scrollY: {
      // enabled: false,
      gt: 100
      // oSize: 0
    }
  },
  export: {
    types: {}
  },
  grid: {
    // size: null,
    // zoomConfig: {
    //   escRestore: true
    // },
    formConfig: {
      enabled: true
    },
    pagerConfig: {
      enabled: true
      // perfect: false
    },
    toolbarConfig: {
      enabled: true
      // perfect: false
    },
    proxyConfig: {
      enabled: true,
      autoLoad: true,
      message: true,
      props: {
        list: null,
        result: "result",
        total: "page.total",
        message: "message"
      }
      // beforeItem: null,
      // beforeColumn: null,
      // beforeQuery: null,
      // afterQuery: null,
      // beforeDelete: null,
      // afterDelete: null,
      // beforeSave: null,
      // afterSave: null
    }
  },
  toolbar: {
    // size: null,
    // import: {
    //   mode: 'covering'
    // },
    // export: {
    //   types: ['csv', 'html', 'xml', 'txt']
    // },
    // buttons: []
  },
  icon: {
    // loading
    LOADING: iconPrefix + "spinner roll vxe-loading--default-icon",
    // table
    TABLE_SORT_ASC: iconPrefix + "caret-up",
    TABLE_SORT_DESC: iconPrefix + "caret-down",
    TABLE_FILTER_NONE: iconPrefix + "funnel",
    TABLE_FILTER_MATCH: iconPrefix + "funnel",
    TABLE_EDIT: iconPrefix + "edit",
    TABLE_TITLE_PREFIX: iconPrefix + "question-circle-fill",
    TABLE_TITLE_SUFFIX: iconPrefix + "question-circle-fill",
    TABLE_TREE_LOADED: iconPrefix + "spinner roll",
    TABLE_TREE_OPEN: iconPrefix + "caret-right rotate90",
    TABLE_TREE_CLOSE: iconPrefix + "caret-right",
    TABLE_EXPAND_LOADED: iconPrefix + "spinner roll",
    TABLE_EXPAND_OPEN: iconPrefix + "arrow-right rotate90",
    TABLE_EXPAND_CLOSE: iconPrefix + "arrow-right",
    TABLE_CHECKBOX_CHECKED: iconPrefix + "checkbox-checked",
    TABLE_CHECKBOX_UNCHECKED: iconPrefix + "checkbox-unchecked",
    TABLE_CHECKBOX_INDETERMINATE: iconPrefix + "checkbox-indeterminate",
    TABLE_RADIO_CHECKED: iconPrefix + "radio-checked",
    TABLE_RADIO_UNCHECKED: iconPrefix + "radio-unchecked",
    // button
    BUTTON_DROPDOWN: iconPrefix + "arrow-down",
    BUTTON_LOADING: iconPrefix + "spinner roll",
    // select
    SELECT_LOADED: iconPrefix + "spinner roll",
    SELECT_OPEN: iconPrefix + "caret-down rotate180",
    SELECT_CLOSE: iconPrefix + "caret-down",
    // pager
    PAGER_HOME: iconPrefix + "home-page",
    PAGER_END: iconPrefix + "end-page",
    PAGER_JUMP_PREV: iconPrefix + "arrow-double-left",
    PAGER_JUMP_NEXT: iconPrefix + "arrow-double-right",
    PAGER_PREV_PAGE: iconPrefix + "arrow-left",
    PAGER_NEXT_PAGE: iconPrefix + "arrow-right",
    PAGER_JUMP_MORE: iconPrefix + "ellipsis-h",
    // input
    INPUT_CLEAR: iconPrefix + "error-circle-fill",
    INPUT_PWD: iconPrefix + "eye-fill",
    INPUT_SHOW_PWD: iconPrefix + "eye-fill-close",
    INPUT_PREV_NUM: iconPrefix + "caret-up",
    INPUT_NEXT_NUM: iconPrefix + "caret-down",
    INPUT_DATE: iconPrefix + "calendar",
    INPUT_SEARCH: iconPrefix + "search",
    // modal
    MODAL_ZOOM_IN: iconPrefix + "square",
    MODAL_ZOOM_OUT: iconPrefix + "maximize",
    MODAL_CLOSE: iconPrefix + "close",
    MODAL_INFO: iconPrefix + "info-circle-fill",
    MODAL_SUCCESS: iconPrefix + "success-circle-fill",
    MODAL_WARNING: iconPrefix + "warnion-circle-fill",
    MODAL_ERROR: iconPrefix + "error-circle-fill",
    MODAL_QUESTION: iconPrefix + "question-circle-fill",
    MODAL_LOADING: iconPrefix + "spinner roll",
    // toolbar
    TOOLBAR_TOOLS_REFRESH: iconPrefix + "repeat",
    TOOLBAR_TOOLS_REFRESH_LOADING: iconPrefix + "repeat roll",
    TOOLBAR_TOOLS_IMPORT: iconPrefix + "upload",
    TOOLBAR_TOOLS_EXPORT: iconPrefix + "download",
    TOOLBAR_TOOLS_PRINT: iconPrefix + "print",
    TOOLBAR_TOOLS_FULLSCREEN: iconPrefix + "fullscreen",
    TOOLBAR_TOOLS_MINIMIZE: iconPrefix + "minimize",
    TOOLBAR_TOOLS_CUSTOM: iconPrefix + "custom-column",
    TOOLBAR_TOOLS_FIXED_LEFT: iconPrefix + "fixed-left",
    TOOLBAR_TOOLS_FIXED_LEFT_ACTIVED: iconPrefix + "fixed-left-fill",
    TOOLBAR_TOOLS_FIXED_RIGHT: iconPrefix + "fixed-right",
    TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVED: iconPrefix + "fixed-right-fill",
    // form
    FORM_PREFIX: iconPrefix + "question-circle-fill",
    FORM_SUFFIX: iconPrefix + "question-circle-fill",
    FORM_FOLDING: iconPrefix + "arrow-up rotate180",
    FORM_UNFOLDING: iconPrefix + "arrow-up"
  },
  tooltip: {
    // size: null,
    trigger: "hover",
    theme: "dark",
    enterDelay: 500,
    leaveDelay: 300
  },
  pager: {
    // size: null,
    // autoHidden: false,
    // perfect: true,
    // pageSize: 10,
    // pagerCount: 7,
    // pageSizes: [10, 15, 20, 50, 100],
    // layouts: ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total']
  },
  form: {
    // preventSubmit: false,
    // size: null,
    // colon: false,
    validConfig: {
      showMessage: true,
      autoPos: true
    },
    tooltipConfig: {
      enterable: true
    },
    titleAsterisk: true
  },
  input: {
    // size: null,
    // transfer: false
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1,
    digits: 2,
    controls: true
  },
  textarea: {
    // size: null,
    // autosize: {
    //   minRows: 1,
    //   maxRows: 10
    // }
  },
  select: {
    // size: null,
    // transfer: false,
    // optionConfig: {
    //   keyField: '_X_OPTION_KEY'
    // },
    multiCharOverflow: 8
  },
  button: {
    // size: null,
    // transfer: false
  },
  buttonGroup: {
    // size: null
  },
  radio: {
    // size: null,
    strict: true
  },
  radioButton: {
    // size: null,
    strict: true
  },
  radioGroup: {
    // size: null,
    strict: true
  },
  checkbox: {
    // size: null
  },
  checkboxGroup: {
    // size: null
  },
  switch: {
    // size: null
  },
  modal: {
    // size: null,
    top: 15,
    showHeader: true,
    minWidth: 340,
    minHeight: 140,
    lockView: true,
    mask: true,
    duration: 3e3,
    marginSize: 0,
    dblclickZoom: true,
    showTitleOverflow: true,
    animat: true,
    showClose: true,
    draggable: true,
    showConfirmButton: null,
    // storage: false,
    storageKey: "VXE_MODAL_POSITION"
  },
  drawer: {
    // size: null,
    showHeader: true,
    lockView: true,
    mask: true,
    showTitleOverflow: true,
    showClose: true
  },
  list: {
    // size: null,
    scrollY: {
      enabled: true,
      gt: 100
      // oSize: 0
    }
  },
  i18n: (key) => key
};
var conf_default = GlobalConfig;

// node_modules/.pnpm/dom-zindex@1.0.6/node_modules/dom-zindex/es/index.esm.js
var winDom = null;
var bodyEl = null;
var storeEl = null;
var storeId = "z-index-manage";
var styleEl = null;
var styleId = "z-index-style";
var storeMainKey = "m";
var storeSubKey = "s";
var storeData = {
  m: 1e3,
  s: 1e3
};
function getDocument() {
  if (!winDom) {
    if (typeof document !== "undefined") {
      winDom = document;
    }
  }
  return winDom;
}
function getBody() {
  if (winDom && !bodyEl) {
    bodyEl = winDom.body || winDom.getElementsByTagName("body")[0];
  }
  return bodyEl;
}
function getDomMaxZIndex() {
  var max = 0;
  var dom = getDocument();
  if (dom) {
    var body = getBody();
    if (body) {
      var allElem = body.getElementsByTagName("*");
      for (var i = 0; i < allElem.length; i++) {
        var elem = allElem[i];
        if (elem && elem.style && elem.nodeType === 1) {
          var zIndex = elem.style.zIndex;
          if (zIndex && /^\d+$/.test(zIndex)) {
            max = Math.max(max, Number(zIndex));
          }
        }
      }
    }
  }
  return max;
}
function getStyle() {
  if (!styleEl) {
    var dom = getDocument();
    if (dom) {
      styleEl = dom.getElementById(styleId);
      if (!styleEl) {
        styleEl = dom.createElement("style");
        styleEl.id = styleId;
        dom.getElementsByTagName("head")[0].appendChild(styleEl);
      }
    }
  }
  return styleEl;
}
function updateVar() {
  var styEl = getStyle();
  if (styEl) {
    var prefixes = "--dom-";
    var propKey = "-z-index";
    styEl.innerHTML = ":root{" + prefixes + "main" + propKey + ":" + getCurrent() + ";" + prefixes + "sub" + propKey + ":" + getSubCurrent() + "}";
  }
}
function getStoreDom() {
  if (!storeEl) {
    var dom = getDocument();
    if (dom) {
      storeEl = dom.getElementById(storeId);
      if (!storeEl) {
        var body = getBody();
        if (body) {
          storeEl = dom.createElement("div");
          storeEl.id = storeId;
          storeEl.style.display = "none";
          body.appendChild(storeEl);
          setCurrent(storeData.m);
          setSubCurrent(storeData.s);
        }
      }
    }
  }
  return storeEl;
}
function createSetHandle(key) {
  return function(value) {
    if (value) {
      value = Number(value);
      storeData[key] = value;
      var el = getStoreDom();
      if (el) {
        if (el.dataset) {
          el.dataset[key] = value + "";
        } else {
          el.setAttribute("data-" + key, value + "");
        }
      }
    }
    updateVar();
    return storeData[key];
  };
}
var setCurrent = createSetHandle(storeMainKey);
function createGetHandle(key, nextMethod) {
  return function getCurrent2(currZindex) {
    var zIndex;
    var el = getStoreDom();
    if (el) {
      var domVal = el.dataset ? el.dataset[key] : el.getAttribute("data-" + key);
      if (domVal) {
        zIndex = Number(domVal);
      }
    }
    if (!zIndex) {
      zIndex = storeData[key];
    }
    if (currZindex) {
      if (Number(currZindex) < zIndex) {
        return nextMethod();
      }
      return currZindex;
    }
    return zIndex;
  };
}
var getCurrent = createGetHandle(storeMainKey, getNext);
function getNext() {
  return setCurrent(getCurrent() + 1);
}
var setSubCurrent = createSetHandle(storeSubKey);
var _getSubCurrent = createGetHandle(storeSubKey, getSubNext);
function getSubCurrent() {
  return getCurrent() + _getSubCurrent();
}
function getSubNext() {
  setSubCurrent(_getSubCurrent() + 1);
  return getSubCurrent();
}
var DomZIndex = {
  setCurrent,
  getCurrent,
  getNext,
  setSubCurrent,
  getSubCurrent,
  getSubNext,
  getMax: getDomMaxZIndex
};
updateVar();
var index_esm_default = DomZIndex;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/interceptor.js
var import_xe_utils = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/tools/log.js
function getLog(message, params) {
  return `[vxe-table v${"4.6.25"}] ${conf_default.i18n(message, params)}`;
}
function outLog(type) {
  return function(message, params) {
    const msg = getLog(message, params);
    console[type](msg);
    return msg;
  };
}
var warnLog = outLog("warn");
var errLog = outLog("error");

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/interceptor.js
var storeMap = {};
var interceptor = {
  mixin(options) {
    import_xe_utils.default.each(options, (callback, type) => interceptor.add(type, callback));
    return interceptor;
  },
  get(type) {
    return storeMap[type] || [];
  },
  add(type, callback) {
    if (true) {
      const eventTypes = ["created", "mounted", "activated", "beforeUnmount", "unmounted", "event.clearEdit", "event.clearActived", "event.clearFilter", "event.clearAreas", "event.showMenu", "event.keydown", "event.export", "event.import"];
      if (eventTypes.indexOf(type) === -1) {
        warnLog("vxe.error.errProp", [`Interceptor.${type}`, eventTypes.join("|")]);
      }
    }
    if (callback) {
      let eList = storeMap[type];
      if (!eList) {
        eList = storeMap[type] = [];
      }
      if (true) {
        if (eList.indexOf(callback) > -1) {
          warnLog("vxe.error.coverProp", ["Interceptor", type]);
        }
      }
      eList.push(callback);
    }
    return interceptor;
  },
  delete(type, callback) {
    const eList = storeMap[type];
    if (eList) {
      if (callback) {
        import_xe_utils.default.remove(eList, (fn) => fn === callback);
      } else {
        delete storeMap[type];
      }
    }
  }
};

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/renderer.js
var import_xe_utils8 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/util.js
var import_xe_utils6 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/columnInfo.js
var import_xe_utils4 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/formats.js
var import_xe_utils2 = __toESM(require_xe_utils());
var VXEFormatsStore = class {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    import_xe_utils2.default.each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    if (import_xe_utils2.default.isFunction(render)) {
      if (true) {
        warnLog("vxe.error.delProp", ["formats -> callback", "cellFormatMethod"]);
      }
      render = {
        cellFormatMethod: render
      };
    }
    if (true) {
      const confKeys = import_xe_utils2.default.keys(conf);
      import_xe_utils2.default.each(render, (item, key) => {
        if (confKeys.includes(key)) {
          warnLog("vxe.error.coverProp", [name, key]);
        }
      });
    }
    this.store[name] = conf ? import_xe_utils2.default.merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    import_xe_utils2.default.objectEach(this.store, callback);
  }
};
var formats = new VXEFormatsStore();
if (true) {
  Object.assign(formats, { _name: "Formats" });
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/tools/utils.js
var import_xe_utils3 = __toESM(require_xe_utils());
function isEnableConf(conf) {
  return conf && conf.enabled !== false;
}
function isEmptyValue(cellValue) {
  return cellValue === null || cellValue === void 0 || cellValue === "";
}
function parseFile(file) {
  const name = file.name;
  const tIndex = import_xe_utils3.default.lastIndexOf(name, ".");
  const type = name.substring(tIndex + 1, name.length).toLowerCase();
  const filename = name.substring(0, tIndex);
  return { filename, type };
}
function nextZIndex() {
  return index_esm_default.getNext();
}
function getLastZIndex() {
  return index_esm_default.getCurrent();
}
function hasChildrenList(item) {
  return item && item.children && item.children.length > 0;
}
function getFuncText(content) {
  return content ? import_xe_utils3.default.toValueString(conf_default.translate ? conf_default.translate("" + content) : content) : "";
}
function formatText(value, placeholder) {
  return "" + (isEmptyValue(value) ? placeholder ? conf_default.emptyCell : "" : value);
}
function eqEmptyValue(cellValue) {
  return cellValue === "" || import_xe_utils3.default.eqNull(cellValue);
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/columnInfo.js
var ColumnInfo = class {
  /* eslint-disable @typescript-eslint/no-use-before-define */
  constructor($xetable, _vm, { renderHeader, renderCell, renderFooter, renderData } = {}) {
    const $xegrid = $xetable.xegrid;
    const formatter = _vm.formatter;
    const visible = import_xe_utils4.default.isBoolean(_vm.visible) ? _vm.visible : true;
    if (true) {
      const types = ["seq", "checkbox", "radio", "expand", "html"];
      if (_vm.type && types.indexOf(_vm.type) === -1) {
        warnLog("vxe.error.errProp", [`type=${_vm.type}`, types.join(", ")]);
      }
      if (import_xe_utils4.default.isBoolean(_vm.cellRender) || _vm.cellRender && !import_xe_utils4.default.isObject(_vm.cellRender)) {
        warnLog("vxe.error.errProp", [`column.cell-render=${_vm.cellRender}`, "column.cell-render={}"]);
      }
      if (import_xe_utils4.default.isBoolean(_vm.editRender) || _vm.editRender && !import_xe_utils4.default.isObject(_vm.editRender)) {
        warnLog("vxe.error.errProp", [`column.edit-render=${_vm.editRender}`, "column.edit-render={}"]);
      }
      if (_vm.cellRender && _vm.editRender) {
        warnLog("vxe.error.errConflicts", ["column.cell-render", "column.edit-render"]);
      }
      if (_vm.type === "expand") {
        const { props: tableProps } = $xetable;
        const { treeConfig } = tableProps;
        const { computeTreeOpts } = $xetable.getComputeMaps();
        const treeOpts = computeTreeOpts.value;
        if (treeConfig && (treeOpts.showLine || treeOpts.line)) {
          errLog("vxe.error.errConflicts", ["tree-config.showLine", "column.type=expand"]);
        }
      }
      if (formatter) {
        if (import_xe_utils4.default.isString(formatter)) {
          const gFormatOpts = formats.get(formatter) || import_xe_utils4.default[formatter];
          if (!gFormatOpts || !import_xe_utils4.default.isFunction(gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod)) {
            errLog("vxe.error.notFormats", [formatter]);
          }
        } else if (import_xe_utils4.default.isArray(formatter)) {
          const gFormatOpts = formats.get(formatter[0]) || import_xe_utils4.default[formatter[0]];
          if (!gFormatOpts || !import_xe_utils4.default.isFunction(gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod)) {
            errLog("vxe.error.notFormats", [formatter[0]]);
          }
        }
      }
    }
    Object.assign(this, {
      // 
      type: _vm.type,
      property: _vm.field,
      field: _vm.field,
      title: _vm.title,
      width: _vm.width,
      minWidth: _vm.minWidth,
      maxWidth: _vm.maxWidth,
      resizable: _vm.resizable,
      fixed: _vm.fixed,
      align: _vm.align,
      headerAlign: _vm.headerAlign,
      footerAlign: _vm.footerAlign,
      showOverflow: _vm.showOverflow,
      showHeaderOverflow: _vm.showHeaderOverflow,
      showFooterOverflow: _vm.showFooterOverflow,
      className: _vm.className,
      headerClassName: _vm.headerClassName,
      footerClassName: _vm.footerClassName,
      formatter,
      sortable: _vm.sortable,
      sortBy: _vm.sortBy,
      sortType: _vm.sortType,
      filters: toFilters(_vm.filters),
      filterMultiple: import_xe_utils4.default.isBoolean(_vm.filterMultiple) ? _vm.filterMultiple : true,
      filterMethod: _vm.filterMethod,
      filterResetMethod: _vm.filterResetMethod,
      filterRecoverMethod: _vm.filterRecoverMethod,
      filterRender: _vm.filterRender,
      treeNode: _vm.treeNode,
      cellType: _vm.cellType,
      cellRender: _vm.cellRender,
      editRender: _vm.editRender,
      contentRender: _vm.contentRender,
      headerExportMethod: _vm.headerExportMethod,
      exportMethod: _vm.exportMethod,
      footerExportMethod: _vm.footerExportMethod,
      titleHelp: _vm.titleHelp,
      titlePrefix: _vm.titlePrefix,
      titleSuffix: _vm.titleSuffix,
      // 
      params: _vm.params,
      // 
      id: _vm.colId || import_xe_utils4.default.uniqueId("col_"),
      parentId: null,
      visible,
      // 
      halfVisible: false,
      defaultVisible: visible,
      defaultFixed: _vm.fixed,
      checked: false,
      halfChecked: false,
      disabled: false,
      // 
      level: 1,
      // 
      rowSpan: 1,
      // 
      colSpan: 1,
      // 
      order: null,
      sortTime: 0,
      // 
      sortNumber: 0,
      renderSortNumber: 0,
      renderWidth: 0,
      renderHeight: 0,
      resizeWidth: 0,
      renderLeft: 0,
      renderArgs: [],
      model: {},
      renderHeader: renderHeader || _vm.renderHeader,
      renderCell: renderCell || _vm.renderCell,
      renderFooter: renderFooter || _vm.renderFooter,
      renderData,
      //  grid 
      slots: _vm.slots
    });
    if ($xegrid) {
      const { computeProxyOpts } = $xegrid.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      if (proxyOpts.beforeColumn) {
        proxyOpts.beforeColumn({ $grid: $xegrid, column: this });
      }
    }
  }
  getTitle() {
    return getFuncText(this.title || (this.type === "seq" ? conf_default.i18n("vxe.table.seqTitle") : ""));
  }
  getKey() {
    return this.field || (this.type ? `type=${this.type}` : null);
  }
  update(name, value) {
    if (name !== "filters") {
      if (name === "field") {
        this.property = value;
      }
      this[name] = value;
    }
  }
};

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/tools/dom.js
var import_xe_utils5 = __toESM(require_xe_utils());
var reClsMap = {};
var browse = import_xe_utils5.default.browse();
function getPropClass(property, params) {
  return property ? import_xe_utils5.default.isFunction(property) ? property(params) : property : "";
}
function getClsRE(cls) {
  if (!reClsMap[cls]) {
    reClsMap[cls] = new RegExp(`(?:^|\\s)${cls}(?!\\S)`, "g");
  }
  return reClsMap[cls];
}
function getNodeOffset(elem, container, rest) {
  if (elem) {
    const parentElem = elem.parentNode;
    rest.top += elem.offsetTop;
    rest.left += elem.offsetLeft;
    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {
      rest.top -= parentElem.scrollTop;
      rest.left -= parentElem.scrollLeft;
    }
    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
      return getNodeOffset(elem.offsetParent, container, rest);
    }
  }
  return rest;
}
function isPx(val) {
  return val && /^\d+(px)?$/.test(val);
}
function isScale(val) {
  return val && /^\d+%$/.test(val);
}
function hasClass(elem, cls) {
  return elem && elem.className && elem.className.match && elem.className.match(getClsRE(cls));
}
function removeClass(elem, cls) {
  if (elem && hasClass(elem, cls)) {
    elem.className = elem.className.replace(getClsRE(cls), "");
  }
}
function addClass(elem, cls) {
  if (elem && !hasClass(elem, cls)) {
    removeClass(elem, cls);
    elem.className = `${elem.className} ${cls}`;
  }
}
function getDomNode() {
  const documentElement = document.documentElement;
  const bodyElem = document.body;
  return {
    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
  };
}
function getOffsetHeight(elem) {
  return elem ? elem.offsetHeight : 0;
}
function getPaddingTopBottomSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingTop = import_xe_utils5.default.toNumber(computedStyle.paddingTop);
    const paddingBottom = import_xe_utils5.default.toNumber(computedStyle.paddingBottom);
    return paddingTop + paddingBottom;
  }
  return 0;
}
function setScrollTop(elem, scrollTop) {
  if (elem) {
    elem.scrollTop = scrollTop;
  }
}
function setScrollLeft(elem, scrollLeft) {
  if (elem) {
    elem.scrollLeft = scrollLeft;
  }
}
function updateCellTitle(overflowElem, column) {
  const content = column.type === "html" ? overflowElem.innerText : overflowElem.textContent;
  if (overflowElem.getAttribute("title") !== content) {
    overflowElem.setAttribute("title", content);
  }
}
function getEventTargetNode(evnt, container, queryCls, queryMethod) {
  let targetElem;
  let target = evnt.target.shadowRoot && evnt.composed ? evnt.composedPath()[0] || evnt.target : evnt.target;
  while (target && target.nodeType && target !== document) {
    if (queryCls && hasClass(target, queryCls) && (!queryMethod || queryMethod(target))) {
      targetElem = target;
    } else if (target === container) {
      return { flag: queryCls ? !!targetElem : true, container, targetElem };
    }
    target = target.parentNode;
  }
  return { flag: false };
}
function getOffsetPos(elem, container) {
  return getNodeOffset(elem, container, { left: 0, top: 0 });
}
function getAbsolutePos(elem) {
  const bounding = elem.getBoundingClientRect();
  const boundingTop = bounding.top;
  const boundingLeft = bounding.left;
  const { scrollTop, scrollLeft, visibleHeight, visibleWidth } = getDomNode();
  return { boundingTop, top: scrollTop + boundingTop, boundingLeft, left: scrollLeft + boundingLeft, visibleHeight, visibleWidth };
}
var scrollIntoViewIfNeeded = "scrollIntoViewIfNeeded";
var scrollIntoView = "scrollIntoView";
function scrollToView(elem) {
  if (elem) {
    if (elem[scrollIntoViewIfNeeded]) {
      elem[scrollIntoViewIfNeeded]();
    } else if (elem[scrollIntoView]) {
      elem[scrollIntoView]();
    }
  }
}
function triggerEvent(targetElem, type) {
  if (targetElem) {
    targetElem.dispatchEvent(new Event(type));
  }
}
function isNodeElement(elem) {
  return elem && elem.nodeType === 1;
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/util.js
var getAllConvertColumns = (columns, parentColumn) => {
  const result = [];
  columns.forEach((column) => {
    column.parentId = parentColumn ? parentColumn.id : null;
    if (column.visible) {
      if (column.children && column.children.length && column.children.some((column2) => column2.visible)) {
        result.push(column);
        result.push(...getAllConvertColumns(column.children, column));
      } else {
        result.push(column);
      }
    }
  });
  return result;
};
var convertHeaderColumnToRows = (originColumns) => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column.level = parent.level + 1;
      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }
    if (column.children && column.children.length && column.children.some((column2) => column2.visible)) {
      let colSpan = 0;
      column.children.forEach((subColumn) => {
        if (subColumn.visible) {
          traverse(subColumn, column);
          colSpan += subColumn.colSpan;
        }
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };
  originColumns.forEach((column) => {
    column.level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getAllConvertColumns(originColumns);
  allColumns.forEach((column) => {
    if (column.children && column.children.length && column.children.some((column2) => column2.visible)) {
      column.rowSpan = 1;
    } else {
      column.rowSpan = maxLevel - column.level + 1;
    }
    rows[column.level - 1].push(column);
  });
  return rows;
};
function restoreScrollLocation($xetable, scrollLeft, scrollTop) {
  const { internalData } = $xetable;
  return $xetable.clearScroll().then(() => {
    if (scrollLeft || scrollTop) {
      internalData.lastScrollLeft = 0;
      internalData.lastScrollTop = 0;
      return $xetable.scrollTo(scrollLeft, scrollTop);
    }
  });
}
function removeScrollListener(scrollElem) {
  if (scrollElem && scrollElem._onscroll) {
    scrollElem.onscroll = null;
  }
}
function restoreScrollListener(scrollElem) {
  if (scrollElem && scrollElem._onscroll) {
    scrollElem.onscroll = scrollElem._onscroll;
  }
}
function getRowUniqueId() {
  return import_xe_utils6.default.uniqueId("row_");
}
function getRowkey($xetable) {
  const { props } = $xetable;
  const { computeRowOpts } = $xetable.getComputeMaps();
  const { rowId } = props;
  const rowOpts = computeRowOpts.value;
  return rowId || rowOpts.keyField || "_X_ROW_KEY";
}
function getRowid($xetable, row) {
  const rowid = import_xe_utils6.default.get(row, getRowkey($xetable));
  return import_xe_utils6.default.eqNull(rowid) ? "" : encodeURIComponent(rowid);
}
var handleFieldOrColumn = ($xetable, fieldOrColumn) => {
  if (fieldOrColumn) {
    return import_xe_utils6.default.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;
  }
  return null;
};
function getPaddingLeftRightSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingLeft = import_xe_utils6.default.toNumber(computedStyle.paddingLeft);
    const paddingRight = import_xe_utils6.default.toNumber(computedStyle.paddingRight);
    return paddingLeft + paddingRight;
  }
  return 0;
}
function getElemenMarginWidth(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const marginLeft = import_xe_utils6.default.toNumber(computedStyle.marginLeft);
    const marginRight = import_xe_utils6.default.toNumber(computedStyle.marginRight);
    return elem.offsetWidth + marginLeft + marginRight;
  }
  return 0;
}
function queryCellElement(cell, selector) {
  return cell.querySelector(".vxe-cell" + selector);
}
function toFilters(filters) {
  if (filters && import_xe_utils6.default.isArray(filters)) {
    return filters.map(({ label, value, data, resetValue, checked }) => {
      return { label, value, data, resetValue, checked: !!checked, _checked: !!checked };
    });
  }
  return filters;
}
function toTreePathSeq(path) {
  return path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("");
}
function getCellValue(row, column) {
  return import_xe_utils6.default.get(row, column.field);
}
function setCellValue(row, column, value) {
  return import_xe_utils6.default.set(row, column.field, value);
}
function getColReMinWidth(params) {
  const { $table, column, cell } = params;
  const { props: tableProps } = $table;
  const { computeResizableOpts } = $table.getComputeMaps();
  const resizableOpts = computeResizableOpts.value;
  const { minWidth: reMinWidth } = resizableOpts;
  if (reMinWidth) {
    const customMinWidth = import_xe_utils6.default.isFunction(reMinWidth) ? reMinWidth(params) : reMinWidth;
    if (customMinWidth !== "auto") {
      return Math.max(1, import_xe_utils6.default.toNumber(customMinWidth));
    }
  }
  const { showHeaderOverflow: allColumnHeaderOverflow } = tableProps;
  const { showHeaderOverflow, minWidth: colMinWidth } = column;
  const headOverflow = import_xe_utils6.default.isUndefined(showHeaderOverflow) || import_xe_utils6.default.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  const showEllipsis = headOverflow === "ellipsis";
  const showTitle = headOverflow === "title";
  const showTooltip = headOverflow === true || headOverflow === "tooltip";
  const hasEllipsis = showTitle || showTooltip || showEllipsis;
  const minTitleWidth = import_xe_utils6.default.floor((import_xe_utils6.default.toNumber(getComputedStyle(cell).fontSize) || 14) * 1.6);
  const paddingLeftRight = getPaddingLeftRightSize(cell) + getPaddingLeftRightSize(queryCellElement(cell, ""));
  let mWidth = minTitleWidth + paddingLeftRight;
  if (hasEllipsis) {
    const checkboxIconWidth = getPaddingLeftRightSize(queryCellElement(cell, "--title>.vxe-cell--checkbox"));
    const requiredIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell--required-icon"));
    const editIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell--edit-icon"));
    const prefixIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell-title-prefix-icon"));
    const suffixIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell-title-suffix-icon"));
    const sortIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell--sort"));
    const filterIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell--filter"));
    mWidth += checkboxIconWidth + requiredIconWidth + editIconWidth + prefixIconWidth + suffixIconWidth + filterIconWidth + sortIconWidth;
  }
  if (colMinWidth) {
    const { refTableBody } = $table.getRefMaps();
    const tableBody = refTableBody.value;
    const bodyElem = tableBody ? tableBody.$el : null;
    if (bodyElem) {
      if (isScale(colMinWidth)) {
        const bodyWidth = bodyElem.clientWidth - 1;
        const meanWidth = bodyWidth / 100;
        return Math.max(mWidth, Math.floor(import_xe_utils6.default.toInteger(colMinWidth) * meanWidth));
      } else if (isPx(colMinWidth)) {
        return Math.max(mWidth, import_xe_utils6.default.toInteger(colMinWidth));
      }
    }
  }
  return mWidth;
}
function isColumnInfo(column) {
  return column && (column.constructor === ColumnInfo || column instanceof ColumnInfo);
}
function createColumn($xetable, options, renderOptions) {
  return isColumnInfo(options) ? options : reactive(new ColumnInfo($xetable, options, renderOptions));
}
function watchColumn($xetable, props, column) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      column.update(name, value);
      if ($xetable) {
        if (name === "filters") {
          $xetable.setFilter(column, value);
          $xetable.handleUpdateDataQueue();
        } else if (["visible", "fixed", "width", "minWidth", "maxWidth"].includes(name)) {
          $xetable.handleRefreshColumnQueue();
        }
      }
    });
  });
}
function assemColumn($xetable, elem, column, colgroup) {
  const { reactData } = $xetable;
  const { staticColumns } = reactData;
  const parentElem = elem.parentNode;
  const parentColumn = colgroup ? colgroup.column : null;
  const parentCols = parentColumn ? parentColumn.children : staticColumns;
  if (parentElem && parentCols) {
    parentCols.splice(import_xe_utils6.default.arrayIndexOf(parentElem.children, elem), 0, column);
    reactData.staticColumns = staticColumns.slice(0);
  }
}
function destroyColumn($xetable, column) {
  const { reactData } = $xetable;
  const { staticColumns } = reactData;
  const matchObj = import_xe_utils6.default.findTree(staticColumns, (item) => item.id === column.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticColumns = staticColumns.slice(0);
}
function getRootColumn($xetable, column) {
  const { internalData } = $xetable;
  const { fullColumnIdData } = internalData;
  if (!column) {
    return null;
  }
  let parentColId = column.parentId;
  while (fullColumnIdData[parentColId]) {
    const column2 = fullColumnIdData[parentColId].column;
    parentColId = column2.parentId;
    if (!parentColId) {
      return column2;
    }
  }
  return column;
}
function mergeBodyMethod(mergeList, _rowIndex, _columnIndex) {
  for (let mIndex = 0; mIndex < mergeList.length; mIndex++) {
    const { row: mergeRowIndex, col: mergeColIndex, rowspan: mergeRowspan, colspan: mergeColspan } = mergeList[mIndex];
    if (mergeColIndex > -1 && mergeRowIndex > -1 && mergeRowspan && mergeColspan) {
      if (mergeRowIndex === _rowIndex && mergeColIndex === _columnIndex) {
        return { rowspan: mergeRowspan, colspan: mergeColspan };
      }
      if (_rowIndex >= mergeRowIndex && _rowIndex < mergeRowIndex + mergeRowspan && _columnIndex >= mergeColIndex && _columnIndex < mergeColIndex + mergeColspan) {
        return { rowspan: 0, colspan: 0 };
      }
    }
  }
}
function clearTableDefaultStatus($xetable) {
  const { props, internalData } = $xetable;
  internalData.initStatus = false;
  $xetable.clearSort();
  $xetable.clearCurrentRow();
  $xetable.clearCurrentColumn();
  $xetable.clearRadioRow();
  $xetable.clearRadioReserve();
  $xetable.clearCheckboxRow();
  $xetable.clearCheckboxReserve();
  $xetable.clearRowExpand();
  $xetable.clearTreeExpand();
  $xetable.clearTreeExpandReserve();
  $xetable.clearPendingRow();
  if ($xetable.clearFilter) {
    $xetable.clearFilter();
  }
  if ($xetable.clearSelected && (props.keyboardConfig || props.mouseConfig)) {
    $xetable.clearSelected();
  }
  if ($xetable.clearCellAreas && props.mouseConfig) {
    $xetable.clearCellAreas();
    $xetable.clearCopyCellArea();
  }
  return $xetable.clearScroll();
}
function clearTableAllStatus($xetable) {
  if ($xetable.clearFilter) {
    $xetable.clearFilter();
  }
  return clearTableDefaultStatus($xetable);
}
function rowToVisible($xetable, row) {
  const { reactData, internalData } = $xetable;
  const { refTableBody } = $xetable.getRefMaps();
  const { scrollYLoad } = reactData;
  const { afterFullData, scrollYStore } = internalData;
  const tableBody = refTableBody.value;
  const bodyElem = tableBody ? tableBody.$el : null;
  if (bodyElem) {
    const trElem = bodyElem.querySelector(`[rowid="${getRowid($xetable, row)}"]`);
    if (trElem) {
      const bodyHeight = bodyElem.clientHeight;
      const bodySrcollTop = bodyElem.scrollTop;
      const trOffsetParent = trElem.offsetParent;
      const trOffsetTop = trElem.offsetTop + (trOffsetParent ? trOffsetParent.offsetTop : 0);
      const trHeight = trElem.clientHeight;
      if (trOffsetTop < bodySrcollTop || trOffsetTop > bodySrcollTop + bodyHeight) {
        return $xetable.scrollTo(null, trOffsetTop);
      } else if (trOffsetTop + trHeight >= bodyHeight + bodySrcollTop) {
        return $xetable.scrollTo(null, bodySrcollTop + trHeight);
      }
    } else {
      if (scrollYLoad) {
        return $xetable.scrollTo(null, (afterFullData.indexOf(row) - 1) * scrollYStore.rowHeight);
      }
    }
  }
  return Promise.resolve();
}
function colToVisible($xetable, column) {
  const { reactData, internalData } = $xetable;
  const { refTableBody } = $xetable.getRefMaps();
  const { scrollXLoad } = reactData;
  const { visibleColumn } = internalData;
  const tableBody = refTableBody.value;
  const bodyElem = tableBody ? tableBody.$el : null;
  if (column && column.fixed) {
    return Promise.resolve();
  }
  if (bodyElem) {
    const tdElem = bodyElem.querySelector(`.${column.id}`);
    if (tdElem) {
      const bodyWidth = bodyElem.clientWidth;
      const bodySrcollLeft = bodyElem.scrollLeft;
      const tdOffsetParent = tdElem.offsetParent;
      const tdOffsetLeft = tdElem.offsetLeft + (tdOffsetParent ? tdOffsetParent.offsetLeft : 0);
      const tdWidth = tdElem.clientWidth;
      if (tdOffsetLeft < bodySrcollLeft || tdOffsetLeft > bodySrcollLeft + bodyWidth) {
        return $xetable.scrollTo(tdOffsetLeft);
      } else if (tdOffsetLeft + tdWidth >= bodyWidth + bodySrcollLeft) {
        return $xetable.scrollTo(bodySrcollLeft + tdWidth);
      }
    } else {
      if (scrollXLoad) {
        let scrollLeft = 0;
        for (let index = 0; index < visibleColumn.length; index++) {
          if (visibleColumn[index] === column) {
            break;
          }
          scrollLeft += visibleColumn[index].renderWidth;
        }
        return $xetable.scrollTo(scrollLeft);
      }
    }
  }
  return Promise.resolve();
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/tools/vn.js
var import_xe_utils7 = __toESM(require_xe_utils());
function getOnName(type) {
  return "on" + type.substring(0, 1).toLocaleUpperCase() + type.substring(1);
}
function getSlotVNs(vns) {
  if (import_xe_utils7.default.isArray(vns)) {
    return vns;
  }
  return [vns];
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/renderer.js
var componentDefaultModelProp = "modelValue";
var defaultCompProps = { transfer: true };
function getModelEvent(renderOpts) {
  switch (renderOpts.name) {
    case "input":
    case "textarea":
      return "input";
  }
  return "update:modelValue";
}
function getChangeEvent(renderOpts) {
  switch (renderOpts.name) {
    case "input":
    case "textarea":
    case "VxeInput":
    case "VxeTextarea":
    case "$input":
    case "$textarea":
      return "input";
  }
  return "change";
}
function parseDate(value, props) {
  return value && props.valueFormat ? import_xe_utils8.default.toStringDate(value, props.valueFormat) : value;
}
function getFormatDate(value, props, defaultFormat) {
  const { dateConfig = {} } = props;
  return import_xe_utils8.default.toDateString(parseDate(value, props), dateConfig.labelFormat || defaultFormat);
}
function getLabelFormatDate(value, props) {
  return getFormatDate(value, props, conf_default.i18n(`vxe.input.date.labelFormat.${props.type}`));
}
function getOldComponentName(name) {
  return `vxe-${name.replace("$", "")}`;
}
function getDefaultComponent({ name }) {
  return resolveComponent(name);
}
function getOldComponent({ name }) {
  return resolveComponent(getOldComponentName(name));
}
function handleConfirmFilter(params, checked, option) {
  const { $panel } = params;
  $panel.changeOption({}, checked, option);
}
function getNativeAttrs(renderOpts) {
  let { name, attrs } = renderOpts;
  if (name === "input") {
    attrs = Object.assign({ type: "text" }, attrs);
  }
  return attrs;
}
function getInputImmediateModel(renderOpts) {
  const { name, immediate, props } = renderOpts;
  if (!immediate) {
    if (name === "VxeInput" || name === "$input") {
      const { type } = props || {};
      return !(!type || type === "text" || type === "number" || type === "integer" || type === "float");
    }
    if (name === "input" || name === "textarea" || name === "$textarea") {
      return false;
    }
    return true;
  }
  return immediate;
}
function getCellEditProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils8.default.assign({ immediate: getInputImmediateModel(renderOpts) }, defaultCompProps, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function getCellEditFilterProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils8.default.assign({}, defaultCompProps, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function getComponentFormItemProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils8.default.assign({}, defaultCompProps, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function isImmediateCell(renderOpts, params) {
  return params.$type === "cell" || getInputImmediateModel(renderOpts);
}
function getCellLabelVNs(renderOpts, params, cellLabel) {
  const { placeholder } = renderOpts;
  return [
    h("span", {
      class: "vxe-cell--label"
    }, placeholder && isEmptyValue(cellLabel) ? [
      h("span", {
        class: "vxe-cell--placeholder"
      }, formatText(getFuncText(placeholder), 1))
    ] : formatText(cellLabel, 1))
  ];
}
function getElementOns(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    import_xe_utils8.default.objectEach(events, (func, key) => {
      ons[getOnName(key)] = function(...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getComponentOns(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const ons = {};
  import_xe_utils8.default.objectEach(events, (func, key) => {
    ons[getOnName(key)] = function(...args) {
      if (true) {
        if (!import_xe_utils8.default.isFunction(func)) {
          errLog("vxe.error.errFunc", [func]);
        }
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getEditOns(renderOpts, params) {
  const { $table, row, column } = params;
  const { name } = renderOpts;
  const { model } = column;
  const isImmediate = isImmediateCell(renderOpts, params);
  return getComponentOns(renderOpts, params, (cellValue) => {
    if (isImmediate) {
      setCellValue(row, column, cellValue);
    } else {
      model.update = true;
      model.value = cellValue;
    }
  }, (eventParams) => {
    if (!isImmediate && ["VxeInput", "VxeTextarea", "$input", "$textarea"].includes(name)) {
      const cellValue = eventParams.value;
      model.update = true;
      model.value = cellValue;
      $table.updateStatus(params, cellValue);
    } else {
      $table.updateStatus(params);
    }
  });
}
function getFilterOns(renderOpts, params, option) {
  return getComponentOns(renderOpts, params, (value) => {
    option.data = value;
  }, () => {
    handleConfirmFilter(params, !import_xe_utils8.default.eqNull(option.data), option);
  });
}
function getItemOns(renderOpts, params) {
  const { $form, data, property } = params;
  return getComponentOns(renderOpts, params, (value) => {
    import_xe_utils8.default.set(data, property, value);
  }, () => {
    $form.updateStatus(params);
  });
}
function getNativeEditOns(renderOpts, params) {
  const { $table, row, column } = params;
  const { model } = column;
  return getElementOns(renderOpts, params, (evnt) => {
    const cellValue = evnt.target.value;
    if (isImmediateCell(renderOpts, params)) {
      setCellValue(row, column, cellValue);
    } else {
      model.update = true;
      model.value = cellValue;
    }
  }, (evnt) => {
    const cellValue = evnt.target.value;
    $table.updateStatus(params, cellValue);
  });
}
function getNativeFilterOns(renderOpts, params, option) {
  return getElementOns(renderOpts, params, (evnt) => {
    option.data = evnt.target.value;
  }, () => {
    handleConfirmFilter(params, !import_xe_utils8.default.eqNull(option.data), option);
  });
}
function getNativeItemOns(renderOpts, params) {
  const { $form, data, property } = params;
  return getElementOns(renderOpts, params, (evnt) => {
    const itemValue = evnt.target.value;
    import_xe_utils8.default.set(data, property, itemValue);
  }, () => {
    $form.updateStatus(params);
  });
}
function nativeEditRender(renderOpts, params) {
  const { row, column } = params;
  const { name } = renderOpts;
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return [
    h(name, Object.assign(Object.assign(Object.assign({ class: `vxe-default-${name}` }, getNativeAttrs(renderOpts)), { value: cellValue }), getNativeEditOns(renderOpts, params)))
  ];
}
function defaultCellRender(renderOpts, params) {
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function defaultEditRender(renderOpts, params) {
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function oldEditRender(renderOpts, params) {
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function oldButtonEditRender(renderOpts, params) {
  return [
    h(resolveComponent("vxe-button"), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function oldButtonsEditRender(renderOpts, params) {
  return renderOpts.children.map((childRenderOpts) => oldButtonEditRender(childRenderOpts, params)[0]);
}
function renderNativeOptgroups(renderOpts, params, renderOptionsMethods) {
  const { optionGroups, optionGroupProps = {} } = renderOpts;
  const groupOptions = optionGroupProps.options || "options";
  const groupLabel = optionGroupProps.label || "label";
  return optionGroups.map((group, gIndex) => {
    return h("optgroup", {
      key: gIndex,
      label: group[groupLabel]
    }, renderOptionsMethods(group[groupOptions], renderOpts, params));
  });
}
function renderNativeOptions(options, renderOpts, params) {
  const { optionProps = {} } = renderOpts;
  const { row, column } = params;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return options.map((option, oIndex) => {
    return h("option", {
      key: oIndex,
      value: option[valueProp],
      disabled: option[disabledProp],
      /* eslint-disable eqeqeq */
      selected: option[valueProp] == cellValue
    }, option[labelProp]);
  });
}
function nativeFilterRender(renderOpts, params) {
  const { column } = params;
  const { name } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  return column.filters.map((option, oIndex) => {
    return h(name, Object.assign(Object.assign(Object.assign({ key: oIndex, class: `vxe-default-${name}` }, attrs), { value: option.data }), getNativeFilterOns(renderOpts, params, option)));
  });
}
function defaultFilterRender(renderOpts, params) {
  const { column } = params;
  return column.filters.map((option, oIndex) => {
    const optionValue = option.data;
    return h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, renderOpts, optionValue)), getFilterOns(renderOpts, params, option)));
  });
}
function oldFilterRender(renderOpts, params) {
  const { column } = params;
  return column.filters.map((option, oIndex) => {
    const optionValue = option.data;
    return h(getOldComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, renderOpts, optionValue)), getFilterOns(renderOpts, params, option)));
  });
}
function handleFilterMethod({ option, row, column }) {
  const { data } = option;
  const cellValue = import_xe_utils8.default.get(row, column.property);
  return cellValue == data;
}
function nativeSelectEditRender(renderOpts, params) {
  return [
    h("select", Object.assign(Object.assign({ class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeEditOns(renderOpts, params)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params))
  ];
}
function defaultSelectEditRender(renderOpts, params) {
  const { row, column } = params;
  const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps, optionGroups, optionGroupProps })), getEditOns(renderOpts, params)))
  ];
}
function oldSelectEditRender(renderOpts, params) {
  const { row, column } = params;
  const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps, optionGroups, optionGroupProps })), getEditOns(renderOpts, params)))
  ];
}
function getSelectCellValue(renderOpts, { row, column }) {
  const { props = {}, options, optionGroups, optionProps = {}, optionGroupProps = {} } = renderOpts;
  const cellValue = import_xe_utils8.default.get(row, column.property);
  let selectItem;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  if (!isEmptyValue(cellValue)) {
    return import_xe_utils8.default.map(props.multiple ? cellValue : [cellValue], optionGroups ? (value) => {
      const groupOptions = optionGroupProps.options || "options";
      for (let index = 0; index < optionGroups.length; index++) {
        selectItem = import_xe_utils8.default.find(optionGroups[index][groupOptions], (item) => item[valueProp] == value);
        if (selectItem) {
          break;
        }
      }
      return selectItem ? selectItem[labelProp] : value;
    } : (value) => {
      selectItem = import_xe_utils8.default.find(options, (item) => item[valueProp] == value);
      return selectItem ? selectItem[labelProp] : value;
    }).join(", ");
  }
  return "";
}
function nativeItemRender(renderOpts, params) {
  const { data, property } = params;
  const { name } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  const itemValue = import_xe_utils8.default.get(data, property);
  return [
    h(name, Object.assign(Object.assign(Object.assign({ class: `vxe-default-${name}` }, attrs), { value: attrs && name === "input" && (attrs.type === "submit" || attrs.type === "reset") ? null : itemValue }), getNativeItemOns(renderOpts, params)))
  ];
}
function defaultItemRender(renderOpts, params) {
  const { data, property } = params;
  const itemValue = import_xe_utils8.default.get(data, property);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldItemRender(renderOpts, params) {
  const { data, property } = params;
  const itemValue = import_xe_utils8.default.get(data, property);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldButtonItemRender(renderOpts, params) {
  return [
    h(resolveComponent("vxe-button"), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function oldButtonsItemRender(renderOpts, params) {
  return renderOpts.children.map((childRenderOpts) => oldButtonItemRender(childRenderOpts, params)[0]);
}
function renderNativeFormOptions(options, renderOpts, params) {
  const { data, property } = params;
  const { optionProps = {} } = renderOpts;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const cellValue = import_xe_utils8.default.get(data, property);
  return options.map((item, oIndex) => {
    return h("option", {
      key: oIndex,
      value: item[valueProp],
      disabled: item[disabledProp],
      /* eslint-disable eqeqeq */
      selected: item[valueProp] == cellValue
    }, item[labelProp]);
  });
}
function handleExportSelectMethod(params) {
  const { row, column, options } = params;
  return options.original ? getCellValue(row, column) : getSelectCellValue(column.editRender || column.cellRender, params);
}
function defaultFormItemRender(renderOpts, params) {
  const { data, property } = params;
  const itemValue = import_xe_utils8.default.get(data, property);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function formItemRadioAndCheckboxRender(renderOpts, params) {
  const { options, optionProps } = renderOpts;
  const { data, property } = params;
  const itemValue = import_xe_utils8.default.get(data, property);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({
      options,
      optionProps
    }, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldFormItemRadioAndCheckboxRender(renderOpts, params) {
  const { name, options, optionProps = {} } = renderOpts;
  const { data, property } = params;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const itemValue = import_xe_utils8.default.get(data, property);
  const compName = getOldComponentName(name);
  if (options) {
    return [
      h(resolveComponent(`${compName}-group`), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)), {
        default: () => {
          return options.map((item, index) => {
            return h(resolveComponent(compName), {
              key: index,
              label: item[valueProp],
              content: item[labelProp],
              disabled: item[disabledProp]
            });
          });
        }
      })
    ];
  }
  return [
    h(resolveComponent(compName), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
var renderMap = {
  input: {
    autofocus: "input",
    renderEdit: nativeEditRender,
    renderDefault: nativeEditRender,
    renderFilter: nativeFilterRender,
    defaultFilterMethod: handleFilterMethod,
    renderItemContent: nativeItemRender
  },
  textarea: {
    autofocus: "textarea",
    renderEdit: nativeEditRender,
    renderItemContent: nativeItemRender
  },
  select: {
    renderEdit: nativeSelectEditRender,
    renderDefault: nativeSelectEditRender,
    renderCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderFilter(renderOpts, params) {
      const { column } = params;
      return column.filters.map((option, oIndex) => {
        return h("select", Object.assign(Object.assign({ key: oIndex, class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeFilterOns(renderOpts, params, option)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params));
      });
    },
    defaultFilterMethod: handleFilterMethod,
    renderItemContent(renderOpts, params) {
      return [
        h("select", Object.assign(Object.assign({ class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeItemOns(renderOpts, params)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeFormOptions) : renderNativeFormOptions(renderOpts.options, renderOpts, params))
      ];
    },
    exportMethod: handleExportSelectMethod
  },
  VxeInput: {
    autofocus: ".vxe-input--inner",
    renderEdit: defaultEditRender,
    renderCell(renderOpts, params) {
      const { props = {} } = renderOpts;
      const { row, column } = params;
      const digits = props.digits || conf_default.input.digits;
      let cellValue = import_xe_utils8.default.get(row, column.property);
      if (cellValue) {
        switch (props.type) {
          case "date":
          case "week":
          case "month":
          case "year":
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case "float":
            cellValue = import_xe_utils8.default.toFixed(import_xe_utils8.default.floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderDefault: defaultEditRender,
    renderFilter: defaultFilterRender,
    defaultFilterMethod: handleFilterMethod,
    renderItemContent: defaultItemRender
  },
  VxeTextarea: {
    autofocus: ".vxe-textarea--inner",
    renderItemContent: defaultItemRender
  },
  VxeButton: {
    renderDefault: defaultCellRender,
    renderItemContent: defaultFormItemRender
  },
  VxeButtonGroup: {
    renderDefault: defaultCellRender,
    renderItemContent(renderOpts, params) {
      const { options } = renderOpts;
      const { data, property } = params;
      const itemValue = import_xe_utils8.default.get(data, property);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ options }, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeSelect: {
    autofocus: ".vxe-input--inner",
    renderEdit: defaultSelectEditRender,
    renderDefault: defaultSelectEditRender,
    renderCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderFilter(renderOpts, params) {
      const { column } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      return column.filters.map((option, oIndex) => {
        const optionValue = option.data;
        return h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, params, optionValue, { options, optionProps, optionGroups, optionGroupProps })), getFilterOns(renderOpts, params, option)));
      });
    },
    defaultFilterMethod: handleFilterMethod,
    renderItemContent(renderOpts, params) {
      const { data, property } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      const itemValue = import_xe_utils8.default.get(data, property);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps, optionGroups, optionGroupProps })), getItemOns(renderOpts, params)))
      ];
    },
    exportMethod: handleExportSelectMethod
  },
  VxeRadio: {
    autofocus: ".vxe-radio--input",
    renderItemContent: defaultFormItemRender
  },
  VxeRadioGroup: {
    autofocus: ".vxe-radio--input",
    renderItemContent: formItemRadioAndCheckboxRender
  },
  VxeCheckbox: {
    autofocus: ".vxe-checkbox--input",
    renderItemContent: defaultFormItemRender
  },
  VxeCheckboxGroup: {
    autofocus: ".vxe-checkbox--input",
    renderItemContent: formItemRadioAndCheckboxRender
  },
  VxeSwitch: {
    autofocus: ".vxe-switch--button",
    renderEdit: defaultEditRender,
    renderDefault: defaultEditRender,
    renderItemContent: defaultItemRender
  },
  // 
  $input: {
    autofocus: ".vxe-input--inner",
    renderEdit: oldEditRender,
    renderCell(renderOpts, params) {
      const { props = {} } = renderOpts;
      const { row, column } = params;
      const digits = props.digits || conf_default.input.digits;
      let cellValue = import_xe_utils8.default.get(row, column.property);
      if (cellValue) {
        switch (props.type) {
          case "date":
          case "week":
          case "month":
          case "year":
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case "float":
            cellValue = import_xe_utils8.default.toFixed(import_xe_utils8.default.floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderDefault: oldEditRender,
    renderFilter: oldFilterRender,
    defaultFilterMethod: handleFilterMethod,
    renderItemContent: oldItemRender
  },
  $textarea: {
    autofocus: ".vxe-textarea--inner",
    renderItemContent: oldItemRender
  },
  $button: {
    renderDefault: oldButtonEditRender,
    renderItemContent: oldButtonItemRender
  },
  $buttons: {
    renderDefault: oldButtonsEditRender,
    renderItemContent: oldButtonsItemRender
  },
  $select: {
    autofocus: ".vxe-input--inner",
    renderEdit: oldSelectEditRender,
    renderDefault: oldSelectEditRender,
    renderCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderFilter(renderOpts, params) {
      const { column } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      return column.filters.map((option, oIndex) => {
        const optionValue = option.data;
        return h(getOldComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, params, optionValue, { options, optionProps, optionGroups, optionGroupProps })), getFilterOns(renderOpts, params, option)));
      });
    },
    defaultFilterMethod: handleFilterMethod,
    renderItemContent(renderOpts, params) {
      const { data, property } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      const itemValue = import_xe_utils8.default.get(data, property);
      return [
        h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps, optionGroups, optionGroupProps })), getItemOns(renderOpts, params)))
      ];
    },
    exportMethod: handleExportSelectMethod
  },
  $radio: {
    autofocus: ".vxe-radio--input",
    renderItemContent: oldFormItemRadioAndCheckboxRender
  },
  $checkbox: {
    autofocus: ".vxe-checkbox--input",
    renderItemContent: oldFormItemRadioAndCheckboxRender
  },
  $switch: {
    autofocus: ".vxe-switch--button",
    renderEdit: oldEditRender,
    renderDefault: oldEditRender,
    renderItemContent: oldItemRender
  }
  // 
};
var renderer = {
  mixin(opts) {
    import_xe_utils8.default.each(opts, (options, name) => renderer.add(name, options));
    return renderer;
  },
  get(name) {
    return renderMap[name] || null;
  },
  add(name, options) {
    if (name && options) {
      const renders = renderMap[name];
      if (renders) {
        if (true) {
          import_xe_utils8.default.each(options, (val, key) => {
            if (!import_xe_utils8.default.eqNull(renders[key]) && renders[key] !== val) {
              warnLog("vxe.error.coverProp", [`Renderer.${name}`, key]);
            }
          });
        }
        Object.assign(renders, options);
      } else {
        renderMap[name] = options;
      }
    }
    return renderer;
  },
  delete(name) {
    delete renderMap[name];
    return renderer;
  }
};

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/commands.js
var import_xe_utils9 = __toESM(require_xe_utils());
var VXECommandsStore = class {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    import_xe_utils9.default.each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    if (import_xe_utils9.default.isFunction(render)) {
      if (true) {
        warnLog("vxe.error.delProp", ["commands -> callback", "commandMethod"]);
      }
      render = {
        commandMethod: render
      };
    }
    if (true) {
      const confKeys = import_xe_utils9.default.keys(conf);
      import_xe_utils9.default.each(render, (item, key) => {
        if (confKeys.includes(key)) {
          warnLog("vxe.error.coverProp", [name, key]);
        }
      });
    }
    this.store[name] = conf ? import_xe_utils9.default.merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    import_xe_utils9.default.objectEach(this.store, callback);
  }
};
var commands = new VXECommandsStore();
if (true) {
  Object.assign(commands, { _name: "Commands" });
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/menus.js
var import_xe_utils10 = __toESM(require_xe_utils());
var VXEMenusStore = class {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    import_xe_utils10.default.each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    if (import_xe_utils10.default.isFunction(render)) {
      if (true) {
        warnLog("vxe.error.delProp", ["menus -> callback", "menuMethod"]);
      }
      render = {
        menuMethod: render
      };
    }
    if (true) {
      const confKeys = import_xe_utils10.default.keys(conf);
      import_xe_utils10.default.each(render, (item, key) => {
        if (confKeys.includes(key)) {
          warnLog("vxe.error.coverProp", [name, key]);
        }
      });
    }
    this.store[name] = conf ? import_xe_utils10.default.merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    import_xe_utils10.default.objectEach(this.store, callback);
  }
};
var menus = new VXEMenusStore();
if (true) {
  Object.assign(menus, { _name: "Menus" });
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/store.js
var import_xe_utils11 = __toESM(require_xe_utils());
var Store = class {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    import_xe_utils11.default.each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, options) {
    const conf = this.store[name];
    if (true) {
      const confKeys = import_xe_utils11.default.keys(conf);
      import_xe_utils11.default.each(options, (item, key) => {
        if (confKeys.includes(key)) {
          warnLog("vxe.error.coverProp", [name, key]);
        }
      });
    }
    this.store[name] = conf ? import_xe_utils11.default.merge(conf, options) : options;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    import_xe_utils11.default.objectEach(this.store, callback);
  }
};
var store_default = Store;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/validators.js
var validators = new store_default();
if (true) {
  Object.assign(validators, { _name: "Validators" });
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/hooks.js
var hooks = new store_default();

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/theme.js
function setTheme(name) {
  let theme = name || conf_default.theme;
  if (!theme || theme === "default") {
    theme = "light";
  }
  conf_default.theme = theme;
  if (typeof document !== "undefined") {
    const documentElement = document.documentElement;
    if (documentElement) {
      documentElement.setAttribute("data-vxe-ui-theme", theme);
    }
  }
}
function getTheme() {
  return conf_default.theme;
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/index.js
function getExportOrImpotType(types, flag) {
  const rest = [];
  import_xe_utils12.default.objectEach(types, (val, type) => {
    if (val === 0 || val === flag) {
      rest.push(type);
    }
  });
  return rest;
}
var installedPlugins = [];
function use(Plugin, options) {
  if (Plugin && Plugin.install) {
    if (installedPlugins.indexOf(Plugin) === -1) {
      Plugin.install(VXETable, options);
      installedPlugins.push(Plugin);
    }
  }
  return VXETable;
}
function t(key, args) {
  return conf_default.i18n(key, args);
}
function _t(key, args) {
  return key ? import_xe_utils12.default.toValueString(conf_default.translate ? conf_default.translate(key, args) : key) : "";
}
var setConfig = (options) => {
  if (options) {
    if (options.theme) {
      setTheme(options.theme);
    }
    if (options.zIndex) {
      index_esm_default.setCurrent(options.zIndex);
    }
    import_xe_utils12.default.merge(conf_default, options);
  }
  return VXETable;
};
var VXETableConfig = class {
  /**
   *  zIndex
   */
  get zIndex() {
    return getLastZIndex();
  }
  /**
   *  zIndex
   */
  get nextZIndex() {
    return nextZIndex();
  }
  /**
   * 
   */
  get exportTypes() {
    return getExportOrImpotType(conf_default.export.types, 1);
  }
  /**
   * 
   */
  get importTypes() {
    return getExportOrImpotType(conf_default.export.types, 2);
  }
};
var globalConfs = new VXETableConfig();
var v = "v4";
var setup = (options) => {
  if (true) {
    warnLog("vxe.error.delFunc", ["setup", "setConfig"]);
  }
  setConfig(options);
  return conf_default;
};
var config = (options) => {
  if (true) {
    warnLog("vxe.error.delFunc", ["setup", "setConfig"]);
  }
  setConfig(options);
  return conf_default;
};
function setIcon(options) {
  if (options) {
    Object.assign(conf_default.icon, options);
  }
  return VXETable;
}
var globalStore = {};
var components = {};
function getComponent(name) {
  return components[name] || null;
}
function component(comp) {
  if (comp && comp.name) {
    components[comp.name] = comp;
  }
}
var version = "4.6.25";
var tableVersion = version;
var VXETable = {
  v,
  version,
  tableVersion,
  setConfig,
  setIcon,
  globalStore,
  interceptor,
  renderer,
  commands,
  formats,
  validators,
  menus,
  hooks,
  use,
  t,
  _t,
  setTheme,
  getTheme,
  getComponent,
  // 
  config,
  setup,
  globalConfs
};
var VxeUI = VXETable;
setTheme("light");

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/filter/src/panel.js
var panel_default = defineComponent({
  name: "VxeTableFilterPanel",
  props: {
    filterStore: Object
  },
  setup(props) {
    const $xetable = inject("$xetable", {});
    const { reactData: tableReactData, internalData: tableInternalData, getComputeMaps } = $xetable;
    const { computeFilterOpts } = getComputeMaps();
    const computeHasCheckOption = computed(() => {
      const { filterStore } = props;
      return filterStore && filterStore.options.some((option) => option.checked);
    });
    const filterCheckAllEvent = (evnt, value) => {
      const { filterStore } = props;
      filterStore.options.forEach((option) => {
        option._checked = value;
        option.checked = value;
      });
      filterStore.isAllSelected = value;
      filterStore.isIndeterminate = false;
    };
    const confirmFilter = (evnt) => {
      const { filterStore } = props;
      filterStore.options.forEach((option) => {
        option.checked = option._checked;
      });
      $xetable.confirmFilterEvent(evnt);
    };
    const changeRadioOption = (evnt, checked, item) => {
      const { filterStore } = props;
      filterStore.options.forEach((option) => {
        option._checked = false;
      });
      item._checked = checked;
      $xetable.checkFilterOptions();
      confirmFilter(evnt);
    };
    const resetFilter = (evnt) => {
      const { filterStore } = props;
      $xetable.handleClearFilter(filterStore.column);
      $xetable.confirmFilterEvent(evnt);
    };
    const changeMultipleOption = (evnt, checked, item) => {
      item._checked = checked;
      $xetable.checkFilterOptions();
    };
    const changeOption = (evnt, checked, item) => {
      const { filterStore } = props;
      if (filterStore.multiple) {
        changeMultipleOption(evnt, checked, item);
      } else {
        changeRadioOption(evnt, checked, item);
      }
    };
    const changeAllOption = (evnt, checked) => {
      const { filterStore } = props;
      if (filterStore.multiple) {
        filterCheckAllEvent(evnt, checked);
      } else {
        resetFilter(evnt);
      }
    };
    const $panel = {
      changeRadioOption,
      changeMultipleOption,
      changeAllOption,
      changeOption,
      confirmFilter,
      resetFilter
    };
    const renderOptions = (filterRender, compConf) => {
      const { filterStore } = props;
      const { column, multiple, maxHeight } = filterStore;
      const { slots } = column;
      const filterSlot = slots ? slots.filter : null;
      const params = Object.assign({}, tableInternalData._currFilterParams, { $panel, $table: $xetable });
      if (filterSlot) {
        return [
          h("div", {
            class: "vxe-table--filter-template"
          }, $xetable.callSlot(filterSlot, params))
        ];
      } else if (compConf && compConf.renderFilter) {
        return [
          h("div", {
            class: "vxe-table--filter-template"
          }, getSlotVNs(compConf.renderFilter(filterRender, params)))
        ];
      }
      const isAllChecked = multiple ? filterStore.isAllSelected : !filterStore.options.some((item) => item._checked);
      const isAllIndeterminate = multiple && filterStore.isIndeterminate;
      return [
        h("ul", {
          class: "vxe-table--filter-header"
        }, [
          h("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": isAllChecked,
              "is--indeterminate": isAllIndeterminate
            }],
            title: conf_default.i18n(multiple ? "vxe.table.allTitle" : "vxe.table.allFilter"),
            onClick: (evnt) => {
              changeAllOption(evnt, !filterStore.isAllSelected);
            }
          }, (multiple ? [
            h("span", {
              class: ["vxe-checkbox--icon", isAllIndeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            h("span", {
              class: "vxe-checkbox--label"
            }, conf_default.i18n("vxe.table.allFilter"))
          ]))
        ]),
        h("ul", {
          class: "vxe-table--filter-body",
          style: maxHeight ? {
            maxHeight: `${maxHeight}px`
          } : {}
        }, filterStore.options.map((item) => {
          const isChecked = item._checked;
          const isIndeterminate = false;
          return h("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": item._checked
            }],
            title: item.label,
            onClick: (evnt) => {
              changeOption(evnt, !item._checked, item);
            }
          }, (multiple ? [
            h("span", {
              class: ["vxe-checkbox--icon", isIndeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            h("span", {
              class: "vxe-checkbox--label"
            }, formatText(item.label, 1))
          ]));
        }))
      ];
    };
    const renderFooters = () => {
      const { filterStore } = props;
      const { column, multiple } = filterStore;
      const filterOpts = computeFilterOpts.value;
      const hasCheckOption = computeHasCheckOption.value;
      const filterRender = column.filterRender;
      const compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
      const isDisabled = !hasCheckOption && !filterStore.isAllSelected && !filterStore.isIndeterminate;
      return multiple && (!compConf || compConf.showFilterFooter !== false) ? [
        h("div", {
          class: "vxe-table--filter-footer"
        }, [
          h("button", {
            class: {
              "is--disabled": isDisabled
            },
            disabled: isDisabled,
            onClick: confirmFilter
          }, filterOpts.confirmButtonText || conf_default.i18n("vxe.table.confirmFilter")),
          h("button", {
            onClick: resetFilter
          }, filterOpts.resetButtonText || conf_default.i18n("vxe.table.resetFilter"))
        ])
      ] : [];
    };
    const renderVN = () => {
      const { filterStore } = props;
      const { initStore } = tableReactData;
      const { column } = filterStore;
      const filterRender = column ? column.filterRender : null;
      const compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
      const filterClassName = compConf ? compConf.filterClassName : "";
      const params = Object.assign({}, tableInternalData._currFilterParams, { $panel, $table: $xetable });
      return h("div", {
        class: [
          "vxe-table--filter-wrapper",
          "filter--prevent-default",
          getPropClass(filterClassName, params),
          {
            "is--animat": $xetable.props.animat,
            "is--multiple": filterStore.multiple,
            "is--active": filterStore.visible
          }
        ],
        style: filterStore.style
      }, initStore.filter && filterStore.visible ? renderOptions(filterRender, compConf).concat(renderFooters()) : []);
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/filter/src/hook.js
var import_xe_utils13 = __toESM(require_xe_utils());
var tableFilterMethodKeys = ["setFilter", "clearFilter", "getCheckedFilters"];
var tableFilterHook = {
  setupTable($xetable) {
    const { props, reactData, internalData } = $xetable;
    const { refTableBody, refTableFilter } = $xetable.getRefMaps();
    const { computeFilterOpts, computeMouseOpts } = $xetable.getComputeMaps();
    const filterPrivateMethods = {
      checkFilterOptions() {
        const { filterStore } = reactData;
        filterStore.isAllSelected = filterStore.options.every((item) => item._checked);
        filterStore.isIndeterminate = !filterStore.isAllSelected && filterStore.options.some((item) => item._checked);
      },
      /**
       * 
       * 
       * 
       * 
       * @param {Event} evnt 
       * @param {ColumnInfo} column 
       * @param {Object} params 
       */
      triggerFilterEvent(evnt, column, params) {
        const { initStore, filterStore } = reactData;
        if (filterStore.column === column && filterStore.visible) {
          filterStore.visible = false;
        } else {
          const { target: targetElem, pageX } = evnt;
          const { visibleWidth } = getDomNode();
          const { filters, filterMultiple, filterRender } = column;
          const compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
          const filterRecoverMethod = column.filterRecoverMethod || (compConf ? compConf.filterRecoverMethod : null);
          internalData._currFilterParams = params;
          Object.assign(filterStore, {
            multiple: filterMultiple,
            options: filters,
            column,
            style: null
          });
          filterStore.options.forEach((option) => {
            const { _checked, checked } = option;
            option._checked = checked;
            if (!checked && _checked !== checked) {
              if (filterRecoverMethod) {
                filterRecoverMethod({ option, column, $table: $xetable });
              }
            }
          });
          this.checkFilterOptions();
          filterStore.visible = true;
          initStore.filter = true;
          nextTick(() => {
            const tableBody = refTableBody.value;
            const bodyElem = tableBody.$el;
            const tableFilter = refTableFilter.value;
            const filterWrapperElem = tableFilter ? tableFilter.$el : null;
            let filterWidth = 0;
            let filterHeight = 0;
            let filterHeadElem = null;
            let filterFootElem = null;
            if (filterWrapperElem) {
              filterWidth = filterWrapperElem.offsetWidth;
              filterHeight = filterWrapperElem.offsetHeight;
              filterHeadElem = filterWrapperElem.querySelector(".vxe-table--filter-header");
              filterFootElem = filterWrapperElem.querySelector(".vxe-table--filter-footer");
            }
            const centerWidth = filterWidth / 2;
            const minMargin = 10;
            const maxLeft = bodyElem.clientWidth - filterWidth - minMargin;
            let left, right;
            const style = {
              top: `${targetElem.offsetTop + targetElem.offsetParent.offsetTop + targetElem.offsetHeight + 8}px`
            };
            let maxHeight = null;
            if (filterHeight >= bodyElem.clientHeight) {
              maxHeight = Math.max(60, bodyElem.clientHeight - (filterFootElem ? filterFootElem.offsetHeight : 0) - (filterHeadElem ? filterHeadElem.offsetHeight : 0));
            }
            if (column.fixed === "left") {
              left = targetElem.offsetLeft + targetElem.offsetParent.offsetLeft - centerWidth;
            } else if (column.fixed === "right") {
              right = targetElem.offsetParent.offsetWidth - targetElem.offsetLeft + (targetElem.offsetParent.offsetParent.offsetWidth - targetElem.offsetParent.offsetLeft) - column.renderWidth - centerWidth;
            } else {
              left = targetElem.offsetLeft + targetElem.offsetParent.offsetLeft - centerWidth - bodyElem.scrollLeft;
            }
            if (left) {
              const overflowWidth = pageX + filterWidth - centerWidth + minMargin - visibleWidth;
              if (overflowWidth > 0) {
                left -= overflowWidth;
              }
              style.left = `${Math.min(maxLeft, Math.max(minMargin, left))}px`;
            } else if (right) {
              const overflowWidth = pageX + filterWidth - centerWidth + minMargin - visibleWidth;
              if (overflowWidth > 0) {
                right += overflowWidth;
              }
              style.right = `${Math.max(minMargin, right)}px`;
            }
            filterStore.style = style;
            filterStore.maxHeight = maxHeight;
          });
        }
        $xetable.dispatchEvent("filter-visible", { column, field: column.field, property: column.field, filterList: $xetable.getCheckedFilters(), visible: filterStore.visible }, evnt);
      },
      handleClearFilter(column) {
        if (column) {
          const { filters, filterRender } = column;
          if (filters) {
            const compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
            const filterResetMethod = column.filterResetMethod || (compConf ? compConf.filterResetMethod : null);
            filters.forEach((item) => {
              item._checked = false;
              item.checked = false;
              if (!filterResetMethod) {
                item.data = import_xe_utils13.default.clone(item.resetValue, true);
              }
            });
            if (filterResetMethod) {
              filterResetMethod({ options: filters, column, $table: $xetable });
            }
          }
        }
      },
      /**
       * 
       * 
       * @param {Event} evnt 
       */
      confirmFilterEvent(evnt) {
        const { mouseConfig } = props;
        const { filterStore, scrollXLoad: oldScrollXLoad, scrollYLoad: oldScrollYLoad } = reactData;
        const filterOpts = computeFilterOpts.value;
        const mouseOpts = computeMouseOpts.value;
        const { column } = filterStore;
        const { field } = column;
        const values = [];
        const datas = [];
        column.filters.forEach((item) => {
          if (item.checked) {
            values.push(item.value);
            datas.push(item.data);
          }
        });
        const filterList = $xetable.getCheckedFilters();
        const params = { $table: $xetable, $event: evnt, column, field, property: field, values, datas, filters: filterList, filterList };
        if (!filterOpts.remote) {
          $xetable.handleTableData(true);
          $xetable.checkSelectionStatus();
        }
        if (mouseConfig && mouseOpts.area && $xetable.handleFilterEvent) {
          $xetable.handleFilterEvent(evnt, params);
        }
        $xetable.dispatchEvent("filter-change", params, evnt);
        $xetable.closeFilter();
        $xetable.updateFooter().then(() => {
          const { scrollXLoad, scrollYLoad } = reactData;
          if (oldScrollXLoad || scrollXLoad || (oldScrollYLoad || scrollYLoad)) {
            if (oldScrollXLoad || scrollXLoad) {
              $xetable.updateScrollXSpace();
            }
            if (oldScrollYLoad || scrollYLoad) {
              $xetable.updateScrollYSpace();
            }
            return $xetable.refreshScroll();
          }
        }).then(() => {
          $xetable.updateCellAreas();
          return $xetable.recalculate(true);
        }).then(() => {
          setTimeout(() => $xetable.recalculate(), 50);
        });
      }
    };
    const filterMethods = {
      /**
       * 
       * @param column
       */
      openFilter(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column && column.filters) {
          const { elemStore } = internalData;
          const { fixed } = column;
          return $xetable.scrollToColumn(column).then(() => {
            const headerWrapperRef = elemStore[`${fixed || "main"}-header-wrapper`] || elemStore["main-header-wrapper"];
            const headerWrapperElem = headerWrapperRef ? headerWrapperRef.value : null;
            if (headerWrapperElem) {
              const filterBtnElem = headerWrapperElem.querySelector(`.vxe-header--column.${column.id} .vxe-filter--btn`);
              triggerEvent(filterBtnElem, "click");
            }
          });
        }
        return nextTick();
      },
      /**
       * 
       * @param {ColumnInfo} fieldOrColumn 
       * @param {Array} options 
       */
      setFilter(fieldOrColumn, options) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column && column.filters) {
          column.filters = toFilters(options || []);
        }
        return nextTick();
      },
      /**
       * 
       * 
       * @param {String} fieldOrColumn 
       */
      clearFilter(fieldOrColumn) {
        const { filterStore } = reactData;
        const { tableFullColumn } = internalData;
        const filterOpts = computeFilterOpts.value;
        let column;
        if (fieldOrColumn) {
          column = handleFieldOrColumn($xetable, fieldOrColumn);
          if (column) {
            filterPrivateMethods.handleClearFilter(column);
          }
        } else {
          tableFullColumn.forEach(filterPrivateMethods.handleClearFilter);
        }
        if (!fieldOrColumn || column !== filterStore.column) {
          Object.assign(filterStore, {
            isAllSelected: false,
            isIndeterminate: false,
            style: null,
            options: [],
            column: null,
            multiple: false,
            visible: false
          });
        }
        if (!filterOpts.remote) {
          return $xetable.updateData();
        }
        return nextTick();
      },
      getCheckedFilters() {
        const { tableFullColumn } = internalData;
        const filterList = [];
        tableFullColumn.forEach((column) => {
          const { field, filters } = column;
          const valueList = [];
          const dataList = [];
          if (filters && filters.length) {
            filters.forEach((item) => {
              if (item.checked) {
                valueList.push(item.value);
                dataList.push(item.data);
              }
            });
            if (valueList.length) {
              filterList.push({ column, field, property: field, values: valueList, datas: dataList });
            }
          }
        });
        return filterList;
      }
    };
    return Object.assign(Object.assign({}, filterMethods), filterPrivateMethods);
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableFilterMethodKeys);
  }
};
var hook_default = tableFilterHook;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/dynamics/index.js
var dynamicContainerElem;
var dynamicStore = reactive({
  modals: [],
  drawers: []
});
var VxeDynamics = defineComponent({
  setup() {
    return () => {
      const { modals, drawers } = dynamicStore;
      return [
        modals.length ? h("div", {
          class: "vxe-dynamics--modal"
        }, modals.map((item) => h(resolveComponent("vxe-modal"), item))) : createCommentVNode(),
        drawers.length ? h("div", {
          class: "vxe-dynamics--drawer"
        }, drawers.map((item) => h(resolveComponent("vxe-drawer"), item))) : createCommentVNode()
      ];
    };
  }
});
var dynamicApp = createApp(VxeDynamics);
function checkDynamic() {
  if (!dynamicContainerElem) {
    dynamicContainerElem = document.createElement("div");
    dynamicContainerElem.className = "vxe-dynamics";
    document.body.appendChild(dynamicContainerElem);
    dynamicApp.mount(dynamicContainerElem);
  }
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/filter/index.js
var VxeTableFilterModule = {
  Panel: panel_default,
  install(app) {
    VXETable.hooks.add("$tableFilter", hook_default);
    app.component(panel_default.name, panel_default);
  }
};
var Filter = VxeTableFilterModule;
dynamicApp.component(panel_default.name, panel_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/menu/src/panel.js
var import_xe_utils14 = __toESM(require_xe_utils());
var panel_default2 = defineComponent({
  name: "VxeTableMenuPanel",
  setup(props, context) {
    const xID = import_xe_utils14.default.uniqueId();
    const $xetable = inject("$xetable", {});
    const { reactData: tableReactData } = $xetable;
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xemenupanel = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const renderVN = () => {
      const { ctxMenuStore } = tableReactData;
      const { computeMenuOpts } = $xetable.getComputeMaps();
      const menuOpts = computeMenuOpts.value;
      return h(Teleport, {
        to: "body",
        disabled: false
      }, [
        h("div", {
          ref: refElem,
          class: ["vxe-table--context-menu-wrapper", menuOpts.className, {
            "is--visible": ctxMenuStore.visible
          }],
          style: ctxMenuStore.style
        }, ctxMenuStore.list.map((options, gIndex) => {
          return options.every((item) => item.visible === false) ? createCommentVNode() : h("ul", {
            class: "vxe-context-menu--option-wrapper",
            key: gIndex
          }, options.map((item, index) => {
            const hasChildMenus = item.children && item.children.some((child) => child.visible !== false);
            return item.visible === false ? null : h("li", {
              class: [item.className, {
                "link--disabled": item.disabled,
                "link--active": item === ctxMenuStore.selected
              }],
              key: `${gIndex}_${index}`
            }, [
              h("a", {
                class: "vxe-context-menu--link",
                onClick(evnt) {
                  $xetable.ctxMenuLinkEvent(evnt, item);
                },
                onMouseover(evnt) {
                  $xetable.ctxMenuMouseoverEvent(evnt, item);
                },
                onMouseout(evnt) {
                  $xetable.ctxMenuMouseoutEvent(evnt, item);
                }
              }, [
                h("i", {
                  class: ["vxe-context-menu--link-prefix", item.prefixIcon]
                }),
                h("span", {
                  class: "vxe-context-menu--link-content"
                }, getFuncText(item.name)),
                h("i", {
                  class: ["vxe-context-menu--link-suffix", hasChildMenus ? item.suffixIcon || "suffix--haschild" : item.suffixIcon]
                })
              ]),
              hasChildMenus ? h("ul", {
                class: ["vxe-table--context-menu-clild-wrapper", {
                  "is--show": item === ctxMenuStore.selected && ctxMenuStore.showChild
                }]
              }, item.children.map((child, cIndex) => {
                return child.visible === false ? null : h("li", {
                  class: [child.className, {
                    "link--disabled": child.disabled,
                    "link--active": child === ctxMenuStore.selectChild
                  }],
                  key: `${gIndex}_${index}_${cIndex}`
                }, [
                  h("a", {
                    class: "vxe-context-menu--link",
                    onClick(evnt) {
                      $xetable.ctxMenuLinkEvent(evnt, child);
                    },
                    onMouseover(evnt) {
                      $xetable.ctxMenuMouseoverEvent(evnt, item, child);
                    },
                    onMouseout(evnt) {
                      $xetable.ctxMenuMouseoutEvent(evnt, item);
                    }
                  }, [
                    h("i", {
                      class: ["vxe-context-menu--link-prefix", child.prefixIcon]
                    }),
                    h("span", {
                      class: "vxe-context-menu--link-content"
                    }, getFuncText(child.name))
                  ])
                ]);
              })) : null
            ]);
          }));
        }))
      ]);
    };
    $xemenupanel.renderVN = renderVN;
    return $xemenupanel;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/menu/src/hooks.js
var import_xe_utils16 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/tools/event.js
var import_xe_utils15 = __toESM(require_xe_utils());
var EVENT_KEYS = {
  F2: "F2",
  ESCAPE: "Escape",
  ENTER: "Enter",
  TAB: "Tab",
  DELETE: "Delete",
  BACKSPACE: "Backspace",
  SPACEBAR: " ",
  CONTEXT_MENU: "ContextMenu",
  ARROW_UP: "ArrowUp",
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown"
};
var convertEventKeys = {
  " ": "Spacebar",
  Apps: EVENT_KEYS.CONTEXT_MENU,
  Del: EVENT_KEYS.DELETE,
  Up: EVENT_KEYS.ARROW_UP,
  Down: EVENT_KEYS.ARROW_DOWN,
  Left: EVENT_KEYS.ARROW_LEFT,
  Right: EVENT_KEYS.ARROW_RIGHT
};
var wheelName = browse.firefox ? "DOMMouseScroll" : "mousewheel";
var eventStore = [];
var hasEventKey = (evnt, targetKey) => {
  const { key } = evnt;
  targetKey = targetKey.toLowerCase();
  return key ? targetKey === key.toLowerCase() || !!(convertEventKeys[key] && convertEventKeys[key].toLowerCase() === targetKey) : false;
};
function triggerEvent2(evnt) {
  const isWheel = evnt.type === wheelName;
  eventStore.forEach(({ type, cb }) => {
    if (!evnt.cancelBubble) {
      if (type === evnt.type || isWheel && type === "mousewheel") {
        cb(evnt);
      }
    }
  });
}
var GlobalEvent = {
  on(comp, type, cb) {
    eventStore.push({ comp, type, cb });
  },
  off(comp, type) {
    import_xe_utils15.default.remove(eventStore, (item) => item.comp === comp && item.type === type);
  },
  trigger: triggerEvent2,
  eqKeypad(evnt, keyVal) {
    const { key } = evnt;
    if (keyVal.toLowerCase() === key.toLowerCase()) {
      return true;
    }
    return false;
  }
};
if (browse.isDoc) {
  if (!browse.msie) {
    window.addEventListener("copy", triggerEvent2, false);
    window.addEventListener("cut", triggerEvent2, false);
    window.addEventListener("paste", triggerEvent2, false);
  }
  document.addEventListener("keydown", triggerEvent2, false);
  document.addEventListener("contextmenu", triggerEvent2, false);
  window.addEventListener("mousedown", triggerEvent2, false);
  window.addEventListener("blur", triggerEvent2, false);
  window.addEventListener("resize", triggerEvent2, false);
  window.addEventListener(wheelName, import_xe_utils15.default.throttle(triggerEvent2, 100, { leading: true, trailing: false }), { passive: true, capture: false });
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/menu/src/hooks.js
var tableMenuMethodKeys = ["closeMenu"];
var tableMenuHook = {
  setupTable($xetable) {
    const { xID, props, reactData, internalData } = $xetable;
    const { refElem, refTableFilter, refTableMenu } = $xetable.getRefMaps();
    const { computeMouseOpts, computeIsMenu, computeMenuOpts } = $xetable.getComputeMaps();
    let menuMethods = {};
    let menuPrivateMethods = {};
    const handleOpenMenuEvent = (evnt, type, params) => {
      const { ctxMenuStore } = reactData;
      const isMenu = computeIsMenu.value;
      const menuOpts = computeMenuOpts.value;
      const config2 = menuOpts[type];
      const visibleMethod = menuOpts.visibleMethod;
      if (config2) {
        const { options, disabled } = config2;
        if (disabled) {
          evnt.preventDefault();
        } else if (isMenu && options && options.length) {
          params.options = options;
          $xetable.preventEvent(evnt, "event.showMenu", params, () => {
            if (!visibleMethod || visibleMethod(params)) {
              evnt.preventDefault();
              $xetable.updateZindex();
              const { scrollTop, scrollLeft, visibleHeight, visibleWidth } = getDomNode();
              let top = evnt.clientY + scrollTop;
              let left = evnt.clientX + scrollLeft;
              const handleVisible = () => {
                internalData._currMenuParams = params;
                Object.assign(ctxMenuStore, {
                  visible: true,
                  list: options,
                  selected: null,
                  selectChild: null,
                  showChild: false,
                  style: {
                    zIndex: internalData.tZindex,
                    top: `${top}px`,
                    left: `${left}px`
                  }
                });
                nextTick(() => {
                  const tableMenu = refTableMenu.value;
                  const ctxElem = tableMenu.getRefMaps().refElem.value;
                  const clientHeight = ctxElem.clientHeight;
                  const clientWidth = ctxElem.clientWidth;
                  const { boundingTop, boundingLeft } = getAbsolutePos(ctxElem);
                  const offsetTop = boundingTop + clientHeight - visibleHeight;
                  const offsetLeft = boundingLeft + clientWidth - visibleWidth;
                  if (offsetTop > -10) {
                    ctxMenuStore.style.top = `${Math.max(scrollTop + 2, top - clientHeight - 2)}px`;
                  }
                  if (offsetLeft > -10) {
                    ctxMenuStore.style.left = `${Math.max(scrollLeft + 2, left - clientWidth - 2)}px`;
                  }
                });
              };
              const { keyboard, row, column } = params;
              if (keyboard && row && column) {
                $xetable.scrollToRow(row, column).then(() => {
                  const cell = $xetable.getCell(row, column);
                  if (cell) {
                    const { boundingTop, boundingLeft } = getAbsolutePos(cell);
                    top = boundingTop + scrollTop + Math.floor(cell.offsetHeight / 2);
                    left = boundingLeft + scrollLeft + Math.floor(cell.offsetWidth / 2);
                  }
                  handleVisible();
                });
              } else {
                handleVisible();
              }
            } else {
              menuMethods.closeMenu();
            }
          });
        }
      }
      $xetable.closeFilter();
    };
    menuMethods = {
      /**
       * 
       */
      closeMenu() {
        Object.assign(reactData.ctxMenuStore, {
          visible: false,
          selected: null,
          selectChild: null,
          showChild: false
        });
        return nextTick();
      }
    };
    menuPrivateMethods = {
      /**
       * 
       */
      moveCtxMenu(evnt, ctxMenuStore, property, hasOper, operRest, menuList) {
        let selectItem;
        const selectIndex = import_xe_utils16.default.findIndexOf(menuList, (item) => ctxMenuStore[property] === item);
        if (hasOper) {
          if (operRest && hasChildrenList(ctxMenuStore.selected)) {
            ctxMenuStore.showChild = true;
          } else {
            ctxMenuStore.showChild = false;
            ctxMenuStore.selectChild = null;
          }
        } else if (hasEventKey(evnt, EVENT_KEYS.ARROW_UP)) {
          for (let len = selectIndex - 1; len >= 0; len--) {
            if (menuList[len].visible !== false) {
              selectItem = menuList[len];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[menuList.length - 1];
        } else if (hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN)) {
          for (let index = selectIndex + 1; index < menuList.length; index++) {
            if (menuList[index].visible !== false) {
              selectItem = menuList[index];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[0];
        } else if (ctxMenuStore[property] && (hasEventKey(evnt, EVENT_KEYS.ENTER) || hasEventKey(evnt, EVENT_KEYS.SPACEBAR))) {
          menuPrivateMethods.ctxMenuLinkEvent(evnt, ctxMenuStore[property]);
        }
      },
      handleOpenMenuEvent,
      /**
       * 
       */
      handleGlobalContextmenuEvent(evnt) {
        const { mouseConfig, menuConfig } = props;
        const { editStore, ctxMenuStore } = reactData;
        const { visibleColumn } = internalData;
        const tableFilter = refTableFilter.value;
        const tableMenu = refTableMenu.value;
        const mouseOpts = computeMouseOpts.value;
        const menuOpts = computeMenuOpts.value;
        const el = refElem.value;
        const { selected } = editStore;
        const layoutList = ["header", "body", "footer"];
        if (isEnableConf(menuConfig)) {
          if (ctxMenuStore.visible && tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
            evnt.preventDefault();
            return;
          }
          if (internalData._keyCtx) {
            const type = "body";
            const params = { type, $table: $xetable, keyboard: true, columns: visibleColumn.slice(0), $event: evnt };
            if (mouseConfig && mouseOpts.area) {
              const activeArea = $xetable.getActiveCellArea();
              if (activeArea && activeArea.row && activeArea.column) {
                params.row = activeArea.row;
                params.column = activeArea.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            } else if (mouseConfig && mouseOpts.selected) {
              if (selected.row && selected.column) {
                params.row = selected.row;
                params.column = selected.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            }
          }
          for (let index = 0; index < layoutList.length; index++) {
            const layout = layoutList[index];
            const columnTargetNode = getEventTargetNode(evnt, el, `vxe-${layout}--column`, (target) => {
              return target.parentNode.parentNode.parentNode.getAttribute("xid") === xID;
            });
            const params = { type: layout, $table: $xetable, columns: visibleColumn.slice(0), $event: evnt };
            if (columnTargetNode.flag) {
              const cell = columnTargetNode.targetElem;
              const columnNodeRest = $xetable.getColumnNode(cell);
              const column = columnNodeRest ? columnNodeRest.item : null;
              let typePrefix = `${layout}-`;
              if (column) {
                Object.assign(params, { column, columnIndex: $xetable.getColumnIndex(column), cell });
              }
              if (layout === "body") {
                const rowNodeRest = $xetable.getRowNode(cell.parentNode);
                const row = rowNodeRest ? rowNodeRest.item : null;
                typePrefix = "";
                if (row) {
                  params.row = row;
                  params.rowIndex = $xetable.getRowIndex(row);
                }
              }
              const eventType = `${typePrefix}cell-menu`;
              handleOpenMenuEvent(evnt, layout, params);
              $xetable.dispatchEvent(eventType, params, evnt);
              return;
            } else if (getEventTargetNode(evnt, el, `vxe-table--${layout}-wrapper`, (target) => target.getAttribute("xid") === xID).flag) {
              if (menuOpts.trigger === "cell") {
                evnt.preventDefault();
              } else {
                handleOpenMenuEvent(evnt, layout, params);
              }
              return;
            }
          }
        }
        if (tableFilter && !getEventTargetNode(evnt, tableFilter.$el).flag) {
          $xetable.closeFilter();
        }
        menuMethods.closeMenu();
      },
      ctxMenuMouseoverEvent(evnt, item, child) {
        const menuElem = evnt.currentTarget;
        const { ctxMenuStore } = reactData;
        evnt.preventDefault();
        evnt.stopPropagation();
        ctxMenuStore.selected = item;
        ctxMenuStore.selectChild = child;
        if (!child) {
          ctxMenuStore.showChild = hasChildrenList(item);
          if (ctxMenuStore.showChild) {
            nextTick(() => {
              const childWrapperElem = menuElem.nextElementSibling;
              if (childWrapperElem) {
                const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(menuElem);
                const posTop = boundingTop + menuElem.offsetHeight;
                const posLeft = boundingLeft + menuElem.offsetWidth;
                let left = "";
                let right = "";
                if (posLeft + childWrapperElem.offsetWidth > visibleWidth - 10) {
                  left = "auto";
                  right = `${menuElem.offsetWidth}px`;
                }
                let top = "";
                let bottom = "";
                if (posTop + childWrapperElem.offsetHeight > visibleHeight - 10) {
                  top = "auto";
                  bottom = "0";
                }
                childWrapperElem.style.left = left;
                childWrapperElem.style.right = right;
                childWrapperElem.style.top = top;
                childWrapperElem.style.bottom = bottom;
              }
            });
          }
        }
      },
      ctxMenuMouseoutEvent(evnt, item) {
        const { ctxMenuStore } = reactData;
        if (!item.children) {
          ctxMenuStore.selected = null;
        }
        ctxMenuStore.selectChild = null;
      },
      /**
       * 
       */
      ctxMenuLinkEvent(evnt, menu) {
        if (!menu.disabled && (menu.code || !menu.children || !menu.children.length)) {
          const gMenuOpts = VXETable.menus.get(menu.code);
          const params = Object.assign({}, internalData._currMenuParams, { menu, $table: $xetable, $grid: $xetable.xegrid, $event: evnt });
          const tmMethod = gMenuOpts ? gMenuOpts.tableMenuMethod || gMenuOpts.menuMethod : null;
          if (tmMethod) {
            tmMethod(params, evnt);
          }
          $xetable.dispatchEvent("menu-click", params, evnt);
          menuMethods.closeMenu();
        }
      }
    };
    return Object.assign(Object.assign({}, menuMethods), menuPrivateMethods);
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableMenuMethodKeys);
  }
};
var hooks_default = tableMenuHook;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/menu/index.js
var VxeTableMenuModule = {
  Panel: panel_default2,
  install(app) {
    VXETable.hooks.add("$tableMenu", hooks_default);
    app.component(panel_default2.name, panel_default2);
  }
};
var Menu = VxeTableMenuModule;
dynamicApp.component(panel_default2.name, panel_default2);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/edit/src/hook.js
var import_xe_utils17 = __toESM(require_xe_utils());
var tableEditMethodKeys = ["insert", "insertAt", "insertNextAt", "remove", "removeCheckboxRow", "removeRadioRow", "removeCurrentRow", "getRecordset", "getInsertRecords", "getRemoveRecords", "getUpdateRecords", "getEditRecord", "getActiveRecord", "getSelectedCell", "clearEdit", "clearActived", "clearSelected", "isEditByRow", "isActiveByRow", "setEditRow", "setActiveRow", "setEditCell", "setActiveCell", "setSelectCell"];
var editHook = {
  setupTable($xetable) {
    const { props, reactData, internalData } = $xetable;
    const { refElem } = $xetable.getRefMaps();
    const { computeMouseOpts, computeEditOpts, computeCheckboxOpts, computeTreeOpts } = $xetable.getComputeMaps();
    let editMethods = {};
    let editPrivateMethods = {};
    const getEditColumnModel = (row, column) => {
      const { model, editRender } = column;
      if (editRender) {
        model.value = getCellValue(row, column);
        model.update = false;
      }
    };
    const setEditColumnModel = (row, column) => {
      const { model, editRender } = column;
      if (editRender && model.update) {
        setCellValue(row, column, model.value);
        model.update = false;
        model.value = null;
      }
    };
    const removeCellSelectedClass = () => {
      const el = refElem.value;
      if (el) {
        const cell = el.querySelector(".col--selected");
        if (cell) {
          removeClass(cell, "col--selected");
        }
      }
    };
    function syncActivedCell() {
      const { editStore, tableColumn } = reactData;
      const editOpts = computeEditOpts.value;
      const { actived } = editStore;
      const { row, column } = actived;
      if (row || column) {
        if (editOpts.mode === "row") {
          tableColumn.forEach((column2) => setEditColumnModel(row, column2));
        } else {
          setEditColumnModel(row, column);
        }
      }
    }
    function insertTreeRow(newRecords, isAppend) {
      const { tableFullTreeData, afterFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { rowField, parentField, mapChildrenField } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const funcName = isAppend ? "push" : "unshift";
      newRecords.forEach((item) => {
        const parentRowId = item[parentField];
        const rowid = getRowid($xetable, item);
        const matchObj = parentRowId ? import_xe_utils17.default.findTree(tableFullTreeData, (item2) => parentRowId === item2[rowField], { children: mapChildrenField }) : null;
        if (matchObj) {
          const { item: parentRow } = matchObj;
          const parentRest = fullAllDataRowIdData[getRowid($xetable, parentRow)];
          const parentLevel = parentRest ? parentRest.level : 0;
          let parentChilds = parentRow[childrenField];
          let mapChilds = parentRow[mapChildrenField];
          if (!import_xe_utils17.default.isArray(parentChilds)) {
            parentChilds = parentRow[childrenField] = [];
          }
          if (!import_xe_utils17.default.isArray(mapChilds)) {
            mapChilds = parentRow[childrenField] = [];
          }
          parentChilds[funcName](item);
          mapChilds[funcName](item);
          const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: parentChilds, parent: parentRow, level: parentLevel + 1 };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        } else {
          if (true) {
            if (parentRowId) {
              warnLog("vxe.error.unableInsert");
            }
          }
          afterFullData[funcName](item);
          tableFullTreeData[funcName](item);
          const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: tableFullTreeData, parent: null, level: 0 };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        }
      });
    }
    const handleInsertRowAt = (records, row, isInsertNextRow) => {
      const { treeConfig } = props;
      const { mergeList, editStore } = reactData;
      const { tableFullTreeData, afterFullData, tableFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { transform, rowField, mapChildrenField } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      if (!import_xe_utils17.default.isArray(records)) {
        records = [records];
      }
      const newRecords = reactive($xetable.defineField(records.map((record) => Object.assign(treeConfig && transform ? { [mapChildrenField]: [], [childrenField]: [] } : {}, record))));
      if (import_xe_utils17.default.eqNull(row)) {
        if (treeConfig && transform) {
          insertTreeRow(newRecords, false);
        } else {
          afterFullData.unshift(...newRecords);
          tableFullData.unshift(...newRecords);
          mergeList.forEach((mergeItem) => {
            const { row: mergeRowIndex } = mergeItem;
            if (mergeRowIndex > 0) {
              mergeItem.row = mergeRowIndex + newRecords.length;
            }
          });
        }
      } else {
        if (row === -1) {
          if (treeConfig && transform) {
            insertTreeRow(newRecords, true);
          } else {
            afterFullData.push(...newRecords);
            tableFullData.push(...newRecords);
            mergeList.forEach((mergeItem) => {
              const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
              if (mergeRowIndex + mergeRowspan > afterFullData.length) {
                mergeItem.rowspan = mergeRowspan + newRecords.length;
              }
            });
          }
        } else {
          if (treeConfig && transform) {
            const matchMapObj = import_xe_utils17.default.findTree(tableFullTreeData, (item) => row[rowField] === item[rowField], { children: mapChildrenField });
            if (matchMapObj) {
              const { parent: parentRow } = matchMapObj;
              const parentMapChilds = parentRow ? parentRow[mapChildrenField] : tableFullTreeData;
              const parentRest = fullAllDataRowIdData[getRowid($xetable, parentRow)];
              const parentLevel = parentRest ? parentRest.level : 0;
              newRecords.forEach((item, i) => {
                const rowid = getRowid($xetable, item);
                if (true) {
                  if (item[treeOpts.parentField]) {
                    if (parentRow && item[treeOpts.parentField] !== parentRow[rowField]) {
                      errLog("vxe.error.errProp", [`${treeOpts.parentField}=${item[treeOpts.parentField]}`, `${treeOpts.parentField}=${parentRow[rowField]}`]);
                    }
                  }
                }
                if (parentRow) {
                  item[treeOpts.parentField] = parentRow[rowField];
                }
                let targetIndex = matchMapObj.index + i;
                if (isInsertNextRow) {
                  targetIndex = targetIndex + 1;
                }
                parentMapChilds.splice(targetIndex, 0, item);
                const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: parentMapChilds, parent: parentRow, level: parentLevel + 1 };
                fullDataRowIdData[rowid] = rest;
                fullAllDataRowIdData[rowid] = rest;
              });
              if (parentRow) {
                const matchObj = import_xe_utils17.default.findTree(tableFullTreeData, (item) => row[rowField] === item[rowField], { children: childrenField });
                if (matchObj) {
                  const parentChilds = matchObj.items;
                  let targetIndex = matchObj.index;
                  if (isInsertNextRow) {
                    targetIndex = targetIndex + 1;
                  }
                  parentChilds.splice(targetIndex, 0, ...newRecords);
                }
              }
            } else {
              if (true) {
                warnLog("vxe.error.unableInsert");
              }
              insertTreeRow(newRecords, true);
            }
          } else {
            if (treeConfig) {
              throw new Error(getLog("vxe.error.noTree", ["insert"]));
            }
            let afIndex = -1;
            if (import_xe_utils17.default.isNumber(row)) {
              if (row < afterFullData.length) {
                afIndex = row;
              }
            } else {
              afIndex = $xetable.findRowIndexOf(afterFullData, row);
            }
            if (isInsertNextRow) {
              afIndex = Math.min(afterFullData.length, afIndex + 1);
            }
            if (afIndex === -1) {
              throw new Error(errLog("vxe.error.unableInsert"));
            }
            afterFullData.splice(afIndex, 0, ...newRecords);
            tableFullData.splice($xetable.findRowIndexOf(tableFullData, row), 0, ...newRecords);
            mergeList.forEach((mergeItem) => {
              const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
              if (mergeRowIndex > afIndex) {
                mergeItem.row = mergeRowIndex + newRecords.length;
              } else if (mergeRowIndex + mergeRowspan > afIndex) {
                mergeItem.rowspan = mergeRowspan + newRecords.length;
              }
            });
          }
        }
      }
      const { insertMaps } = editStore;
      newRecords.forEach((newRow) => {
        const rowid = getRowid($xetable, newRow);
        insertMaps[rowid] = newRow;
      });
      $xetable.cacheRowMap();
      $xetable.updateScrollYStatus();
      $xetable.handleTableData(treeConfig && transform);
      if (!(treeConfig && transform)) {
        $xetable.updateAfterDataIndex();
      }
      $xetable.updateFooter();
      $xetable.checkSelectionStatus();
      if (reactData.scrollYLoad) {
        $xetable.updateScrollYSpace();
      }
      return nextTick().then(() => {
        $xetable.updateCellAreas();
        return $xetable.recalculate();
      }).then(() => {
        return {
          row: newRecords.length ? newRecords[newRecords.length - 1] : null,
          rows: newRecords
        };
      });
    };
    editMethods = {
      /**
       * 
       *
       * @param {*} records
       */
      insert(records) {
        return handleInsertRowAt(records, null);
      },
      /**
       * 
       *  row 
       *  row  -1 
       *  row 
       * @param {Object/Array} records 
       * @param {Row} row 
       */
      insertAt(records, row) {
        return handleInsertRowAt(records, row);
      },
      insertNextAt(records, row) {
        return handleInsertRowAt(records, row, true);
      },
      /**
       * 
       *  row 
       *  rows 
       * 
       */
      remove(rows) {
        const { treeConfig } = props;
        const { mergeList, editStore, selectCheckboxMaps } = reactData;
        const { tableFullTreeData, afterFullData, tableFullData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const { actived, removeMaps, insertMaps } = editStore;
        const { checkField } = checkboxOpts;
        let delList = [];
        if (!rows) {
          rows = tableFullData;
        } else if (!import_xe_utils17.default.isArray(rows)) {
          rows = [rows];
        }
        rows.forEach((row) => {
          if (!$xetable.isInsertByRow(row)) {
            const rowid = getRowid($xetable, row);
            removeMaps[rowid] = row;
          }
        });
        if (!checkField) {
          const selectRowMaps = Object.assign({}, selectCheckboxMaps);
          rows.forEach((row) => {
            const rowid = getRowid($xetable, row);
            if (selectRowMaps[rowid]) {
              delete selectRowMaps[rowid];
            }
          });
          reactData.selectCheckboxMaps = selectRowMaps;
        }
        if (tableFullData === rows) {
          rows = delList = tableFullData.slice(0);
          internalData.tableFullData = [];
          internalData.afterFullData = [];
          $xetable.clearMergeCells();
        } else {
          if (treeConfig && transform) {
            rows.forEach((row) => {
              const rowid = getRowid($xetable, row);
              const matchMapObj = import_xe_utils17.default.findTree(tableFullTreeData, (item) => rowid === getRowid($xetable, item), { children: mapChildrenField });
              if (matchMapObj) {
                const rItems = matchMapObj.items.splice(matchMapObj.index, 1);
                delList.push(rItems[0]);
              }
              const matchObj = import_xe_utils17.default.findTree(tableFullTreeData, (item) => rowid === getRowid($xetable, item), { children: childrenField });
              if (matchObj) {
                matchObj.items.splice(matchObj.index, 1);
              }
              const afIndex = $xetable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                afterFullData.splice(afIndex, 1);
              }
            });
          } else {
            rows.forEach((row) => {
              const tfIndex = $xetable.findRowIndexOf(tableFullData, row);
              if (tfIndex > -1) {
                const rItems = tableFullData.splice(tfIndex, 1);
                delList.push(rItems[0]);
              }
              const afIndex = $xetable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                mergeList.forEach((mergeItem) => {
                  const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
                  if (mergeRowIndex > afIndex) {
                    mergeItem.row = mergeRowIndex - 1;
                  } else if (mergeRowIndex + mergeRowspan > afIndex) {
                    mergeItem.rowspan = mergeRowspan - 1;
                  }
                });
                afterFullData.splice(afIndex, 1);
              }
            });
          }
        }
        if (actived.row && $xetable.findRowIndexOf(rows, actived.row) > -1) {
          editMethods.clearEdit();
        }
        rows.forEach((row) => {
          const rowid = getRowid($xetable, row);
          if (insertMaps[rowid]) {
            delete insertMaps[rowid];
          }
        });
        $xetable.updateFooter();
        $xetable.cacheRowMap();
        $xetable.handleTableData(treeConfig && transform);
        if (!(treeConfig && transform)) {
          $xetable.updateAfterDataIndex();
        }
        $xetable.checkSelectionStatus();
        if (reactData.scrollYLoad) {
          $xetable.updateScrollYSpace();
        }
        return nextTick().then(() => {
          $xetable.updateCellAreas();
          return $xetable.recalculate();
        }).then(() => {
          return { row: delList.length ? delList[delList.length - 1] : null, rows: delList };
        });
      },
      /**
       * 
       */
      removeCheckboxRow() {
        return editMethods.remove($xetable.getCheckboxRecords()).then((params) => {
          $xetable.clearCheckboxRow();
          return params;
        });
      },
      /**
       * 
       */
      removeRadioRow() {
        const radioRecord = $xetable.getRadioRecord();
        return editMethods.remove(radioRecord || []).then((params) => {
          $xetable.clearRadioRow();
          return params;
        });
      },
      /**
       * 
       */
      removeCurrentRow() {
        const currentRecord = $xetable.getCurrentRecord();
        return editMethods.remove(currentRecord || []).then((params) => {
          $xetable.clearCurrentRow();
          return params;
        });
      },
      /**
       * 
       */
      getRecordset() {
        return {
          insertRecords: editMethods.getInsertRecords(),
          removeRecords: editMethods.getRemoveRecords(),
          updateRecords: editMethods.getUpdateRecords(),
          pendingRecords: $xetable.getPendingRecords()
        };
      },
      /**
       * 
       */
      getInsertRecords() {
        const { editStore } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const { insertMaps } = editStore;
        const insertRecords = [];
        import_xe_utils17.default.each(insertMaps, (row, rowid) => {
          if (fullAllDataRowIdData[rowid]) {
            insertRecords.push(row);
          }
        });
        return insertRecords;
      },
      /**
       * 
       */
      getRemoveRecords() {
        const { editStore } = reactData;
        const { removeMaps } = editStore;
        const removeRecords = [];
        import_xe_utils17.default.each(removeMaps, (row) => {
          removeRecords.push(row);
        });
        return removeRecords;
      },
      /**
       * 
       *  row 
       * 
       */
      getUpdateRecords() {
        const { keepSource, treeConfig } = props;
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        if (keepSource) {
          syncActivedCell();
          if (treeConfig) {
            return import_xe_utils17.default.filterTree(tableFullData, (row) => $xetable.isUpdateByRow(row), treeOpts);
          }
          return tableFullData.filter((row) => $xetable.isUpdateByRow(row));
        }
        return [];
      },
      getActiveRecord() {
        if (true) {
          warnLog("vxe.error.delFunc", ["getActiveRecord", "getEditRecord"]);
        }
        return this.getEditRecord();
      },
      getEditRecord() {
        const { editStore } = reactData;
        const { afterFullData } = internalData;
        const el = refElem.value;
        const { args, row } = editStore.actived;
        if (args && $xetable.findRowIndexOf(afterFullData, row) > -1 && el.querySelectorAll(".vxe-body--column.col--active").length) {
          return Object.assign({}, args);
        }
        return null;
      },
      /**
       * 
       */
      getSelectedCell() {
        const { editStore } = reactData;
        const { args, column } = editStore.selected;
        if (args && column) {
          return Object.assign({}, args);
        }
        return null;
      },
      clearActived(evnt) {
        if (true) {
          warnLog("vxe.error.delFunc", ["clearActived", "clearEdit"]);
        }
        return this.clearEdit(evnt);
      },
      /**
       * 
       */
      clearEdit(evnt) {
        const { editStore } = reactData;
        const { actived, focused } = editStore;
        const { row, column } = actived;
        if (row || column) {
          syncActivedCell();
          actived.args = null;
          actived.row = null;
          actived.column = null;
          $xetable.updateFooter();
          $xetable.dispatchEvent("edit-closed", {
            row,
            rowIndex: $xetable.getRowIndex(row),
            $rowIndex: $xetable.getVMRowIndex(row),
            column,
            columnIndex: $xetable.getColumnIndex(column),
            $columnIndex: $xetable.getVMColumnIndex(column)
          }, evnt || null);
        }
        if (conf_default.cellVaildMode === "obsolete") {
          if ($xetable.clearValidate) {
            return $xetable.clearValidate();
          }
        }
        focused.row = null;
        focused.column = null;
        return nextTick();
      },
      /**
       * 
       */
      clearSelected() {
        const { editStore } = reactData;
        const { selected } = editStore;
        selected.row = null;
        selected.column = null;
        removeCellSelectedClass();
        return nextTick();
      },
      isActiveByRow(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["isActiveByRow", "isEditByRow"]);
        }
        return this.isEditByRow(row);
      },
      /**
       * 
       * @param {Row} row 
       */
      isEditByRow(row) {
        const { editStore } = reactData;
        return editStore.actived.row === row;
      },
      setActiveRow(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["setActiveRow", "setEditRow"]);
        }
        return editMethods.setEditRow(row);
      },
      /**
       * 
       */
      setEditRow(row, fieldOrColumn) {
        const { visibleColumn } = internalData;
        let column = import_xe_utils17.default.find(visibleColumn, (column2) => isEnableConf(column2.editRender));
        if (fieldOrColumn) {
          column = import_xe_utils17.default.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        }
        return $xetable.setEditCell(row, column);
      },
      setActiveCell(row, fieldOrColumn) {
        if (true) {
          warnLog("vxe.error.delFunc", ["setActiveCell", "setEditCell"]);
        }
        return editMethods.setEditCell(row, fieldOrColumn);
      },
      /**
       * 
       */
      setEditCell(row, fieldOrColumn) {
        const { editConfig } = props;
        const column = import_xe_utils17.default.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        if (row && column && isEnableConf(editConfig) && isEnableConf(column.editRender)) {
          return $xetable.scrollToRow(row, column).then(() => {
            const cell = $xetable.getCell(row, column);
            if (cell) {
              editPrivateMethods.handleActived({
                row,
                rowIndex: $xetable.getRowIndex(row),
                column,
                columnIndex: $xetable.getColumnIndex(column),
                cell,
                $table: $xetable
              });
              internalData._lastCallTime = Date.now();
            }
            return nextTick();
          });
        }
        return nextTick();
      },
      /**
       *  trigger=dblclick 
       */
      setSelectCell(row, fieldOrColumn) {
        const { tableData } = reactData;
        const editOpts = computeEditOpts.value;
        const column = import_xe_utils17.default.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        if (row && column && editOpts.trigger !== "manual") {
          const rowIndex = $xetable.findRowIndexOf(tableData, row);
          if (rowIndex > -1 && column) {
            const cell = $xetable.getCell(row, column);
            const params = {
              row,
              rowIndex,
              column,
              columnIndex: $xetable.getColumnIndex(column),
              cell
            };
            $xetable.handleSelected(params, {});
          }
        }
        return nextTick();
      }
    };
    editPrivateMethods = {
      /**
       * 
       */
      handleActived(params, evnt) {
        const { editConfig, mouseConfig } = props;
        const { editStore, tableColumn } = reactData;
        const editOpts = computeEditOpts.value;
        const { mode } = editOpts;
        const { actived, focused } = editStore;
        const { row, column } = params;
        const { editRender } = column;
        const cell = params.cell || $xetable.getCell(row, column);
        const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
        params.cell = cell;
        if (cell && isEnableConf(editConfig) && isEnableConf(editRender)) {
          if (!$xetable.hasPendingByRow(row)) {
            if (actived.row !== row || (mode === "cell" ? actived.column !== column : false)) {
              let type = "edit-disabled";
              if (!beforeEditMethod || beforeEditMethod(Object.assign(Object.assign({}, params), { $table: $xetable, $grid: $xetable.xegrid }))) {
                if (mouseConfig) {
                  editMethods.clearSelected();
                  if ($xetable.clearCellAreas) {
                    $xetable.clearCellAreas();
                    $xetable.clearCopyCellArea();
                  }
                }
                $xetable.closeTooltip();
                if (actived.column) {
                  editMethods.clearEdit(evnt);
                }
                type = "edit-activated";
                column.renderHeight = cell.offsetHeight;
                actived.args = params;
                actived.row = row;
                actived.column = column;
                if (mode === "row") {
                  tableColumn.forEach((column2) => getEditColumnModel(row, column2));
                } else {
                  getEditColumnModel(row, column);
                }
                const afterEditMethod = editOpts.afterEditMethod;
                nextTick(() => {
                  editPrivateMethods.handleFocus(params, evnt);
                  if (afterEditMethod) {
                    afterEditMethod(Object.assign(Object.assign({}, params), { $table: $xetable, $grid: $xetable.xegrid }));
                  }
                });
              }
              $xetable.dispatchEvent(type, {
                row,
                rowIndex: $xetable.getRowIndex(row),
                $rowIndex: $xetable.getVMRowIndex(row),
                column,
                columnIndex: $xetable.getColumnIndex(column),
                $columnIndex: $xetable.getVMColumnIndex(column)
              }, evnt);
              if (type === "edit-activated") {
                $xetable.dispatchEvent("edit-actived", {
                  row,
                  rowIndex: $xetable.getRowIndex(row),
                  $rowIndex: $xetable.getVMRowIndex(row),
                  column,
                  columnIndex: $xetable.getColumnIndex(column),
                  $columnIndex: $xetable.getVMColumnIndex(column)
                }, evnt);
              }
            } else {
              const { column: oldColumn } = actived;
              if (mouseConfig) {
                editMethods.clearSelected();
                if ($xetable.clearCellAreas) {
                  $xetable.clearCellAreas();
                  $xetable.clearCopyCellArea();
                }
              }
              if (oldColumn !== column) {
                const { model: oldModel } = oldColumn;
                if (oldModel.update) {
                  setCellValue(row, oldColumn, oldModel.value);
                }
                if ($xetable.clearValidate) {
                  $xetable.clearValidate(row, column);
                }
              }
              column.renderHeight = cell.offsetHeight;
              actived.args = params;
              actived.column = column;
              setTimeout(() => {
                editPrivateMethods.handleFocus(params, evnt);
              });
            }
            focused.column = null;
            focused.row = null;
            $xetable.focus();
          }
        }
        return nextTick();
      },
      /**
       * 
       */
      handleFocus(params) {
        const { row, column, cell } = params;
        const { editRender } = column;
        if (isEnableConf(editRender)) {
          const compRender = renderer.get(editRender.name);
          let { autofocus, autoselect } = editRender;
          let inputElem;
          if (!autofocus && compRender) {
            autofocus = compRender.autofocus;
          }
          if (!autoselect && compRender) {
            autoselect = compRender.autoselect;
          }
          if (import_xe_utils17.default.isFunction(autofocus)) {
            inputElem = autofocus.call(this, params);
          } else if (autofocus) {
            if (autofocus === true) {
              inputElem = cell.querySelector("input,textarea");
            } else {
              inputElem = cell.querySelector(autofocus);
            }
            if (inputElem) {
              inputElem.focus();
            }
          }
          if (inputElem) {
            if (autoselect) {
              inputElem.select();
            } else {
              if (browse.msie) {
                const textRange = inputElem.createTextRange();
                textRange.collapse(false);
                textRange.select();
              }
            }
          } else {
            $xetable.scrollToRow(row, column);
          }
        }
      },
      /**
       * 
       */
      handleSelected(params, evnt) {
        const { mouseConfig } = props;
        const { editStore } = reactData;
        const mouseOpts = computeMouseOpts.value;
        const editOpts = computeEditOpts.value;
        const { actived, selected } = editStore;
        const { row, column } = params;
        const isMouseSelected = mouseConfig && mouseOpts.selected;
        const selectMethod = () => {
          if (isMouseSelected && (selected.row !== row || selected.column !== column)) {
            if (actived.row !== row || (editOpts.mode === "cell" ? actived.column !== column : false)) {
              editMethods.clearEdit(evnt);
              editMethods.clearSelected();
              if ($xetable.clearCellAreas) {
                $xetable.clearCellAreas();
                $xetable.clearCopyCellArea();
              }
              selected.args = params;
              selected.row = row;
              selected.column = column;
              if (isMouseSelected) {
                editPrivateMethods.addCellSelectedClass();
              }
              $xetable.focus();
              if (evnt) {
                $xetable.dispatchEvent("cell-selected", params, evnt);
              }
            }
          }
          return nextTick();
        };
        return selectMethod();
      },
      addCellSelectedClass() {
        const { editStore } = reactData;
        const { selected } = editStore;
        const { row, column } = selected;
        removeCellSelectedClass();
        if (row && column) {
          const cell = $xetable.getCell(row, column);
          if (cell) {
            addClass(cell, "col--selected");
          }
        }
      }
    };
    return Object.assign(Object.assign({}, editMethods), editPrivateMethods);
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableEditMethodKeys);
  }
};
var hook_default2 = editHook;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/edit/index.js
var VxeTableEditModule = {
  install() {
    VXETable.hooks.add("$tableEdit", hook_default2);
  }
};
var Edit = VxeTableEditModule;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/export/src/export-panel.js
var import_xe_utils25 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/modal/src/modal.js
var import_xe_utils19 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/hooks/size.js
function useSize(props) {
  const xesize = inject("xesize", null);
  const computeSize = computed(() => {
    return props.size || (xesize ? xesize.value : null);
  });
  provide("xesize", computeSize);
  return computeSize;
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/button/src/button.js
var import_xe_utils18 = __toESM(require_xe_utils());
var button_default = defineComponent({
  name: "VxeButton",
  props: {
    /**
     * 
     */
    type: String,
    mode: String,
    className: [String, Function],
    popupClassName: [String, Function],
    /**
     * 
     */
    size: { type: String, default: () => conf_default.button.size || conf_default.size },
    /**
     * 
     */
    name: [String, Number],
    /**
     * 
     */
    content: String,
    /**
     * 
     */
    placement: String,
    /**
     * 
     */
    status: String,
    /**
     * 
     */
    title: String,
    /**
     * 
     */
    icon: String,
    /**
     * 
     */
    round: Boolean,
    /**
     * 
     */
    circle: Boolean,
    /**
     * 
     */
    disabled: Boolean,
    /**
     * 
     */
    loading: Boolean,
    /**
     * 
     */
    destroyOnClose: Boolean,
    /**
     *  body 
     */
    transfer: { type: Boolean, default: () => conf_default.button.transfer }
  },
  emits: [
    "click",
    "mouseenter",
    "mouseleave",
    "dropdown-click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils18.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      inited: false,
      showPanel: false,
      animatVisible: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: ""
    });
    const internalData = {
      showTime: null
    };
    const refElem = ref();
    const refButton = ref();
    const refBtnPanel = ref();
    const refMaps = {
      refElem
    };
    const $xebutton = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const $xebuttonggroup = inject("$xebuttongroup", null);
    let buttonMethods = {};
    const computeIsFormBtn = computed(() => {
      const { type } = props;
      if (type) {
        return ["submit", "reset", "button"].indexOf(type) > -1;
      }
      return false;
    });
    const computeBtnMode = computed(() => {
      const { type, mode } = props;
      if (mode === "text" || type === "text" || $xebuttonggroup && $xebuttonggroup.props.mode === "text") {
        return "text";
      }
      return "button";
    });
    const computeBtnStatus = computed(() => {
      const { status } = props;
      if (status) {
        return status;
      }
      if ($xebuttonggroup) {
        return $xebuttonggroup.props.status;
      }
      return "";
    });
    const computeBtnRound = computed(() => {
      const { round } = props;
      if (round) {
        return round;
      }
      if ($xebuttonggroup) {
        return $xebuttonggroup.props.round;
      }
      return false;
    });
    const computeBtnCircle = computed(() => {
      const { circle } = props;
      if (circle) {
        return circle;
      }
      if ($xebuttonggroup) {
        return $xebuttonggroup.props.circle;
      }
      return false;
    });
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { transfer, placement } = props;
        const { panelIndex } = reactData;
        const targetElem = refButton.value;
        const panelElem = refBtnPanel.value;
        if (panelElem && targetElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { top, left, boundingTop, visibleHeight, visibleWidth } = getAbsolutePos(targetElem);
          let panelPlacement = "bottom";
          if (transfer) {
            let btnLeft = left + targetWidth - panelWidth;
            let btnTop = top + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              btnTop = top - panelHeight;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                btnTop = top - panelHeight;
              }
              if (btnTop < marginSize) {
                panelPlacement = "bottom";
                btnTop = top + targetHeight;
              }
            }
            if (btnLeft + panelWidth + marginSize > visibleWidth) {
              btnLeft -= btnLeft + panelWidth + marginSize - visibleWidth;
            }
            if (btnLeft < marginSize) {
              btnLeft = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${btnLeft}px`,
              right: "auto",
              top: `${btnTop}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const clickEvent = (evnt) => {
      if ($xebuttonggroup) {
        $xebuttonggroup.handleClick({ name: props.name }, evnt);
      } else {
        buttonMethods.dispatchEvent("click", { $event: evnt }, evnt);
      }
    };
    const mousedownDropdownEvent = (evnt) => {
      const isLeftBtn = evnt.button === 0;
      if (isLeftBtn) {
        evnt.stopPropagation();
      }
    };
    const clickDropdownEvent = (evnt) => {
      const dropdownElem = evnt.currentTarget;
      const panelElem = refBtnPanel.value;
      const { flag, targetElem } = getEventTargetNode(evnt, dropdownElem, "vxe-button");
      if (flag) {
        if (panelElem) {
          panelElem.dataset.active = "N";
        }
        reactData.showPanel = false;
        setTimeout(() => {
          if (!panelElem || panelElem.dataset.active !== "Y") {
            reactData.animatVisible = false;
          }
        }, 350);
        buttonMethods.dispatchEvent("dropdown-click", { name: targetElem.getAttribute("name"), $event: evnt }, evnt);
      }
    };
    const mouseenterDropdownEvent = () => {
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = "Y";
        reactData.animatVisible = true;
        setTimeout(() => {
          if (panelElem.dataset.active === "Y") {
            reactData.showPanel = true;
            updateZindex();
            updatePlacement();
            setTimeout(() => {
              if (reactData.showPanel) {
                updatePlacement();
              }
            }, 50);
          }
        }, 20);
      }
    };
    const mouseenterTargetEvent = (evnt) => {
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = "Y";
        if (!reactData.inited) {
          reactData.inited = true;
        }
        internalData.showTime = setTimeout(() => {
          if (panelElem.dataset.active === "Y") {
            mouseenterDropdownEvent();
          } else {
            reactData.animatVisible = false;
          }
        }, 250);
      }
      mouseenterEvent(evnt);
    };
    const mouseleaveTargetEvent = (evnt) => {
      closePanel();
      mouseleaveEvent(evnt);
    };
    const mouseenterEvent = (evnt) => {
      emit("mouseenter", { $event: evnt });
    };
    const mouseleaveEvent = (evnt) => {
      emit("mouseleave", { $event: evnt });
    };
    const closePanel = () => {
      const panelElem = refBtnPanel.value;
      clearTimeout(internalData.showTime);
      if (panelElem) {
        panelElem.dataset.active = "N";
        setTimeout(() => {
          if (panelElem.dataset.active !== "Y") {
            reactData.showPanel = false;
            setTimeout(() => {
              if (panelElem.dataset.active !== "Y") {
                reactData.animatVisible = false;
              }
            }, 350);
          }
        }, 100);
      } else {
        reactData.animatVisible = false;
        reactData.showPanel = false;
      }
    };
    const mouseleaveDropdownEvent = () => {
      closePanel();
    };
    const renderContent = () => {
      const { content, icon, loading } = props;
      const contVNs = [];
      if (loading) {
        contVNs.push(h("i", {
          class: ["vxe-button--loading-icon", conf_default.icon.BUTTON_LOADING]
        }));
      } else if (slots.icon) {
        contVNs.push(h("span", {
          class: "vxe-button--custom-icon"
        }, slots.icon({})));
      } else if (icon) {
        contVNs.push(h("i", {
          class: ["vxe-button--icon", icon]
        }));
      }
      if (slots.default) {
        contVNs.push(h("span", {
          class: "vxe-button--content"
        }, slots.default({})));
      } else if (content) {
        contVNs.push(h("span", {
          class: "vxe-button--content"
        }, getFuncText(content)));
      }
      return contVNs;
    };
    buttonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $button: $xebutton, $event: evnt }, params));
      },
      focus() {
        const btnElem = refButton.value;
        btnElem.focus();
        return nextTick();
      },
      blur() {
        const btnElem = refButton.value;
        btnElem.blur();
        return nextTick();
      }
    };
    Object.assign($xebutton, buttonMethods);
    onMounted(() => {
      GlobalEvent.on($xebutton, "mousewheel", (evnt) => {
        const panelElem = refBtnPanel.value;
        if (reactData.showPanel && !getEventTargetNode(evnt, panelElem).flag) {
          closePanel();
        }
      });
    });
    onUnmounted(() => {
      GlobalEvent.off($xebutton, "mousewheel");
    });
    const renderVN = () => {
      const { className, popupClassName, transfer, title, type, destroyOnClose, name, disabled, loading } = props;
      const { inited, showPanel } = reactData;
      const isFormBtn = computeIsFormBtn.value;
      const btnMode = computeBtnMode.value;
      const btnStatus = computeBtnStatus.value;
      const btnRound = computeBtnRound.value;
      const btnCircle = computeBtnCircle.value;
      const vSize = computeSize.value;
      if (slots.dropdowns) {
        return h("div", {
          ref: refElem,
          class: ["vxe-button--dropdown", className ? import_xe_utils18.default.isFunction(className) ? className({ $button: $xebutton }) : className : "", {
            [`size--${vSize}`]: vSize,
            "is--active": showPanel
          }]
        }, [
          h("button", {
            ref: refButton,
            class: ["vxe-button", `type--${btnMode}`, {
              [`size--${vSize}`]: vSize,
              [`theme--${btnStatus}`]: btnStatus,
              "is--round": btnRound,
              "is--circle": btnCircle,
              "is--disabled": disabled || loading,
              "is--loading": loading
            }],
            title,
            name,
            type: isFormBtn ? type : "button",
            disabled: disabled || loading,
            onMouseenter: mouseenterTargetEvent,
            onMouseleave: mouseleaveTargetEvent,
            onClick: clickEvent
          }, renderContent().concat([
            h("i", {
              class: `vxe-button--dropdown-arrow ${conf_default.icon.BUTTON_DROPDOWN}`
            })
          ])),
          h(Teleport, {
            to: "body",
            disabled: transfer ? !inited : true
          }, [
            h("div", {
              ref: refBtnPanel,
              class: ["vxe-button--dropdown-panel", popupClassName ? import_xe_utils18.default.isFunction(popupClassName) ? popupClassName({ $button: $xebutton }) : popupClassName : "", {
                [`size--${vSize}`]: vSize,
                "animat--leave": reactData.animatVisible,
                "animat--enter": showPanel
              }],
              placement: reactData.panelPlacement,
              style: reactData.panelStyle
            }, inited ? [
              h("div", {
                class: "vxe-button--dropdown-wrapper",
                onMousedown: mousedownDropdownEvent,
                onClick: clickDropdownEvent,
                onMouseenter: mouseenterDropdownEvent,
                onMouseleave: mouseleaveDropdownEvent
              }, destroyOnClose && !showPanel ? [] : slots.dropdowns({}))
            ] : [])
          ])
        ]);
      }
      return h("button", {
        ref: refButton,
        class: ["vxe-button", `type--${btnMode}`, className ? import_xe_utils18.default.isFunction(className) ? className({ $button: $xebutton }) : className : "", {
          [`size--${vSize}`]: vSize,
          [`theme--${btnStatus}`]: btnStatus,
          "is--round": btnRound,
          "is--circle": btnCircle,
          "is--disabled": disabled || loading,
          "is--loading": loading
        }],
        title,
        name,
        type: isFormBtn ? type : "button",
        disabled: disabled || loading,
        onClick: clickEvent,
        onMouseenter: mouseenterEvent,
        onMouseleave: mouseleaveEvent
      }, renderContent());
    };
    $xebutton.renderVN = renderVN;
    return $xebutton;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/loading/src/loading.js
var loading_default = defineComponent({
  name: "VxeLoading",
  props: {
    modelValue: Boolean,
    icon: String,
    text: String
  },
  setup(props, { slots }) {
    const computeLoadingIcon = computed(() => {
      return props.icon || conf_default.icon.LOADING;
    });
    const computeLoadingText = computed(() => {
      const loadingText = conf_default.loadingText;
      return props.text || (loadingText === null ? loadingText : conf_default.i18n("vxe.loading.text"));
    });
    return () => {
      const loadingIcon = computeLoadingIcon.value;
      const loadingText = computeLoadingText.value;
      return h("div", {
        class: ["vxe-loading", {
          "is--visible": props.modelValue
        }]
      }, slots.default ? [
        h("div", {
          class: "vxe-loading--wrapper"
        }, slots.default({}))
      ] : [
        h("div", {
          class: "vxe-loading--chunk"
        }, [
          loadingIcon ? h("i", {
            class: loadingIcon
          }) : h("div", {
            class: "vxe-loading--spinner"
          }),
          loadingText ? h("div", {
            class: "vxe-loading--text"
          }, `${loadingText}`) : null
        ])
      ]);
    };
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/loading/index.js
var VxeLoading = Object.assign(loading_default, {
  install(app) {
    app.component(loading_default.name, loading_default);
  }
});
var loading_default2 = VxeLoading;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/modal/src/modal.js
var allActiveModals = [];
var msgQueue = [];
var modal_default = defineComponent({
  name: "VxeModal",
  props: {
    modelValue: Boolean,
    id: String,
    type: { type: String, default: "modal" },
    loading: { type: Boolean, default: null },
    status: String,
    iconStatus: String,
    className: String,
    top: { type: [Number, String], default: () => conf_default.modal.top },
    position: [String, Object],
    title: String,
    duration: { type: [Number, String], default: () => conf_default.modal.duration },
    message: [Number, String],
    content: [Number, String],
    showCancelButton: { type: Boolean, default: null },
    cancelButtonText: { type: String, default: () => conf_default.modal.cancelButtonText },
    showConfirmButton: { type: Boolean, default: () => conf_default.modal.showConfirmButton },
    confirmButtonText: { type: String, default: () => conf_default.modal.confirmButtonText },
    lockView: { type: Boolean, default: () => conf_default.modal.lockView },
    lockScroll: Boolean,
    mask: { type: Boolean, default: () => conf_default.modal.mask },
    maskClosable: { type: Boolean, default: () => conf_default.modal.maskClosable },
    escClosable: { type: Boolean, default: () => conf_default.modal.escClosable },
    resize: Boolean,
    showHeader: { type: Boolean, default: () => conf_default.modal.showHeader },
    showFooter: { type: Boolean, default: () => conf_default.modal.showFooter },
    showZoom: Boolean,
    showClose: { type: Boolean, default: () => conf_default.modal.showClose },
    dblclickZoom: { type: Boolean, default: () => conf_default.modal.dblclickZoom },
    width: [Number, String],
    height: [Number, String],
    minWidth: { type: [Number, String], default: () => conf_default.modal.minWidth },
    minHeight: { type: [Number, String], default: () => conf_default.modal.minHeight },
    zIndex: Number,
    marginSize: { type: [Number, String], default: () => conf_default.modal.marginSize },
    fullscreen: Boolean,
    draggable: { type: Boolean, default: () => conf_default.modal.draggable },
    remember: { type: Boolean, default: () => conf_default.modal.remember },
    destroyOnClose: { type: Boolean, default: () => conf_default.modal.destroyOnClose },
    showTitleOverflow: { type: Boolean, default: () => conf_default.modal.showTitleOverflow },
    transfer: { type: Boolean, default: () => conf_default.modal.transfer },
    storage: { type: Boolean, default: () => conf_default.modal.storage },
    storageKey: { type: String, default: () => conf_default.modal.storageKey },
    animat: { type: Boolean, default: () => conf_default.modal.animat },
    size: { type: String, default: () => conf_default.modal.size || conf_default.size },
    beforeHideMethod: { type: Function, default: () => conf_default.modal.beforeHideMethod },
    slots: Object
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel",
    "zoom",
    "resize",
    "move"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils19.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      inited: false,
      visible: false,
      contentVisible: false,
      modalTop: 0,
      modalZindex: 0,
      zoomLocat: null,
      firstOpen: true
    });
    const refElem = ref();
    const refModalBox = ref();
    const refConfirmBtn = ref();
    const refCancelBtn = ref();
    const refMaps = {
      refElem
    };
    const $xemodal = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let modalMethods = {};
    const computeIsMsg = computed(() => {
      return props.type === "message";
    });
    const getBox = () => {
      const boxElem = refModalBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const { width, height } = props;
      const boxElem = getBox();
      boxElem.style.width = `${width ? isNaN(width) ? width : `${width}px` : ""}`;
      boxElem.style.height = `${height ? isNaN(height) ? height : `${height}px` : ""}`;
      return nextTick();
    };
    const updateZindex = () => {
      const { zIndex } = props;
      const { modalZindex } = reactData;
      if (zIndex) {
        reactData.modalZindex = zIndex;
      } else if (modalZindex < getLastZIndex()) {
        reactData.modalZindex = nextZIndex();
      }
    };
    const updatePosition = () => {
      return nextTick().then(() => {
        const { position } = props;
        const marginSize = import_xe_utils19.default.toNumber(props.marginSize);
        const boxElem = getBox();
        const clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;
        const clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;
        const isPosCenter = position === "center";
        const { top, left } = import_xe_utils19.default.isString(position) ? { top: position, left: position } : Object.assign({}, position);
        const topCenter = isPosCenter || top === "center";
        const leftCenter = isPosCenter || left === "center";
        let posTop = "";
        let posLeft = "";
        if (left && !leftCenter) {
          posLeft = isNaN(left) ? left : `${left}px`;
        } else {
          posLeft = `${Math.max(marginSize, clientVisibleWidth / 2 - boxElem.offsetWidth / 2)}px`;
        }
        if (top && !topCenter) {
          posTop = isNaN(top) ? top : `${top}px`;
        } else {
          posTop = `${Math.max(marginSize, clientVisibleHeight / 2 - boxElem.offsetHeight / 2)}px`;
        }
        boxElem.style.top = posTop;
        boxElem.style.left = posLeft;
      });
    };
    const updateStyle = () => {
      nextTick(() => {
        let offsetTop = 0;
        msgQueue.forEach((comp) => {
          const boxElem = comp.getBox();
          offsetTop += import_xe_utils19.default.toNumber(comp.props.top);
          comp.reactData.modalTop = offsetTop;
          offsetTop += boxElem.clientHeight;
        });
      });
    };
    const removeMsgQueue = () => {
      if (msgQueue.indexOf($xemodal) > -1) {
        import_xe_utils19.default.remove(msgQueue, (comp) => comp === $xemodal);
      }
      updateStyle();
    };
    const closeModal2 = (type) => {
      const { remember, beforeHideMethod } = props;
      const { visible } = reactData;
      const isMsg = computeIsMsg.value;
      const params = { type };
      if (visible) {
        Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then((rest) => {
          if (!import_xe_utils19.default.isError(rest)) {
            if (isMsg) {
              removeMsgQueue();
            }
            reactData.contentVisible = false;
            if (!remember) {
              reactData.zoomLocat = null;
            }
            import_xe_utils19.default.remove(allActiveModals, (item) => item === $xemodal);
            modalMethods.dispatchEvent("before-hide", params);
            setTimeout(() => {
              reactData.visible = false;
              emit("update:modelValue", false);
              modalMethods.dispatchEvent("hide", params);
            }, 200);
          }
        }).catch((e) => e);
      }
      return nextTick();
    };
    const closeEvent = (evnt) => {
      const type = "close";
      modalMethods.dispatchEvent(type, { type }, evnt);
      closeModal2(type);
    };
    const confirmEvent = (evnt) => {
      const type = "confirm";
      modalMethods.dispatchEvent(type, { type }, evnt);
      closeModal2(type);
    };
    const cancelEvent = (evnt) => {
      const type = "cancel";
      modalMethods.dispatchEvent(type, { type }, evnt);
      closeModal2(type);
    };
    const getStorageMap = (key) => {
      const version2 = conf_default.version;
      const rest = import_xe_utils19.default.toStringJSON(localStorage.getItem(key) || "");
      return rest && rest._v === version2 ? rest : { _v: version2 };
    };
    const hasPosStorage = () => {
      const { id, remember, storage, storageKey } = props;
      return !!(id && remember && storage && getStorageMap(storageKey)[id]);
    };
    const restorePosStorage = () => {
      const { id, remember, storage, storageKey } = props;
      if (id && remember && storage) {
        const posStorage = getStorageMap(storageKey)[id];
        if (posStorage) {
          const boxElem = getBox();
          const [left, top, width, height, zoomLeft, zoomTop, zoomWidth, zoomHeight] = posStorage.split(",");
          if (left) {
            boxElem.style.left = `${left}px`;
          }
          if (top) {
            boxElem.style.top = `${top}px`;
          }
          if (width) {
            boxElem.style.width = `${width}px`;
          }
          if (height) {
            boxElem.style.height = `${height}px`;
          }
          if (zoomLeft && zoomTop) {
            reactData.zoomLocat = {
              left: zoomLeft,
              top: zoomTop,
              width: zoomWidth,
              height: zoomHeight
            };
          }
        }
      }
    };
    const addMsgQueue = () => {
      if (msgQueue.indexOf($xemodal) === -1) {
        msgQueue.push($xemodal);
      }
      updateStyle();
    };
    const savePosStorage = () => {
      const { id, remember, storage, storageKey } = props;
      const { zoomLocat } = reactData;
      if (id && remember && storage) {
        const boxElem = getBox();
        const posStorageMap = getStorageMap(storageKey);
        posStorageMap[id] = [
          boxElem.style.left,
          boxElem.style.top,
          boxElem.style.width,
          boxElem.style.height
        ].concat(zoomLocat ? [
          zoomLocat.left,
          zoomLocat.top,
          zoomLocat.width,
          zoomLocat.height
        ] : []).map((val) => val ? import_xe_utils19.default.toNumber(val) : "").join(",");
        localStorage.setItem(storageKey, import_xe_utils19.default.toJSONString(posStorageMap));
      }
    };
    const maximize = () => {
      return nextTick().then(() => {
        if (!reactData.zoomLocat) {
          const marginSize = Math.max(0, import_xe_utils19.default.toNumber(props.marginSize));
          const boxElem = getBox();
          const { visibleHeight, visibleWidth } = getDomNode();
          reactData.zoomLocat = {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft,
            width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
            height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
          };
          Object.assign(boxElem.style, {
            top: `${marginSize}px`,
            left: `${marginSize}px`,
            width: `${visibleWidth - marginSize * 2}px`,
            height: `${visibleHeight - marginSize * 2}px`
          });
          savePosStorage();
        }
      });
    };
    const openModal2 = () => {
      const { duration, remember, showFooter } = props;
      const { inited, visible } = reactData;
      const isMsg = computeIsMsg.value;
      if (!inited) {
        reactData.inited = true;
      }
      if (!visible) {
        if (!remember) {
          recalculate();
        }
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveModals.push($xemodal);
        setTimeout(() => {
          reactData.contentVisible = true;
          nextTick(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = "";
            const params = { type };
            emit("update:modelValue", true);
            modalMethods.dispatchEvent("show", params);
          });
        }, 10);
        if (isMsg) {
          addMsgQueue();
          if (duration !== -1) {
            setTimeout(() => closeModal2("close"), import_xe_utils19.default.toNumber(duration));
          }
        } else {
          nextTick(() => {
            const { fullscreen } = props;
            const { firstOpen } = reactData;
            if (!remember || firstOpen) {
              updatePosition().then(() => {
                setTimeout(() => updatePosition(), 20);
              });
            }
            if (firstOpen) {
              reactData.firstOpen = false;
              if (hasPosStorage()) {
                restorePosStorage();
              } else if (fullscreen) {
                nextTick(() => maximize());
              }
            } else {
              if (fullscreen) {
                nextTick(() => maximize());
              }
            }
          });
        }
      }
      return nextTick();
    };
    const selfClickEvent = (evnt) => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = "mask";
        closeModal2(type);
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastModal = import_xe_utils19.default.max(allActiveModals, (item) => item.reactData.modalZindex);
        if (lastModal) {
          setTimeout(() => {
            if (lastModal === $xemodal && lastModal.props.escClosable) {
              closeModal2("exit");
            }
          }, 10);
        }
      }
    };
    const isMaximized = () => {
      return !!reactData.zoomLocat;
    };
    const revert = () => {
      return nextTick().then(() => {
        const { zoomLocat } = reactData;
        if (zoomLocat) {
          const boxElem = getBox();
          reactData.zoomLocat = null;
          Object.assign(boxElem.style, {
            top: `${zoomLocat.top}px`,
            left: `${zoomLocat.left}px`,
            width: `${zoomLocat.width}px`,
            height: `${zoomLocat.height}px`
          });
          savePosStorage();
        }
      });
    };
    const zoom = () => {
      if (reactData.zoomLocat) {
        return revert().then(() => isMaximized());
      }
      return maximize().then(() => isMaximized());
    };
    const toggleZoomEvent = (evnt) => {
      const { zoomLocat } = reactData;
      const params = { type: zoomLocat ? "revert" : "max" };
      return zoom().then(() => {
        modalMethods.dispatchEvent("zoom", params, evnt);
      });
    };
    const getPosition = () => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          return {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft
          };
        }
      }
      return null;
    };
    const setPosition = (top, left) => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (import_xe_utils19.default.isNumber(top)) {
          boxElem.style.top = `${top}px`;
        }
        if (import_xe_utils19.default.isNumber(left)) {
          boxElem.style.left = `${left}px`;
        }
      }
      return nextTick();
    };
    const boxMousedownEvent = () => {
      const { modalZindex } = reactData;
      if (allActiveModals.some((comp) => comp.reactData.visible && comp.reactData.modalZindex > modalZindex)) {
        updateZindex();
      }
    };
    const mousedownEvent = (evnt) => {
      const { remember, storage } = props;
      const { zoomLocat } = reactData;
      const marginSize = import_xe_utils19.default.toNumber(props.marginSize);
      const boxElem = getBox();
      if (!zoomLocat && evnt.button === 0 && !getEventTargetNode(evnt, boxElem, "trigger--btn").flag) {
        evnt.preventDefault();
        const domMousemove = document.onmousemove;
        const domMouseup = document.onmouseup;
        const disX = evnt.clientX - boxElem.offsetLeft;
        const disY = evnt.clientY - boxElem.offsetTop;
        const { visibleHeight, visibleWidth } = getDomNode();
        document.onmousemove = (evnt2) => {
          evnt2.preventDefault();
          const offsetWidth = boxElem.offsetWidth;
          const offsetHeight = boxElem.offsetHeight;
          const minX = marginSize;
          const maxX = visibleWidth - offsetWidth - marginSize - 1;
          const minY = marginSize;
          const maxY = visibleHeight - offsetHeight - marginSize - 1;
          let left = evnt2.clientX - disX;
          let top = evnt2.clientY - disY;
          if (left > maxX) {
            left = maxX;
          }
          if (left < minX) {
            left = minX;
          }
          if (top > maxY) {
            top = maxY;
          }
          if (top < minY) {
            top = minY;
          }
          boxElem.style.left = `${left}px`;
          boxElem.style.top = `${top}px`;
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
          emit("move", { type: "move", $event: evnt2 });
        };
        document.onmouseup = () => {
          document.onmousemove = domMousemove;
          document.onmouseup = domMouseup;
          if (remember && storage) {
            nextTick(() => {
              savePosStorage();
            });
          }
          setTimeout(() => {
            boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
          }, 50);
        };
      }
    };
    const dragEvent = (evnt) => {
      evnt.preventDefault();
      const { remember, storage } = props;
      const { visibleHeight, visibleWidth } = getDomNode();
      const marginSize = import_xe_utils19.default.toNumber(props.marginSize);
      const targetElem = evnt.target;
      const type = targetElem.getAttribute("type");
      const minWidth = import_xe_utils19.default.toNumber(props.minWidth);
      const minHeight = import_xe_utils19.default.toNumber(props.minHeight);
      const maxWidth = visibleWidth;
      const maxHeight = visibleHeight;
      const boxElem = getBox();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const clientWidth = boxElem.clientWidth;
      const clientHeight = boxElem.clientHeight;
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      const offsetTop = boxElem.offsetTop;
      const offsetLeft = boxElem.offsetLeft;
      const params = { type: "resize" };
      document.onmousemove = (evnt2) => {
        evnt2.preventDefault();
        let dragLeft;
        let dragTop;
        let width;
        let height;
        switch (type) {
          case "wl":
            dragLeft = disX - evnt2.clientX;
            width = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            break;
          case "swst":
            dragLeft = disX - evnt2.clientX;
            dragTop = disY - evnt2.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "swlb":
            dragLeft = disX - evnt2.clientX;
            dragTop = evnt2.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case "st":
            dragTop = disY - evnt2.clientY;
            height = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "wr":
            dragLeft = evnt2.clientX - disX;
            width = dragLeft + clientWidth;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case "sest":
            dragLeft = evnt2.clientX - disX;
            dragTop = disY - evnt2.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "selb":
            dragLeft = evnt2.clientX - disX;
            dragTop = evnt2.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case "sb":
            dragTop = evnt2.clientY - disY;
            height = dragTop + clientHeight;
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
        if (remember && storage) {
          savePosStorage();
        }
        modalMethods.dispatchEvent("resize", params, evnt2);
      };
      document.onmouseup = () => {
        reactData.zoomLocat = null;
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        setTimeout(() => {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
        }, 50);
      };
    };
    modalMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $modal: $xemodal, $event: evnt }, params));
      },
      open: openModal2,
      close() {
        return closeModal2("close");
      },
      getBox,
      getPosition,
      setPosition,
      isMaximized,
      zoom,
      maximize,
      revert
    };
    Object.assign($xemodal, modalMethods);
    const renderTitles = () => {
      const { slots: propSlots = {}, showClose, showZoom, title } = props;
      const { zoomLocat } = reactData;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      const titVNs = [
        h("div", {
          class: "vxe-modal--header-title"
        }, titleSlot ? getSlotVNs(titleSlot({ $modal: $xemodal })) : title ? getFuncText(title) : conf_default.i18n("vxe.alert.title"))
      ];
      const rightVNs = [];
      if (cornerSlot) {
        rightVNs.push(h("span", {
          class: "vxe-modal--corner-wrapper"
        }, getSlotVNs(cornerSlot({ $modal: $xemodal }))));
      }
      if (showZoom) {
        rightVNs.push(h("i", {
          class: ["vxe-modal--zoom-btn", "trigger--btn", zoomLocat ? conf_default.icon.MODAL_ZOOM_OUT : conf_default.icon.MODAL_ZOOM_IN],
          title: conf_default.i18n(`vxe.modal.zoom${zoomLocat ? "Out" : "In"}`),
          onClick: toggleZoomEvent
        }));
      }
      if (showClose) {
        rightVNs.push(h("i", {
          class: ["vxe-modal--close-btn", "trigger--btn", conf_default.icon.MODAL_CLOSE],
          title: conf_default.i18n("vxe.modal.close"),
          onClick: closeEvent
        }));
      }
      titVNs.push(h("div", {
        class: "vxe-modal--header-right"
      }, rightVNs));
      return titVNs;
    };
    const renderHeaders = () => {
      const { slots: propSlots = {}, showZoom, draggable } = props;
      const isMsg = computeIsMsg.value;
      const headerSlot = slots.header || propSlots.header;
      const headVNs = [];
      if (props.showHeader) {
        const headerOns = {};
        if (draggable) {
          headerOns.onMousedown = mousedownEvent;
        }
        if (showZoom && props.dblclickZoom && props.type === "modal") {
          headerOns.onDblclick = toggleZoomEvent;
        }
        headVNs.push(h("div", Object.assign({ class: ["vxe-modal--header", {
          "is--draggable": draggable,
          "is--ellipsis": !isMsg && props.showTitleOverflow
        }] }, headerOns), headerSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(headerSlot({ $modal: $xemodal })) : renderTitles()));
      }
      return headVNs;
    };
    const renderBodys = () => {
      const { slots: propSlots = {}, status, message } = props;
      const content = props.content || message;
      const isMsg = computeIsMsg.value;
      const defaultSlot = slots.default || propSlots.default;
      const contVNs = [];
      if (status) {
        contVNs.push(h("div", {
          class: "vxe-modal--status-wrapper"
        }, [
          h("i", {
            class: ["vxe-modal--status-icon", props.iconStatus || conf_default.icon[`MODAL_${status}`.toLocaleUpperCase()]]
          })
        ]));
      }
      contVNs.push(h("div", {
        class: "vxe-modal--content"
      }, defaultSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(defaultSlot({ $modal: $xemodal })) : getFuncText(content)));
      if (!isMsg) {
        contVNs.push(h(loading_default2, {
          class: "vxe-modal--loading",
          modelValue: props.loading
        }));
      }
      return [
        h("div", {
          class: "vxe-modal--body"
        }, contVNs)
      ];
    };
    const renderBtns = () => {
      const { showCancelButton, showConfirmButton, type } = props;
      const btnVNs = [];
      if (import_xe_utils19.default.isBoolean(showCancelButton) ? showCancelButton : type === "confirm") {
        btnVNs.push(h(button_default, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || conf_default.i18n("vxe.button.cancel"),
          onClick: cancelEvent
        }));
      }
      if (import_xe_utils19.default.isBoolean(showConfirmButton) ? showConfirmButton : type === "confirm" || type === "alert") {
        btnVNs.push(h(button_default, {
          key: 2,
          ref: refConfirmBtn,
          status: "primary",
          content: props.confirmButtonText || conf_default.i18n("vxe.button.confirm"),
          onClick: confirmEvent
        }));
      }
      return btnVNs;
    };
    const renderFooters = () => {
      const { slots: propSlots = {} } = props;
      const isMsg = computeIsMsg.value;
      const footerSlot = slots.footer || propSlots.footer;
      const footVNs = [];
      if (props.showFooter) {
        footVNs.push(h("div", {
          class: "vxe-modal--footer"
        }, footerSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(footerSlot({ $modal: $xemodal })) : renderBtns()));
      }
      if (!isMsg && props.resize) {
        footVNs.push(h("span", {
          class: "vxe-modal--resize"
        }, ["wl", "wr", "swst", "sest", "st", "swlb", "selb", "sb"].map((type) => {
          return h("span", {
            class: `${type}-resize`,
            type,
            onMousedown: dragEvent
          });
        })));
      }
      return footVNs;
    };
    const renderVN = () => {
      const { className, type, animat, loading, status, lockScroll, lockView, mask, resize } = props;
      const { inited, zoomLocat, modalTop, contentVisible, visible } = reactData;
      const vSize = computeSize.value;
      return h(Teleport, {
        to: "body",
        disabled: props.transfer ? !inited : true
      }, [
        h("div", {
          ref: refElem,
          class: ["vxe-modal--wrapper", `type--${type}`, className || "", {
            [`size--${vSize}`]: vSize,
            [`status--${status}`]: status,
            "is--animat": animat,
            "lock--scroll": lockScroll,
            "lock--view": lockView,
            "is--resize": resize,
            "is--mask": mask,
            "is--maximize": zoomLocat,
            "is--visible": contentVisible,
            "is--active": visible,
            "is--loading": loading
          }],
          style: {
            zIndex: reactData.modalZindex,
            top: modalTop ? `${modalTop}px` : null
          },
          onClick: selfClickEvent
        }, [
          h("div", {
            ref: refModalBox,
            class: "vxe-modal--box",
            onMousedown: boxMousedownEvent
          }, renderHeaders().concat(renderBodys(), renderFooters()))
        ])
      ]);
    };
    $xemodal.renderVN = renderVN;
    watch(() => props.width, recalculate);
    watch(() => props.height, recalculate);
    watch(() => props.modelValue, (value) => {
      if (value) {
        openModal2();
      } else {
        closeModal2("model");
      }
    });
    onMounted(() => {
      if (true) {
        if (props.type === "modal" && props.showFooter && !(props.showConfirmButton || props.showCancelButton || slots.footer)) {
          warnLog("vxe.modal.footPropErr");
        }
      }
      nextTick(() => {
        if (props.storage && !props.id) {
          errLog("vxe.error.reqProp", ["modal.id"]);
        }
        if (props.modelValue) {
          openModal2();
        }
        recalculate();
      });
      if (props.escClosable) {
        GlobalEvent.on($xemodal, "keydown", handleGlobalKeydownEvent);
      }
    });
    onUnmounted(() => {
      GlobalEvent.off($xemodal, "keydown");
      removeMsgQueue();
    });
    return $xemodal;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/input/src/input.js
var import_xe_utils22 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/input/src/date.js
var import_xe_utils20 = __toESM(require_xe_utils());
function toStringTimeDate(str) {
  if (str) {
    const rest = /* @__PURE__ */ new Date();
    let h2 = 0;
    let m = 0;
    let s = 0;
    if (import_xe_utils20.default.isDate(str)) {
      h2 = str.getHours();
      m = str.getMinutes();
      s = str.getSeconds();
    } else {
      str = import_xe_utils20.default.toValueString(str);
      const parses = str.match(/^(\d{1,2})(:(\d{1,2}))?(:(\d{1,2}))?/);
      if (parses) {
        h2 = import_xe_utils20.default.toNumber(parses[1]);
        m = import_xe_utils20.default.toNumber(parses[3]);
        s = import_xe_utils20.default.toNumber(parses[5]);
      }
    }
    rest.setHours(h2);
    rest.setMinutes(m);
    rest.setSeconds(s);
    return rest;
  }
  return /* @__PURE__ */ new Date("");
}
function getDateQuarter(date) {
  const month = date.getMonth();
  if (month < 3) {
    return 1;
  } else if (month < 6) {
    return 2;
  } else if (month < 9) {
    return 3;
  }
  return 4;
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/input/src/number.js
var import_xe_utils21 = __toESM(require_xe_utils());
function handleNumber(val) {
  return import_xe_utils21.default.isString(val) ? val.replace(/,/g, "") : val;
}
function toFloatValueFixed(inputValue, digitsValue) {
  if (/^-/.test("" + inputValue)) {
    return import_xe_utils21.default.toFixed(import_xe_utils21.default.ceil(inputValue, digitsValue), digitsValue);
  }
  return import_xe_utils21.default.toFixed(import_xe_utils21.default.floor(inputValue, digitsValue), digitsValue);
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/input/src/input.js
var yearSize = 12;
var monthSize = 20;
var quarterSize = 8;
var input_default = defineComponent({
  name: "VxeInput",
  props: {
    modelValue: [String, Number, Date],
    immediate: { type: Boolean, default: true },
    name: String,
    type: { type: String, default: "text" },
    clearable: { type: Boolean, default: () => conf_default.input.clearable },
    readonly: Boolean,
    disabled: Boolean,
    placeholder: {
      type: String,
      default: () => import_xe_utils22.default.eqNull(conf_default.input.placeholder) ? conf_default.i18n("vxe.base.pleaseInput") : conf_default.input.placeholder
    },
    maxlength: [String, Number],
    autocomplete: { type: String, default: "off" },
    align: String,
    form: String,
    className: String,
    size: { type: String, default: () => conf_default.input.size || conf_default.size },
    multiple: Boolean,
    // text
    showWordCount: Boolean,
    countMethod: Function,
    // numberintegerfloat
    min: { type: [String, Number], default: null },
    max: { type: [String, Number], default: null },
    step: [String, Number],
    exponential: { type: Boolean, default: () => conf_default.input.exponential },
    // numberintegerfloatpassword
    controls: { type: Boolean, default: () => conf_default.input.controls },
    // float
    digits: { type: [String, Number], default: () => conf_default.input.digits },
    // dateweekmonthquarteryear
    startDate: { type: [String, Number, Date], default: () => conf_default.input.startDate },
    endDate: { type: [String, Number, Date], default: () => conf_default.input.endDate },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    //  startWeek startDay 
    startWeek: Number,
    startDay: { type: [String, Number], default: () => conf_default.input.startDay },
    labelFormat: { type: String, default: () => conf_default.input.labelFormat },
    valueFormat: { type: String, default: () => conf_default.input.valueFormat },
    editable: { type: Boolean, default: true },
    festivalMethod: { type: Function, default: () => conf_default.input.festivalMethod },
    disabledMethod: { type: Function, default: () => conf_default.input.disabledMethod },
    // week
    selectDay: { type: [String, Number], default: () => conf_default.input.selectDay },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: { type: Boolean, default: () => conf_default.input.transfer }
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "search-click",
    "toggle-visible",
    "prev-number",
    "next-number",
    "prefix-click",
    "suffix-click",
    "date-prev",
    "date-today",
    "date-next"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils22.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      inited: false,
      panelIndex: 0,
      showPwd: false,
      visiblePanel: false,
      animatVisible: false,
      panelStyle: null,
      panelPlacement: "",
      isActivated: false,
      inputValue: props.modelValue,
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    });
    const refElem = ref();
    const refInputTarget = ref();
    const refInputPanel = ref();
    const refInputTimeBody = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeinput = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let inputMethods = {};
    const parseDate2 = (value, format) => {
      const { type } = props;
      if (type === "time") {
        return toStringTimeDate(value);
      }
      return import_xe_utils22.default.toStringDate(value, format);
    };
    const computeIsDateTimeType = computed(() => {
      const { type } = props;
      return type === "time" || type === "datetime";
    });
    const computeIsNumType = computed(() => {
      return ["number", "integer", "float"].indexOf(props.type) > -1;
    });
    const computeInputCount = computed(() => {
      return import_xe_utils22.default.getSize(reactData.inputValue);
    });
    const computeIsCountError = computed(() => {
      const inputCount = computeInputCount.value;
      return props.maxlength && inputCount > import_xe_utils22.default.toNumber(props.maxlength);
    });
    const computeIsDatePickerType = computed(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeIsPawdType = computed(() => {
      return props.type === "password";
    });
    const computeIsSearchType = computed(() => {
      return props.type === "search";
    });
    const computeDigitsValue = computed(() => {
      return import_xe_utils22.default.toInteger(props.digits) || 1;
    });
    const computeStepValue = computed(() => {
      const { type } = props;
      const digitsValue = computeDigitsValue.value;
      const step = props.step;
      if (type === "integer") {
        return import_xe_utils22.default.toInteger(step) || 1;
      } else if (type === "float") {
        return import_xe_utils22.default.toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return import_xe_utils22.default.toNumber(step) || 1;
    });
    const computeIsClearable = computed(() => {
      const { type } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      return props.clearable && (isPawdType || isNumType || isDatePickerType || type === "text" || type === "search");
    });
    const computeDateStartTime = computed(() => {
      return props.startDate ? import_xe_utils22.default.toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = computed(() => {
      return props.endDate ? import_xe_utils22.default.toStringDate(props.endDate) : null;
    });
    const computeSupportMultiples = computed(() => {
      return ["date", "week", "month", "quarter", "year"].includes(props.type);
    });
    const computeDateListValue = computed(() => {
      const { modelValue, multiple } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePickerType) {
        return import_xe_utils22.default.toValueString(modelValue).split(",").map((item) => {
          const date = parseDate2(item, dateValueFormat);
          if (import_xe_utils22.default.isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map((date) => import_xe_utils22.default.toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map((date) => import_xe_utils22.default.toDateString(date, dateLabelFormat)).join(", ");
    });
    const computeDateValueFormat = computed(() => {
      const { type } = props;
      return type === "time" ? "HH:mm:ss" : props.valueFormat || (type === "datetime" ? "yyyy-MM-dd HH:mm:ss" : "yyyy-MM-dd");
    });
    const computeDateValue = computed(() => {
      const { modelValue } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePickerType) {
        const date = parseDate2(modelValue, dateValueFormat);
        if (import_xe_utils22.default.isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = computed(() => {
      const dateStartTime = computeDateStartTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = computed(() => {
      const dateEndTime = computeDateEndTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = computed(() => {
      const { datetimePanelValue } = reactData;
      if (datetimePanelValue) {
        return import_xe_utils22.default.toDateString(datetimePanelValue, "HH:mm:ss");
      }
      return "";
    });
    const computeDateHMSTime = computed(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1e3 : 0;
    });
    const computeDateLabelFormat = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        return props.labelFormat || conf_default.i18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return null;
    });
    const computeYearList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index = -4; index < yearSize + 4; index++) {
          const date = import_xe_utils22.default.getWhatYear(startYearDate, index, "first");
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelLabel = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const { datePanelType, selectMonth } = reactData;
        const yearList = computeYearList.value;
        let year = "";
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === "quarter") {
          return conf_default.i18n("vxe.input.date.quarterLabel", [year]);
        } else if (datePanelType === "month") {
          return conf_default.i18n("vxe.input.date.monthLabel", [year]);
        } else if (datePanelType === "year") {
          return yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : "";
        }
        return conf_default.i18n("vxe.input.date.dayLabel", [year, month ? conf_default.i18n(`vxe.input.date.m${month}`) : "-"]);
      }
      return "";
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay, startWeek } = props;
      return import_xe_utils22.default.toNumber(import_xe_utils22.default.isNumber(startDay) || import_xe_utils22.default.isString(startDay) ? startDay : startWeek);
    });
    const computeWeekDatas = computed(() => {
      const weeks = [];
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map((day) => {
          return {
            value: day,
            label: conf_default.i18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const dateHeaders = computeDateHeaders.value;
        return [{ label: conf_default.i18n("vxe.input.date.weeks.w") }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = computed(() => {
      const yearList = computeYearList.value;
      return import_xe_utils22.default.chunk(yearList, 4);
    });
    const computeQuarterList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = import_xe_utils22.default.getWhatYear(selectMonth, 0, "first");
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize - 2; index++) {
          const date = import_xe_utils22.default.getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = computed(() => {
      const quarterList = computeQuarterList.value;
      return import_xe_utils22.default.chunk(quarterList, 2);
    });
    const computeMonthList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = import_xe_utils22.default.getWhatYear(selectMonth, 0, "first").getFullYear();
        for (let index = -4; index < monthSize - 4; index++) {
          const date = import_xe_utils22.default.getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = computed(() => {
      const monthList = computeMonthList.value;
      return import_xe_utils22.default.chunk(monthList, 4);
    });
    const computeDayList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(import_xe_utils22.default.getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = import_xe_utils22.default.getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = computed(() => {
      const dayList = computeDayList.value;
      return import_xe_utils22.default.chunk(dayList, 7);
    });
    const computeWeekDates = computed(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map((list) => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: import_xe_utils22.default.getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 24; index++) {
          list.push({
            value: index,
            label: ("" + index).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeMinuteList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 60; index++) {
          list.push({
            value: index,
            label: ("" + index).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeSecondList = computed(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const computeInpReadonly = computed(() => {
      const { type, readonly, editable, multiple } = props;
      return readonly || multiple || !editable || type === "week" || type === "quarter";
    });
    const computeInputType = computed(() => {
      const { type } = props;
      const { showPwd } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      if (isDatePickerType || isNumType || isPawdType && showPwd || type === "number") {
        return "text";
      }
      return type;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      return "";
    });
    const computeInpMaxlength = computed(() => {
      const { maxlength } = props;
      const isNumType = computeIsNumType.value;
      return isNumType && !import_xe_utils22.default.toNumber(maxlength) ? 16 : maxlength;
    });
    const computeInpImmediate = computed(() => {
      const { type, immediate } = props;
      return immediate || !(type === "text" || type === "number" || type === "integer" || type === "float");
    });
    const computeNumValue = computed(() => {
      const { type } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        return type === "integer" ? import_xe_utils22.default.toInteger(handleNumber(inputValue)) : import_xe_utils22.default.toNumber(handleNumber(inputValue));
      }
      return 0;
    });
    const computeIsDisabledSubtractNumber = computed(() => {
      const { min } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && isNumType && min !== null) {
        return numValue <= import_xe_utils22.default.toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = computed(() => {
      const { max } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && isNumType && max !== null) {
        return numValue >= import_xe_utils22.default.toNumber(max);
      }
      return false;
    });
    const getNumberValue = (val) => {
      const { type, exponential } = props;
      const inpMaxlength = computeInpMaxlength.value;
      const digitsValue = computeDigitsValue.value;
      const restVal = type === "float" ? toFloatValueFixed(val, digitsValue) : import_xe_utils22.default.toValueString(val);
      if (exponential && (val === restVal || import_xe_utils22.default.toValueString(val).toLowerCase() === import_xe_utils22.default.toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxlength);
    };
    const triggerEvent3 = (evnt) => {
      const { inputValue } = reactData;
      inputMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const emitModel = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      inputMethods.dispatchEvent("input", { value }, evnt);
      if (import_xe_utils22.default.toValueString(props.modelValue) !== value) {
        inputMethods.dispatchEvent("change", { value }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, value);
        }
      }
    };
    const emitInputEvent = (value, evnt) => {
      const isDatePickerType = computeIsDatePickerType.value;
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (!isDatePickerType) {
        if (inpImmediate) {
          emitModel(value, evnt);
        } else {
          inputMethods.dispatchEvent("input", { value }, evnt);
        }
      }
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = (evnt) => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent3(evnt);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent3(evnt);
    };
    const clickPrefixEvent = (evnt) => {
      const { disabled } = props;
      if (!disabled) {
        const { inputValue } = reactData;
        inputMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    let hidePanelTimeout;
    const hidePanel = () => {
      return new Promise((resolve) => {
        reactData.visiblePanel = false;
        hidePanelTimeout = window.setTimeout(() => {
          reactData.animatVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const { type } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      if (isNumType || ["text", "search", "password"].indexOf(type) > -1) {
        focus();
      }
      inputMethods.dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const { disabled } = props;
      if (!disabled) {
        if (hasClass(evnt.currentTarget, "is--clear")) {
          emitModel("", evnt);
          clearValueEvent(evnt, "");
        } else {
          const { inputValue } = reactData;
          inputMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
        }
      }
    };
    const dateParseValue = (value) => {
      const { type } = props;
      const { valueFormat } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = "";
      if (value) {
        dValue = parseDate2(value, valueFormat);
      }
      if (import_xe_utils22.default.isValidDate(dValue)) {
        dLabel = import_xe_utils22.default.toDateString(dValue, dateLabelFormat, { firstDay: firstDayOfWeek });
        if (dateLabelFormat && type === "week") {
          const firstWeekDate = import_xe_utils22.default.getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf("yyyy");
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    const changeValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      const { inputValue } = reactData;
      if (isDatePickerType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    const initValue = () => {
      const { type } = props;
      const { inputValue } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const digitsValue = computeDigitsValue.value;
      if (isDatePickerType) {
        changeValue();
      } else if (type === "float") {
        if (inputValue) {
          const validValue = toFloatValueFixed(inputValue, digitsValue);
          if (inputValue !== validValue) {
            emitModel(validValue, { type: "init" });
          }
        }
      }
    };
    const vaildMaxNum = (num) => {
      return props.max === null || import_xe_utils22.default.toNumber(num) <= import_xe_utils22.default.toNumber(props.max);
    };
    const vaildMinNum = (num) => {
      return props.min === null || import_xe_utils22.default.toNumber(num) >= import_xe_utils22.default.toNumber(props.min);
    };
    const dateRevert = () => {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const dateCheckMonth = (date) => {
      const month = import_xe_utils22.default.getWhatMonth(date, 0, "first");
      if (!import_xe_utils22.default.isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date) => {
      const { modelValue, multiple } = props;
      const { datetimePanelValue } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === "week") {
        const sWeek = import_xe_utils22.default.toNumber(props.selectDay);
        date = import_xe_utils22.default.getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        date.setHours(datetimePanelValue.getHours());
        date.setMinutes(datetimePanelValue.getMinutes());
        date.setSeconds(datetimePanelValue.getSeconds());
      }
      const inpVal = import_xe_utils22.default.toDateString(date, dateValueFormat, { firstDay: firstDayOfWeek });
      dateCheckMonth(date);
      if (multiple) {
        const dateMultipleValue = computeDateMultipleValue.value;
        if (isDateTimeType) {
          const dateListValue = [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = import_xe_utils22.default.findIndexOf(dateListValue, (val) => import_xe_utils22.default.isDateSame(date, val, "yyyyMMdd"));
          if (eqIndex === -1) {
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach((item) => {
            if (item) {
              item.setHours(datetimePanelValue.getHours());
              item.setMinutes(datetimePanelValue.getMinutes());
              item.setSeconds(datetimePanelValue.getSeconds());
              datetimeRest.push(item);
            }
          });
          emitModel(datetimeRest.map((date2) => import_xe_utils22.default.toDateString(date2, dateValueFormat)).join(","), { type: "update" });
        } else {
          if (dateMultipleValue.some((val) => import_xe_utils22.default.isEqual(val, inpVal))) {
            emitModel(dateMultipleValue.filter((val) => !import_xe_utils22.default.isEqual(val, inpVal)).join(","), { type: "update" });
          } else {
            emitModel(dateMultipleValue.concat([inpVal]).join(","), { type: "update" });
          }
        }
      } else {
        if (!import_xe_utils22.default.isEqual(modelValue, inpVal)) {
          emitModel(inpVal, { type: "update" });
        }
      }
    };
    const afterCheckValue = () => {
      const { type, min, max, exponential } = props;
      const { inputValue, datetimePanelValue } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      const inpReadonly = computeInpReadonly.value;
      if (!inpReadonly) {
        if (isNumType) {
          if (inputValue) {
            let inpNumVal = type === "integer" ? import_xe_utils22.default.toInteger(handleNumber(inputValue)) : import_xe_utils22.default.toNumber(handleNumber(inputValue));
            if (!vaildMinNum(inpNumVal)) {
              inpNumVal = min;
            } else if (!vaildMaxNum(inpNumVal)) {
              inpNumVal = max;
            }
            if (exponential) {
              const inpStringVal = import_xe_utils22.default.toValueString(inputValue).toLowerCase();
              if (inpStringVal === import_xe_utils22.default.toNumber(inpNumVal).toExponential()) {
                inpNumVal = inpStringVal;
              }
            }
            emitModel(getNumberValue(inpNumVal), { type: "check" });
          }
        } else if (isDatePickerType) {
          if (inputValue) {
            let inpDateVal = parseDate2(inputValue, dateLabelFormat);
            if (import_xe_utils22.default.isValidDate(inpDateVal)) {
              if (type === "time") {
                inpDateVal = import_xe_utils22.default.toDateString(inpDateVal, dateLabelFormat);
                if (inputValue !== inpDateVal) {
                  emitModel(inpDateVal, { type: "check" });
                }
                reactData.inputValue = inpDateVal;
              } else {
                let isChange = false;
                const firstDayOfWeek = computeFirstDayOfWeek.value;
                if (type === "datetime") {
                  const dateValue = computeDateValue.value;
                  if (inputValue !== import_xe_utils22.default.toDateString(dateValue, dateLabelFormat) || inputValue !== import_xe_utils22.default.toDateString(inpDateVal, dateLabelFormat)) {
                    isChange = true;
                    datetimePanelValue.setHours(inpDateVal.getHours());
                    datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                    datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                  }
                } else {
                  isChange = true;
                }
                reactData.inputValue = import_xe_utils22.default.toDateString(inpDateVal, dateLabelFormat, { firstDay: firstDayOfWeek });
                if (isChange) {
                  dateChange(inpDateVal);
                }
              }
            } else {
              dateRevert();
            }
          } else {
            emitModel("", { type: "check" });
          }
        }
      }
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        emitModel(inputValue, evnt);
      }
      afterCheckValue();
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      inputMethods.dispatchEvent("blur", { value: inputValue }, evnt);
    };
    const passwordToggleEvent = (evnt) => {
      const { readonly, disabled } = props;
      const { showPwd } = reactData;
      if (!disabled && !readonly) {
        reactData.showPwd = !showPwd;
      }
      inputMethods.dispatchEvent("toggle-visible", { visible: reactData.showPwd }, evnt);
    };
    const searchEvent = (evnt) => {
      inputMethods.dispatchEvent("search-click", {}, evnt);
    };
    const numberChange = (isPlus, evnt) => {
      const { min, max, type } = props;
      const { inputValue } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === "integer" ? import_xe_utils22.default.toInteger(handleNumber(inputValue)) : import_xe_utils22.default.toNumber(handleNumber(inputValue));
      const newValue = isPlus ? import_xe_utils22.default.add(numValue, stepValue) : import_xe_utils22.default.subtract(numValue, stepValue);
      let restNum;
      if (!vaildMinNum(newValue)) {
        restNum = min;
      } else if (!vaildMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    let downbumTimeout;
    const numberNextEvent = (evnt) => {
      const { readonly, disabled } = props;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      clearTimeout(downbumTimeout);
      if (!disabled && !readonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      inputMethods.dispatchEvent("next-number", { value: reactData.inputValue }, evnt);
    };
    const numberDownNextEvent = (evnt) => {
      downbumTimeout = window.setTimeout(() => {
        numberNextEvent(evnt);
        numberDownNextEvent(evnt);
      }, 60);
    };
    const numberPrevEvent = (evnt) => {
      const { readonly, disabled } = props;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      clearTimeout(downbumTimeout);
      if (!disabled && !readonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      inputMethods.dispatchEvent("prev-number", { value: reactData.inputValue }, evnt);
    };
    const numberKeydownEvent = (evnt) => {
      const isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
      const isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
      }
    };
    const keydownEvent = (evnt) => {
      const { exponential, controls } = props;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        const isCtrlKey = evnt.ctrlKey;
        const isShiftKey = evnt.shiftKey;
        const isAltKey = evnt.altKey;
        const keyCode = evnt.keyCode;
        if (!isCtrlKey && !isShiftKey && !isAltKey && (hasEventKey(evnt, EVENT_KEYS.SPACEBAR) || (!exponential || keyCode !== 69) && (keyCode >= 65 && keyCode <= 90) || keyCode >= 186 && keyCode <= 188 || keyCode >= 191)) {
          evnt.preventDefault();
        }
        if (controls) {
          numberKeydownEvent(evnt);
        }
      }
      triggerEvent3(evnt);
    };
    const keyupEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const numberStopDown = () => {
      clearTimeout(downbumTimeout);
    };
    const numberDownPrevEvent = (evnt) => {
      downbumTimeout = window.setTimeout(() => {
        numberPrevEvent(evnt);
        numberDownPrevEvent(evnt);
      }, 60);
    };
    const numberMousedownEvent = (evnt) => {
      numberStopDown();
      if (evnt.button === 0) {
        const isPrevNumber = hasClass(evnt.currentTarget, "is--prev");
        if (isPrevNumber) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
        downbumTimeout = window.setTimeout(() => {
          if (isPrevNumber) {
            numberDownPrevEvent(evnt);
          } else {
            numberDownNextEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = (evnt) => {
      const isNumType = computeIsNumType.value;
      if (isNumType && props.controls) {
        if (reactData.isActivated) {
          const delta = evnt.deltaY;
          if (delta > 0) {
            numberNextEvent(evnt);
          } else if (delta < 0) {
            numberPrevEvent(evnt);
          }
          evnt.preventDefault();
        }
      }
      triggerEvent3(evnt);
    };
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = import_xe_utils22.default.getWhatMonth(date, offsetMonth, "first");
    };
    const dateNowHandle = () => {
      const currentDate = import_xe_utils22.default.getWhatDay(Date.now(), 0, "first");
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleTypeEvent = () => {
      let { datePanelType } = reactData;
      if (datePanelType === "month" || datePanelType === "quarter") {
        datePanelType = "year";
      } else {
        datePanelType = "month";
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputValue } = reactData;
      const value = inputValue;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        if (type === "year") {
          reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, -yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, -yearSize, "first");
          } else {
            reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, -1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, -yearSize, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, -1, "first");
          } else {
            reactData.selectMonth = import_xe_utils22.default.getWhatMonth(selectMonth, -1, "first");
          }
        }
        inputMethods.dispatchEvent("date-prev", { value, type }, evnt);
      }
    };
    const dateTodayMonthEvent = (evnt) => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
        hidePanel();
      }
      inputMethods.dispatchEvent("date-today", { type: props.type }, evnt);
    };
    const dateNextEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputValue } = reactData;
      const value = inputValue;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        if (type === "year") {
          reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, yearSize, "first");
          } else {
            reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, 1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, yearSize, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, 1, "first");
          } else {
            reactData.selectMonth = import_xe_utils22.default.getWhatMonth(selectMonth, 1, "first");
          }
        }
        inputMethods.dispatchEvent("date-next", { value, type }, evnt);
      }
    };
    const isDateDisabled = (item) => {
      const { disabledMethod } = props;
      const { datePanelType } = reactData;
      return disabledMethod && disabledMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $input: $xeinput });
    };
    const dateSelectItem = (date) => {
      const { type, multiple } = props;
      const { datePanelType } = reactData;
      if (type === "month") {
        if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === "year") {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === "quarter") {
        if (datePanelType === "year") {
          reactData.datePanelType = "quarter";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === "month") {
          reactData.datePanelType = type === "week" ? type : "day";
          dateCheckMonth(date);
        } else if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === "datetime") {
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = (item) => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = (offsetDay) => {
      if (!isDateDisabled({ date: offsetDay })) {
        const dayList = computeDayList.value;
        if (!dayList.some((item) => import_xe_utils22.default.isDateSame(item.date, offsetDay, "yyyyMMdd"))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = (offsetYear) => {
      if (!isDateDisabled({ date: offsetYear })) {
        const yearList = computeYearList.value;
        if (!yearList.some((item) => import_xe_utils22.default.isDateSame(item.date, offsetYear, "yyyy"))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = (offsetQuarter) => {
      if (!isDateDisabled({ date: offsetQuarter })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some((item) => import_xe_utils22.default.isDateSame(item.date, offsetQuarter, "yyyyq"))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = (offsetMonth) => {
      if (!isDateDisabled({ date: offsetMonth })) {
        const monthList = computeMonthList.value;
        if (!monthList.some((item) => import_xe_utils22.default.isDateSame(item.date, offsetMonth, "yyyyMM"))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = (item) => {
      if (!isDateDisabled(item)) {
        const { datePanelType } = reactData;
        if (datePanelType === "month") {
          dateMoveMonth(item.date);
        } else if (datePanelType === "quarter") {
          dateMoveQuarter(item.date);
        } else if (datePanelType === "year") {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const updateTimePos = (liElem) => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = (evnt) => {
      reactData.datetimePanelValue = new Date(reactData.datetimePanelValue.getTime());
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      reactData.datetimePanelValue.setHours(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = () => {
      const { multiple } = props;
      const { datetimePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach((item) => {
              if (item) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
                datetimeRest.push(item);
              }
            });
            emitModel(datetimeRest.map((date) => import_xe_utils22.default.toDateString(date, dateValueFormat)).join(","), { type: "update" });
          } else {
            emitModel(dateMultipleValue.join(","), { type: "update" });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
    };
    const dateMinuteEvent = (evnt, item) => {
      reactData.datetimePanelValue.setMinutes(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      reactData.datetimePanelValue.setSeconds(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateOffsetEvent = (evnt) => {
      const { isActivated, datePanelValue, datePanelType } = reactData;
      if (isActivated) {
        evnt.preventDefault();
        const isLeftArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
        const isRightArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
        if (datePanelType === "year") {
          let offsetYear = import_xe_utils22.default.getWhatYear(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetYear = import_xe_utils22.default.getWhatYear(offsetYear, -1);
          } else if (isUpArrow) {
            offsetYear = import_xe_utils22.default.getWhatYear(offsetYear, -4);
          } else if (isRightArrow) {
            offsetYear = import_xe_utils22.default.getWhatYear(offsetYear, 1);
          } else if (isDwArrow) {
            offsetYear = import_xe_utils22.default.getWhatYear(offsetYear, 4);
          }
          dateMoveYear(offsetYear);
        } else if (datePanelType === "quarter") {
          let offsetQuarter = import_xe_utils22.default.getWhatQuarter(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetQuarter = import_xe_utils22.default.getWhatQuarter(offsetQuarter, -1);
          } else if (isUpArrow) {
            offsetQuarter = import_xe_utils22.default.getWhatQuarter(offsetQuarter, -2);
          } else if (isRightArrow) {
            offsetQuarter = import_xe_utils22.default.getWhatQuarter(offsetQuarter, 1);
          } else if (isDwArrow) {
            offsetQuarter = import_xe_utils22.default.getWhatQuarter(offsetQuarter, 2);
          }
          dateMoveQuarter(offsetQuarter);
        } else if (datePanelType === "month") {
          let offsetMonth = import_xe_utils22.default.getWhatMonth(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetMonth = import_xe_utils22.default.getWhatMonth(offsetMonth, -1);
          } else if (isUpArrow) {
            offsetMonth = import_xe_utils22.default.getWhatMonth(offsetMonth, -4);
          } else if (isRightArrow) {
            offsetMonth = import_xe_utils22.default.getWhatMonth(offsetMonth, 1);
          } else if (isDwArrow) {
            offsetMonth = import_xe_utils22.default.getWhatMonth(offsetMonth, 4);
          }
          dateMoveMonth(offsetMonth);
        } else {
          let offsetDay = datePanelValue || import_xe_utils22.default.getWhatDay(Date.now(), 0, "first");
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          if (isLeftArrow) {
            offsetDay = import_xe_utils22.default.getWhatDay(offsetDay, -1);
          } else if (isUpArrow) {
            offsetDay = import_xe_utils22.default.getWhatWeek(offsetDay, -1, firstDayOfWeek);
          } else if (isRightArrow) {
            offsetDay = import_xe_utils22.default.getWhatDay(offsetDay, 1);
          } else if (isDwArrow) {
            offsetDay = import_xe_utils22.default.getWhatWeek(offsetDay, 1, firstDayOfWeek);
          }
          dateMoveDay(offsetDay);
        }
      }
    };
    const datePgOffsetEvent = (evnt) => {
      const { isActivated } = reactData;
      if (isActivated) {
        const isPgUp = hasEventKey(evnt, EVENT_KEYS.PAGE_UP);
        evnt.preventDefault();
        if (isPgUp) {
          datePrevEvent(evnt);
        } else {
          dateNextEvent(evnt);
        }
      }
    };
    const dateOpenPanel = () => {
      const { type } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (["year", "quarter", "month", "week"].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = "day";
      }
      reactData.currentDate = import_xe_utils22.default.getWhatDay(Date.now(), 0, "first");
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || import_xe_utils22.default.getWhatDay(Date.now(), 0, "first");
        nextTick(() => {
          const timeBodyElem = refInputTimeBody.value;
          import_xe_utils22.default.arrayEach(timeBodyElem.querySelectorAll("li.is--selected"), updateTimePos);
        });
      }
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { transfer, placement } = props;
        const { panelIndex } = reactData;
        const targetElem = refInputTarget.value;
        const panelElem = refInputPanel.value;
        if (targetElem && panelElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(targetElem);
          let panelPlacement = "bottom";
          console.log(getAbsolutePos(targetElem));
          if (transfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showPanel = () => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!disabled && !visiblePanel) {
        if (!reactData.inited) {
          reactData.inited = true;
        }
        clearTimeout(hidePanelTimeout);
        reactData.isActivated = true;
        reactData.animatVisible = true;
        if (isDatePickerType) {
          dateOpenPanel();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return nextTick();
    };
    const datePickerOpenEvent = (evnt) => {
      const { readonly } = props;
      if (!readonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel, isActivated } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const el = refElem.value;
      const panelElem = refInputPanel.value;
      if (!disabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (!reactData.isActivated) {
          if (isDatePickerType) {
            if (visiblePanel) {
              hidePanel();
              afterCheckValue();
            }
          } else {
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable, disabled } = props;
      const { visiblePanel } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!disabled) {
        const isTab = hasEventKey(evnt, EVENT_KEYS.TAB);
        const isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);
        const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
        const isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);
        const isLeftArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
        const isRightArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
        const isPgUp = hasEventKey(evnt, EVENT_KEYS.PAGE_UP);
        const isPgDn = hasEventKey(evnt, EVENT_KEYS.PAGE_DOWN);
        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        } else if (operArrow) {
          if (isDatePickerType) {
            if (isActivated) {
              if (visiblePanel) {
                dateOffsetEvent(evnt);
              } else if (isUpArrow || isDwArrow) {
                datePickerOpenEvent(evnt);
              }
            }
          }
        } else if (isEnter) {
          if (isDatePickerType) {
            if (visiblePanel) {
              if (reactData.datePanelValue) {
                dateSelectItem(reactData.datePanelValue);
              } else {
                hidePanel();
              }
            } else if (isActivated) {
              datePickerOpenEvent(evnt);
            }
          }
        } else if (isPgUp || isPgDn) {
          if (isDatePickerType) {
            if (isActivated) {
              datePgOffsetEvent(evnt);
            }
          }
        }
        if (isTab || isEsc) {
          if (visiblePanel) {
            hidePanel();
          }
        } else if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      if (!disabled) {
        if (visiblePanel) {
          const panelElem = refInputPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { isActivated, visiblePanel } = reactData;
      if (visiblePanel) {
        hidePanel();
        afterCheckValue();
      } else if (isActivated) {
        afterCheckValue();
      }
    };
    const renderDateLabel = (item, label) => {
      const { festivalMethod } = props;
      if (festivalMethod) {
        const { datePanelType } = reactData;
        const festivalRest = festivalMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $input: $xeinput });
        const festivalItem = festivalRest ? import_xe_utils22.default.isString(festivalRest) ? { label: festivalRest } : festivalRest : {};
        const extraItem = festivalItem.extra ? import_xe_utils22.default.isString(festivalItem.extra) ? { label: festivalItem.extra } : festivalItem.extra : null;
        const labels = [
          h("span", {
            class: ["vxe-input--date-label", {
              "is-notice": festivalItem.notice
            }]
          }, extraItem && extraItem.label ? [
            h("span", label),
            h("span", {
              class: ["vxe-input--date-label--extra", extraItem.important ? "is-important" : "", extraItem.className],
              style: extraItem.style
            }, import_xe_utils22.default.toValueString(extraItem.label))
          ] : label)
        ];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          const festivalLabels = import_xe_utils22.default.toValueString(festivalLabel).split(",");
          labels.push(h("span", {
            class: ["vxe-input--date-festival", festivalItem.important ? "is-important" : "", festivalItem.className],
            style: festivalItem.style
          }, [
            festivalLabels.length > 1 ? h("span", {
              class: ["vxe-input--date-festival--overlap", `overlap--${festivalLabels.length}`]
            }, festivalLabels.map((label2) => h("span", label2.substring(0, 3)))) : h("span", {
              class: "vxe-input--date-festival--label"
            }, festivalLabels[0].substring(0, 3))
          ]));
        }
        return labels;
      }
      return label;
    };
    const renderDateDayTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", dateHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", dayDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils22.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils22.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils22.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateWeekTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", weekHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", weekDates.map((rows) => {
            const isSelected = multiple ? rows.some((item) => dateListValue.some((val) => import_xe_utils22.default.isDateSame(val, item.date, matchFormat))) : rows.some((item) => import_xe_utils22.default.isDateSame(dateValue, item.date, matchFormat));
            const isHover = rows.some((item) => import_xe_utils22.default.isDateSame(datePanelValue, item.date, matchFormat));
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--hover": isHover
                },
                // event
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateMonthTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMM";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", monthDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils22.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils22.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils22.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, conf_default.i18n(`vxe.input.date.months.m${item.month}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateQuarterTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyq";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", quarterDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils22.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils22.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils22.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, conf_default.i18n(`vxe.input.date.quarters.q${item.quarter}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateYearTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyy";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", yearDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils22.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils22.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils22.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.year));
            }));
          }))
        ])
      ];
    };
    const renderDateTable = () => {
      const { datePanelType } = reactData;
      switch (datePanelType) {
        case "week":
          return renderDateWeekTable();
        case "month":
          return renderDateMonthTable();
        case "quarter":
          return renderDateQuarterTable();
        case "year":
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const { multiple } = props;
      const { datePanelType } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelLabel = computeSelectDatePanelLabel.value;
      return [
        h("div", {
          class: "vxe-input--date-picker-header"
        }, [
          h("div", {
            class: "vxe-input--date-picker-type-wrapper"
          }, [
            datePanelType === "year" ? h("span", {
              class: "vxe-input--date-picker-label"
            }, selectDatePanelLabel) : h("span", {
              class: "vxe-input--date-picker-btn",
              onClick: dateToggleTypeEvent
            }, selectDatePanelLabel)
          ]),
          h("div", {
            class: "vxe-input--date-picker-btn-wrapper"
          }, [
            h("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-prev-btn", {
                "is--disabled": isDisabledPrevDateBtn
              }],
              onClick: datePrevEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-left"
              })
            ]),
            h("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-current-btn",
              onClick: dateTodayMonthEvent
            }, [
              h("i", {
                class: "vxe-icon-dot"
              })
            ]),
            h("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-next-btn", {
                "is--disabled": isDisabledNextDateBtn
              }],
              onClick: dateNextEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-right"
              })
            ]),
            multiple && computeSupportMultiples.value ? h("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-confirm-btn"
            }, [
              h("button", {
                class: "vxe-input--date-picker-confirm",
                type: "button",
                onClick: dateConfirmEvent
              }, conf_default.i18n("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        h("div", {
          class: "vxe-input--date-picker-body"
        }, renderDateTable())
      ];
    };
    const renderTimePanel = () => {
      const { datetimePanelValue } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const minuteList = computeMinuteList.value;
      const secondList = computeSecondList.value;
      return [
        h("div", {
          class: "vxe-input--time-picker-header"
        }, [
          h("span", {
            class: "vxe-input--time-picker-title"
          }, dateTimeLabel),
          h("button", {
            class: "vxe-input--time-picker-confirm",
            type: "button",
            onClick: dateConfirmEvent
          }, conf_default.i18n("vxe.button.confirm"))
        ]),
        h("div", {
          ref: refInputTimeBody,
          class: "vxe-input--time-picker-body"
        }, [
          h("ul", {
            class: "vxe-input--time-picker-hour-list"
          }, hourList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getHours() === item.value
              },
              onClick: (evnt) => dateHourEvent(evnt, item)
            }, item.label);
          })),
          h("ul", {
            class: "vxe-input--time-picker-minute-list"
          }, minuteList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getMinutes() === item.value
              },
              onClick: (evnt) => dateMinuteEvent(evnt, item)
            }, item.label);
          })),
          h("ul", {
            class: "vxe-input--time-picker-second-list"
          }, secondList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getSeconds() === item.value
              },
              onClick: (evnt) => dateSecondEvent(evnt, item)
            }, item.label);
          }))
        ])
      ];
    };
    const renderPanel = () => {
      const { type, transfer } = props;
      const { inited, animatVisible, visiblePanel, panelPlacement, panelStyle } = reactData;
      const vSize = computeSize.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const renders = [];
      if (isDatePickerType) {
        if (type === "datetime") {
          renders.push(h("div", {
            class: "vxe-input--panel-layout-wrapper"
          }, [
            h("div", {
              class: "vxe-input--panel-left-wrapper"
            }, renderDatePanel()),
            h("div", {
              class: "vxe-input--panel-right-wrapper"
            }, renderTimePanel())
          ]));
        } else if (type === "time") {
          renders.push(h("div", {
            class: "vxe-input--panel-wrapper"
          }, renderTimePanel()));
        } else {
          renders.push(h("div", {
            class: "vxe-input--panel-wrapper"
          }, renderDatePanel()));
        }
        return h(Teleport, {
          to: "body",
          disabled: transfer ? !inited : true
        }, [
          h("div", {
            ref: refInputPanel,
            class: ["vxe-table--ignore-clear vxe-input--panel", `type--${type}`, {
              [`size--${vSize}`]: vSize,
              "is--transfer": transfer,
              "animat--leave": animatVisible,
              "animat--enter": visiblePanel
            }],
            placement: panelPlacement,
            style: panelStyle
          }, renders)
        ]);
      }
      return null;
    };
    const renderNumberIcon = () => {
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return h("span", {
        class: "vxe-input--number-suffix"
      }, [
        h("span", {
          class: ["vxe-input--number-prev is--prev", {
            "is--disabled": isDisabledAddNumber
          }],
          onMousedown: numberMousedownEvent,
          onMouseup: numberStopDown,
          onMouseleave: numberStopDown
        }, [
          h("i", {
            class: ["vxe-input--number-prev-icon", conf_default.icon.INPUT_PREV_NUM]
          })
        ]),
        h("span", {
          class: ["vxe-input--number-next is--next", {
            "is--disabled": isDisabledSubtractNumber
          }],
          onMousedown: numberMousedownEvent,
          onMouseup: numberStopDown,
          onMouseleave: numberStopDown
        }, [
          h("i", {
            class: ["vxe-input--number-next-icon", conf_default.icon.INPUT_NEXT_NUM]
          })
        ])
      ]);
    };
    const renderDatePickerIcon = () => {
      return h("span", {
        class: "vxe-input--date-picker-suffix",
        onClick: datePickerOpenEvent
      }, [
        h("i", {
          class: ["vxe-input--date-picker-icon", conf_default.icon.INPUT_DATE]
        })
      ]);
    };
    const renderSearchIcon = () => {
      return h("span", {
        class: "vxe-input--search-suffix",
        onClick: searchEvent
      }, [
        h("i", {
          class: ["vxe-input--search-icon", conf_default.icon.INPUT_SEARCH]
        })
      ]);
    };
    const renderPasswordIcon = () => {
      const { showPwd } = reactData;
      return h("span", {
        class: "vxe-input--password-suffix",
        onClick: passwordToggleEvent
      }, [
        h("i", {
          class: ["vxe-input--password-icon", showPwd ? conf_default.icon.INPUT_SHOW_PWD : conf_default.icon.INPUT_PWD]
        })
      ]);
    };
    const rendePrefixIcon = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      const icons = [];
      if (prefixSlot) {
        icons.push(h("span", {
          class: "vxe-input--prefix-icon"
        }, prefixSlot({})));
      } else if (prefixIcon) {
        icons.push(h("i", {
          class: ["vxe-input--prefix-icon", prefixIcon]
        }));
      }
      return icons.length ? h("span", {
        class: "vxe-input--prefix",
        onClick: clickPrefixEvent
      }, icons) : null;
    };
    const renderSuffixIcon2 = () => {
      const { disabled, suffixIcon } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isClearable = computeIsClearable.value;
      const icons = [];
      if (suffixSlot) {
        icons.push(h("span", {
          class: "vxe-input--suffix-icon"
        }, suffixSlot({})));
      } else if (suffixIcon) {
        icons.push(h("i", {
          class: ["vxe-input--suffix-icon", suffixIcon]
        }));
      }
      if (isClearable) {
        icons.push(h("i", {
          class: ["vxe-input--clear-icon", conf_default.icon.INPUT_CLEAR]
        }));
      }
      return icons.length ? h("span", {
        class: ["vxe-input--suffix", {
          "is--clear": isClearable && !disabled && !(inputValue === "" || import_xe_utils22.default.eqNull(inputValue))
        }],
        onClick: clickSuffixEvent
      }, icons) : null;
    };
    const renderExtraSuffixIcon = () => {
      const { controls } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      let icons;
      if (isPawdType) {
        icons = renderPasswordIcon();
      } else if (isNumType) {
        if (controls) {
          icons = renderNumberIcon();
        }
      } else if (isDatePickerType) {
        icons = renderDatePickerIcon();
      } else if (isSearchType) {
        icons = renderSearchIcon();
      }
      return icons ? h("span", {
        class: "vxe-input--extra-suffix"
      }, [icons]) : null;
    };
    inputMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $input: $xeinput, $event: evnt }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeinput, inputMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      changeValue();
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        inputValue: props.modelValue,
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    watch(computeDateLabelFormat, () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    nextTick(() => {
      GlobalEvent.on($xeinput, "mousewheel", handleGlobalMousewheelEvent);
      GlobalEvent.on($xeinput, "mousedown", handleGlobalMousedownEvent);
      GlobalEvent.on($xeinput, "keydown", handleGlobalKeydownEvent);
      GlobalEvent.on($xeinput, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      numberStopDown();
      GlobalEvent.off($xeinput, "mousewheel");
      GlobalEvent.off($xeinput, "mousedown");
      GlobalEvent.off($xeinput, "keydown");
      GlobalEvent.off($xeinput, "blur");
    });
    initValue();
    const renderVN = () => {
      const { className, controls, type, align, showWordCount, countMethod, name, disabled, readonly, autocomplete } = props;
      const { inputValue, visiblePanel, isActivated } = reactData;
      const vSize = computeSize.value;
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const inpReadonly = computeInpReadonly.value;
      const inpMaxlength = computeInpMaxlength.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const childs = [];
      const prefix = rendePrefixIcon();
      const suffix = renderSuffixIcon2();
      if (prefix) {
        childs.push(prefix);
      }
      childs.push(h("input", {
        ref: refInputTarget,
        class: "vxe-input--inner",
        value: inputValue,
        name,
        type: inputType,
        placeholder: inpPlaceholder,
        maxlength: inpMaxlength,
        readonly: inpReadonly,
        disabled,
        autocomplete,
        onKeydown: keydownEvent,
        onKeyup: keyupEvent,
        onWheel: wheelEvent,
        onClick: clickEvent,
        onInput: inputEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      }));
      if (suffix) {
        childs.push(suffix);
      }
      childs.push(renderExtraSuffixIcon());
      if (isDatePickerType) {
        childs.push(renderPanel());
      }
      let isWordCount = false;
      if (showWordCount && ["text", "search"].includes(type)) {
        isWordCount = true;
        childs.push(h("span", {
          class: ["vxe-input--count", {
            "is--error": isCountError
          }]
        }, countMethod ? `${countMethod({ value: inputValue })}` : `${inputCount}${inpMaxlength ? `/${inpMaxlength}` : ""}`));
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-input", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          "is--controls": controls,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--readonly": readonly,
          "is--visivle": visiblePanel,
          "is--count": isWordCount,
          "is--disabled": disabled,
          "is--active": isActivated
        }]
      }, childs);
    };
    $xeinput.renderVN = renderVN;
    return $xeinput;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/checkbox/src/checkbox.js
var import_xe_utils23 = __toESM(require_xe_utils());
var checkbox_default = defineComponent({
  name: "VxeCheckbox",
  props: {
    modelValue: [String, Number, Boolean],
    label: { type: [String, Number], default: null },
    indeterminate: Boolean,
    title: [String, Number],
    checkedValue: { type: [String, Number, Boolean], default: true },
    uncheckedValue: { type: [String, Number, Boolean], default: false },
    content: [String, Number],
    disabled: Boolean,
    size: { type: String, default: () => conf_default.checkbox.size || conf_default.size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils23.default.uniqueId();
    const $xecheckbox = {
      xID,
      props,
      context
    };
    let checkboxMethods = {};
    const computeSize = useSize(props);
    const $xecheckboxgroup = inject("$xecheckboxgroup", null);
    const computeIsChecked = computed(() => {
      if ($xecheckboxgroup) {
        return import_xe_utils23.default.includes($xecheckboxgroup.props.modelValue, props.label);
      }
      return props.modelValue === props.checkedValue;
    });
    const computeIsDisabled = computed(() => {
      if (props.disabled) {
        return true;
      }
      if ($xecheckboxgroup) {
        const { props: groupProps } = $xecheckboxgroup;
        const { computeIsMaximize } = $xecheckboxgroup.getComputeMaps();
        const isMaximize = computeIsMaximize.value;
        const isChecked = computeIsChecked.value;
        return groupProps.disabled || isMaximize && !isChecked;
      }
      return false;
    });
    const changeEvent = (evnt) => {
      const { checkedValue, uncheckedValue } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const checked = evnt.target.checked;
        const value = checked ? checkedValue : uncheckedValue;
        const params = { checked, value, label: props.label };
        if ($xecheckboxgroup) {
          $xecheckboxgroup.handleChecked(params, evnt);
        } else {
          emit("update:modelValue", value);
          checkboxMethods.dispatchEvent("change", params, evnt);
          if ($xeform && $xeformiteminfo) {
            $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, value);
          }
        }
      }
    };
    checkboxMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $checkbox: $xecheckbox, $event: evnt }, params));
      }
    };
    Object.assign($xecheckbox, checkboxMethods);
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isChecked = computeIsChecked.value;
      const indeterminate = props.indeterminate;
      return h("label", {
        class: ["vxe-checkbox", {
          [`size--${vSize}`]: vSize,
          "is--indeterminate": indeterminate,
          "is--disabled": isDisabled,
          "is--checked": isChecked
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-checkbox--input",
          type: "checkbox",
          disabled: isDisabled,
          checked: isChecked,
          onChange: changeEvent
        }),
        h("span", {
          class: ["vxe-checkbox--icon", indeterminate ? "vxe-icon-checkbox-indeterminate" : isChecked ? "vxe-icon-checkbox-checked" : "vxe-icon-checkbox-unchecked"]
        }),
        h("span", {
          class: "vxe-checkbox--label"
        }, slots.default ? slots.default({}) : getFuncText(props.content))
      ]);
    };
    $xecheckbox.renderVN = renderVN;
    return $xecheckbox;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/select/src/select.js
var import_xe_utils24 = __toESM(require_xe_utils());
function isOptionVisible(option) {
  return option.visible !== false;
}
function getOptUniqueId() {
  return import_xe_utils24.default.uniqueId("opt_");
}
var select_default = defineComponent({
  name: "VxeSelect",
  props: {
    modelValue: null,
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => import_xe_utils24.default.eqNull(conf_default.select.placeholder) ? conf_default.i18n("vxe.base.pleaseSelect") : conf_default.select.placeholder
    },
    loading: Boolean,
    disabled: Boolean,
    multiple: Boolean,
    multiCharOverflow: { type: [Number, String], default: () => conf_default.select.multiCharOverflow },
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    optionGroups: Array,
    optionGroupProps: Object,
    optionConfig: Object,
    className: [String, Function],
    popupClassName: [String, Function],
    max: { type: [String, Number], default: null },
    size: { type: String, default: () => conf_default.select.size || conf_default.size },
    filterable: Boolean,
    filterMethod: Function,
    remote: Boolean,
    remoteMethod: Function,
    emptyText: String,
    //  option-config.keyField 
    optionId: { type: String, default: () => conf_default.select.optionId },
    //  option-config.useKey 
    optionKey: Boolean,
    transfer: { type: Boolean, default: () => conf_default.select.transfer }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils24.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      inited: false,
      staticOptions: [],
      fullGroupList: [],
      fullOptionList: [],
      visibleGroupList: [],
      visibleOptionList: [],
      remoteValueList: [],
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      currentOption: null,
      currentValue: null,
      visiblePanel: false,
      animatVisible: false,
      isActivated: false,
      searchValue: "",
      searchLoading: false
    });
    const refElem = ref();
    const refInput = ref();
    const refInpSearch = ref();
    const refOptionWrapper = ref();
    const refOptionPanel = ref();
    const refMaps = {
      refElem
    };
    const $xeselect = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let selectMethods = {};
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeGroupPropsOpts = computed(() => {
      return props.optionGroupProps || {};
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeGroupLabelField = computed(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.label || "label";
    });
    const computeGroupOptionsField = computed(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.options || "options";
    });
    const computeIsMaximize = computed(() => {
      const { modelValue, multiple, max } = props;
      if (multiple && max) {
        return (modelValue ? modelValue.length : 0) >= import_xe_utils24.default.toNumber(max);
      }
      return false;
    });
    const computeOptionOpts = computed(() => {
      return Object.assign({}, conf_default.select.optionConfig, props.optionConfig);
    });
    const computeIsGroup = computed(() => {
      return reactData.fullGroupList.some((item) => item.options && item.options.length);
    });
    const computeMultiMaxCharNum = computed(() => {
      return import_xe_utils24.default.toNumber(props.multiCharOverflow);
    });
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils24.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils24.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const findOption = (optionValue) => {
      const { fullOptionList, fullGroupList } = reactData;
      const isGroup = computeIsGroup.value;
      const valueField = computeValueField.value;
      if (isGroup) {
        for (let gIndex = 0; gIndex < fullGroupList.length; gIndex++) {
          const group = fullGroupList[gIndex];
          if (group.options) {
            for (let index = 0; index < group.options.length; index++) {
              const option = group.options[index];
              if (optionValue === option[valueField]) {
                return option;
              }
            }
          }
        }
      }
      return fullOptionList.find((item) => optionValue === item[valueField]);
    };
    const getRemoteSelectLabel = (value) => {
      const { remoteValueList } = reactData;
      const labelField = computeLabelField.value;
      const remoteItem = remoteValueList.find((item2) => value === item2.key);
      const item = remoteItem ? remoteItem.result : null;
      return import_xe_utils24.default.toValueString(item ? item[labelField] : value);
    };
    const getSelectLabel = (value) => {
      const labelField = computeLabelField.value;
      const item = findOption(value);
      return import_xe_utils24.default.toValueString(item ? item[labelField] : value);
    };
    const computeSelectLabel = computed(() => {
      const { modelValue, multiple, remote } = props;
      const multiMaxCharNum = computeMultiMaxCharNum.value;
      if (modelValue && multiple) {
        const vals = import_xe_utils24.default.isArray(modelValue) ? modelValue : [modelValue];
        if (remote) {
          return vals.map((val) => getRemoteSelectLabel(val)).join(", ");
        }
        return vals.map((val) => {
          const label = getSelectLabel(val);
          if (multiMaxCharNum > 0 && label.length > multiMaxCharNum) {
            return `${label.substring(0, multiMaxCharNum)}...`;
          }
          return label;
        }).join(", ");
      }
      if (remote) {
        return getRemoteSelectLabel(modelValue);
      }
      return getSelectLabel(modelValue);
    });
    const getOptkey = () => {
      const optionOpts = computeOptionOpts.value;
      return optionOpts.keyField || props.optionId || "_X_OPTION_KEY";
    };
    const getOptid = (option) => {
      const optid = option[getOptkey()];
      return optid ? encodeURIComponent(optid) : "";
    };
    const refreshOption = () => {
      const { filterable, filterMethod } = props;
      const { fullOptionList, fullGroupList, searchValue } = reactData;
      const isGroup = computeIsGroup.value;
      const groupLabelField = computeGroupLabelField.value;
      const labelField = computeLabelField.value;
      if (isGroup) {
        if (filterable && filterMethod) {
          reactData.visibleGroupList = fullGroupList.filter((group) => isOptionVisible(group) && filterMethod({ group, option: null, searchValue }));
        } else if (filterable) {
          reactData.visibleGroupList = fullGroupList.filter((group) => isOptionVisible(group) && (!searchValue || `${group[groupLabelField]}`.indexOf(searchValue) > -1));
        } else {
          reactData.visibleGroupList = fullGroupList.filter(isOptionVisible);
        }
      } else {
        if (filterable && filterMethod) {
          reactData.visibleOptionList = fullOptionList.filter((option) => isOptionVisible(option) && filterMethod({ group: null, option, searchValue }));
        } else if (filterable) {
          reactData.visibleOptionList = fullOptionList.filter((option) => isOptionVisible(option) && (!searchValue || `${option[labelField]}`.indexOf(searchValue) > -1));
        } else {
          reactData.visibleOptionList = fullOptionList.filter(isOptionVisible);
        }
      }
      return nextTick();
    };
    const cacheItemMap = () => {
      const { fullOptionList, fullGroupList } = reactData;
      const groupOptionsField = computeGroupOptionsField.value;
      const key = getOptkey();
      const handleOptis = (item) => {
        if (!getOptid(item)) {
          item[key] = getOptUniqueId();
        }
      };
      if (fullGroupList.length) {
        fullGroupList.forEach((group) => {
          handleOptis(group);
          if (group[groupOptionsField]) {
            group[groupOptionsField].forEach(handleOptis);
          }
        });
      } else if (fullOptionList.length) {
        fullOptionList.forEach(handleOptis);
      }
      refreshOption();
    };
    const setCurrentOption = (option) => {
      const valueField = computeValueField.value;
      if (option) {
        reactData.currentOption = option;
        reactData.currentValue = option[valueField];
      }
    };
    const scrollToOption = (option, isAlignBottom) => {
      return nextTick().then(() => {
        if (option) {
          const optWrapperElem = refOptionWrapper.value;
          const panelElem = refOptionPanel.value;
          const optElem = panelElem.querySelector(`[optid='${getOptid(option)}']`);
          if (optWrapperElem && optElem) {
            const wrapperHeight = optWrapperElem.offsetHeight;
            const offsetPadding = 5;
            if (isAlignBottom) {
              if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
              }
            } else {
              if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
              }
            }
          }
        }
      });
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { transfer, placement } = props;
        const { panelIndex } = reactData;
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        if (panelElem && el) {
          const targetHeight = el.offsetHeight;
          const targetWidth = el.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(el);
          let panelPlacement = "bottom";
          if (transfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    let hidePanelTimeout;
    const showOptionPanel = () => {
      const { loading, disabled, filterable } = props;
      if (!loading && !disabled) {
        clearTimeout(hidePanelTimeout);
        if (!reactData.inited) {
          reactData.inited = true;
        }
        reactData.isActivated = true;
        reactData.animatVisible = true;
        if (filterable) {
          refreshOption();
        }
        setTimeout(() => {
          const { modelValue, multiple } = props;
          const currOption = findOption(multiple && modelValue ? modelValue[0] : modelValue);
          reactData.visiblePanel = true;
          if (currOption) {
            setCurrentOption(currOption);
            scrollToOption(currOption);
          }
          handleFocusSearch();
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.searchValue = "";
      reactData.searchLoading = false;
      reactData.visiblePanel = false;
      hidePanelTimeout = window.setTimeout(() => {
        reactData.animatVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      if (selectValue !== props.modelValue) {
        emit("update:modelValue", selectValue);
        selectMethods.dispatchEvent("change", { value: selectValue }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      reactData.remoteValueList = [];
      changeEvent(evnt, selectValue);
      selectMethods.dispatchEvent("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const changeOptionEvent = (evnt, selectValue, option) => {
      const { modelValue, multiple } = props;
      const { remoteValueList } = reactData;
      if (multiple) {
        let multipleValue;
        if (modelValue) {
          if (modelValue.indexOf(selectValue) === -1) {
            multipleValue = modelValue.concat([selectValue]);
          } else {
            multipleValue = modelValue.filter((val) => val !== selectValue);
          }
        } else {
          multipleValue = [selectValue];
        }
        const remoteItem = remoteValueList.find((item) => item.key === selectValue);
        if (remoteItem) {
          remoteItem.result = option;
        } else {
          remoteValueList.push({ key: selectValue, result: option });
        }
        changeEvent(evnt, multipleValue);
      } else {
        reactData.remoteValueList = [{ key: selectValue, result: option }];
        changeEvent(evnt, selectValue);
        hideOptionPanel();
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      if (!disabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      if (!disabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const findOffsetOption = (optionValue, isUpArrow) => {
      const { visibleOptionList, visibleGroupList } = reactData;
      const isGroup = computeIsGroup.value;
      const valueField = computeValueField.value;
      const groupOptionsField = computeGroupOptionsField.value;
      let firstOption;
      let prevOption;
      let nextOption;
      let currOption;
      if (isGroup) {
        for (let gIndex = 0; gIndex < visibleGroupList.length; gIndex++) {
          const group = visibleGroupList[gIndex];
          const groupOptionList = group[groupOptionsField];
          const isGroupDisabled = group.disabled;
          if (groupOptionList) {
            for (let index = 0; index < groupOptionList.length; index++) {
              const option = groupOptionList[index];
              const isVisible = isOptionVisible(option);
              const isDisabled = isGroupDisabled || option.disabled;
              if (!firstOption && !isDisabled) {
                firstOption = option;
              }
              if (currOption) {
                if (isVisible && !isDisabled) {
                  nextOption = option;
                  if (!isUpArrow) {
                    return { offsetOption: nextOption };
                  }
                }
              }
              if (optionValue === option[valueField]) {
                currOption = option;
                if (isUpArrow) {
                  return { offsetOption: prevOption };
                }
              } else {
                if (isVisible && !isDisabled) {
                  prevOption = option;
                }
              }
            }
          }
        }
      } else {
        for (let index = 0; index < visibleOptionList.length; index++) {
          const option = visibleOptionList[index];
          const isDisabled = option.disabled;
          if (!firstOption && !isDisabled) {
            firstOption = option;
          }
          if (currOption) {
            if (!isDisabled) {
              nextOption = option;
              if (!isUpArrow) {
                return { offsetOption: nextOption };
              }
            }
          }
          if (optionValue === option[valueField]) {
            currOption = option;
            if (isUpArrow) {
              return { offsetOption: prevOption };
            }
          } else {
            if (!isDisabled) {
              prevOption = option;
            }
          }
        }
      }
      return { firstOption };
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable, disabled } = props;
      const { visiblePanel, currentValue, currentOption } = reactData;
      if (!disabled) {
        const isTab = hasEventKey(evnt, EVENT_KEYS.TAB);
        const isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);
        const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
        const isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
        const isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
        const isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);
        const isSpacebar = hasEventKey(evnt, EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            evnt.preventDefault();
            evnt.stopPropagation();
            changeOptionEvent(evnt, currentValue, currentOption);
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
            let { firstOption, offsetOption } = findOffsetOption(currentValue, isUpArrow);
            if (!offsetOption && !findOption(currentValue)) {
              offsetOption = firstOption;
            }
            setCurrentOption(offsetOption);
            scrollToOption(offsetOption, isDwArrow);
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const handleFocusSearch = () => {
      if (props.filterable) {
        nextTick(() => {
          const inpSearch = refInpSearch.value;
          if (inpSearch) {
            inpSearch.focus();
          }
        });
      }
    };
    const focusEvent = (evnt) => {
      if (!props.disabled) {
        reactData.isActivated = true;
      }
      selectMethods.dispatchEvent("focus", {}, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      selectMethods.dispatchEvent("blur", {}, evnt);
    };
    const modelSearchEvent = (value) => {
      reactData.searchValue = value;
    };
    const focusSearchEvent = () => {
      reactData.isActivated = true;
    };
    const keydownSearchEvent = (params) => {
      const { $event } = params;
      const isEnter = hasEventKey($event, EVENT_KEYS.ENTER);
      if (isEnter) {
        $event.preventDefault();
        $event.stopPropagation();
      }
    };
    const triggerSearchEvent = import_xe_utils24.default.debounce(function() {
      const { remote, remoteMethod } = props;
      const { searchValue } = reactData;
      if (remote && remoteMethod) {
        reactData.searchLoading = true;
        Promise.resolve(remoteMethod({ searchValue })).then(() => nextTick()).catch(() => nextTick()).finally(() => {
          reactData.searchLoading = false;
          refreshOption();
        });
      } else {
        refreshOption();
      }
    }, 350, { trailing: true });
    const togglePanelEvent = (params) => {
      const { $event } = params;
      $event.preventDefault();
      if (reactData.visiblePanel) {
        hideOptionPanel();
      } else {
        showOptionPanel();
      }
    };
    const checkOptionDisabled = (isSelected, option, group) => {
      if (option.disabled) {
        return true;
      }
      if (group && group.disabled) {
        return true;
      }
      const isMaximize = computeIsMaximize.value;
      if (isMaximize && !isSelected) {
        return true;
      }
      return false;
    };
    const renderOption = (list, group) => {
      const { optionKey, modelValue, multiple } = props;
      const { currentValue } = reactData;
      const optionOpts = computeOptionOpts.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const isGroup = computeIsGroup.value;
      const { useKey } = optionOpts;
      const optionSlot = slots.option;
      return list.map((option, cIndex) => {
        const { slots: slots2, className } = option;
        const optionValue = option[valueField];
        const isSelected = multiple ? modelValue && modelValue.indexOf(optionValue) > -1 : modelValue === optionValue;
        const isVisible = !isGroup || isOptionVisible(option);
        const isDisabled = checkOptionDisabled(isSelected, option, group);
        const optid = getOptid(option);
        const defaultSlot = slots2 ? slots2.default : null;
        const optParams = { option, group: null, $select: $xeselect };
        return isVisible ? h("div", {
          key: useKey || optionKey ? optid : cIndex,
          class: ["vxe-select-option", className ? import_xe_utils24.default.isFunction(className) ? className(optParams) : className : "", {
            "is--disabled": isDisabled,
            "is--selected": isSelected,
            "is--hover": currentValue === optionValue
          }],
          // attrs
          optid,
          // event
          onMousedown: (evnt) => {
            const isLeftBtn = evnt.button === 0;
            if (isLeftBtn) {
              evnt.stopPropagation();
            }
          },
          onClick: (evnt) => {
            if (!isDisabled) {
              changeOptionEvent(evnt, optionValue, option);
            }
          },
          onMouseenter: () => {
            if (!isDisabled) {
              setCurrentOption(option);
            }
          }
        }, optionSlot ? callSlot(optionSlot, optParams) : defaultSlot ? callSlot(defaultSlot, optParams) : formatText(getFuncText(option[labelField]))) : null;
      });
    };
    const renderOptgroup = () => {
      const { optionKey } = props;
      const { visibleGroupList } = reactData;
      const optionOpts = computeOptionOpts.value;
      const groupLabelField = computeGroupLabelField.value;
      const groupOptionsField = computeGroupOptionsField.value;
      const { useKey } = optionOpts;
      const optionSlot = slots.option;
      return visibleGroupList.map((group, gIndex) => {
        const { slots: slots2, className } = group;
        const optid = getOptid(group);
        const isGroupDisabled = group.disabled;
        const defaultSlot = slots2 ? slots2.default : null;
        const optParams = { option: group, group, $select: $xeselect };
        return h("div", {
          key: useKey || optionKey ? optid : gIndex,
          class: ["vxe-optgroup", className ? import_xe_utils24.default.isFunction(className) ? className(optParams) : className : "", {
            "is--disabled": isGroupDisabled
          }],
          // attrs
          optid
        }, [
          h("div", {
            class: "vxe-optgroup--title"
          }, optionSlot ? callSlot(optionSlot, optParams) : defaultSlot ? callSlot(defaultSlot, optParams) : getFuncText(group[groupLabelField])),
          h("div", {
            class: "vxe-optgroup--wrapper"
          }, renderOption(group[groupOptionsField] || [], group))
        ]);
      });
    };
    const renderOpts = () => {
      const { visibleGroupList, visibleOptionList, searchLoading } = reactData;
      const isGroup = computeIsGroup.value;
      if (searchLoading) {
        return [
          h("div", {
            class: "vxe-select--search-loading"
          }, [
            h("i", {
              class: ["vxe-select--search-icon", conf_default.icon.SELECT_LOADED]
            }),
            h("span", {
              class: "vxe-select--search-text"
            }, conf_default.i18n("vxe.select.loadingText"))
          ])
        ];
      }
      if (isGroup) {
        if (visibleGroupList.length) {
          return renderOptgroup();
        }
      } else {
        if (visibleOptionList.length) {
          return renderOption(visibleOptionList);
        }
      }
      return [
        h("div", {
          class: "vxe-select--empty-placeholder"
        }, props.emptyText || conf_default.i18n("vxe.select.emptyText"))
      ];
    };
    selectMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $select: $xeselect, $event: evnt }, params));
      },
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return nextTick();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return nextTick();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return nextTick();
      },
      refreshOption,
      focus() {
        const $input = refInput.value;
        reactData.isActivated = true;
        $input.blur();
        return nextTick();
      },
      blur() {
        const $input = refInput.value;
        $input.blur();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xeselect, selectMethods);
    watch(() => reactData.staticOptions, (value) => {
      if (value.some((item) => item.options && item.options.length)) {
        reactData.fullOptionList = [];
        reactData.fullGroupList = value;
      } else {
        reactData.fullGroupList = [];
        reactData.fullOptionList = value || [];
      }
      cacheItemMap();
    });
    watch(() => props.options, (value) => {
      reactData.fullGroupList = [];
      reactData.fullOptionList = value || [];
      cacheItemMap();
    });
    watch(() => props.optionGroups, (value) => {
      reactData.fullOptionList = [];
      reactData.fullGroupList = value || [];
      cacheItemMap();
    });
    onMounted(() => {
      nextTick(() => {
        const { options, optionGroups } = props;
        if (optionGroups) {
          reactData.fullGroupList = optionGroups;
        } else if (options) {
          reactData.fullOptionList = options;
        }
        cacheItemMap();
      });
      GlobalEvent.on($xeselect, "mousewheel", handleGlobalMousewheelEvent);
      GlobalEvent.on($xeselect, "mousedown", handleGlobalMousedownEvent);
      GlobalEvent.on($xeselect, "keydown", handleGlobalKeydownEvent);
      GlobalEvent.on($xeselect, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      GlobalEvent.off($xeselect, "mousewheel");
      GlobalEvent.off($xeselect, "mousedown");
      GlobalEvent.off($xeselect, "keydown");
      GlobalEvent.off($xeselect, "blur");
    });
    const renderVN = () => {
      const { className, popupClassName, transfer, disabled, loading, filterable } = props;
      const { inited, isActivated, visiblePanel } = reactData;
      const vSize = computeSize.value;
      const selectLabel = computeSelectLabel.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      return h("div", {
        ref: refElem,
        class: ["vxe-select", className ? import_xe_utils24.default.isFunction(className) ? className({ $select: $xeselect }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visivle": visiblePanel,
          "is--disabled": disabled,
          "is--filter": filterable,
          "is--loading": loading,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          class: "vxe-select-slots",
          ref: "hideOption"
        }, defaultSlot ? defaultSlot({}) : []),
        h(input_default, {
          ref: refInput,
          clearable: props.clearable,
          placeholder: props.placeholder,
          readonly: true,
          disabled,
          type: "text",
          prefixIcon: props.prefixIcon,
          suffixIcon: loading ? conf_default.icon.SELECT_LOADED : visiblePanel ? conf_default.icon.SELECT_OPEN : conf_default.icon.SELECT_CLOSE,
          modelValue: selectLabel,
          onClear: clearEvent,
          onClick: togglePanelEvent,
          onFocus: focusEvent,
          onBlur: blurEvent,
          onSuffixClick: togglePanelEvent
        }, prefixSlot ? {
          prefix: () => prefixSlot({})
        } : {}),
        h(Teleport, {
          to: "body",
          disabled: transfer ? !inited : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-select--panel", popupClassName ? import_xe_utils24.default.isFunction(popupClassName) ? popupClassName({ $select: $xeselect }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": transfer,
              "animat--leave": !loading && reactData.animatVisible,
              "animat--enter": !loading && visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, inited ? [
            filterable ? h("div", {
              class: "vxe-select--panel-search"
            }, [
              h(input_default, {
                ref: refInpSearch,
                class: "vxe-select-search--input",
                modelValue: reactData.searchValue,
                clearable: true,
                placeholder: conf_default.i18n("vxe.select.search"),
                prefixIcon: conf_default.icon.INPUT_SEARCH,
                "onUpdate:modelValue": modelSearchEvent,
                onFocus: focusSearchEvent,
                onKeydown: keydownSearchEvent,
                onChange: triggerSearchEvent,
                onSearch: triggerSearchEvent
              })
            ]) : createCommentVNode(),
            h("div", {
              class: "vxe-select--panel-wrapper"
            }, [
              headerSlot ? h("div", {
                class: "vxe-select--panel-header"
              }, headerSlot({})) : createCommentVNode(),
              h("div", {
                class: "vxe-select--panel-body"
              }, [
                h("div", {
                  ref: refOptionWrapper,
                  class: "vxe-select-option--wrapper"
                }, renderOpts())
              ]),
              footerSlot ? h("div", {
                class: "vxe-select--panel-footer"
              }, footerSlot({})) : createCommentVNode()
            ])
          ] : [])
        ])
      ]);
    };
    $xeselect.renderVN = renderVN;
    provide("$xeselect", $xeselect);
    return $xeselect;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/export/src/export-panel.js
var export_panel_default = defineComponent({
  name: "VxeTableExportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const $xetable = inject("$xetable", {});
    const { computeExportOpts, computePrintOpts } = $xetable.getComputeMaps();
    const reactData = reactive({
      isAll: false,
      isIndeterminate: false,
      loading: false
    });
    const xButtonConfirm = ref();
    const xInputFilename = ref();
    const xInputSheetname = ref();
    const computeCheckedAll = computed(() => {
      const { storeData: storeData2 } = props;
      return storeData2.columns.every((column) => column.checked);
    });
    const computeShowSheet = computed(() => {
      const { defaultOptions } = props;
      return ["html", "xml", "xlsx", "pdf"].indexOf(defaultOptions.type) > -1;
    });
    const computeSupportMerge = computed(() => {
      const { storeData: storeData2, defaultOptions } = props;
      return !defaultOptions.original && defaultOptions.mode === "current" && (storeData2.isPrint || ["html", "xlsx"].indexOf(defaultOptions.type) > -1);
    });
    const computeSupportStyle = computed(() => {
      const { defaultOptions } = props;
      return !defaultOptions.original && ["xlsx"].indexOf(defaultOptions.type) > -1;
    });
    const handleOptionCheck = (column) => {
      const { storeData: storeData2 } = props;
      const matchObj = import_xe_utils25.default.findTree(storeData2.columns, (item) => item === column);
      if (matchObj && matchObj.parent) {
        const { parent } = matchObj;
        if (parent.children && parent.children.length) {
          parent.checked = parent.children.every((column2) => column2.checked);
          parent.halfChecked = !parent.checked && parent.children.some((column2) => column2.checked || column2.halfChecked);
          handleOptionCheck(parent);
        }
      }
    };
    const checkStatus = () => {
      const { storeData: storeData2 } = props;
      const columns = storeData2.columns;
      reactData.isAll = columns.every((column) => column.disabled || column.checked);
      reactData.isIndeterminate = !reactData.isAll && columns.some((column) => !column.disabled && (column.checked || column.halfChecked));
    };
    const changeOption = (column) => {
      const isChecked = !column.checked;
      import_xe_utils25.default.eachTree([column], (item) => {
        item.checked = isChecked;
        item.halfChecked = false;
      });
      handleOptionCheck(column);
      checkStatus();
    };
    const allColumnEvent = () => {
      const { storeData: storeData2 } = props;
      const isAll = !reactData.isAll;
      import_xe_utils25.default.eachTree(storeData2.columns, (column) => {
        if (!column.disabled) {
          column.checked = isAll;
          column.halfChecked = false;
        }
      });
      reactData.isAll = isAll;
      checkStatus();
    };
    const showEvent = () => {
      nextTick(() => {
        const filenameInp = xInputFilename.value;
        const sheetnameInp = xInputSheetname.value;
        const confirmBtn = xButtonConfirm.value;
        const targetElem = filenameInp || sheetnameInp || confirmBtn;
        if (targetElem) {
          targetElem.focus();
        }
      });
      checkStatus();
    };
    const getExportOption = () => {
      const { storeData: storeData2, defaultOptions } = props;
      const { hasMerge, columns } = storeData2;
      const checkedAll = computeCheckedAll.value;
      const supportMerge = computeSupportMerge.value;
      const expColumns = import_xe_utils25.default.searchTree(columns, (column) => column.checked, { children: "children", mapChildren: "childNodes", original: true });
      return Object.assign({}, defaultOptions, {
        columns: expColumns,
        isMerge: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false
      });
    };
    const printEvent = () => {
      const { storeData: storeData2 } = props;
      const printOpts = computePrintOpts.value;
      storeData2.visible = false;
      $xetable.print(Object.assign({}, printOpts, getExportOption()));
    };
    const exportEvent = () => {
      const { storeData: storeData2 } = props;
      const exportOpts = computeExportOpts.value;
      reactData.loading = true;
      $xetable.exportData(Object.assign({}, exportOpts, getExportOption())).then(() => {
        reactData.loading = false;
        storeData2.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const cancelEvent = () => {
      const { storeData: storeData2 } = props;
      storeData2.visible = false;
    };
    const confirmEvent = () => {
      const { storeData: storeData2 } = props;
      if (storeData2.isPrint) {
        printEvent();
      } else {
        exportEvent();
      }
    };
    const renderVN = () => {
      const { defaultOptions, storeData: storeData2 } = props;
      const { isAll: isAllChecked, isIndeterminate: isAllIndeterminate } = reactData;
      const { hasTree, hasMerge, isPrint, hasColgroup } = storeData2;
      const { isHeader } = defaultOptions;
      const cols = [];
      const checkedAll = computeCheckedAll.value;
      const showSheet = computeShowSheet.value;
      const supportMerge = computeSupportMerge.value;
      const supportStyle = computeSupportStyle.value;
      import_xe_utils25.default.eachTree(storeData2.columns, (column) => {
        const colTitle = formatText(column.getTitle(), 1);
        const isColGroup = column.children && column.children.length;
        const isChecked = column.checked;
        const indeterminate = column.halfChecked;
        cols.push(h("li", {
          class: ["vxe-export--panel-column-option", `level--${column.level}`, {
            "is--group": isColGroup,
            "is--checked": isChecked,
            "is--indeterminate": indeterminate,
            "is--disabled": column.disabled
          }],
          title: colTitle,
          onClick: () => {
            if (!column.disabled) {
              changeOption(column);
            }
          }
        }, [
          h("span", {
            class: ["vxe-checkbox--icon", indeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
          }),
          h("span", {
            class: "vxe-checkbox--label"
          }, colTitle)
        ]));
      });
      return h(modal_default, {
        modelValue: storeData2.visible,
        title: conf_default.i18n(isPrint ? "vxe.export.printTitle" : "vxe.export.expTitle"),
        className: "vxe-table-export-popup-wrapper",
        width: 660,
        mask: true,
        lockView: true,
        showFooter: false,
        escClosable: true,
        maskClosable: true,
        loading: reactData.loading,
        "onUpdate:modelValue"(value) {
          storeData2.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          return h("div", {
            class: "vxe-export--panel"
          }, [
            h("table", {
              cellspacing: 0,
              cellpadding: 0,
              border: 0
            }, [
              h("tbody", [
                [
                  isPrint ? createCommentVNode() : h("tr", [
                    h("td", conf_default.i18n("vxe.export.expName")),
                    h("td", [
                      h(input_default, {
                        ref: xInputFilename,
                        modelValue: defaultOptions.filename,
                        type: "text",
                        clearable: true,
                        placeholder: conf_default.i18n("vxe.export.expNamePlaceholder"),
                        "onUpdate:modelValue"(value) {
                          defaultOptions.filename = value;
                        }
                      })
                    ])
                  ]),
                  isPrint ? createCommentVNode() : h("tr", [
                    h("td", conf_default.i18n("vxe.export.expType")),
                    h("td", [
                      h(select_default, {
                        modelValue: defaultOptions.type,
                        options: storeData2.typeList.map((item) => {
                          return {
                            value: item.value,
                            label: conf_default.i18n(item.label)
                          };
                        }),
                        "onUpdate:modelValue"(value) {
                          defaultOptions.type = value;
                        }
                      })
                    ])
                  ]),
                  isPrint || showSheet ? h("tr", [
                    h("td", conf_default.i18n("vxe.export.expSheetName")),
                    h("td", [
                      h(input_default, {
                        ref: xInputSheetname,
                        modelValue: defaultOptions.sheetName,
                        type: "text",
                        clearable: true,
                        placeholder: conf_default.i18n("vxe.export.expSheetNamePlaceholder"),
                        "onUpdate:modelValue"(value) {
                          defaultOptions.sheetName = value;
                        }
                      })
                    ])
                  ]) : createCommentVNode(),
                  h("tr", [
                    h("td", conf_default.i18n("vxe.export.expMode")),
                    h("td", [
                      h(select_default, {
                        modelValue: defaultOptions.mode,
                        options: storeData2.modeList.map((item) => {
                          return {
                            value: item.value,
                            label: conf_default.i18n(item.label)
                          };
                        }),
                        "onUpdate:modelValue"(value) {
                          defaultOptions.mode = value;
                        }
                      })
                    ])
                  ]),
                  h("tr", [
                    h("td", [conf_default.i18n("vxe.export.expColumn")]),
                    h("td", [
                      h("div", {
                        class: "vxe-export--panel-column"
                      }, [
                        h("ul", {
                          class: "vxe-export--panel-column-header"
                        }, [
                          h("li", {
                            class: ["vxe-export--panel-column-option", {
                              "is--checked": isAllChecked,
                              "is--indeterminate": isAllIndeterminate
                            }],
                            title: conf_default.i18n("vxe.table.allTitle"),
                            onClick: allColumnEvent
                          }, [
                            h("span", {
                              class: ["vxe-checkbox--icon", isAllIndeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
                            }),
                            h("span", {
                              class: "vxe-checkbox--label"
                            }, conf_default.i18n("vxe.export.expCurrentColumn"))
                          ])
                        ]),
                        h("ul", {
                          class: "vxe-export--panel-column-body"
                        }, cols)
                      ])
                    ])
                  ]),
                  h("tr", [
                    h("td", conf_default.i18n("vxe.export.expOpts")),
                    h("td", [
                      h("div", {
                        class: "vxe-export--panel-option-row"
                      }, [
                        h(checkbox_default, {
                          modelValue: defaultOptions.isHeader,
                          title: conf_default.i18n("vxe.export.expHeaderTitle"),
                          content: conf_default.i18n("vxe.export.expOptHeader"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.isHeader = value;
                          }
                        }),
                        h(checkbox_default, {
                          modelValue: defaultOptions.isFooter,
                          disabled: !storeData2.hasFooter,
                          title: conf_default.i18n("vxe.export.expFooterTitle"),
                          content: conf_default.i18n("vxe.export.expOptFooter"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.isFooter = value;
                          }
                        }),
                        h(checkbox_default, {
                          modelValue: defaultOptions.original,
                          title: conf_default.i18n("vxe.export.expOriginalTitle"),
                          content: conf_default.i18n("vxe.export.expOptOriginal"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.original = value;
                          }
                        })
                      ]),
                      h("div", {
                        class: "vxe-export--panel-option-row"
                      }, [
                        h(checkbox_default, {
                          modelValue: isHeader && hasColgroup && supportMerge ? defaultOptions.isColgroup : false,
                          title: conf_default.i18n("vxe.export.expColgroupTitle"),
                          disabled: !isHeader || !hasColgroup || !supportMerge,
                          content: conf_default.i18n("vxe.export.expOptColgroup"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.isColgroup = value;
                          }
                        }),
                        h(checkbox_default, {
                          modelValue: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false,
                          title: conf_default.i18n("vxe.export.expMergeTitle"),
                          disabled: !hasMerge || !supportMerge || !checkedAll,
                          content: conf_default.i18n("vxe.export.expOptMerge"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.isMerge = value;
                          }
                        }),
                        isPrint ? createCommentVNode() : h(checkbox_default, {
                          modelValue: supportStyle ? defaultOptions.useStyle : false,
                          disabled: !supportStyle,
                          title: conf_default.i18n("vxe.export.expUseStyleTitle"),
                          content: conf_default.i18n("vxe.export.expOptUseStyle"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.useStyle = value;
                          }
                        }),
                        h(checkbox_default, {
                          modelValue: hasTree ? defaultOptions.isAllExpand : false,
                          disabled: !hasTree,
                          title: conf_default.i18n("vxe.export.expAllExpandTitle"),
                          content: conf_default.i18n("vxe.export.expOptAllExpand"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.isAllExpand = value;
                          }
                        })
                      ])
                    ])
                  ])
                ]
              ])
            ]),
            h("div", {
              class: "vxe-export--panel-btns"
            }, [
              h(button_default, {
                content: conf_default.i18n("vxe.export.expCancel"),
                onClick: cancelEvent
              }),
              h(button_default, {
                ref: xButtonConfirm,
                status: "primary",
                content: conf_default.i18n(isPrint ? "vxe.export.expPrint" : "vxe.export.expConfirm"),
                onClick: confirmEvent
              })
            ])
          ]);
        }
      });
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/export/src/import-panel.js
var import_xe_utils29 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/radio/src/group.js
var import_xe_utils28 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/radio/src/radio.js
var import_xe_utils26 = __toESM(require_xe_utils());
var radio_default = defineComponent({
  name: "VxeRadio",
  props: {
    modelValue: [String, Number, Boolean],
    label: { type: [String, Number, Boolean], default: null },
    title: [String, Number],
    content: [String, Number],
    disabled: Boolean,
    name: String,
    strict: { type: Boolean, default: () => conf_default.radio.strict },
    size: { type: String, default: () => conf_default.radio.size || conf_default.size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils26.default.uniqueId();
    const $xeradio = {
      xID,
      props,
      context
    };
    const computeSize = useSize(props);
    const $xeradiogroup = inject("$xeradiogroup", null);
    let radioMethods = {};
    const computeDisabled = computed(() => {
      return props.disabled || $xeradiogroup && $xeradiogroup.props.disabled;
    });
    const computeName = computed(() => {
      return $xeradiogroup ? $xeradiogroup.name : props.name;
    });
    const computeStrict = computed(() => {
      return $xeradiogroup ? $xeradiogroup.props.strict : props.strict;
    });
    const computeChecked = computed(() => {
      const { modelValue, label } = props;
      return $xeradiogroup ? $xeradiogroup.props.modelValue === label : modelValue === label;
    });
    const handleValue = (label, evnt) => {
      if ($xeradiogroup) {
        $xeradiogroup.handleChecked({ label }, evnt);
      } else {
        emit("update:modelValue", label);
        radioMethods.dispatchEvent("change", { label }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, label);
        }
      }
    };
    const changeEvent = (evnt) => {
      const isDisabled = computeDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    const clickEvent = (evnt) => {
      const isDisabled = computeDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeradiogroup ? $xeradiogroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    radioMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $radio: $xeradio, $event: evnt }, params));
      }
    };
    Object.assign($xeradio, radioMethods);
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeDisabled.value;
      const name = computeName.value;
      const isChecked = computeChecked.value;
      return h("label", {
        class: ["vxe-radio", {
          [`size--${vSize}`]: vSize,
          "is--checked": isChecked,
          "is--disabled": isDisabled
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-radio--input",
          type: "radio",
          name,
          checked: isChecked,
          disabled: isDisabled,
          onChange: changeEvent,
          onClick: clickEvent
        }),
        h("span", {
          class: ["vxe-radio--icon", isChecked ? "vxe-icon-radio-checked" : "vxe-icon-radio-unchecked"]
        }),
        h("span", {
          class: "vxe-radio--label"
        }, slots.default ? slots.default({}) : getFuncText(props.content))
      ]);
    };
    $xeradio.renderVN = renderVN;
    return $xeradio;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/radio/src/button.js
var import_xe_utils27 = __toESM(require_xe_utils());
var button_default2 = defineComponent({
  name: "VxeRadioButton",
  props: {
    modelValue: [String, Number, Boolean],
    label: { type: [String, Number, Boolean], default: null },
    title: [String, Number],
    content: [String, Number],
    disabled: Boolean,
    strict: { type: Boolean, default: () => conf_default.radioButton.strict },
    size: { type: String, default: () => conf_default.radioButton.size || conf_default.size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils27.default.uniqueId();
    const computeSize = useSize(props);
    const $xeradiobutton = {
      xID,
      props,
      context
    };
    let radioButtonMethods = {};
    const $xeradiogroup = inject("$xeradiogroup", null);
    const computeDisabled = computed(() => {
      return props.disabled || $xeradiogroup && $xeradiogroup.props.disabled;
    });
    const computeName = computed(() => {
      return $xeradiogroup ? $xeradiogroup.name : null;
    });
    const computeStrict = computed(() => {
      return $xeradiogroup ? $xeradiogroup.props.strict : props.strict;
    });
    const computeChecked = computed(() => {
      const { modelValue, label } = props;
      return $xeradiogroup ? $xeradiogroup.props.modelValue === label : modelValue === label;
    });
    radioButtonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $radioButton: $xeradiobutton, $event: evnt }, params));
      }
    };
    Object.assign($xeradiobutton, radioButtonMethods);
    const handleValue = (label, evnt) => {
      if ($xeradiogroup) {
        $xeradiogroup.handleChecked({ label }, evnt);
      } else {
        emit("update:modelValue", label);
        radioButtonMethods.dispatchEvent("change", { label }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, label);
        }
      }
    };
    const changeEvent = (evnt) => {
      const isDisabled = computeDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    const clickEvent = (evnt) => {
      const isDisabled = computeDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeradiogroup ? $xeradiogroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeDisabled.value;
      const name = computeName.value;
      const checked = computeChecked.value;
      return h("label", {
        class: ["vxe-radio", "vxe-radio-button", {
          [`size--${vSize}`]: vSize,
          "is--disabled": isDisabled
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-radio--input",
          type: "radio",
          name,
          checked,
          disabled: isDisabled,
          onChange: changeEvent,
          onClick: clickEvent
        }),
        h("span", {
          class: "vxe-radio--label"
        }, slots.default ? slots.default({}) : getFuncText(props.content))
      ]);
    };
    Object.assign($xeradiobutton, {
      renderVN,
      dispatchEvent
    });
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/radio/src/group.js
var group_default = defineComponent({
  name: "VxeRadioGroup",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: Boolean,
    type: String,
    options: Array,
    optionProps: Object,
    strict: { type: Boolean, default: () => conf_default.radioGroup.strict },
    size: { type: String, default: () => conf_default.radioGroup.size || conf_default.size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils28.default.uniqueId();
    const $xeradiogroup = {
      xID,
      props,
      context,
      name: import_xe_utils28.default.uniqueId("xegroup_")
    };
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeDisabledField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || "disabled";
    });
    let radioGroupMethods = {};
    useSize(props);
    const radioGroupPrivateMethods = {
      handleChecked(params, evnt) {
        emit("update:modelValue", params.label);
        radioGroupMethods.dispatchEvent("change", params);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, params.label);
        }
      }
    };
    radioGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $radioGroup: $xeradiogroup, $event: evnt }, params));
      }
    };
    const renderVN = () => {
      const { options, type } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      const btnComp = type === "button" ? button_default2 : radio_default;
      return h("div", {
        class: "vxe-radio-group"
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item) => {
        return h(btnComp, {
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    Object.assign($xeradiogroup, radioGroupPrivateMethods, {
      renderVN,
      dispatchEvent
    });
    provide("$xeradiogroup", $xeradiogroup);
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/export/src/import-panel.js
var import_panel_default = defineComponent({
  name: "VxeTableImportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const $xetable = inject("$xetable", {});
    const { computeImportOpts } = $xetable.getComputeMaps();
    const reactData = reactive({
      loading: false
    });
    const refFileBtn = ref();
    const computeSelectName = computed(() => {
      const { storeData: storeData2 } = props;
      return `${storeData2.filename}.${storeData2.type}`;
    });
    const computeHasFile = computed(() => {
      const { storeData: storeData2 } = props;
      return storeData2.file && storeData2.type;
    });
    const computeParseTypeLabel = computed(() => {
      const { storeData: storeData2 } = props;
      const { type, typeList } = storeData2;
      if (type) {
        const selectItem = import_xe_utils29.default.find(typeList, (item) => type === item.value);
        return selectItem ? conf_default.i18n(selectItem.label) : "*.*";
      }
      return `*.${typeList.map((item) => item.value).join(", *.")}`;
    });
    const clearFileEvent = () => {
      const { storeData: storeData2 } = props;
      Object.assign(storeData2, {
        filename: "",
        sheetName: "",
        type: ""
      });
    };
    const selectFileEvent = () => {
      const { storeData: storeData2, defaultOptions } = props;
      $xetable.readFile(defaultOptions).then((params) => {
        const { file } = params;
        Object.assign(storeData2, parseFile(file), { file });
      }).catch((e) => e);
    };
    const showEvent = () => {
      nextTick(() => {
        const targetElem = refFileBtn.value;
        if (targetElem) {
          targetElem.focus();
        }
      });
    };
    const cancelEvent = () => {
      const { storeData: storeData2 } = props;
      storeData2.visible = false;
    };
    const importEvent = () => {
      const { storeData: storeData2, defaultOptions } = props;
      const importOpts = computeImportOpts.value;
      reactData.loading = true;
      $xetable.importByFile(storeData2.file, Object.assign({}, importOpts, defaultOptions)).then(() => {
        reactData.loading = false;
        storeData2.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const renderVN = () => {
      const { defaultOptions, storeData: storeData2 } = props;
      const selectName = computeSelectName.value;
      const hasFile = computeHasFile.value;
      const parseTypeLabel = computeParseTypeLabel.value;
      return h(modal_default, {
        modelValue: storeData2.visible,
        title: conf_default.i18n("vxe.import.impTitle"),
        className: "vxe-table-import-popup-wrapper",
        width: 440,
        mask: true,
        lockView: true,
        showFooter: false,
        escClosable: true,
        maskClosable: true,
        loading: reactData.loading,
        "onUpdate:modelValue"(value) {
          storeData2.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          return h("div", {
            class: "vxe-export--panel"
          }, [
            h("table", {
              cellspacing: 0,
              cellpadding: 0,
              border: 0
            }, [
              h("tbody", [
                h("tr", [
                  h("td", conf_default.i18n("vxe.import.impFile")),
                  h("td", [
                    hasFile ? h("div", {
                      class: "vxe-import-selected--file",
                      title: selectName
                    }, [
                      h("span", selectName),
                      h("i", {
                        class: conf_default.icon.INPUT_CLEAR,
                        onClick: clearFileEvent
                      })
                    ]) : h("button", {
                      ref: refFileBtn,
                      class: "vxe-import-select--file",
                      onClick: selectFileEvent
                    }, conf_default.i18n("vxe.import.impSelect"))
                  ])
                ]),
                h("tr", [
                  h("td", conf_default.i18n("vxe.import.impType")),
                  h("td", parseTypeLabel)
                ]),
                h("tr", [
                  h("td", conf_default.i18n("vxe.import.impOpts")),
                  h("td", [
                    h(group_default, {
                      modelValue: defaultOptions.mode,
                      "onUpdate:modelValue"(value) {
                        defaultOptions.mode = value;
                      }
                    }, {
                      default: () => storeData2.modeList.map((item) => h(radio_default, { label: item.value, content: conf_default.i18n(item.label) }))
                    })
                  ])
                ])
              ])
            ]),
            h("div", {
              class: "vxe-export--panel-btns"
            }, [
              h(button_default, {
                content: conf_default.i18n("vxe.import.impCancel"),
                onClick: cancelEvent
              }),
              h(button_default, {
                status: "primary",
                disabled: !hasFile,
                content: conf_default.i18n("vxe.import.impConfirm"),
                onClick: importEvent
              })
            ])
          ]);
        }
      });
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/export/src/hook.js
var import_xe_utils31 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/export/src/util.js
var import_xe_utils30 = __toESM(require_xe_utils());
var fileForm;
var fileInput;
var printFrame;
var defaultHtmlStyle = 'body{margin:0;padding: 0 1px;color:#333333;font-size:14px;font-family:"Microsoft YaHei",,"MicrosoftJhengHei",,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function createFrame() {
  const frame = document.createElement("iframe");
  frame.className = "vxe-table--print-frame";
  return frame;
}
function getExportBlobByContent(content, options) {
  return new Blob([content], { type: `text/${options.type};charset=utf-8;` });
}
function createHtmlPage(opts, content) {
  const { style } = opts;
  return [
    "<!DOCTYPE html><html>",
    "<head>",
    '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">',
    `<title>${opts.sheetName}</title>`,
    '<style media="print">.vxe-page-break-before{page-break-before:always;}.vxe-page-break-after{page-break-after:always;}</style>',
    `<style>${defaultHtmlStyle}</style>`,
    style ? `<style>${style}</style>` : "",
    "</head>",
    `<body>${content}</body>`,
    "</html>"
  ].join("");
}
var readLocalFile = (options) => {
  const opts = Object.assign({}, options);
  if (!fileForm) {
    fileForm = document.createElement("form");
    fileInput = document.createElement("input");
    fileForm.className = "vxe-table--file-form";
    fileInput.name = "file";
    fileInput.type = "file";
    fileForm.appendChild(fileInput);
    document.body.appendChild(fileForm);
  }
  return new Promise((resolve, reject) => {
    const types = opts.types || [];
    const isAllType = !types.length || types.some((type) => type === "*");
    fileInput.multiple = !!opts.multiple;
    fileInput.accept = isAllType ? "" : `.${types.join(", .")}`;
    fileInput.onchange = (evnt) => {
      const { files } = evnt.target;
      const file = files[0];
      let errType = "";
      if (!isAllType) {
        for (let fIndex = 0; fIndex < files.length; fIndex++) {
          const { type } = parseFile(files[fIndex]);
          if (!import_xe_utils30.default.includes(types, type)) {
            errType = type;
            break;
          }
        }
      }
      if (!errType) {
        resolve({ status: true, files, file });
      } else {
        if (opts.message !== false) {
          if (true) {
            if (!VXETable.modal) {
              errLog("vxe.error.reqModule", ["Modal"]);
            }
          }
          VXETable.modal.message({ content: conf_default.i18n("vxe.error.notType", [errType]), status: "error" });
        }
        const params = { status: false, files, file };
        reject(params);
      }
    };
    fileForm.reset();
    fileInput.click();
  });
};
function removePrintFrame() {
  if (printFrame) {
    if (printFrame.parentNode) {
      try {
        printFrame.contentDocument.write("");
      } catch (e) {
      }
      printFrame.parentNode.removeChild(printFrame);
    }
    printFrame = null;
  }
}
function appendPrintFrame() {
  if (!printFrame.parentNode) {
    document.body.appendChild(printFrame);
  }
}
function afterPrintEvent() {
  requestAnimationFrame(removePrintFrame);
}
function handlePrint($xetable, opts, content = "") {
  const { beforePrintMethod } = opts;
  if (beforePrintMethod) {
    content = beforePrintMethod({ content, options: opts, $table: $xetable }) || "";
  }
  content = createHtmlPage(opts, content);
  const blob = getExportBlobByContent(content, opts);
  if (browse.msie) {
    removePrintFrame();
    printFrame = createFrame();
    appendPrintFrame();
    printFrame.contentDocument.write(content);
    printFrame.contentDocument.execCommand("print");
  } else {
    if (!printFrame) {
      printFrame = createFrame();
      printFrame.onload = (evnt) => {
        if (evnt.target.src) {
          evnt.target.contentWindow.onafterprint = afterPrintEvent;
          evnt.target.contentWindow.print();
        }
      };
    }
    appendPrintFrame();
    printFrame.src = URL.createObjectURL(blob);
  }
}
var saveLocalFile = (options) => {
  const { filename, type, content } = options;
  const name = `${filename}.${type}`;
  if (window.Blob) {
    const blob = content instanceof Blob ? content : getExportBlobByContent(import_xe_utils30.default.toValueString(content), options);
    if (navigator.msSaveBlob) {
      navigator.msSaveBlob(blob, name);
    } else {
      const url = URL.createObjectURL(blob);
      const linkElem = document.createElement("a");
      linkElem.target = "_blank";
      linkElem.download = name;
      linkElem.href = url;
      document.body.appendChild(linkElem);
      linkElem.click();
      requestAnimationFrame(() => {
        if (linkElem.parentNode) {
          linkElem.parentNode.removeChild(linkElem);
        }
        URL.revokeObjectURL(url);
      });
    }
    return Promise.resolve();
  }
  return Promise.reject(new Error(getLog("vxe.error.notExp")));
};

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/export/src/hook.js
var htmlCellElem;
var csvBOM = "\uFEFF";
var enterSymbol = "\r\n";
function defaultFilterExportColumn(column) {
  return column.property || ["seq", "checkbox", "radio"].indexOf(column.type) > -1;
}
var getConvertColumns = (columns) => {
  const result = [];
  columns.forEach((column) => {
    if (column.childNodes && column.childNodes.length) {
      result.push(column);
      result.push(...getConvertColumns(column.childNodes));
    } else {
      result.push(column);
    }
  });
  return result;
};
var convertToRows = (originColumns) => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column._level = parent._level + 1;
      if (maxLevel < column._level) {
        maxLevel = column._level;
      }
    }
    if (column.childNodes && column.childNodes.length) {
      let colSpan = 0;
      column.childNodes.forEach((subColumn) => {
        traverse(subColumn, column);
        colSpan += subColumn._colSpan;
      });
      column._colSpan = colSpan;
    } else {
      column._colSpan = 1;
    }
  };
  originColumns.forEach((column) => {
    column._level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getConvertColumns(originColumns);
  allColumns.forEach((column) => {
    if (column.childNodes && column.childNodes.length) {
      column._rowSpan = 1;
    } else {
      column._rowSpan = maxLevel - column._level + 1;
    }
    rows[column._level - 1].push(column);
  });
  return rows;
};
function toTableBorder(border) {
  if (border === true) {
    return "full";
  }
  if (border) {
    return border;
  }
  return "default";
}
function getBooleanValue(cellValue) {
  return cellValue === "TRUE" || cellValue === "true" || cellValue === true;
}
function getFooterData(opts, footerTableData) {
  const { footerFilterMethod } = opts;
  return footerFilterMethod ? footerTableData.filter((items, index) => footerFilterMethod({ items, $rowIndex: index })) : footerTableData;
}
function getCsvCellTypeLabel(column, cellValue) {
  if (cellValue) {
    if (column.type === "seq") {
      return `	${cellValue}`;
    }
    switch (column.cellType) {
      case "string":
        if (!isNaN(cellValue)) {
          return `	${cellValue}`;
        }
        break;
      case "number":
        break;
      default:
        if (cellValue.length >= 12 && !isNaN(cellValue)) {
          return `	${cellValue}`;
        }
        break;
    }
  }
  return cellValue;
}
function toTxtCellLabel(val) {
  if (/[",\s\n]/.test(val)) {
    return `"${val.replace(/"/g, '""')}"`;
  }
  return val;
}
function getElementsByTagName(elem, qualifiedName) {
  return elem.getElementsByTagName(qualifiedName);
}
function getTxtCellKey(now) {
  return `#${now}@${import_xe_utils31.default.uniqueId()}`;
}
function replaceTxtCell(cell, vMaps) {
  return cell.replace(/#\d+@\d+/g, (key) => import_xe_utils31.default.hasOwnProp(vMaps, key) ? vMaps[key] : key);
}
function getTxtCellValue(val, vMaps) {
  const rest = replaceTxtCell(val, vMaps);
  return rest.replace(/^"+$/g, (qVal) => '"'.repeat(Math.ceil(qVal.length / 2)));
}
function parseCsvAndTxt(columns, content, cellSeparator) {
  const list = content.split(enterSymbol);
  const rows = [];
  let fields = [];
  if (list.length) {
    const vMaps = {};
    const now = Date.now();
    list.forEach((rVal) => {
      if (rVal) {
        const item = {};
        rVal = rVal.replace(/("")|(\n)/g, (text, dVal) => {
          const key = getTxtCellKey(now);
          vMaps[key] = dVal ? '"' : "\n";
          return key;
        }).replace(/"(.*?)"/g, (text, cVal) => {
          const key = getTxtCellKey(now);
          vMaps[key] = replaceTxtCell(cVal, vMaps);
          return key;
        });
        const cells = rVal.split(cellSeparator);
        if (!fields.length) {
          fields = cells.map((val) => getTxtCellValue(val.trim(), vMaps));
        } else {
          cells.forEach((val, colIndex) => {
            if (colIndex < fields.length) {
              item[fields[colIndex]] = getTxtCellValue(val.trim(), vMaps);
            }
          });
          rows.push(item);
        }
      }
    });
  }
  return { fields, rows };
}
function parseCsv(columns, content) {
  return parseCsvAndTxt(columns, content, ",");
}
function parseTxt(columns, content) {
  return parseCsvAndTxt(columns, content, "	");
}
function parseHTML(columns, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, "text/html");
  const bodyNodes = getElementsByTagName(xmlDoc, "body");
  const rows = [];
  const fields = [];
  if (bodyNodes.length) {
    const tableNodes = getElementsByTagName(bodyNodes[0], "table");
    if (tableNodes.length) {
      const theadNodes = getElementsByTagName(tableNodes[0], "thead");
      if (theadNodes.length) {
        import_xe_utils31.default.arrayEach(getElementsByTagName(theadNodes[0], "tr"), (rowNode) => {
          import_xe_utils31.default.arrayEach(getElementsByTagName(rowNode, "th"), (cellNode) => {
            fields.push(cellNode.textContent);
          });
        });
        const tbodyNodes = getElementsByTagName(tableNodes[0], "tbody");
        if (tbodyNodes.length) {
          import_xe_utils31.default.arrayEach(getElementsByTagName(tbodyNodes[0], "tr"), (rowNode) => {
            const item = {};
            import_xe_utils31.default.arrayEach(getElementsByTagName(rowNode, "td"), (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent || "";
              }
            });
            rows.push(item);
          });
        }
      }
    }
  }
  return { fields, rows };
}
function parseXML(columns, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, "application/xml");
  const sheetNodes = getElementsByTagName(xmlDoc, "Worksheet");
  const rows = [];
  const fields = [];
  if (sheetNodes.length) {
    const tableNodes = getElementsByTagName(sheetNodes[0], "Table");
    if (tableNodes.length) {
      const rowNodes = getElementsByTagName(tableNodes[0], "Row");
      if (rowNodes.length) {
        import_xe_utils31.default.arrayEach(getElementsByTagName(rowNodes[0], "Cell"), (cellNode) => {
          fields.push(cellNode.textContent);
        });
        import_xe_utils31.default.arrayEach(rowNodes, (rowNode, index) => {
          if (index) {
            const item = {};
            const cellNodes = getElementsByTagName(rowNode, "Cell");
            import_xe_utils31.default.arrayEach(cellNodes, (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent;
              }
            });
            rows.push(item);
          }
        });
      }
    }
  }
  return { fields, rows };
}
function clearColumnConvert(columns) {
  import_xe_utils31.default.eachTree(columns, (column) => {
    delete column._level;
    delete column._colSpan;
    delete column._rowSpan;
    delete column._children;
    delete column.childNodes;
  }, { children: "children" });
}
function checkImportData(columns, fields) {
  const tableFields = [];
  columns.forEach((column) => {
    const field = column.property;
    if (field) {
      tableFields.push(field);
    }
  });
  return fields.some((field) => tableFields.indexOf(field) > -1);
}
var tableExportMethodKeys = ["exportData", "importByFile", "importData", "saveFile", "readFile", "print", "openImport", "openExport", "openPrint"];
var tableExportHook = {
  setupTable($xetable) {
    const { props, reactData, internalData } = $xetable;
    const { computeTreeOpts, computePrintOpts, computeExportOpts, computeImportOpts, computeCustomOpts, computeSeqOpts, computeRadioOpts, computeCheckboxOpts, computeColumnOpts } = $xetable.getComputeMaps();
    const $xegrid = inject("$xegrid", null);
    const hasTreeChildren = (row) => {
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      return row[childrenField] && row[childrenField].length;
    };
    const getSeq = (row, $rowIndex, column, $columnIndex) => {
      const seqOpts = computeSeqOpts.value;
      const seqMethod = seqOpts.seqMethod || column.seqMethod;
      if (seqMethod) {
        return seqMethod({
          row,
          rowIndex: $xetable.getRowIndex(row),
          $rowIndex,
          column,
          columnIndex: $xetable.getColumnIndex(column),
          $columnIndex
        });
      }
      return $xetable.getRowSeq(row);
    };
    function getHeaderTitle(opts, column) {
      const columnOpts = computeColumnOpts.value;
      const headExportMethod = column.headerExportMethod || columnOpts.headerExportMethod;
      return headExportMethod ? headExportMethod({ column, options: opts, $table: $xetable }) : (opts.original ? column.property : column.getTitle()) || "";
    }
    const toBooleanValue = (cellValue) => {
      return import_xe_utils31.default.isBoolean(cellValue) ? cellValue ? "TRUE" : "FALSE" : cellValue;
    };
    const getLabelData = (opts, columns, datas) => {
      const { isAllExpand, mode } = opts;
      const { treeConfig } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeOpts = computeTreeOpts.value;
      const columnOpts = computeColumnOpts.value;
      if (!htmlCellElem) {
        htmlCellElem = document.createElement("div");
      }
      if (treeConfig) {
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const rest = [];
        const expandMaps = /* @__PURE__ */ new Map();
        import_xe_utils31.default.eachTree(datas, (item, $rowIndex, items, path, parent, nodes) => {
          const row = item._row || item;
          const parentRow = parent && parent._row ? parent._row : parent;
          if (isAllExpand || !parentRow || expandMaps.has(parentRow) && $xetable.isTreeExpandByRow(parentRow)) {
            const hasRowChild = hasTreeChildren(row);
            const item2 = {
              _row: row,
              _level: nodes.length - 1,
              _hasChild: hasRowChild,
              _expand: hasRowChild && $xetable.isTreeExpandByRow(row)
            };
            columns.forEach((column, $columnIndex) => {
              let cellValue = "";
              const renderOpts = column.editRender || column.cellRender;
              let bodyExportMethod = column.exportMethod;
              if (!bodyExportMethod && renderOpts && renderOpts.name) {
                const compConf = VXETable.renderer.get(renderOpts.name);
                if (compConf) {
                  bodyExportMethod = compConf.exportMethod;
                }
              }
              if (!bodyExportMethod) {
                bodyExportMethod = columnOpts.exportMethod;
              }
              if (bodyExportMethod) {
                cellValue = bodyExportMethod({ $table: $xetable, row, column, options: opts });
              } else {
                switch (column.type) {
                  case "seq":
                    cellValue = mode === "all" ? path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("") : getSeq(row, $rowIndex, column, $columnIndex);
                    break;
                  case "checkbox":
                    cellValue = toBooleanValue($xetable.isCheckedByCheckboxRow(row));
                    item2._checkboxLabel = checkboxOpts.labelField ? import_xe_utils31.default.get(row, checkboxOpts.labelField) : "";
                    item2._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ row });
                    break;
                  case "radio":
                    cellValue = toBooleanValue($xetable.isCheckedByRadioRow(row));
                    item2._radioLabel = radioOpts.labelField ? import_xe_utils31.default.get(row, radioOpts.labelField) : "";
                    item2._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ row });
                    break;
                  default:
                    if (opts.original) {
                      cellValue = getCellValue(row, column);
                    } else {
                      cellValue = $xetable.getCellLabel(row, column);
                      if (column.type === "html") {
                        htmlCellElem.innerHTML = cellValue;
                        cellValue = htmlCellElem.innerText.trim();
                      } else {
                        const cell = $xetable.getCell(row, column);
                        if (cell) {
                          cellValue = cell.innerText.trim();
                        }
                      }
                    }
                }
              }
              item2[column.id] = import_xe_utils31.default.toValueString(cellValue);
            });
            expandMaps.set(row, 1);
            rest.push(Object.assign(item2, row));
          }
        }, { children: childrenField });
        return rest;
      }
      return datas.map((row, $rowIndex) => {
        const item = {
          _row: row
        };
        columns.forEach((column, $columnIndex) => {
          let cellValue = "";
          const renderOpts = column.editRender || column.cellRender;
          let exportLabelMethod = column.exportMethod;
          if (!exportLabelMethod && renderOpts && renderOpts.name) {
            const compConf = VXETable.renderer.get(renderOpts.name);
            if (compConf) {
              exportLabelMethod = compConf.exportMethod;
            }
          }
          if (exportLabelMethod) {
            cellValue = exportLabelMethod({ $table: $xetable, row, column, options: opts });
          } else {
            switch (column.type) {
              case "seq":
                cellValue = mode === "all" ? $rowIndex + 1 : getSeq(row, $rowIndex, column, $columnIndex);
                break;
              case "checkbox":
                cellValue = toBooleanValue($xetable.isCheckedByCheckboxRow(row));
                item._checkboxLabel = checkboxOpts.labelField ? import_xe_utils31.default.get(row, checkboxOpts.labelField) : "";
                item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ row });
                break;
              case "radio":
                cellValue = toBooleanValue($xetable.isCheckedByRadioRow(row));
                item._radioLabel = radioOpts.labelField ? import_xe_utils31.default.get(row, radioOpts.labelField) : "";
                item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ row });
                break;
              default:
                if (opts.original) {
                  cellValue = getCellValue(row, column);
                } else {
                  cellValue = $xetable.getCellLabel(row, column);
                  if (column.type === "html") {
                    htmlCellElem.innerHTML = cellValue;
                    cellValue = htmlCellElem.innerText.trim();
                  } else {
                    const cell = $xetable.getCell(row, column);
                    if (cell) {
                      cellValue = cell.innerText.trim();
                    }
                  }
                }
            }
          }
          item[column.id] = import_xe_utils31.default.toValueString(cellValue);
        });
        return item;
      });
    };
    const getExportData = (opts) => {
      const { columns, dataFilterMethod } = opts;
      let datas = opts.data;
      if (dataFilterMethod) {
        datas = datas.filter((row, index) => dataFilterMethod({ row, $rowIndex: index }));
      }
      return getLabelData(opts, columns, datas);
    };
    const getFooterCellValue = (opts, items, column) => {
      const columnOpts = computeColumnOpts.value;
      const renderOpts = column.editRender || column.cellRender;
      let footLabelMethod = column.footerExportMethod;
      if (!footLabelMethod && renderOpts && renderOpts.name) {
        const compConf = VXETable.renderer.get(renderOpts.name);
        if (compConf) {
          footLabelMethod = compConf.footerExportMethod;
        }
      }
      if (!footLabelMethod) {
        footLabelMethod = columnOpts.footerExportMethod;
      }
      const _columnIndex = $xetable.getVTColumnIndex(column);
      const cellValue = footLabelMethod ? footLabelMethod({ $table: $xetable, items, itemIndex: _columnIndex, row: items, _columnIndex, column, options: opts }) : import_xe_utils31.default.toValueString(items[_columnIndex]);
      return cellValue;
    };
    const toCsv = (opts, columns, datas) => {
      let content = csvBOM;
      if (opts.isHeader) {
        content += columns.map((column) => toTxtCellLabel(getHeaderTitle(opts, column))).join(",") + enterSymbol;
      }
      datas.forEach((row) => {
        content += columns.map((column) => toTxtCellLabel(getCsvCellTypeLabel(column, row[column.id]))).join(",") + enterSymbol;
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach((rows) => {
          content += columns.map((column) => toTxtCellLabel(getFooterCellValue(opts, rows, column))).join(",") + enterSymbol;
        });
      }
      return content;
    };
    const toTxt = (opts, columns, datas) => {
      let content = "";
      if (opts.isHeader) {
        content += columns.map((column) => toTxtCellLabel(getHeaderTitle(opts, column))).join("	") + enterSymbol;
      }
      datas.forEach((row) => {
        content += columns.map((column) => toTxtCellLabel(row[column.id])).join("	") + enterSymbol;
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach((rows) => {
          content += columns.map((column) => toTxtCellLabel(getFooterCellValue(opts, rows, column))).join(",") + enterSymbol;
        });
      }
      return content;
    };
    const hasEllipsis = (column, property, allColumnOverflow) => {
      const columnOverflow = column[property];
      const headOverflow = import_xe_utils31.default.isUndefined(columnOverflow) || import_xe_utils31.default.isNull(columnOverflow) ? allColumnOverflow : columnOverflow;
      const showEllipsis = headOverflow === "ellipsis";
      const showTitle = headOverflow === "title";
      const showTooltip = headOverflow === true || headOverflow === "tooltip";
      let isEllipsis = showTitle || showTooltip || showEllipsis;
      const { scrollXLoad, scrollYLoad } = reactData;
      if ((scrollXLoad || scrollYLoad) && !isEllipsis) {
        isEllipsis = true;
      }
      return isEllipsis;
    };
    const toHtml = (opts, columns, datas) => {
      const { id, border, treeConfig, headerAlign: allHeaderAlign, align: allAlign, footerAlign: allFooterAlign, showOverflow: allColumnOverflow, showHeaderOverflow: allColumnHeaderOverflow } = props;
      const { isAllSelected, isIndeterminate, mergeList } = reactData;
      const treeOpts = computeTreeOpts.value;
      const { print: isPrint, isHeader, isFooter, isColgroup, isMerge, colgroups, original } = opts;
      const allCls = "check-all";
      const clss = [
        "vxe-table",
        `border--${toTableBorder(border)}`,
        isPrint ? "is--print" : "",
        isHeader ? "is--header" : ""
      ].filter((cls) => cls);
      const tables = [
        `<table class="${clss.join(" ")}" border="0" cellspacing="0" cellpadding="0">`,
        `<colgroup>${columns.map((column) => `<col style="width:${column.renderWidth}px">`).join("")}</colgroup>`
      ];
      if (isHeader) {
        tables.push("<thead>");
        if (isColgroup && !original) {
          colgroups.forEach((cols) => {
            tables.push(`<tr>${cols.map((column) => {
              const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
              const classNames = hasEllipsis(column, "showHeaderOverflow", allColumnHeaderOverflow) ? ["col--ellipsis"] : [];
              const cellTitle = getHeaderTitle(opts, column);
              let childWidth = 0;
              let countChild = 0;
              import_xe_utils31.default.eachTree([column], (item) => {
                if (!item.childNodes || !column.childNodes.length) {
                  countChild++;
                }
                childWidth += item.renderWidth;
              }, { children: "childNodes" });
              const cellWidth = childWidth - countChild;
              if (headAlign) {
                classNames.push(`col--${headAlign}`);
              }
              if (column.type === "checkbox") {
                return `<th class="${classNames.join(" ")}" colspan="${column._colSpan}" rowspan="${column._rowSpan}"><div ${isPrint ? "" : `style="width: ${cellWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? "checked" : ""}><span>${cellTitle}</span></div></th>`;
              }
              return `<th class="${classNames.join(" ")}" colspan="${column._colSpan}" rowspan="${column._rowSpan}" title="${cellTitle}"><div ${isPrint ? "" : `style="width: ${cellWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
            }).join("")}</tr>`);
          });
        } else {
          tables.push(`<tr>${columns.map((column) => {
            const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
            const classNames = hasEllipsis(column, "showHeaderOverflow", allColumnHeaderOverflow) ? ["col--ellipsis"] : [];
            const cellTitle = getHeaderTitle(opts, column);
            if (headAlign) {
              classNames.push(`col--${headAlign}`);
            }
            if (column.type === "checkbox") {
              return `<th class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? "checked" : ""}><span>${cellTitle}</span></div></th>`;
            }
            return `<th class="${classNames.join(" ")}" title="${cellTitle}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
          }).join("")}</tr>`);
        }
        tables.push("</thead>");
      }
      if (datas.length) {
        tables.push("<tbody>");
        if (treeConfig) {
          datas.forEach((item) => {
            tables.push("<tr>" + columns.map((column) => {
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = item[column.id];
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.treeNode) {
                let treeIcon = "";
                if (item._hasChild) {
                  treeIcon = `<i class="${item._expand ? "vxe-table--tree-fold-icon" : "vxe-table--tree-unfold-icon"}"></i>`;
                }
                classNames.push("vxe-table--tree-node");
                if (column.type === "radio") {
                  return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="radio" name="radio_${id}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></div></div></td>`;
                } else if (column.type === "checkbox") {
                  return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></div></div></td>`;
                }
                return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell">${cellValue}</div></div></div></td>`;
              }
              if (column.type === "radio") {
                return `<td class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === "checkbox") {
                return `<td class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("") + "</tr>");
          });
        } else {
          datas.forEach((item) => {
            tables.push("<tr>" + columns.map((column) => {
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = item[column.id];
              let rowSpan = 1;
              let colSpan = 1;
              if (isMerge && mergeList.length) {
                const _rowIndex = $xetable.getVTRowIndex(item._row);
                const _columnIndex = $xetable.getVTColumnIndex(column);
                const spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);
                if (spanRest) {
                  const { rowspan, colspan } = spanRest;
                  if (!rowspan || !colspan) {
                    return "";
                  }
                  if (rowspan > 1) {
                    rowSpan = rowspan;
                  }
                  if (colspan > 1) {
                    colSpan = colspan;
                  }
                }
              }
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.type === "radio") {
                return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === "checkbox") {
                return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("") + "</tr>");
          });
        }
        tables.push("</tbody>");
      }
      if (isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        if (footers.length) {
          tables.push("<tfoot>");
          footers.forEach((rows) => {
            tables.push(`<tr>${columns.map((column) => {
              const footAlign = column.footerAlign || column.align || allFooterAlign || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = getFooterCellValue(opts, rows, column);
              if (footAlign) {
                classNames.push(`col--${footAlign}`);
              }
              return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("")}</tr>`);
          });
          tables.push("</tfoot>");
        }
      }
      const script = !isAllSelected && isIndeterminate ? `<script>(function(){var a=document.querySelector(".${allCls}");if(a){a.indeterminate=true}})()<\/script>` : "";
      tables.push("</table>", script);
      return isPrint ? tables.join("") : createHtmlPage(opts, tables.join(""));
    };
    const toXML = (opts, columns, datas) => {
      let xml = [
        '<?xml version="1.0"?>',
        '<?mso-application progid="Excel.Sheet"?>',
        '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">',
        '<DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">',
        "<Version>16.00</Version>",
        "</DocumentProperties>",
        '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel">',
        "<WindowHeight>7920</WindowHeight>",
        "<WindowWidth>21570</WindowWidth>",
        "<WindowTopX>32767</WindowTopX>",
        "<WindowTopY>32767</WindowTopY>",
        "<ProtectStructure>False</ProtectStructure>",
        "<ProtectWindows>False</ProtectWindows>",
        "</ExcelWorkbook>",
        `<Worksheet ss:Name="${opts.sheetName}">`,
        "<Table>",
        columns.map((column) => `<Column ss:Width="${column.renderWidth}"/>`).join("")
      ].join("");
      if (opts.isHeader) {
        xml += `<Row>${columns.map((column) => `<Cell><Data ss:Type="String">${getHeaderTitle(opts, column)}</Data></Cell>`).join("")}</Row>`;
      }
      datas.forEach((row) => {
        xml += "<Row>" + columns.map((column) => `<Cell><Data ss:Type="String">${row[column.id]}</Data></Cell>`).join("") + "</Row>";
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach((rows) => {
          xml += `<Row>${columns.map((column) => `<Cell><Data ss:Type="String">${getFooterCellValue(opts, rows, column)}</Data></Cell>`).join("")}</Row>`;
        });
      }
      return `${xml}</Table></Worksheet></Workbook>`;
    };
    const getContent = (opts, columns, datas) => {
      if (columns.length) {
        switch (opts.type) {
          case "csv":
            return toCsv(opts, columns, datas);
          case "txt":
            return toTxt(opts, columns, datas);
          case "html":
            return toHtml(opts, columns, datas);
          case "xml":
            return toXML(opts, columns, datas);
        }
      }
      return "";
    };
    const downloadFile = (opts, content) => {
      const { filename, type, download } = opts;
      if (!download) {
        const blob = getExportBlobByContent(content, opts);
        return Promise.resolve({ type, content, blob });
      }
      saveLocalFile({ filename, type, content }).then(() => {
        if (opts.message !== false) {
          if (true) {
            if (!VXETable.modal) {
              errLog("vxe.error.reqModule", ["Modal"]);
            }
          }
          VXETable.modal.message({ content: conf_default.i18n("vxe.table.expSuccess"), status: "success" });
        }
      });
    };
    const handleExport = (opts) => {
      const { remote, columns, colgroups, exportMethod, afterExportMethod } = opts;
      return new Promise((resolve) => {
        if (remote) {
          const params = { options: opts, $table: $xetable, $grid: $xegrid };
          resolve(exportMethod ? exportMethod(params) : params);
        } else {
          const datas = getExportData(opts);
          resolve($xetable.preventEvent(null, "event.export", { options: opts, columns, colgroups, datas }, () => {
            return downloadFile(opts, getContent(opts, columns, datas));
          }));
        }
      }).then((params) => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({ status: true, options: opts, $table: $xetable, $grid: $xegrid });
          }
        }
        return Object.assign({ status: true }, params);
      }).catch(() => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({ status: false, options: opts, $table: $xetable, $grid: $xegrid });
          }
        }
        const params = { status: false };
        return Promise.reject(params);
      });
    };
    const handleImport = (content, opts) => {
      const { tableFullColumn, _importResolve, _importReject } = internalData;
      let rest = { fields: [], rows: [] };
      switch (opts.type) {
        case "csv":
          rest = parseCsv(tableFullColumn, content);
          break;
        case "txt":
          rest = parseTxt(tableFullColumn, content);
          break;
        case "html":
          rest = parseHTML(tableFullColumn, content);
          break;
        case "xml":
          rest = parseXML(tableFullColumn, content);
          break;
      }
      const { fields, rows } = rest;
      const status = checkImportData(tableFullColumn, fields);
      if (status) {
        $xetable.createData(rows).then((data) => {
          let loadRest;
          if (opts.mode === "insert") {
            loadRest = $xetable.insert(data);
          } else {
            loadRest = $xetable.reloadData(data);
          }
          if (opts.message !== false) {
            if (true) {
              if (!VXETable.modal) {
                errLog("vxe.error.reqModule", ["Modal"]);
              }
            }
            VXETable.modal.message({ content: conf_default.i18n("vxe.table.impSuccess", [rows.length]), status: "success" });
          }
          return loadRest.then(() => {
            if (_importResolve) {
              _importResolve({ status: true });
            }
          });
        });
      } else if (opts.message !== false) {
        if (true) {
          if (!VXETable.modal) {
            errLog("vxe.error.reqModule", ["Modal"]);
          }
        }
        VXETable.modal.message({ content: conf_default.i18n("vxe.error.impFields"), status: "error" });
        if (_importReject) {
          _importReject({ status: false });
        }
      }
    };
    const handleFileImport = (file, opts) => {
      const { importMethod, afterImportMethod } = opts;
      const { type, filename } = parseFile(file);
      if (!importMethod && !import_xe_utils31.default.includes(VXETable.globalConfs.importTypes, type)) {
        if (opts.message !== false) {
          if (true) {
            if (!VXETable.modal) {
              errLog("vxe.error.reqModule", ["Modal"]);
            }
          }
          VXETable.modal.message({ content: conf_default.i18n("vxe.error.notType", [type]), status: "error" });
        }
        const params = { status: false };
        return Promise.reject(params);
      }
      const rest = new Promise((resolve, reject) => {
        const _importResolve = (params) => {
          resolve(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        const _importReject = (params) => {
          reject(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        internalData._importResolve = _importResolve;
        internalData._importReject = _importReject;
        if (window.FileReader) {
          const options = Object.assign({ mode: "insert" }, opts, { type, filename });
          if (options.remote) {
            if (importMethod) {
              Promise.resolve(importMethod({ file, options, $table: $xetable })).then(() => {
                _importResolve({ status: true });
              }).catch(() => {
                _importResolve({ status: true });
              });
            } else {
              _importResolve({ status: true });
            }
          } else {
            const { tableFullColumn } = internalData;
            $xetable.preventEvent(null, "event.import", { file, options, columns: tableFullColumn }, () => {
              const reader = new FileReader();
              reader.onerror = () => {
                errLog("vxe.error.notType", [type]);
                _importReject({ status: false });
              };
              reader.onload = (e) => {
                handleImport(e.target.result, options);
              };
              reader.readAsText(file, options.encoding || "UTF-8");
            });
          }
        } else {
          if (true) {
            errLog("vxe.error.notExp");
          }
          _importResolve({ status: true });
        }
      });
      return rest.then(() => {
        if (afterImportMethod) {
          afterImportMethod({ status: true, options: opts, $table: $xetable });
        }
      }).catch((e) => {
        if (afterImportMethod) {
          afterImportMethod({ status: false, options: opts, $table: $xetable });
        }
        return Promise.reject(e);
      });
    };
    const handleExportAndPrint = (options, isPrint) => {
      const { treeConfig, showHeader, showFooter } = props;
      const { initStore, mergeList, isGroup, footerTableData, exportStore, exportParams } = reactData;
      const { collectColumn } = internalData;
      const hasTree = treeConfig;
      const customOpts = computeCustomOpts.value;
      const selectRecords = $xetable.getCheckboxRecords();
      const hasFooter = !!footerTableData.length;
      const hasMerge = !hasTree && mergeList.length;
      const defOpts = Object.assign({ message: true, isHeader: showHeader, isFooter: showFooter }, options);
      const types = defOpts.types || VXETable.globalConfs.exportTypes;
      const modes = defOpts.modes;
      const checkMethod = customOpts.checkMethod;
      const exportColumns = collectColumn.slice(0);
      const { columns } = defOpts;
      const typeList = types.map((value) => {
        return {
          value,
          label: `vxe.export.types.${value}`
        };
      });
      const modeList = modes.map((value) => {
        return {
          value,
          label: `vxe.export.modes.${value}`
        };
      });
      import_xe_utils31.default.eachTree(exportColumns, (column, index, items, path, parent) => {
        const isColGroup = column.children && column.children.length;
        if (isColGroup || defaultFilterExportColumn(column)) {
          column.checked = columns ? columns.some((item) => {
            if (isColumnInfo(item)) {
              return column === item;
            } else if (import_xe_utils31.default.isString(item)) {
              return column.field === item;
            } else {
              const colid = item.id || item.colId;
              const type = item.type;
              const field = item.property || item.field;
              if (colid) {
                return column.id === colid;
              } else if (field && type) {
                return column.property === field && column.type === type;
              } else if (field) {
                return column.property === field;
              } else if (type) {
                return column.type === type;
              }
            }
            return false;
          }) : column.visible;
          column.halfChecked = false;
          column.disabled = parent && parent.disabled || (checkMethod ? !checkMethod({ column }) : false);
        }
      });
      Object.assign(exportStore, {
        columns: exportColumns,
        typeList,
        modeList,
        hasFooter,
        hasMerge,
        hasTree,
        isPrint,
        hasColgroup: isGroup,
        visible: true
      });
      Object.assign(exportParams, {
        mode: selectRecords.length ? "selected" : "current"
      }, defOpts);
      if (modes.indexOf(exportParams.mode) === -1) {
        exportParams.mode = modes[0];
      }
      if (types.indexOf(exportParams.type) === -1) {
        exportParams.type = types[0];
      }
      initStore.export = true;
      return nextTick();
    };
    const exportMethods = {
      /**
       *  csv/html/xml/txt
       * 
       *  dataFilterMethod 
       * @param {Object} options 
       */
      exportData(options) {
        const { treeConfig } = props;
        const { isGroup, tableGroupColumn } = reactData;
        const { tableFullColumn, afterFullData } = internalData;
        const exportOpts = computeExportOpts.value;
        const treeOpts = computeTreeOpts.value;
        const opts = Object.assign({
          // filename: '',
          // sheetName: '',
          // original: false,
          // message: false,
          isHeader: true,
          isFooter: true,
          isColgroup: true,
          // isMerge: false,
          // isAllExpand: false,
          download: true,
          type: "csv",
          mode: "current"
          // data: null,
          // remote: false,
          // dataFilterMethod: null,
          // footerFilterMethod: null,
          // exportMethod: null,
          // columnFilterMethod: null,
          // beforeExportMethod: null,
          // afterExportMethod: null
        }, exportOpts, {
          print: false
        }, options);
        const { type, mode, columns, original, beforeExportMethod } = opts;
        let groups = [];
        const customCols = columns && columns.length ? columns : null;
        let columnFilterMethod = opts.columnFilterMethod;
        if (!customCols && !columnFilterMethod) {
          columnFilterMethod = original ? ({ column }) => column.property : ({ column }) => defaultFilterExportColumn(column);
        }
        if (customCols) {
          opts._isCustomColumn = true;
          groups = import_xe_utils31.default.searchTree(import_xe_utils31.default.mapTree(customCols, (item) => {
            let targetColumn;
            if (item) {
              if (isColumnInfo(item)) {
                targetColumn = item;
              } else if (import_xe_utils31.default.isString(item)) {
                targetColumn = $xetable.getColumnByField(item);
              } else {
                const colid = item.id || item.colId;
                const type2 = item.type;
                const field = item.property || item.field;
                if (colid) {
                  targetColumn = $xetable.getColumnById(colid);
                } else if (field && type2) {
                  targetColumn = tableFullColumn.find((column) => column.property === field && column.type === type2);
                } else if (field) {
                  targetColumn = $xetable.getColumnByField(field);
                } else if (type2) {
                  targetColumn = tableFullColumn.find((column) => column.type === type2);
                }
              }
              return targetColumn || {};
            }
          }, {
            children: "childNodes",
            mapChildren: "_children"
          }), (column, index) => isColumnInfo(column) && (!columnFilterMethod || columnFilterMethod({ column, $columnIndex: index })), {
            children: "_children",
            mapChildren: "childNodes",
            original: true
          });
        } else {
          groups = import_xe_utils31.default.searchTree(isGroup ? tableGroupColumn : tableFullColumn, (column, index) => column.visible && (!columnFilterMethod || columnFilterMethod({ column, $columnIndex: index })), { children: "children", mapChildren: "childNodes", original: true });
        }
        const cols = [];
        import_xe_utils31.default.eachTree(groups, (column) => {
          const isColGroup = column.children && column.children.length;
          if (!isColGroup) {
            cols.push(column);
          }
        }, { children: "childNodes" });
        opts.columns = cols;
        opts.colgroups = convertToRows(groups);
        if (!opts.filename) {
          opts.filename = conf_default.i18n(opts.original ? "vxe.table.expOriginFilename" : "vxe.table.expFilename", [import_xe_utils31.default.toDateString(Date.now(), "yyyyMMddHHmmss")]);
        }
        if (!opts.sheetName) {
          opts.sheetName = document.title;
        }
        if (!opts.exportMethod && !import_xe_utils31.default.includes(VXETable.globalConfs.exportTypes, type)) {
          if (true) {
            errLog("vxe.error.notType", [type]);
          }
          const params = { status: false };
          return Promise.reject(params);
        }
        if (!opts.print) {
          if (beforeExportMethod) {
            beforeExportMethod({ options: opts, $table: $xetable, $grid: $xegrid });
          }
        }
        if (!opts.data) {
          opts.data = afterFullData;
          if (mode === "selected") {
            const selectRecords = $xetable.getCheckboxRecords();
            if (["html", "pdf"].indexOf(type) > -1 && treeConfig) {
              opts.data = import_xe_utils31.default.searchTree($xetable.getTableData().fullData, (item) => $xetable.findRowIndexOf(selectRecords, item) > -1, Object.assign({}, treeOpts, { data: "_row" }));
            } else {
              opts.data = selectRecords;
            }
          } else if (mode === "all") {
            if (true) {
              if (!$xegrid) {
                warnLog("vxe.error.errProp", ["all", "mode=current,selected"]);
              }
            }
            if ($xegrid && !opts.remote) {
              const { reactData: gridReactData } = $xegrid;
              const { computeProxyOpts } = $xegrid.getComputeMaps();
              const proxyOpts = computeProxyOpts.value;
              const { beforeQueryAll, afterQueryAll, ajax = {}, props: props2 = {} } = proxyOpts;
              const ajaxMethods = ajax.queryAll;
              if (true) {
                if (!ajaxMethods) {
                  warnLog("vxe.error.notFunc", ["proxy-config.ajax.queryAll"]);
                }
              }
              if (ajaxMethods) {
                const params = {
                  $table: $xetable,
                  $grid: $xegrid,
                  sort: gridReactData.sortData,
                  filters: gridReactData.filterData,
                  form: gridReactData.formData,
                  target: ajaxMethods,
                  options: opts
                };
                return Promise.resolve((beforeQueryAll || ajaxMethods)(params)).catch((e) => e).then((rest) => {
                  opts.data = (props2.list ? import_xe_utils31.default.get(rest, props2.list) : rest) || [];
                  if (afterQueryAll) {
                    afterQueryAll(params);
                  }
                  return handleExport(opts);
                });
              }
            }
          }
        }
        return handleExport(opts);
      },
      importByFile(file, options) {
        const opts = Object.assign({}, options);
        const { beforeImportMethod } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({ options: opts, $table: $xetable });
        }
        return handleFileImport(file, opts);
      },
      importData(options) {
        const importOpts = computeImportOpts.value;
        const opts = Object.assign({
          types: VXETable.globalConfs.importTypes
          // beforeImportMethod: null,
          // afterImportMethod: null
        }, importOpts, options);
        const { beforeImportMethod, afterImportMethod } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({ options: opts, $table: $xetable });
        }
        return readLocalFile(opts).catch((e) => {
          if (afterImportMethod) {
            afterImportMethod({ status: false, options: opts, $table: $xetable });
          }
          return Promise.reject(e);
        }).then((params) => {
          const { file } = params;
          return handleFileImport(file, opts);
        });
      },
      saveFile(options) {
        return saveLocalFile(options);
      },
      readFile(options) {
        return readLocalFile(options);
      },
      print(options) {
        const printOpts = computePrintOpts.value;
        const opts = Object.assign({
          original: false
          // beforePrintMethod
        }, printOpts, options, {
          type: "html",
          download: false,
          remote: false,
          print: true
        });
        if (!opts.sheetName) {
          opts.sheetName = document.title;
        }
        return new Promise((resolve) => {
          if (opts.content) {
            resolve(handlePrint($xetable, opts, opts.content));
          } else {
            resolve(exportMethods.exportData(opts).then(({ content }) => {
              return handlePrint($xetable, opts, content);
            }));
          }
        });
      },
      openImport(options) {
        const { treeConfig, importConfig } = props;
        const { initStore, importStore, importParams } = reactData;
        const importOpts = computeImportOpts.value;
        const defOpts = Object.assign({ mode: "insert", message: true, types: VXETable.globalConfs.importTypes }, options, importOpts);
        const { types } = defOpts;
        const isTree = !!treeConfig;
        if (isTree) {
          if (defOpts.message) {
            VXETable.modal.message({ content: conf_default.i18n("vxe.error.treeNotImp"), status: "error" });
          }
          return;
        }
        if (!importConfig) {
          errLog("vxe.error.reqProp", ["import-config"]);
        }
        const typeList = types.map((value) => {
          return {
            value,
            label: `vxe.export.types.${value}`
          };
        });
        const modeList = defOpts.modes.map((value) => {
          return {
            value,
            label: `vxe.import.modes.${value}`
          };
        });
        Object.assign(importStore, {
          file: null,
          type: "",
          filename: "",
          modeList,
          typeList,
          visible: true
        });
        Object.assign(importParams, defOpts);
        initStore.import = true;
      },
      openExport(options) {
        const exportOpts = computeExportOpts.value;
        if (true) {
          if (!props.exportConfig) {
            errLog("vxe.error.reqProp", ["export-config"]);
          }
        }
        handleExportAndPrint(Object.assign({}, exportOpts, options));
      },
      openPrint(options) {
        const printOpts = computePrintOpts.value;
        if (true) {
          if (!props.printConfig) {
            errLog("vxe.error.reqProp", ["print-config"]);
          }
        }
        handleExportAndPrint(Object.assign({}, printOpts, options), true);
      }
    };
    return exportMethods;
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableExportMethodKeys);
  }
};
var hook_default3 = tableExportHook;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/export/index.js
var print = (options) => {
  const opts = Object.assign({}, options, {
    type: "html"
  });
  handlePrint(null, opts, opts.content);
};
var VxeTableExportModule = {
  ExportPanel: export_panel_default,
  ImportPanel: import_panel_default,
  install(app) {
    VXETable.saveFile = saveLocalFile;
    VXETable.readFile = readLocalFile;
    VXETable.print = print;
    VXETable.setConfig({
      export: {
        types: {
          csv: 0,
          html: 0,
          xml: 0,
          txt: 0
        }
      }
    });
    VXETable.hooks.add("$tableExport", hook_default3);
    app.component(export_panel_default.name, export_panel_default);
    app.component(import_panel_default.name, import_panel_default);
  }
};
var Export = VxeTableExportModule;
dynamicApp.component(export_panel_default.name, export_panel_default);
dynamicApp.component(import_panel_default.name, import_panel_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/keyboard/src/hook.js
var import_xe_utils32 = __toESM(require_xe_utils());
function getTargetOffset(target, container) {
  let offsetTop = 0;
  let offsetLeft = 0;
  const triggerCheckboxLabel = !browse.firefox && hasClass(target, "vxe-checkbox--label");
  if (triggerCheckboxLabel) {
    const checkboxLabelStyle = getComputedStyle(target);
    offsetTop -= import_xe_utils32.default.toNumber(checkboxLabelStyle.paddingTop);
    offsetLeft -= import_xe_utils32.default.toNumber(checkboxLabelStyle.paddingLeft);
  }
  while (target && target !== container) {
    offsetTop += target.offsetTop;
    offsetLeft += target.offsetLeft;
    target = target.offsetParent;
    if (triggerCheckboxLabel) {
      const checkboxStyle = getComputedStyle(target);
      offsetTop -= import_xe_utils32.default.toNumber(checkboxStyle.paddingTop);
      offsetLeft -= import_xe_utils32.default.toNumber(checkboxStyle.paddingLeft);
    }
  }
  return { offsetTop, offsetLeft };
}
var tableKeyboardHook = {
  setupTable($xetable) {
    const { props, reactData, internalData } = $xetable;
    const { refElem } = $xetable.getRefMaps();
    const { computeEditOpts, computeCheckboxOpts, computeMouseOpts, computeTreeOpts } = $xetable.getComputeMaps();
    function getCheckboxRangeRows(params, targetTrElem, moveRange) {
      let countHeight = 0;
      let rangeRows = [];
      const isDown = moveRange > 0;
      const moveSize = moveRange > 0 ? moveRange : Math.abs(moveRange) + targetTrElem.offsetHeight;
      const { scrollYLoad } = reactData;
      const { afterFullData, scrollYStore } = internalData;
      if (scrollYLoad) {
        const _rowIndex = $xetable.getVTRowIndex(params.row);
        if (isDown) {
          rangeRows = afterFullData.slice(_rowIndex, _rowIndex + Math.ceil(moveSize / scrollYStore.rowHeight));
        } else {
          rangeRows = afterFullData.slice(_rowIndex - Math.floor(moveSize / scrollYStore.rowHeight) + 1, _rowIndex + 1);
        }
      } else {
        const siblingProp = isDown ? "next" : "previous";
        while (targetTrElem && countHeight < moveSize) {
          const rowNodeRest = $xetable.getRowNode(targetTrElem);
          if (rowNodeRest) {
            rangeRows.push(rowNodeRest.item);
            countHeight += targetTrElem.offsetHeight;
            targetTrElem = targetTrElem[`${siblingProp}ElementSibling`];
          }
        }
      }
      return rangeRows;
    }
    const handleCheckboxRangeEvent = (evnt, params) => {
      const { column, cell } = params;
      if (column.type === "checkbox") {
        const el = refElem.value;
        const { elemStore } = internalData;
        const disX = evnt.clientX;
        const disY = evnt.clientY;
        const bodyWrapperRef = elemStore[`${column.fixed || "main"}-body-wrapper`] || elemStore["main-body-wrapper"];
        const bodyWrapperElem = bodyWrapperRef ? bodyWrapperRef.value : null;
        if (!bodyWrapperElem) {
          return;
        }
        const checkboxRangeElem = bodyWrapperElem.querySelector(".vxe-table--checkbox-range");
        const domMousemove = document.onmousemove;
        const domMouseup = document.onmouseup;
        const trElem = cell.parentNode;
        const selectRecords = $xetable.getCheckboxRecords();
        let lastRangeRows = [];
        const marginSize = 1;
        const offsetRest = getTargetOffset(evnt.target, bodyWrapperElem);
        const startTop = offsetRest.offsetTop + evnt.offsetY;
        const startLeft = offsetRest.offsetLeft + evnt.offsetX;
        const startScrollTop = bodyWrapperElem.scrollTop;
        const rowHeight = trElem.offsetHeight;
        let mouseScrollTimeout = null;
        let isMouseScrollDown = false;
        let mouseScrollSpaceSize = 1;
        const triggerEvent3 = (type, evnt2) => {
          $xetable.dispatchEvent(`checkbox-range-${type}`, { records: $xetable.getCheckboxRecords(), reserves: $xetable.getCheckboxReserveRecords() }, evnt2);
        };
        const handleChecked = (evnt2) => {
          const { clientX, clientY } = evnt2;
          const offsetLeft = clientX - disX;
          const offsetTop = clientY - disY + (bodyWrapperElem.scrollTop - startScrollTop);
          let rangeHeight = Math.abs(offsetTop);
          let rangeWidth = Math.abs(offsetLeft);
          let rangeTop = startTop;
          let rangeLeft = startLeft;
          if (offsetTop < marginSize) {
            rangeTop += offsetTop;
            if (rangeTop < marginSize) {
              rangeTop = marginSize;
              rangeHeight = startTop;
            }
          } else {
            rangeHeight = Math.min(rangeHeight, bodyWrapperElem.scrollHeight - startTop - marginSize);
          }
          if (offsetLeft < marginSize) {
            rangeLeft += offsetLeft;
            if (rangeWidth > startLeft) {
              rangeLeft = marginSize;
              rangeWidth = startLeft;
            }
          } else {
            rangeWidth = Math.min(rangeWidth, bodyWrapperElem.clientWidth - startLeft - marginSize);
          }
          checkboxRangeElem.style.height = `${rangeHeight}px`;
          checkboxRangeElem.style.width = `${rangeWidth}px`;
          checkboxRangeElem.style.left = `${rangeLeft}px`;
          checkboxRangeElem.style.top = `${rangeTop}px`;
          checkboxRangeElem.style.display = "block";
          const rangeRows = getCheckboxRangeRows(params, trElem, offsetTop < marginSize ? -rangeHeight : rangeHeight);
          if (rangeHeight > 10 && rangeRows.length !== lastRangeRows.length) {
            lastRangeRows = rangeRows;
            if (evnt2.ctrlKey) {
              rangeRows.forEach((row) => {
                $xetable.handleSelectRow({ row }, selectRecords.indexOf(row) === -1);
              });
            } else {
              $xetable.setAllCheckboxRow(false);
              $xetable.handleCheckedCheckboxRow(rangeRows, true, false);
            }
            triggerEvent3("change", evnt2);
          }
        };
        const stopMouseScroll = () => {
          clearTimeout(mouseScrollTimeout);
          mouseScrollTimeout = null;
        };
        const startMouseScroll = (evnt2) => {
          stopMouseScroll();
          mouseScrollTimeout = setTimeout(() => {
            if (mouseScrollTimeout) {
              const { scrollLeft, scrollTop, clientHeight, scrollHeight } = bodyWrapperElem;
              const topSize = Math.ceil(mouseScrollSpaceSize * 50 / rowHeight);
              if (isMouseScrollDown) {
                if (scrollTop + clientHeight < scrollHeight) {
                  $xetable.scrollTo(scrollLeft, scrollTop + topSize);
                  startMouseScroll(evnt2);
                  handleChecked(evnt2);
                } else {
                  stopMouseScroll();
                }
              } else {
                if (scrollTop) {
                  $xetable.scrollTo(scrollLeft, scrollTop - topSize);
                  startMouseScroll(evnt2);
                  handleChecked(evnt2);
                } else {
                  stopMouseScroll();
                }
              }
            }
          }, 50);
        };
        addClass(el, "drag--range");
        document.onmousemove = (evnt2) => {
          evnt2.preventDefault();
          evnt2.stopPropagation();
          const { clientY } = evnt2;
          const { boundingTop } = getAbsolutePos(bodyWrapperElem);
          if (clientY < boundingTop) {
            isMouseScrollDown = false;
            mouseScrollSpaceSize = boundingTop - clientY;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt2);
            }
          } else if (clientY > boundingTop + bodyWrapperElem.clientHeight) {
            isMouseScrollDown = true;
            mouseScrollSpaceSize = clientY - boundingTop - bodyWrapperElem.clientHeight;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt2);
            }
          } else if (mouseScrollTimeout) {
            stopMouseScroll();
          }
          handleChecked(evnt2);
        };
        document.onmouseup = (evnt2) => {
          stopMouseScroll();
          removeClass(el, "drag--range");
          checkboxRangeElem.removeAttribute("style");
          document.onmousemove = domMousemove;
          document.onmouseup = domMouseup;
          triggerEvent3("end", evnt2);
        };
        triggerEvent3("start", evnt);
      }
    };
    const handleCellMousedownEvent = (evnt, params) => {
      const { editConfig, checkboxConfig, mouseConfig } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const editOpts = computeEditOpts.value;
      if (mouseConfig && mouseOpts.area && $xetable.handleCellAreaEvent) {
        return $xetable.handleCellAreaEvent(evnt, params);
      } else {
        if (checkboxConfig && checkboxOpts.range) {
          handleCheckboxRangeEvent(evnt, params);
        }
        if (mouseConfig && mouseOpts.selected) {
          if (!editConfig || editOpts.mode === "cell") {
            $xetable.handleSelected(params, evnt);
          }
        }
      }
    };
    const keyboardMethods = {
      //  Tab 
      moveTabSelected(args, isLeft, evnt) {
        const { editConfig } = props;
        const { afterFullData, visibleColumn } = internalData;
        const editOpts = computeEditOpts.value;
        let targetRow;
        let targetRowIndex;
        let targetColumnIndex;
        const params = Object.assign({}, args);
        const _rowIndex = $xetable.getVTRowIndex(params.row);
        const _columnIndex = $xetable.getVTColumnIndex(params.column);
        evnt.preventDefault();
        if (isLeft) {
          if (_columnIndex <= 0) {
            if (_rowIndex > 0) {
              targetRowIndex = _rowIndex - 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = visibleColumn.length - 1;
            }
          } else {
            targetColumnIndex = _columnIndex - 1;
          }
        } else {
          if (_columnIndex >= visibleColumn.length - 1) {
            if (_rowIndex < afterFullData.length - 1) {
              targetRowIndex = _rowIndex + 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = 0;
            }
          } else {
            targetColumnIndex = _columnIndex + 1;
          }
        }
        const targetColumn = visibleColumn[targetColumnIndex];
        if (targetColumn) {
          if (targetRow) {
            params.rowIndex = targetRowIndex;
            params.row = targetRow;
          } else {
            params.rowIndex = _rowIndex;
          }
          params.columnIndex = targetColumnIndex;
          params.column = targetColumn;
          params.cell = $xetable.getCell(params.row, params.column);
          if (editConfig) {
            if (editOpts.trigger === "click" || editOpts.trigger === "dblclick") {
              if (editOpts.mode === "row") {
                $xetable.handleActived(params, evnt);
              } else {
                $xetable.scrollToRow(params.row, params.column).then(() => $xetable.handleSelected(params, evnt));
              }
            }
          } else {
            $xetable.scrollToRow(params.row, params.column).then(() => $xetable.handleSelected(params, evnt));
          }
        }
      },
      // 
      moveCurrentRow(isUpArrow, isDwArrow, evnt) {
        const { treeConfig } = props;
        const { currentRow } = reactData;
        const { afterFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let targetRow;
        evnt.preventDefault();
        if (currentRow) {
          if (treeConfig) {
            const { index, items } = import_xe_utils32.default.findTree(afterFullData, (item) => item === currentRow, { children: childrenField });
            if (isUpArrow && index > 0) {
              targetRow = items[index - 1];
            } else if (isDwArrow && index < items.length - 1) {
              targetRow = items[index + 1];
            }
          } else {
            const _rowIndex = $xetable.getVTRowIndex(currentRow);
            if (isUpArrow && _rowIndex > 0) {
              targetRow = afterFullData[_rowIndex - 1];
            } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
              targetRow = afterFullData[_rowIndex + 1];
            }
          }
        } else {
          targetRow = afterFullData[0];
        }
        if (targetRow) {
          const params = {
            $table: $xetable,
            row: targetRow,
            rowIndex: $xetable.getRowIndex(targetRow),
            $rowIndex: $xetable.getVMRowIndex(targetRow)
          };
          $xetable.scrollToRow(targetRow).then(() => $xetable.triggerCurrentRowEvent(evnt, params));
        }
      },
      // 
      moveSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        const { afterFullData, visibleColumn } = internalData;
        const params = Object.assign({}, args);
        const _rowIndex = $xetable.getVTRowIndex(params.row);
        const _columnIndex = $xetable.getVTColumnIndex(params.column);
        evnt.preventDefault();
        if (isUpArrow && _rowIndex > 0) {
          params.rowIndex = _rowIndex - 1;
          params.row = afterFullData[params.rowIndex];
        } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
          params.rowIndex = _rowIndex + 1;
          params.row = afterFullData[params.rowIndex];
        } else if (isLeftArrow && _columnIndex) {
          params.columnIndex = _columnIndex - 1;
          params.column = visibleColumn[params.columnIndex];
        } else if (isRightArrow && _columnIndex < visibleColumn.length - 1) {
          params.columnIndex = _columnIndex + 1;
          params.column = visibleColumn[params.columnIndex];
        }
        $xetable.scrollToRow(params.row, params.column).then(() => {
          params.cell = $xetable.getCell(params.row, params.column);
          $xetable.handleSelected(params, evnt);
        });
      },
      /**
       * 
       */
      triggerHeaderCellMousedownEvent(evnt, params) {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        if (mouseConfig && mouseOpts.area && $xetable.handleHeaderCellAreaEvent) {
          const cell = evnt.currentTarget;
          const triggerSort = getEventTargetNode(evnt, cell, "vxe-cell--sort").flag;
          const triggerFilter = getEventTargetNode(evnt, cell, "vxe-cell--filter").flag;
          $xetable.handleHeaderCellAreaEvent(evnt, Object.assign({ cell, triggerSort, triggerFilter }, params));
        }
        $xetable.focus();
        if ($xetable.closeMenu) {
          $xetable.closeMenu();
        }
      },
      /**
       * 
       */
      triggerCellMousedownEvent(evnt, params) {
        const cell = evnt.currentTarget;
        params.cell = cell;
        handleCellMousedownEvent(evnt, params);
        $xetable.focus();
        $xetable.closeFilter();
        if ($xetable.closeMenu) {
          $xetable.closeMenu();
        }
      }
    };
    return keyboardMethods;
  }
};
var hook_default4 = tableKeyboardHook;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/keyboard/index.js
var VxeTableKeyboardModule = {
  install() {
    VXETable.hooks.add("$tableKeyboard", hook_default4);
  }
};
var Keyboard = VxeTableKeyboardModule;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/validator/src/hook.js
var import_xe_utils33 = __toESM(require_xe_utils());
var Rule = class {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.max,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  /**
   * 
   * 
   */
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
};
var tableValidatorMethodKeys = ["fullValidate", "validate", "clearValidate"];
var validatorHook = {
  setupTable($xetable) {
    const { props, reactData, internalData } = $xetable;
    const { refValidTooltip } = $xetable.getRefMaps();
    const { computeValidOpts, computeTreeOpts, computeEditOpts } = $xetable.getComputeMaps();
    let validatorMethods = {};
    let validatorPrivateMethods = {};
    let validRuleErr;
    const handleValidError = (params) => {
      return new Promise((resolve) => {
        const validOpts = computeValidOpts.value;
        if (validOpts.autoPos === false) {
          $xetable.dispatchEvent("valid-error", params, null);
          resolve();
        } else {
          $xetable.handleActived(params, { type: "valid-error", trigger: "call" }).then(() => {
            resolve(validatorPrivateMethods.showValidTooltip(params));
          });
        }
      });
    };
    const handleErrMsgMode = (validErrMaps) => {
      const validOpts = computeValidOpts.value;
      if (validOpts.msgMode === "single") {
        const keys = Object.keys(validErrMaps);
        const resMaps = validErrMaps;
        if (keys.length) {
          const firstKey = keys[0];
          resMaps[firstKey] = validErrMaps[firstKey];
        }
        return resMaps;
      }
      return validErrMaps;
    };
    const beginValidate = (rows, cb, isFull) => {
      const validRest = {};
      const { editRules, treeConfig } = props;
      const { afterFullData, visibleColumn } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const validOpts = computeValidOpts.value;
      let validList;
      if (rows === true) {
        validList = afterFullData;
      } else if (rows) {
        if (import_xe_utils33.default.isFunction(rows)) {
          cb = rows;
        } else {
          validList = import_xe_utils33.default.isArray(rows) ? rows : [rows];
        }
      }
      if (!validList) {
        if ($xetable.getInsertRecords) {
          validList = $xetable.getInsertRecords().concat($xetable.getUpdateRecords());
        } else {
          validList = [];
        }
      }
      const rowValidErrs = [];
      internalData._lastCallTime = Date.now();
      validRuleErr = false;
      validatorMethods.clearValidate();
      const validErrMaps = {};
      if (editRules) {
        const columns = $xetable.getColumns();
        const handleVaild = (row) => {
          if (isFull || !validRuleErr) {
            const colVailds = [];
            columns.forEach((column) => {
              if ((isFull || !validRuleErr) && import_xe_utils33.default.has(editRules, column.property)) {
                colVailds.push(validatorPrivateMethods.validCellRules("all", row, column).catch(({ rule, rules }) => {
                  const rest = {
                    rule,
                    rules,
                    rowIndex: $xetable.getRowIndex(row),
                    row,
                    columnIndex: $xetable.getColumnIndex(column),
                    column,
                    field: column.property,
                    $table: $xetable
                  };
                  if (!validRest[column.property]) {
                    validRest[column.property] = [];
                  }
                  validErrMaps[`${getRowid($xetable, row)}:${column.id}`] = {
                    column,
                    row,
                    rule,
                    content: rule.content
                  };
                  validRest[column.property].push(rest);
                  if (!isFull) {
                    validRuleErr = true;
                    return Promise.reject(rest);
                  }
                }));
              }
            });
            rowValidErrs.push(Promise.all(colVailds));
          }
        };
        if (treeConfig) {
          import_xe_utils33.default.eachTree(validList, handleVaild, { children: childrenField });
        } else {
          validList.forEach(handleVaild);
        }
        return Promise.all(rowValidErrs).then(() => {
          const ruleProps = Object.keys(validRest);
          reactData.validErrorMaps = handleErrMsgMode(validErrMaps);
          return nextTick().then(() => {
            if (ruleProps.length) {
              return Promise.reject(validRest[ruleProps[0]][0]);
            }
            if (cb) {
              cb();
            }
          });
        }).catch((firstErrParams) => {
          return new Promise((resolve, reject) => {
            const finish = () => {
              nextTick(() => {
                if (cb) {
                  cb(validRest);
                  resolve();
                } else {
                  if (conf_default.validToReject === "obsolete") {
                    reject(validRest);
                  } else {
                    resolve(validRest);
                  }
                }
              });
            };
            const posAndFinish = () => {
              firstErrParams.cell = $xetable.getCell(firstErrParams.row, firstErrParams.column);
              scrollToView(firstErrParams.cell);
              handleValidError(firstErrParams).then(finish);
            };
            if (validOpts.autoPos === false) {
              finish();
            } else {
              const row = firstErrParams.row;
              const column = firstErrParams.column;
              const rowIndex = afterFullData.indexOf(row);
              const columnIndex = visibleColumn.indexOf(column);
              const targetRow = rowIndex > 0 ? afterFullData[rowIndex - 1] : row;
              const targetColumn = columnIndex > 0 ? visibleColumn[columnIndex - 1] : column;
              $xetable.scrollToRow(targetRow, targetColumn).then(posAndFinish);
            }
          });
        });
      } else {
        reactData.validErrorMaps = {};
      }
      return nextTick().then(() => {
        if (cb) {
          cb();
        }
      });
    };
    validatorMethods = {
      /**
       *  validate 
       */
      fullValidate(rows, cb) {
        if (true) {
          if (import_xe_utils33.default.isFunction(cb)) {
            warnLog("vxe.error.notValidators", ["fullValidate(rows, callback)", "fullValidate(rows)"]);
          }
        }
        return beginValidate(rows, cb, true);
      },
      /**
       * 
       */
      validate(rows, cb) {
        if (true) {
          if (import_xe_utils33.default.isFunction(cb)) {
            warnLog("vxe.error.notValidators", ["validate(rows, callback)", "validate(rows)"]);
          }
        }
        return beginValidate(rows, cb);
      },
      clearValidate(rows, fieldOrColumn) {
        const { validErrorMaps } = reactData;
        const validTip = refValidTooltip.value;
        const validOpts = computeValidOpts.value;
        const rowList = import_xe_utils33.default.isArray(rows) ? rows : rows ? [rows] : [];
        const colList = import_xe_utils33.default.isArray(fieldOrColumn) ? fieldOrColumn : (fieldOrColumn ? [fieldOrColumn] : []).map((column) => handleFieldOrColumn($xetable, column));
        let validErrMaps = {};
        if (validTip && validTip.reactData.visible) {
          validTip.close();
        }
        if (validOpts.msgMode === "single") {
          reactData.validErrorMaps = {};
          return nextTick();
        }
        if (rowList.length && colList.length) {
          validErrMaps = Object.assign({}, validErrorMaps);
          rowList.forEach((row) => {
            colList.forEach((column) => {
              const validKey = `${getRowid($xetable, row)}:${column.id}`;
              if (validErrMaps[validKey]) {
                delete validErrMaps[validKey];
              }
            });
          });
        } else if (rowList.length) {
          const rowIdList = rowList.map((row) => `${getRowid($xetable, row)}`);
          import_xe_utils33.default.each(validErrorMaps, (item, key) => {
            if (rowIdList.indexOf(key.split(":")[0]) > -1) {
              validErrMaps[key] = item;
            }
          });
        } else if (colList.length) {
          const colidList = colList.map((column) => `${column.id}`);
          import_xe_utils33.default.each(validErrorMaps, (item, key) => {
            if (colidList.indexOf(key.split(":")[1]) > -1) {
              validErrMaps[key] = item;
            }
          });
        }
        reactData.validErrorMaps = validErrMaps;
        return nextTick();
      }
    };
    const validErrorRuleValue2 = (rule, val) => {
      const { type, min, max, pattern } = rule;
      const isNumType = type === "number";
      const numVal = isNumType ? import_xe_utils33.default.toNumber(val) : import_xe_utils33.default.getSize(val);
      if (isNumType && isNaN(val)) {
        return true;
      }
      if (!import_xe_utils33.default.eqNull(min) && numVal < import_xe_utils33.default.toNumber(min)) {
        return true;
      }
      if (!import_xe_utils33.default.eqNull(max) && numVal > import_xe_utils33.default.toNumber(max)) {
        return true;
      }
      if (pattern && !(import_xe_utils33.default.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
        return true;
      }
      return false;
    };
    validatorPrivateMethods = {
      /**
       * 
       * 
       * 
       * Promise<>
       * 
       *
       * rule 
       *  required=Boolean 
       *  min=Number 
       *  max=Number 
       *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex })  Promise
       *  trigger=blur|change 
       */
      validCellRules(validType, row, column, val) {
        const { editRules } = props;
        const { field } = column;
        const errorRules = [];
        const syncValidList = [];
        if (field && editRules) {
          const rules = import_xe_utils33.default.get(editRules, field);
          if (rules) {
            const cellValue = import_xe_utils33.default.isUndefined(val) ? import_xe_utils33.default.get(row, field) : val;
            rules.forEach((rule) => {
              const { type, trigger, required, validator } = rule;
              if (validType === "all" || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    cellValue,
                    rule,
                    rules,
                    row,
                    rowIndex: $xetable.getRowIndex(row),
                    column,
                    columnIndex: $xetable.getColumnIndex(column),
                    field: column.field,
                    $table: $xetable,
                    $grid: $xetable.xegrid
                  };
                  let customValid;
                  if (import_xe_utils33.default.isString(validator)) {
                    const gvItem = VXETable.validators.get(validator);
                    if (gvItem) {
                      if (gvItem.cellValidatorMethod) {
                        customValid = gvItem.cellValidatorMethod(validParams);
                      } else {
                        if (true) {
                          warnLog("vxe.error.notValidators", [validator]);
                        }
                      }
                    } else {
                      if (true) {
                        errLog("vxe.error.notValidators", [validator]);
                      }
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (import_xe_utils33.default.isError(customValid)) {
                      validRuleErr = true;
                      errorRules.push(new Rule({ type: "custom", trigger, content: customValid.message, rule: new Rule(rule) }));
                    } else if (customValid.catch) {
                      syncValidList.push(customValid.catch((e) => {
                        validRuleErr = true;
                        errorRules.push(new Rule({ type: "custom", trigger, content: e && e.message ? e.message : rule.content || rule.message, rule: new Rule(rule) }));
                      }));
                    }
                  }
                } else {
                  const isArrType = type === "array";
                  const isArrVal = import_xe_utils33.default.isArray(cellValue);
                  let hasEmpty = true;
                  if (isArrType || isArrVal) {
                    hasEmpty = !isArrVal || !cellValue.length;
                  } else if (import_xe_utils33.default.isString(cellValue)) {
                    hasEmpty = eqEmptyValue(cellValue.trim());
                  } else {
                    hasEmpty = eqEmptyValue(cellValue);
                  }
                  if (required ? hasEmpty || validErrorRuleValue2(rule, cellValue) : !hasEmpty && validErrorRuleValue2(rule, cellValue)) {
                    validRuleErr = true;
                    errorRules.push(new Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncValidList).then(() => {
          if (errorRules.length) {
            const rest = { rules: errorRules, rule: errorRules[0] };
            return Promise.reject(rest);
          }
        });
      },
      hasCellRules(type, row, column) {
        const { editRules } = props;
        const { field } = column;
        if (field && editRules) {
          const rules = import_xe_utils33.default.get(editRules, field);
          return rules && !!import_xe_utils33.default.find(rules, (rule) => type === "all" || !rule.trigger || type === rule.trigger);
        }
        return false;
      },
      /**
       * 
       */
      triggerValidate(type) {
        const { editConfig, editRules } = props;
        const { editStore } = reactData;
        const { actived } = editStore;
        const editOpts = computeEditOpts.value;
        const validOpts = computeValidOpts.value;
        if (editRules && validOpts.msgMode === "single") {
          reactData.validErrorMaps = {};
        }
        if (editConfig && editRules && actived.row) {
          const { row, column, cell } = actived.args;
          if (validatorPrivateMethods.hasCellRules(type, row, column)) {
            return validatorPrivateMethods.validCellRules(type, row, column).then(() => {
              if (editOpts.mode === "row") {
                validatorMethods.clearValidate(row, column);
              }
            }).catch(({ rule }) => {
              if (!rule.trigger || type === rule.trigger) {
                const rest = { rule, row, column, cell };
                validatorPrivateMethods.showValidTooltip(rest);
                return Promise.reject(rest);
              }
              return Promise.resolve();
            });
          }
        }
        return Promise.resolve();
      },
      /**
       * 
       */
      showValidTooltip(params) {
        const { height } = props;
        const { tableData, validStore, validErrorMaps } = reactData;
        const { rule, row, column, cell } = params;
        const validOpts = computeValidOpts.value;
        const validTip = refValidTooltip.value;
        const content = rule.content;
        validStore.visible = true;
        if (validOpts.msgMode === "single") {
          reactData.validErrorMaps = {
            [`${getRowid($xetable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          };
        } else {
          reactData.validErrorMaps = Object.assign({}, validErrorMaps, {
            [`${getRowid($xetable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          });
        }
        $xetable.dispatchEvent("valid-error", params, null);
        if (validTip) {
          if (validTip && (validOpts.message === "tooltip" || validOpts.message === "default" && !height && tableData.length < 2)) {
            return validTip.open(cell, content);
          }
        }
        return nextTick();
      }
    };
    return Object.assign(Object.assign({}, validatorMethods), validatorPrivateMethods);
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableValidatorMethodKeys);
  }
};
var hook_default5 = validatorHook;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/validator/index.js
var VxeTableValidatorModule = {
  install() {
    VXETable.hooks.add("$tableValidator", hook_default5);
  }
};
var Validator = VxeTableValidatorModule;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/tooltip/src/tooltip.js
var import_xe_utils34 = __toESM(require_xe_utils());
var tooltip_default = defineComponent({
  name: "VxeTooltip",
  props: {
    modelValue: Boolean,
    size: { type: String, default: () => conf_default.tooltip.size || conf_default.size },
    trigger: { type: String, default: () => conf_default.tooltip.trigger || "hover" },
    theme: { type: String, default: () => conf_default.tooltip.theme || "dark" },
    content: { type: [String, Number], default: null },
    useHTML: Boolean,
    zIndex: [String, Number],
    popupClassName: [String, Function],
    isArrow: { type: Boolean, default: true },
    enterable: Boolean,
    enterDelay: { type: Number, default: () => conf_default.tooltip.enterDelay },
    leaveDelay: { type: Number, default: () => conf_default.tooltip.leaveDelay }
  },
  emits: [
    "update:modelValue"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils34.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      target: null,
      isUpdate: false,
      visible: false,
      tipContent: "",
      tipActive: false,
      tipTarget: null,
      tipZindex: 0,
      tipStore: {
        style: {},
        placement: "",
        arrowStyle: {}
      }
    });
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xetooltip = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let tooltipMethods = {};
    const updateTipStyle = () => {
      const { tipTarget, tipStore } = reactData;
      if (tipTarget) {
        const { scrollTop, scrollLeft, visibleWidth } = getDomNode();
        const { top, left } = getAbsolutePos(tipTarget);
        const el = refElem.value;
        const marginSize = 6;
        const offsetHeight = el.offsetHeight;
        const offsetWidth = el.offsetWidth;
        let tipLeft = left;
        let tipTop = top - offsetHeight - marginSize;
        tipLeft = Math.max(marginSize, left + Math.floor((tipTarget.offsetWidth - offsetWidth) / 2));
        if (tipLeft + offsetWidth + marginSize > scrollLeft + visibleWidth) {
          tipLeft = scrollLeft + visibleWidth - offsetWidth - marginSize;
        }
        if (top - offsetHeight < scrollTop + marginSize) {
          tipStore.placement = "bottom";
          tipTop = top + tipTarget.offsetHeight + marginSize;
        }
        tipStore.style.top = `${tipTop}px`;
        tipStore.style.left = `${tipLeft}px`;
        tipStore.arrowStyle.left = `${left - tipLeft + tipTarget.offsetWidth / 2}px`;
      }
    };
    const updateValue = (value) => {
      if (value !== reactData.visible) {
        reactData.visible = value;
        reactData.isUpdate = true;
        emit("update:modelValue", value);
      }
    };
    const updateZindex = () => {
      if (reactData.tipZindex < getLastZIndex()) {
        reactData.tipZindex = nextZIndex();
      }
    };
    const clickEvent = () => {
      if (reactData.visible) {
        tooltipMethods.close();
      } else {
        tooltipMethods.open();
      }
    };
    const targetMouseenterEvent = () => {
      tooltipMethods.open();
    };
    const targetMouseleaveEvent = () => {
      const { trigger, enterable, leaveDelay } = props;
      reactData.tipActive = false;
      if (enterable && trigger === "hover") {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      } else {
        tooltipMethods.close();
      }
    };
    const wrapperMouseenterEvent = () => {
      reactData.tipActive = true;
    };
    const wrapperMouseleaveEvent = () => {
      const { trigger, enterable, leaveDelay } = props;
      reactData.tipActive = false;
      if (enterable && trigger === "hover") {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      }
    };
    const showTip = () => {
      const { tipStore } = reactData;
      const el = refElem.value;
      if (el) {
        const parentNode = el.parentNode;
        if (!parentNode) {
          document.body.appendChild(el);
        }
      }
      updateValue(true);
      updateZindex();
      tipStore.placement = "top";
      tipStore.style = { width: "auto", left: 0, top: 0, zIndex: props.zIndex || reactData.tipZindex };
      tipStore.arrowStyle = { left: "50%" };
      return tooltipMethods.updatePlacement();
    };
    const showDelayTip = import_xe_utils34.default.debounce(() => {
      if (reactData.tipActive) {
        showTip();
      }
    }, props.enterDelay, { leading: false, trailing: true });
    tooltipMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $tooltip: $xetooltip, $event: evnt }, params));
      },
      open(target, content) {
        return tooltipMethods.toVisible(target || reactData.target, content);
      },
      close() {
        reactData.tipTarget = null;
        reactData.tipActive = false;
        Object.assign(reactData.tipStore, {
          style: {},
          placement: "",
          arrowStyle: null
        });
        updateValue(false);
        return nextTick();
      },
      toVisible(target, content) {
        if (target) {
          const { trigger, enterDelay } = props;
          reactData.tipActive = true;
          reactData.tipTarget = target;
          if (content) {
            reactData.tipContent = content;
          }
          if (enterDelay && trigger === "hover") {
            showDelayTip();
          } else {
            return showTip();
          }
        }
        return nextTick();
      },
      updatePlacement() {
        return nextTick().then(() => {
          const { tipTarget } = reactData;
          const el = refElem.value;
          if (tipTarget && el) {
            updateTipStyle();
            return nextTick().then(updateTipStyle);
          }
        });
      },
      isActived() {
        return reactData.tipActive;
      },
      setActived(actived) {
        reactData.tipActive = !!actived;
      }
    };
    Object.assign($xetooltip, tooltipMethods);
    watch(() => props.content, () => {
      reactData.tipContent = props.content;
    });
    watch(() => props.modelValue, () => {
      if (!reactData.isUpdate) {
        if (props.modelValue) {
          tooltipMethods.open();
        } else {
          tooltipMethods.close();
        }
      }
      reactData.isUpdate = false;
    });
    onMounted(() => {
      nextTick(() => {
        const { trigger, content, modelValue } = props;
        const wrapperElem = refElem.value;
        if (wrapperElem) {
          const parentNode = wrapperElem.parentNode;
          if (parentNode) {
            reactData.tipContent = content;
            reactData.tipZindex = nextZIndex();
            import_xe_utils34.default.arrayEach(wrapperElem.children, (elem, index) => {
              if (index > 1) {
                parentNode.insertBefore(elem, wrapperElem);
                if (!reactData.target) {
                  reactData.target = elem;
                }
              }
            });
            parentNode.removeChild(wrapperElem);
            const { target } = reactData;
            if (target) {
              if (trigger === "hover") {
                target.onmouseenter = targetMouseenterEvent;
                target.onmouseleave = targetMouseleaveEvent;
              } else if (trigger === "click") {
                target.onclick = clickEvent;
              }
            }
            if (modelValue) {
              tooltipMethods.open();
            }
          }
        }
      });
    });
    onBeforeUnmount(() => {
      const { trigger } = props;
      const { target } = reactData;
      const wrapperElem = refElem.value;
      if (target) {
        if (trigger === "hover") {
          target.onmouseenter = null;
          target.onmouseleave = null;
        } else if (trigger === "click") {
          target.onclick = null;
        }
      }
      if (wrapperElem) {
        const parentNode = wrapperElem.parentNode;
        if (parentNode) {
          parentNode.removeChild(wrapperElem);
        }
      }
    });
    const renderContent = () => {
      const { useHTML } = props;
      const { tipContent } = reactData;
      const contentSlot = slots.content;
      if (contentSlot) {
        return h("div", {
          key: 1,
          class: "vxe-table--tooltip-content"
        }, getSlotVNs(contentSlot({})));
      }
      if (useHTML) {
        return h("div", {
          key: 2,
          class: "vxe-table--tooltip-content",
          innerHTML: tipContent
        });
      }
      return h("div", {
        key: 3,
        class: "vxe-table--tooltip-content"
      }, formatText(tipContent));
    };
    const renderVN = () => {
      const { popupClassName, theme, isArrow, enterable } = props;
      const { tipActive, visible, tipStore } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      let ons;
      if (enterable) {
        ons = {
          onMouseenter: wrapperMouseenterEvent,
          onMouseleave: wrapperMouseleaveEvent
        };
      }
      return h("div", Object.assign({ ref: refElem, class: ["vxe-table--tooltip-wrapper", `theme--${theme}`, popupClassName ? import_xe_utils34.default.isFunction(popupClassName) ? popupClassName({ $tooltip: $xetooltip }) : popupClassName : "", {
        [`size--${vSize}`]: vSize,
        [`placement--${tipStore.placement}`]: tipStore.placement,
        "is--enterable": enterable,
        "is--visible": visible,
        "is--arrow": isArrow,
        "is--active": tipActive
      }], style: tipStore.style }, ons), [
        renderContent(),
        h("div", {
          class: "vxe-table--tooltip-arrow",
          style: tipStore.arrowStyle
        }),
        ...defaultSlot ? getSlotVNs(defaultSlot({})) : []
      ]);
    };
    $xetooltip.renderVN = renderVN;
    return $xetooltip;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/custom/src/panel.js
var import_xe_utils35 = __toESM(require_xe_utils());
var panel_default3 = defineComponent({
  name: "VxeTableCustomPanel",
  props: {
    customStore: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props) {
    const $xetable = inject("$xetable", {});
    const { reactData } = $xetable;
    const { computeCustomOpts, computeColumnOpts, computeIsMaxFixedColumn } = $xetable.getComputeMaps();
    const refElem = ref();
    const bodyElemRef = ref();
    const dragHintElemRef = ref();
    const dragColumn = ref();
    let prevDropTrEl;
    const handleWrapperMouseenterEvent = (evnt) => {
      const { customStore } = props;
      customStore.activeWrapper = true;
      $xetable.customOpenEvent(evnt);
    };
    const handleWrapperMouseleaveEvent = (evnt) => {
      const { customStore } = props;
      customStore.activeWrapper = false;
      setTimeout(() => {
        if (!customStore.activeBtn && !customStore.activeWrapper) {
          $xetable.customColseEvent(evnt);
        }
      }, 300);
    };
    const confirmCustomEvent = (evnt) => {
      updateColumnSort();
      $xetable.closeCustom();
      $xetable.emitCustomEvent("confirm", evnt);
    };
    const cancelCustomEvent = (evnt) => {
      $xetable.closeCustom();
      $xetable.emitCustomEvent("cancel", evnt);
    };
    const resetCustomEvent = (evnt) => {
      $xetable.resetColumn(true);
      $xetable.closeCustom();
      $xetable.emitCustomEvent("reset", evnt);
    };
    const resetPopupCustomEvent = (evnt) => {
      if (VXETable.modal) {
        VXETable.modal.confirm({
          content: conf_default.i18n("vxe.custom.cstmConfirmRestore"),
          className: "vxe-table--ignore-clear",
          escClosable: true
        }).then((type) => {
          if (type === "confirm") {
            resetCustomEvent(evnt);
          }
        });
      } else {
        resetCustomEvent(evnt);
      }
    };
    const handleOptionCheck = (column) => {
      const { customColumnList } = reactData;
      const matchObj = import_xe_utils35.default.findTree(customColumnList, (item) => item === column);
      if (matchObj && matchObj.parent) {
        const { parent } = matchObj;
        if (parent.children && parent.children.length) {
          parent.visible = parent.children.every((column2) => column2.visible);
          parent.halfVisible = !parent.visible && parent.children.some((column2) => column2.visible || column2.halfVisible);
          handleOptionCheck(parent);
        }
      }
    };
    const changeCheckboxOption = (column) => {
      const isChecked = !column.visible;
      const customOpts = computeCustomOpts.value;
      import_xe_utils35.default.eachTree([column], (item) => {
        item.visible = isChecked;
        item.halfVisible = false;
      });
      handleOptionCheck(column);
      if (customOpts.immediate) {
        $xetable.handleCustom();
      }
      $xetable.checkCustomStatus();
    };
    const changeFixedOption = (column, colFixed) => {
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      if (column.fixed === colFixed) {
        $xetable.clearColumnFixed(column);
      } else {
        if (!isMaxFixedColumn || column.fixed) {
          $xetable.setColumnFixed(column, colFixed);
        }
      }
    };
    const changePopupFixedOption = (column) => {
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      if (!isMaxFixedColumn) {
        $xetable.setColumnFixed(column, column.fixed);
      }
    };
    const allCustomEvent = () => {
      const { customStore } = props;
      const { customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { checkMethod } = customOpts;
      const isAll = !customStore.isAll;
      import_xe_utils35.default.eachTree(customColumnList, (column) => {
        if (!checkMethod || checkMethod({ column })) {
          column.visible = isAll;
          column.halfVisible = false;
        }
      });
      customStore.isAll = isAll;
      $xetable.checkCustomStatus();
    };
    const sortMousedownEvent = (evnt) => {
      const btnEl = evnt.currentTarget;
      const tdEl = btnEl.parentNode;
      const trEl = tdEl.parentNode;
      const colid = trEl.getAttribute("colid");
      const column = $xetable.getColumnById(colid);
      trEl.draggable = true;
      dragColumn.value = column;
      addClass(trEl, "active--drag-origin");
    };
    const sortMouseupEvent = (evnt) => {
      const btnEl = evnt.currentTarget;
      const tdEl = btnEl.parentNode;
      const trEl = tdEl.parentNode;
      const dragHintEl = dragHintElemRef.value;
      trEl.draggable = false;
      dragColumn.value = null;
      removeClass(trEl, "active--drag-origin");
      if (dragHintEl) {
        dragHintEl.style.display = "";
      }
    };
    const sortDragstartEvent = (evnt) => {
      const img = new Image();
      if (evnt.dataTransfer) {
        evnt.dataTransfer.setDragImage(img, 0, 0);
      }
    };
    const updateColumnSort = () => {
      const { customColumnList } = reactData;
      customColumnList.forEach((column, index) => {
        const sortIndex = index + 1;
        column.renderSortNumber = sortIndex;
      });
    };
    const sortDragendEvent = (evnt) => {
      const { customColumnList } = reactData;
      const trEl = evnt.currentTarget;
      const dragHintEl = dragHintElemRef.value;
      if (prevDropTrEl) {
        if (prevDropTrEl !== trEl) {
          const dragOffset = prevDropTrEl.getAttribute("drag-pos");
          const colid = trEl.getAttribute("colid");
          const column = $xetable.getColumnById(colid);
          if (!column) {
            return;
          }
          const cIndex = import_xe_utils35.default.findIndexOf(customColumnList, (item) => item.id === column.id);
          const targetColid = prevDropTrEl.getAttribute("colid");
          const targetColumn = $xetable.getColumnById(targetColid);
          if (!targetColumn) {
            return;
          }
          customColumnList.splice(cIndex, 1);
          const tcIndex = import_xe_utils35.default.findIndexOf(customColumnList, (item) => item.id === targetColumn.id);
          customColumnList.splice(tcIndex + (dragOffset === "bottom" ? 1 : 0), 0, column);
        }
        prevDropTrEl.draggable = false;
        prevDropTrEl.removeAttribute("drag-pos");
        removeClass(prevDropTrEl, "active--drag-target");
      }
      dragColumn.value = null;
      trEl.draggable = false;
      trEl.removeAttribute("drag-pos");
      if (dragHintEl) {
        dragHintEl.style.display = "";
      }
      removeClass(trEl, "active--drag-target");
      removeClass(trEl, "active--drag-origin");
      updateColumnSort();
    };
    const sortDragoverEvent = (evnt) => {
      const trEl = evnt.currentTarget;
      if (prevDropTrEl !== trEl) {
        removeClass(prevDropTrEl, "active--drag-target");
      }
      const colid = trEl.getAttribute("colid");
      const column = $xetable.getColumnById(colid);
      if (column && column.level === 1) {
        evnt.preventDefault();
        const offsetY = evnt.clientY - trEl.getBoundingClientRect().y;
        const dragOffset = offsetY < trEl.clientHeight / 2 ? "top" : "bottom";
        addClass(trEl, "active--drag-target");
        trEl.setAttribute("drag-pos", dragOffset);
        prevDropTrEl = trEl;
      }
      updateDropHint(evnt);
    };
    const updateDropHint = (evnt) => {
      const dragHintEl = dragHintElemRef.value;
      const bodyEl2 = bodyElemRef.value;
      if (!bodyEl2) {
        return;
      }
      if (dragHintEl) {
        const wrapperEl = bodyEl2.parentNode;
        const wrapperRect = wrapperEl.getBoundingClientRect();
        dragHintEl.style.display = "block";
        dragHintEl.style.top = `${Math.min(wrapperEl.clientHeight - wrapperEl.scrollTop - dragHintEl.clientHeight, evnt.clientY - wrapperRect.y)}px`;
        dragHintEl.style.left = `${Math.min(wrapperEl.clientWidth - wrapperEl.scrollLeft - dragHintEl.clientWidth - 16, evnt.clientX - wrapperRect.x)}px`;
      }
    };
    const renderSimplePanel = () => {
      const { customStore } = props;
      const { customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { maxHeight } = customStore;
      const { checkMethod, visibleMethod, trigger } = customOpts;
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const colVNs = [];
      const customWrapperOns = {};
      if (trigger === "hover") {
        customWrapperOns.onMouseenter = handleWrapperMouseenterEvent;
        customWrapperOns.onMouseleave = handleWrapperMouseleaveEvent;
      }
      import_xe_utils35.default.eachTree(customColumnList, (column, index, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({ column }) : true;
        if (isVisible) {
          const isChecked = column.visible;
          const isIndeterminate = column.halfVisible;
          const isColGroup = column.children && column.children.length;
          const colTitle = formatText(column.getTitle(), 1);
          const isDisabled = checkMethod ? !checkMethod({ column }) : false;
          colVNs.push(h("li", {
            key: column.id,
            class: ["vxe-table-custom--option", `level--${column.level}`, {
              "is--group": isColGroup
            }]
          }, [
            h("div", {
              title: colTitle,
              class: ["vxe-table-custom--checkbox-option", {
                "is--checked": isChecked,
                "is--indeterminate": isIndeterminate,
                "is--disabled": isDisabled
              }],
              onClick: () => {
                if (!isDisabled) {
                  changeCheckboxOption(column);
                }
              }
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isIndeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
              }),
              h("span", {
                class: "vxe-checkbox--label"
              }, colTitle)
            ]),
            !parent && customOpts.allowFixed ? h("div", {
              class: "vxe-table-custom--fixed-option"
            }, [
              h("span", {
                class: ["vxe-table-custom--fixed-left-option", column.fixed === "left" ? conf_default.icon.TOOLBAR_TOOLS_FIXED_LEFT_ACTIVED : conf_default.icon.TOOLBAR_TOOLS_FIXED_LEFT, {
                  "is--checked": column.fixed === "left",
                  "is--disabled": isMaxFixedColumn && !column.fixed
                }],
                title: conf_default.i18n(column.fixed === "left" ? "vxe.toolbar.cancelFixed" : "vxe.toolbar.fixedLeft"),
                onClick: () => {
                  changeFixedOption(column, "left");
                }
              }),
              h("span", {
                class: ["vxe-table-custom--fixed-right-option", column.fixed === "right" ? conf_default.icon.TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVED : conf_default.icon.TOOLBAR_TOOLS_FIXED_RIGHT, {
                  "is--checked": column.fixed === "right",
                  "is--disabled": isMaxFixedColumn && !column.fixed
                }],
                title: conf_default.i18n(column.fixed === "right" ? "vxe.toolbar.cancelFixed" : "vxe.toolbar.fixedRight"),
                onClick: () => {
                  changeFixedOption(column, "right");
                }
              })
            ]) : null
          ]));
        }
      });
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      return h("div", {
        ref: refElem,
        key: "simple",
        class: ["vxe-table-custom-wrapper", {
          "is--active": customStore.visible
        }]
      }, [
        h("ul", {
          class: "vxe-table-custom--header"
        }, [
          h("li", {
            class: "vxe-table-custom--option"
          }, [
            h("div", {
              class: ["vxe-table-custom--checkbox-option", {
                "is--checked": isAllChecked,
                "is--indeterminate": isAllIndeterminate
              }],
              title: conf_default.i18n("vxe.table.allTitle"),
              onClick: allCustomEvent
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isAllIndeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
              }),
              h("span", {
                class: "vxe-checkbox--label"
              }, conf_default.i18n("vxe.toolbar.customAll"))
            ])
          ])
        ]),
        h("ul", Object.assign({ class: "vxe-table-custom--body", style: maxHeight ? {
          maxHeight: `${maxHeight}px`
        } : {} }, customWrapperOns), colVNs),
        customOpts.showFooter ? h("div", {
          class: "vxe-table-custom--footer"
        }, [
          h("button", {
            class: "btn--reset",
            onClick: resetCustomEvent
          }, customOpts.resetButtonText || conf_default.i18n("vxe.toolbar.customRestore")),
          h("button", {
            class: "btn--confirm",
            onClick: confirmCustomEvent
          }, customOpts.confirmButtonText || conf_default.i18n("vxe.toolbar.customConfirm"))
        ]) : null
      ]);
    };
    const renderPopupPanel = () => {
      const { customStore } = props;
      const { customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { checkMethod, visibleMethod } = customOpts;
      const columnOpts = computeColumnOpts.value;
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const trVNs = [];
      import_xe_utils35.default.eachTree(customColumnList, (column, index, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({ column }) : true;
        if (isVisible) {
          const isChecked = column.visible;
          const isIndeterminate = column.halfVisible;
          const colTitle = formatText(column.getTitle(), 1);
          const isColGroup = column.children && column.children.length;
          const isDisabled = checkMethod ? !checkMethod({ column }) : false;
          trVNs.push(h("tr", {
            key: column.id,
            colid: column.id,
            class: [`vxe-table-custom-popup--row level--${column.level}`, {
              "is--group": isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [
            h("td", {
              class: "vxe-table-custom-popup--column-item col--sort"
            }, [
              column.level === 1 ? h("span", {
                class: "vxe-table-custom-popup--column-sort-btn",
                onMousedown: sortMousedownEvent,
                onMouseup: sortMouseupEvent
              }, [
                h("i", {
                  class: "vxe-icon-sort"
                })
              ]) : null
            ]),
            h("td", {
              class: "vxe-table-custom-popup--column-item col--name"
            }, [
              h("div", {
                class: "vxe-table-custom-popup--name",
                title: colTitle
              }, colTitle)
            ]),
            h("td", {
              class: "vxe-table-custom-popup--column-item col--visible"
            }, [
              h("div", {
                class: ["vxe-table-custom--checkbox-option", {
                  "is--checked": isChecked,
                  "is--indeterminate": isIndeterminate,
                  "is--disabled": isDisabled
                }],
                onClick: () => {
                  if (!isDisabled) {
                    changeCheckboxOption(column);
                  }
                }
              }, [
                h("span", {
                  class: ["vxe-checkbox--icon", isIndeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
                })
              ])
            ]),
            h("td", {
              class: "vxe-table-custom-popup--column-item col--fixed"
            }, [
              !parent && customOpts.allowFixed ? h(group_default, {
                modelValue: column.fixed || "",
                type: "button",
                size: "mini",
                options: [
                  { label: conf_default.i18n("vxe.custom.setting.fixedLeft"), value: "left", disabled: isMaxFixedColumn },
                  { label: conf_default.i18n("vxe.custom.setting.fixedUnset"), value: "" },
                  { label: conf_default.i18n("vxe.custom.setting.fixedRight"), value: "right", disabled: isMaxFixedColumn }
                ],
                "onUpdate:modelValue"(value) {
                  column.fixed = value;
                },
                onChange() {
                  changePopupFixedOption(column);
                }
              }) : null
            ])
          ]));
        }
      });
      return h(modal_default, {
        key: "popup",
        className: "vxe-table-custom-popup-wrapper vxe-table--ignore-clear",
        modelValue: customStore.visible,
        title: conf_default.i18n("vxe.custom.cstmTitle"),
        width: "40vw",
        minWidth: 520,
        height: "50vh",
        minHeight: 300,
        mask: true,
        lockView: true,
        showFooter: true,
        resize: true,
        escClosable: true,
        destroyOnClose: true,
        "onUpdate:modelValue"(value) {
          customStore.visible = value;
        }
      }, {
        default: () => {
          return h("div", {
            ref: bodyElemRef,
            class: "vxe-table-custom-popup--body"
          }, [
            h("div", {
              class: "vxe-table-custom-popup--table-wrapper"
            }, [
              h("table", {}, [
                h("colgroup", {}, [
                  h("col", {
                    style: {
                      width: "80px"
                    }
                  }),
                  h("col", {}),
                  h("col", {
                    style: {
                      width: "80px"
                    }
                  }),
                  h("col", {
                    style: {
                      width: "200px"
                    }
                  })
                ]),
                h("thead", {}, [
                  h("tr", {}, [
                    h("th", {}, [
                      h("span", {
                        class: "vxe-table-custom-popup--table-sort-help-title"
                      }, conf_default.i18n("vxe.custom.setting.colSort")),
                      h(tooltip_default, {
                        enterable: true,
                        content: conf_default.i18n("vxe.custom.setting.sortHelpTip")
                      }, {
                        default: () => {
                          return h("i", {
                            class: "vxe-table-custom-popup--table-sort-help-icon vxe-icon-question-circle-fill"
                          });
                        }
                      })
                    ]),
                    h("th", {}, conf_default.i18n("vxe.custom.setting.colTitle")),
                    h("th", {}, conf_default.i18n("vxe.custom.setting.colVisible")),
                    h("th", {}, conf_default.i18n("vxe.custom.setting.colFixed", [columnOpts.maxFixedSize || 0]))
                  ])
                ]),
                h(TransitionGroup, {
                  class: "vxe-table-custom--body",
                  tag: "tbody",
                  name: "vxe-table-custom--list"
                }, {
                  default: () => trVNs
                })
              ])
            ]),
            h("div", {
              ref: dragHintElemRef,
              class: "vxe-table-custom-popup--drag-hint"
            }, conf_default.i18n("vxe.custom.cstmDragTarget", [dragColumn.value ? dragColumn.value.getTitle() : ""]))
          ]);
        },
        footer: () => {
          return h("div", {
            class: "vxe-table-custom-popup--footer"
          }, [
            h(button_default, {
              content: customOpts.resetButtonText || conf_default.i18n("vxe.custom.cstmRestore"),
              onClick: resetPopupCustomEvent
            }),
            h(button_default, {
              content: customOpts.resetButtonText || conf_default.i18n("vxe.custom.cstmCancel"),
              onClick: cancelCustomEvent
            }),
            h(button_default, {
              status: "primary",
              content: customOpts.confirmButtonText || conf_default.i18n("vxe.custom.cstmConfirm"),
              onClick: confirmCustomEvent
            })
          ]);
        }
      });
    };
    const renderVN = () => {
      const customOpts = computeCustomOpts.value;
      if (customOpts.mode === "popup") {
        return renderPopupPanel();
      }
      return renderSimplePanel();
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/custom/src/hook.js
var tableCustomMethodKeys = ["openCustom", "closeCustom"];
var customHook = {
  setupTable($xetable) {
    const { reactData, internalData } = $xetable;
    const { computeCustomOpts } = $xetable.getComputeMaps();
    const { refTableHeader, refTableBody, refTableCustom } = $xetable.getRefMaps();
    const $xegrid = $xetable.xegrid;
    const calcMaxHeight = () => {
      const { customStore } = reactData;
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableCustom = refTableCustom.value;
      const customWrapperElem = tableCustom ? tableCustom.$el : null;
      const headElem = tableHeader.$el;
      const bodyElem = tableBody.$el;
      let tableHeight = 0;
      if (headElem) {
        tableHeight += headElem.clientHeight;
      }
      if (bodyElem) {
        tableHeight += bodyElem.clientHeight;
      }
      customStore.maxHeight = Math.max(0, customWrapperElem ? Math.min(customWrapperElem.clientHeight, tableHeight - 80) : 0);
    };
    const openCustom = () => {
      const { initStore, customStore } = reactData;
      customStore.visible = true;
      initStore.custom = true;
      reactData.customColumnList = internalData.collectColumn.slice(0);
      checkCustomStatus();
      calcMaxHeight();
      return nextTick().then(() => calcMaxHeight());
    };
    const closeCustom = () => {
      const { customStore } = reactData;
      const customOpts = computeCustomOpts.value;
      if (customStore.visible) {
        customStore.visible = false;
        if (!customOpts.immediate) {
          $xetable.handleCustom();
        }
      }
      return nextTick();
    };
    const customMethods = {
      openCustom,
      closeCustom
    };
    const checkCustomStatus = () => {
      const { customStore } = reactData;
      const { collectColumn } = internalData;
      const customOpts = computeCustomOpts.value;
      const { checkMethod } = customOpts;
      customStore.isAll = collectColumn.every((column) => (checkMethod ? !checkMethod({ column }) : false) || column.visible);
      customStore.isIndeterminate = !customStore.isAll && collectColumn.some((column) => (!checkMethod || checkMethod({ column })) && (column.visible || column.halfVisible));
    };
    const emitCustomEvent = (type, evnt) => {
      const comp = $xegrid || $xetable;
      comp.dispatchEvent("custom", { type }, evnt);
    };
    const customPrivateMethods = {
      checkCustomStatus,
      emitCustomEvent,
      triggerCustomEvent(evnt) {
        const { customStore } = $xetable.reactData;
        if (customStore.visible) {
          closeCustom();
          emitCustomEvent("close", evnt);
        } else {
          customStore.btnEl = evnt.target;
          openCustom();
          emitCustomEvent("open", evnt);
        }
      },
      customOpenEvent(evnt) {
        const { customStore } = reactData;
        if (!customStore.visible) {
          customStore.activeBtn = true;
          customStore.btnEl = evnt.target;
          $xetable.openCustom();
          $xetable.emitCustomEvent("open", evnt);
        }
      },
      customColseEvent(evnt) {
        const { customStore } = reactData;
        if (customStore.visible) {
          customStore.activeBtn = false;
          $xetable.closeCustom();
          $xetable.emitCustomEvent("close", evnt);
        }
      }
    };
    return Object.assign(Object.assign({}, customMethods), customPrivateMethods);
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableCustomMethodKeys);
  }
};
var hook_default6 = customHook;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/custom/index.js
var VxeTableCustomModule = {
  Panel: panel_default3,
  install(app) {
    VXETable.hooks.add("$tableCustom", hook_default6);
    app.component(panel_default3.name, panel_default3);
  }
};
var Custom = VxeTableCustomModule;
dynamicApp.component(panel_default3.name, panel_default3);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/icon/src/icon.js
var icon_default = defineComponent({
  name: "VxeIcon",
  props: {
    name: String,
    roll: Boolean,
    status: String
  },
  emits: [
    "click"
  ],
  setup(props, { emit }) {
    const clickEvent = (evnt) => {
      emit("click", { $event: evnt });
    };
    return () => {
      const { name, roll, status } = props;
      return h("i", {
        class: [`vxe-icon-${name}`, roll ? "roll" : "", status ? [`theme--${status}`] : ""],
        onClick: clickEvent
      });
    };
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/icon/index.js
var VxeIcon = Object.assign(icon_default, {
  install(app) {
    app.component(icon_default.name, icon_default);
  }
});
var Icon = VxeIcon;
dynamicApp.component(VxeIcon.name, VxeIcon);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/cell.js
var import_xe_utils36 = __toESM(require_xe_utils());
function renderTitlePrefixIcon(params) {
  const { $table, column } = params;
  const titlePrefix = column.titlePrefix || column.titleHelp;
  return titlePrefix ? [
    h("i", {
      class: ["vxe-cell-title-prefix-icon", titlePrefix.icon || conf_default.icon.TABLE_TITLE_PREFIX],
      onMouseenter(evnt) {
        $table.triggerHeaderTitleEvent(evnt, titlePrefix, params);
      },
      onMouseleave(evnt) {
        $table.handleTargetLeaveEvent(evnt);
      }
    })
  ] : [];
}
function renderTitleSuffixIcon(params) {
  const { $table, column } = params;
  const titleSuffix = column.titleSuffix;
  return titleSuffix ? [
    h("i", {
      class: ["vxe-cell-title-suffix-icon", titleSuffix.icon || conf_default.icon.TABLE_TITLE_SUFFIX],
      onMouseenter(evnt) {
        $table.triggerHeaderTitleEvent(evnt, titleSuffix, params);
      },
      onMouseleave(evnt) {
        $table.handleTargetLeaveEvent(evnt);
      }
    })
  ] : [];
}
function renderTitleContent(params, content) {
  const { $table, column } = params;
  const { props, reactData } = $table;
  const { computeTooltipOpts } = $table.getComputeMaps();
  const { showHeaderOverflow: allColumnHeaderOverflow } = props;
  const { type, showHeaderOverflow } = column;
  const tooltipOpts = computeTooltipOpts.value;
  const showAllTip = tooltipOpts.showAll;
  const headOverflow = import_xe_utils36.default.isUndefined(showHeaderOverflow) || import_xe_utils36.default.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  const showTitle = headOverflow === "title";
  const showTooltip = headOverflow === true || headOverflow === "tooltip";
  const ons = {};
  if (showTitle || showTooltip || showAllTip) {
    ons.onMouseenter = (evnt) => {
      if (reactData._isResize) {
        return;
      }
      if (showTitle) {
        updateCellTitle(evnt.currentTarget, column);
      } else if (showTooltip || showAllTip) {
        $table.triggerHeaderTooltipEvent(evnt, params);
      }
    };
  }
  if (showTooltip || showAllTip) {
    ons.onMouseleave = (evnt) => {
      if (reactData._isResize) {
        return;
      }
      if (showTooltip || showAllTip) {
        $table.handleTargetLeaveEvent(evnt);
      }
    };
  }
  return [
    type === "html" && import_xe_utils36.default.isString(content) ? h("span", Object.assign({ class: "vxe-cell--title", innerHTML: content }, ons)) : h("span", Object.assign({ class: "vxe-cell--title" }, ons), getSlotVNs(content))
  ];
}
function getFooterContent(params) {
  const { $table, column, _columnIndex, items, row } = params;
  const { slots, editRender, cellRender } = column;
  const renderOpts = editRender || cellRender;
  const footerSlot = slots ? slots.footer : null;
  if (footerSlot) {
    return $table.callSlot(footerSlot, params);
  }
  if (renderOpts) {
    const compConf = VXETable.renderer.get(renderOpts.name);
    if (compConf && compConf.renderFooter) {
      return getSlotVNs(compConf.renderFooter(renderOpts, params));
    }
  }
  if (import_xe_utils36.default.isArray(items)) {
    return [formatText(items[_columnIndex], 1)];
  }
  return [formatText(import_xe_utils36.default.get(row, column.field), 1)];
}
function getDefaultCellLabel(params) {
  const { $table, row, column } = params;
  return formatText($table.getCellLabel(row, column), 1);
}
var Cell = {
  createColumn($xetable, columnOpts) {
    const { type, sortable, filters, editRender, treeNode } = columnOpts;
    const { props } = $xetable;
    const { editConfig } = props;
    const { computeEditOpts, computeCheckboxOpts } = $xetable.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const editOpts = computeEditOpts.value;
    const renConfs = {
      renderHeader: Cell.renderDefaultHeader,
      renderCell: treeNode ? Cell.renderTreeCell : Cell.renderDefaultCell,
      renderFooter: Cell.renderDefaultFooter
    };
    switch (type) {
      case "seq":
        renConfs.renderHeader = Cell.renderSeqHeader;
        renConfs.renderCell = treeNode ? Cell.renderTreeIndexCell : Cell.renderSeqCell;
        break;
      case "radio":
        renConfs.renderHeader = Cell.renderRadioHeader;
        renConfs.renderCell = treeNode ? Cell.renderTreeRadioCell : Cell.renderRadioCell;
        break;
      case "checkbox":
        renConfs.renderHeader = Cell.renderCheckboxHeader;
        renConfs.renderCell = checkboxOpts.checkField ? treeNode ? Cell.renderTreeSelectionCellByProp : Cell.renderCheckboxCellByProp : treeNode ? Cell.renderTreeSelectionCell : Cell.renderCheckboxCell;
        break;
      case "expand":
        renConfs.renderCell = Cell.renderExpandCell;
        renConfs.renderData = Cell.renderExpandData;
        break;
      case "html":
        renConfs.renderCell = treeNode ? Cell.renderTreeHTMLCell : Cell.renderHTMLCell;
        if (filters && sortable) {
          renConfs.renderHeader = Cell.renderSortAndFilterHeader;
        } else if (sortable) {
          renConfs.renderHeader = Cell.renderSortHeader;
        } else if (filters) {
          renConfs.renderHeader = Cell.renderFilterHeader;
        }
        break;
      default:
        if (editConfig && editRender) {
          renConfs.renderHeader = Cell.renderEditHeader;
          renConfs.renderCell = editOpts.mode === "cell" ? treeNode ? Cell.renderTreeCellEdit : Cell.renderCellEdit : treeNode ? Cell.renderTreeRowEdit : Cell.renderRowEdit;
        } else if (filters && sortable) {
          renConfs.renderHeader = Cell.renderSortAndFilterHeader;
        } else if (sortable) {
          renConfs.renderHeader = Cell.renderSortHeader;
        } else if (filters) {
          renConfs.renderHeader = Cell.renderFilterHeader;
        }
    }
    return createColumn($xetable, columnOpts, renConfs);
  },
  /**
   * 
   */
  renderHeaderTitle(params) {
    const { $table, column } = params;
    const { slots, editRender, cellRender } = column;
    const renderOpts = editRender || cellRender;
    const headerSlot = slots ? slots.header : null;
    if (headerSlot) {
      return renderTitleContent(params, $table.callSlot(headerSlot, params));
    }
    if (renderOpts) {
      const compConf = VXETable.renderer.get(renderOpts.name);
      if (compConf && compConf.renderHeader) {
        return renderTitleContent(params, getSlotVNs(compConf.renderHeader(renderOpts, params)));
      }
    }
    return renderTitleContent(params, formatText(column.getTitle(), 1));
  },
  renderDefaultHeader(params) {
    return renderTitlePrefixIcon(params).concat(Cell.renderHeaderTitle(params)).concat(renderTitleSuffixIcon(params));
  },
  renderDefaultCell(params) {
    const { $table, row, column } = params;
    const { slots, editRender, cellRender } = column;
    const renderOpts = editRender || cellRender;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return $table.callSlot(defaultSlot, params);
    }
    if (renderOpts) {
      const funName = editRender ? "renderCell" : "renderDefault";
      const compConf = VXETable.renderer.get(renderOpts.name);
      const compFn = compConf ? compConf[funName] : null;
      if (compFn) {
        return getSlotVNs(compFn(renderOpts, Object.assign({ $type: editRender ? "edit" : "cell" }, params)));
      }
    }
    const cellValue = $table.getCellLabel(row, column);
    const cellPlaceholder = editRender ? editRender.placeholder : "";
    return [
      h("span", {
        class: "vxe-cell--label"
      }, editRender && eqEmptyValue(cellValue) ? [
        // 
        h("span", {
          class: "vxe-cell--placeholder"
        }, formatText(getFuncText(cellPlaceholder), 1))
      ] : formatText(cellValue, 1))
    ];
  },
  renderTreeCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderDefaultCell(params));
  },
  renderDefaultFooter(params) {
    return [
      h("span", {
        class: "vxe-cell--item"
      }, getFooterContent(params))
    ];
  },
  /**
   * 
   */
  renderTreeIcon(params, cellVNodes) {
    const { $table, isHidden } = params;
    const { reactData } = $table;
    const { computeTreeOpts } = $table.getComputeMaps();
    const { treeExpandedMaps, treeExpandLazyLoadedMaps } = reactData;
    const treeOpts = computeTreeOpts.value;
    const { row, column, level } = params;
    const { slots } = column;
    const { indent, lazy, trigger, iconLoaded, showIcon, iconOpen, iconClose } = treeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
    const rowChilds = row[childrenField];
    const iconSlot = slots ? slots.icon : null;
    let hasLazyChilds = false;
    let isAceived = false;
    let isLazyLoaded = false;
    const ons = {};
    if (iconSlot) {
      return $table.callSlot(iconSlot, params);
    }
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isAceived = !!treeExpandedMaps[rowid];
      if (lazy) {
        isLazyLoaded = !!treeExpandLazyLoadedMaps[rowid];
        hasLazyChilds = row[hasChildField];
      }
    }
    if (!trigger || trigger === "default") {
      ons.onClick = (evnt) => {
        evnt.stopPropagation();
        $table.triggerTreeExpandEvent(evnt, params);
      };
    }
    return [
      h("div", {
        class: ["vxe-cell--tree-node", {
          "is--active": isAceived
        }],
        style: {
          paddingLeft: `${level * indent}px`
        }
      }, [
        showIcon && (rowChilds && rowChilds.length || hasLazyChilds) ? [
          h("div", Object.assign({ class: "vxe-tree--btn-wrapper" }, ons), [
            h("i", {
              class: ["vxe-tree--node-btn", isLazyLoaded ? iconLoaded || conf_default.icon.TABLE_TREE_LOADED : isAceived ? iconOpen || conf_default.icon.TABLE_TREE_OPEN : iconClose || conf_default.icon.TABLE_TREE_CLOSE]
            })
          ])
        ] : null,
        h("div", {
          class: "vxe-tree-cell"
        }, cellVNodes)
      ])
    ];
  },
  /**
   * 
   */
  renderSeqHeader(params) {
    const { $table, column } = params;
    const { slots } = column;
    const headerSlot = slots ? slots.header : null;
    return renderTitleContent(params, headerSlot ? $table.callSlot(headerSlot, params) : formatText(column.getTitle(), 1));
  },
  renderSeqCell(params) {
    const { $table, column } = params;
    const { props } = $table;
    const { treeConfig } = props;
    const { computeSeqOpts } = $table.getComputeMaps();
    const seqOpts = computeSeqOpts.value;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return $table.callSlot(defaultSlot, params);
    }
    const { seq } = params;
    const seqMethod = seqOpts.seqMethod;
    return [formatText(seqMethod ? seqMethod(params) : treeConfig ? seq : (seqOpts.startIndex || 0) + seq, 1)];
  },
  renderTreeIndexCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderSeqCell(params));
  },
  /**
   * 
   */
  renderRadioHeader(params) {
    const { $table, column } = params;
    const { slots } = column;
    const headerSlot = slots ? slots.header : null;
    const titleSlot = slots ? slots.title : null;
    return renderTitleContent(params, headerSlot ? $table.callSlot(headerSlot, params) : [
      h("span", {
        class: "vxe-radio--label"
      }, titleSlot ? $table.callSlot(titleSlot, params) : formatText(column.getTitle(), 1))
    ]);
  },
  renderRadioCell(params) {
    const { $table, column, isHidden } = params;
    const { reactData } = $table;
    const { computeRadioOpts } = $table.getComputeMaps();
    const { selectRadioRow } = reactData;
    const radioOpts = computeRadioOpts.value;
    const { slots } = column;
    const { labelField, checkMethod, visibleMethod } = radioOpts;
    const { row } = params;
    const defaultSlot = slots ? slots.default : null;
    const radioSlot = slots ? slots.radio : null;
    const isChecked = $table.eqRow(row, selectRadioRow);
    const isVisible = !visibleMethod || visibleMethod({ row });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            evnt.stopPropagation();
            $table.triggerRadioRowEvent(evnt, params);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({ row });
      }
    }
    const radioParams = Object.assign(Object.assign({}, params), { checked: isChecked, disabled: isDisabled, visible: isVisible });
    if (radioSlot) {
      return $table.callSlot(radioSlot, radioParams);
    }
    const radioVNs = [];
    if (isVisible) {
      radioVNs.push(h("span", {
        class: ["vxe-radio--icon", isChecked ? conf_default.icon.TABLE_RADIO_CHECKED : conf_default.icon.TABLE_RADIO_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      radioVNs.push(h("span", {
        class: "vxe-radio--label"
      }, defaultSlot ? $table.callSlot(defaultSlot, radioParams) : import_xe_utils36.default.get(row, labelField)));
    }
    return [
      h("span", Object.assign({ class: ["vxe-cell--radio", {
        "is--checked": isChecked,
        "is--disabled": isDisabled
      }] }, ons), radioVNs)
    ];
  },
  renderTreeRadioCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderRadioCell(params));
  },
  /**
   * 
   */
  renderCheckboxHeader(params) {
    const { $table, column, isHidden } = params;
    const { reactData } = $table;
    const { computeIsAllCheckboxDisabled, computeCheckboxOpts } = $table.getComputeMaps();
    const { isAllSelected: isAllCheckboxSelected, isIndeterminate: isAllCheckboxIndeterminate } = reactData;
    const isAllCheckboxDisabled = computeIsAllCheckboxDisabled.value;
    const { slots } = column;
    const headerSlot = slots ? slots.header : null;
    const titleSlot = slots ? slots.title : null;
    const checkboxOpts = computeCheckboxOpts.value;
    const headerTitle = column.getTitle();
    let ons;
    if (!isHidden) {
      ons = {
        onClick(evnt) {
          if (!isAllCheckboxDisabled) {
            evnt.stopPropagation();
            $table.triggerCheckAllEvent(evnt, !isAllCheckboxSelected);
          }
        }
      };
    }
    const checkboxParams = Object.assign(Object.assign({}, params), { checked: isAllCheckboxSelected, disabled: isAllCheckboxDisabled, indeterminate: isAllCheckboxIndeterminate });
    if (headerSlot) {
      return renderTitleContent(checkboxParams, $table.callSlot(headerSlot, checkboxParams));
    }
    if (checkboxOpts.checkStrictly ? !checkboxOpts.showHeader : checkboxOpts.showHeader === false) {
      return renderTitleContent(checkboxParams, [
        h("span", {
          class: "vxe-checkbox--label"
        }, titleSlot ? $table.callSlot(titleSlot, checkboxParams) : headerTitle)
      ]);
    }
    return renderTitleContent(checkboxParams, [
      h("span", Object.assign({ class: ["vxe-cell--checkbox", {
        "is--checked": isAllCheckboxSelected,
        "is--disabled": isAllCheckboxDisabled,
        "is--indeterminate": isAllCheckboxIndeterminate
      }], title: conf_default.i18n("vxe.table.allTitle") }, ons), [
        h("span", {
          class: ["vxe-checkbox--icon", isAllCheckboxIndeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isAllCheckboxSelected ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
        })
      ].concat(titleSlot || headerTitle ? [
        h("span", {
          class: "vxe-checkbox--label"
        }, titleSlot ? $table.callSlot(titleSlot, checkboxParams) : headerTitle)
      ] : []))
    ]);
  },
  renderCheckboxCell(params) {
    const { $table, row, column, isHidden } = params;
    const { props, reactData } = $table;
    const { treeConfig } = props;
    const { selectCheckboxMaps, treeIndeterminateMaps } = reactData;
    const { computeCheckboxOpts } = $table.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const { labelField, checkMethod, visibleMethod } = checkboxOpts;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    const checkboxSlot = slots ? slots.checkbox : null;
    let indeterminate = false;
    let isChecked = false;
    const isVisible = !visibleMethod || visibleMethod({ row });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isChecked = !!selectCheckboxMaps[rowid];
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            evnt.stopPropagation();
            $table.triggerCheckRowEvent(evnt, params, !isChecked);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({ row });
      }
      if (treeConfig) {
        indeterminate = !!treeIndeterminateMaps[rowid];
      }
    }
    const checkboxParams = Object.assign(Object.assign({}, params), { checked: isChecked, disabled: isDisabled, visible: isVisible, indeterminate });
    if (checkboxSlot) {
      return $table.callSlot(checkboxSlot, checkboxParams);
    }
    const checkVNs = [];
    if (isVisible) {
      checkVNs.push(h("span", {
        class: ["vxe-checkbox--icon", indeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      checkVNs.push(h("span", {
        class: "vxe-checkbox--label"
      }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams) : import_xe_utils36.default.get(row, labelField)));
    }
    return [
      h("span", Object.assign({ class: ["vxe-cell--checkbox", {
        "is--checked": isChecked,
        "is--disabled": isDisabled,
        "is--indeterminate": indeterminate,
        "is--hidden": !isVisible
      }] }, ons), checkVNs)
    ];
  },
  renderTreeSelectionCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderCheckboxCell(params));
  },
  renderCheckboxCellByProp(params) {
    const { $table, row, column, isHidden } = params;
    const { props, reactData } = $table;
    const { treeConfig } = props;
    const { treeIndeterminateMaps } = reactData;
    const { computeCheckboxOpts } = $table.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const { labelField, checkField, checkMethod, visibleMethod } = checkboxOpts;
    const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    const checkboxSlot = slots ? slots.checkbox : null;
    let isIndeterminate = false;
    let isChecked = false;
    const isVisible = !visibleMethod || visibleMethod({ row });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isChecked = import_xe_utils36.default.get(row, checkField);
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            evnt.stopPropagation();
            $table.triggerCheckRowEvent(evnt, params, !isChecked);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({ row });
      }
      if (treeConfig) {
        isIndeterminate = !!treeIndeterminateMaps[rowid];
      }
    }
    const checkboxParams = Object.assign(Object.assign({}, params), { checked: isChecked, disabled: isDisabled, visible: isVisible, indeterminate: isIndeterminate });
    if (checkboxSlot) {
      return $table.callSlot(checkboxSlot, checkboxParams);
    }
    const checkVNs = [];
    if (isVisible) {
      checkVNs.push(h("span", {
        class: ["vxe-checkbox--icon", isIndeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
      }));
      if (defaultSlot || labelField) {
        checkVNs.push(h("span", {
          class: "vxe-checkbox--label"
        }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams) : import_xe_utils36.default.get(row, labelField)));
      }
    }
    return [
      h("span", Object.assign({ class: ["vxe-cell--checkbox", {
        "is--checked": isChecked,
        "is--disabled": isDisabled,
        "is--indeterminate": indeterminateField && !isChecked ? row[indeterminateField] : isIndeterminate,
        "is--hidden": !isVisible
      }] }, ons), checkVNs)
    ];
  },
  renderTreeSelectionCellByProp(params) {
    return Cell.renderTreeIcon(params, Cell.renderCheckboxCellByProp(params));
  },
  /**
   * 
   */
  renderExpandCell(params) {
    const { $table, isHidden, row, column } = params;
    const { reactData } = $table;
    const { rowExpandedMaps, rowExpandLazyLoadedMaps } = reactData;
    const { computeExpandOpts } = $table.getComputeMaps();
    const expandOpts = computeExpandOpts.value;
    const { lazy, labelField, iconLoaded, showIcon, iconOpen, iconClose, visibleMethod } = expandOpts;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    const iconSlot = slots ? slots.icon : null;
    let isAceived = false;
    let isLazyLoaded = false;
    if (iconSlot) {
      return $table.callSlot(iconSlot, params);
    }
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isAceived = !!rowExpandedMaps[rowid];
      if (lazy) {
        isLazyLoaded = !!rowExpandLazyLoadedMaps[rowid];
      }
    }
    return [
      showIcon && (!visibleMethod || visibleMethod(params)) ? h("span", {
        class: ["vxe-table--expanded", {
          "is--active": isAceived
        }],
        onClick(evnt) {
          evnt.stopPropagation();
          $table.triggerRowExpandEvent(evnt, params);
        }
      }, [
        h("i", {
          class: ["vxe-table--expand-btn", isLazyLoaded ? iconLoaded || conf_default.icon.TABLE_EXPAND_LOADED : isAceived ? iconOpen || conf_default.icon.TABLE_EXPAND_OPEN : iconClose || conf_default.icon.TABLE_EXPAND_CLOSE]
        })
      ]) : null,
      defaultSlot || labelField ? h("span", {
        class: "vxe-table--expand-label"
      }, defaultSlot ? $table.callSlot(defaultSlot, params) : import_xe_utils36.default.get(row, labelField)) : null
    ];
  },
  renderExpandData(params) {
    const { $table, column } = params;
    const { slots, contentRender } = column;
    const contentSlot = slots ? slots.content : null;
    if (contentSlot) {
      return $table.callSlot(contentSlot, params);
    }
    if (contentRender) {
      const compConf = VXETable.renderer.get(contentRender.name);
      if (compConf && compConf.renderExpand) {
        return getSlotVNs(compConf.renderExpand(contentRender, params));
      }
    }
    return [];
  },
  /**
   * HTML 
   */
  renderHTMLCell(params) {
    const { $table, column } = params;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return $table.callSlot(defaultSlot, params);
    }
    return [
      h("span", {
        class: "vxe-cell--html",
        innerHTML: getDefaultCellLabel(params)
      })
    ];
  },
  renderTreeHTMLCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderHTMLCell(params));
  },
  /**
   * 
   */
  renderSortAndFilterHeader(params) {
    return Cell.renderDefaultHeader(params).concat(Cell.renderSortIcon(params)).concat(Cell.renderFilterIcon(params));
  },
  /**
   * 
   */
  renderSortHeader(params) {
    return Cell.renderDefaultHeader(params).concat(Cell.renderSortIcon(params));
  },
  renderSortIcon(params) {
    const { $table, column } = params;
    const { computeSortOpts } = $table.getComputeMaps();
    const sortOpts = computeSortOpts.value;
    const { showIcon, iconLayout, iconAsc, iconDesc } = sortOpts;
    const { order } = column;
    if (showIcon) {
      return [
        h("span", {
          class: ["vxe-cell--sort", `vxe-cell--sort-${iconLayout}-layout`]
        }, [
          h("i", {
            class: ["vxe-sort--asc-btn", iconAsc || conf_default.icon.TABLE_SORT_ASC, {
              "sort--active": order === "asc"
            }],
            title: conf_default.i18n("vxe.table.sortAsc"),
            onClick(evnt) {
              evnt.stopPropagation();
              $table.triggerSortEvent(evnt, column, "asc");
            }
          }),
          h("i", {
            class: ["vxe-sort--desc-btn", iconDesc || conf_default.icon.TABLE_SORT_DESC, {
              "sort--active": order === "desc"
            }],
            title: conf_default.i18n("vxe.table.sortDesc"),
            onClick(evnt) {
              evnt.stopPropagation();
              $table.triggerSortEvent(evnt, column, "desc");
            }
          })
        ])
      ];
    }
    return [];
  },
  /**
   * 
   */
  renderFilterHeader(params) {
    return Cell.renderDefaultHeader(params).concat(Cell.renderFilterIcon(params));
  },
  renderFilterIcon(params) {
    const { $table, column, hasFilter } = params;
    const { reactData } = $table;
    const { filterStore } = reactData;
    const { computeFilterOpts } = $table.getComputeMaps();
    const filterOpts = computeFilterOpts.value;
    const { showIcon, iconNone, iconMatch } = filterOpts;
    return showIcon ? [
      h("span", {
        class: ["vxe-cell--filter", {
          "is--active": filterStore.visible && filterStore.column === column
        }]
      }, [
        h("i", {
          class: ["vxe-filter--btn", hasFilter ? iconMatch || conf_default.icon.TABLE_FILTER_MATCH : iconNone || conf_default.icon.TABLE_FILTER_NONE],
          title: conf_default.i18n("vxe.table.filter"),
          onClick(evnt) {
            if ($table.triggerFilterEvent) {
              $table.triggerFilterEvent(evnt, params.column, params);
            }
          }
        })
      ])
    ] : [];
  },
  /**
   * 
   */
  renderEditHeader(params) {
    const { $table, column } = params;
    const { props } = $table;
    const { computeEditOpts } = $table.getComputeMaps();
    const { editConfig, editRules } = props;
    const editOpts = computeEditOpts.value;
    const { sortable, filters, editRender } = column;
    let isRequired = false;
    if (editRules) {
      const columnRules = import_xe_utils36.default.get(editRules, column.field);
      if (columnRules) {
        isRequired = columnRules.some((rule) => rule.required);
      }
    }
    return (isEnableConf(editConfig) ? [
      isRequired && editOpts.showAsterisk ? h("i", {
        class: "vxe-cell--required-icon"
      }) : null,
      isEnableConf(editRender) && editOpts.showIcon ? h("i", {
        class: ["vxe-cell--edit-icon", editOpts.icon || conf_default.icon.TABLE_EDIT]
      }) : null
    ] : []).concat(Cell.renderDefaultHeader(params)).concat(sortable ? Cell.renderSortIcon(params) : []).concat(filters ? Cell.renderFilterIcon(params) : []);
  },
  // 
  renderRowEdit(params) {
    const { $table, column } = params;
    const { reactData } = $table;
    const { editStore } = reactData;
    const { actived } = editStore;
    const { editRender } = column;
    return Cell.runRenderer(params, isEnableConf(editRender) && actived && actived.row === params.row);
  },
  renderTreeRowEdit(params) {
    return Cell.renderTreeIcon(params, Cell.renderRowEdit(params));
  },
  // 
  renderCellEdit(params) {
    const { $table, column } = params;
    const { reactData } = $table;
    const { editStore } = reactData;
    const { actived } = editStore;
    const { editRender } = column;
    return Cell.runRenderer(params, isEnableConf(editRender) && actived && actived.row === params.row && actived.column === params.column);
  },
  renderTreeCellEdit(params) {
    return Cell.renderTreeIcon(params, Cell.renderCellEdit(params));
  },
  runRenderer(params, isEdit) {
    const { $table, column } = params;
    const { slots, editRender, formatter } = column;
    const defaultSlot = slots ? slots.default : null;
    const editSlot = slots ? slots.edit : null;
    const compConf = VXETable.renderer.get(editRender.name);
    if (isEdit) {
      if (editSlot) {
        return $table.callSlot(editSlot, params);
      }
      if (compConf && compConf.renderEdit) {
        return getSlotVNs(compConf.renderEdit(editRender, Object.assign({ $type: "edit" }, params)));
      }
      return [];
    }
    if (defaultSlot) {
      return $table.callSlot(defaultSlot, params);
    }
    if (formatter) {
      return [
        h("span", {
          class: "vxe-cell--label"
        }, getDefaultCellLabel(params))
      ];
    }
    return Cell.renderDefaultCell(params);
  }
};
var cell_default = Cell;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/column.js
var columnProps = {
  // 
  colId: [String, Number],
  //  index,radio,checkbox,expand,html
  type: String,
  // 
  field: String,
  // 
  title: String,
  // 
  width: [Number, String],
  // 
  minWidth: [Number, String],
  // 
  maxWidth: [Number, String],
  // 
  resizable: { type: Boolean, default: null },
  // 
  fixed: String,
  // 
  align: String,
  // 
  headerAlign: String,
  // 
  footerAlign: String,
  // 
  showOverflow: { type: [Boolean, String], default: null },
  // 
  showHeaderOverflow: { type: [Boolean, String], default: null },
  // 
  showFooterOverflow: { type: [Boolean, String], default: null },
  //  className
  className: [String, Function],
  //  className
  headerClassName: [String, Function],
  //  className
  footerClassName: [String, Function],
  // 
  formatter: [Function, Array, String],
  // 
  sortable: Boolean,
  // 
  sortBy: [String, Function],
  // 
  sortType: String,
  // 
  filters: { type: Array, default: null },
  // 
  filterMultiple: { type: Boolean, default: true },
  // 
  filterMethod: Function,
  // 
  filterResetMethod: Function,
  // 
  filterRecoverMethod: Function,
  // 
  filterRender: Object,
  // 
  treeNode: Boolean,
  // 
  visible: { type: Boolean, default: null },
  // 
  headerExportMethod: Function,
  // 
  exportMethod: Function,
  // 
  footerExportMethod: Function,
  //  titlePrefix 
  titleHelp: Object,
  // 
  titlePrefix: Object,
  // 
  titleSuffix: Object,
  // 
  cellType: String,
  // 
  cellRender: Object,
  // 
  editRender: Object,
  // 
  contentRender: Object,
  // 
  params: Object
};
var column_default = defineComponent({
  name: "VxeColumn",
  props: columnProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xetable = inject("$xetable", {});
    const colgroup = inject("xecolgroup", null);
    const column = cell_default.createColumn($xetable, props);
    column.slots = slots;
    provide("$xegrid", null);
    watchColumn($xetable, props, column);
    onMounted(() => {
      assemColumn($xetable, refElem.value, column, colgroup);
    });
    onUnmounted(() => {
      destroyColumn($xetable, column);
    });
    const renderVN = () => {
      return h("div", {
        ref: refElem
      });
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/column/index.js
var VxeColumn = Object.assign(column_default, {
  install(app) {
    app.component(column_default.name, column_default);
    app.component("VxeTableColumn", column_default);
  }
});
var Column = VxeColumn;
dynamicApp.component(column_default.name, column_default);
dynamicApp.component("VxeTableColumn", column_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/group.js
var group_default2 = defineComponent({
  name: "VxeColgroup",
  props: columnProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xetable = inject("$xetable", {});
    const colgroup = inject("xecolgroup", null);
    const column = cell_default.createColumn($xetable, props);
    const columnSlots = {};
    if (slots.header) {
      columnSlots.header = slots.header;
    }
    const xecolumn = { column };
    column.slots = columnSlots;
    column.children = [];
    provide("xecolgroup", xecolumn);
    provide("$xegrid", null);
    watchColumn($xetable, props, column);
    onMounted(() => {
      assemColumn($xetable, refElem.value, column, colgroup);
    });
    onUnmounted(() => {
      destroyColumn($xetable, column);
    });
    const renderVN = () => {
      return h("div", {
        ref: refElem
      }, slots.default ? slots.default() : []);
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/colgroup/index.js
var VxeColgroup = Object.assign(group_default2, {
  install(app) {
    app.component(group_default2.name, group_default2);
    app.component("VxeTableColgroup", group_default2);
  }
});
var Colgroup = VxeColgroup;
dynamicApp.component(group_default2.name, group_default2);
dynamicApp.component("VxeTableColgroup", group_default2);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/grid/src/grid.js
var import_xe_utils48 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/table.js
var import_xe_utils41 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/tools/resize.js
var import_xe_utils37 = __toESM(require_xe_utils());
var resizeTimeout;
var eventStore2 = [];
var defaultInterval = 500;
function eventHandle() {
  if (eventStore2.length) {
    eventStore2.forEach((item) => {
      item.tarList.forEach((observer) => {
        const { target, width, heighe } = observer;
        const clientWidth = target.clientWidth;
        const clientHeight = target.clientHeight;
        const rWidth = clientWidth && width !== clientWidth;
        const rHeight = clientHeight && heighe !== clientHeight;
        if (rWidth || rHeight) {
          observer.width = clientWidth;
          observer.heighe = clientHeight;
          setTimeout(item.callback);
        }
      });
    });
    eventListener();
  }
}
function eventListener() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(eventHandle, conf_default.resizeInterval || defaultInterval);
}
var XEResizeObserver = class {
  constructor(callback) {
    Object.defineProperty(this, "tarList", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "callback", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.callback = callback;
  }
  observe(target) {
    if (target) {
      const { tarList } = this;
      if (!tarList.some((observer) => observer.target === target)) {
        tarList.push({
          target,
          width: target.clientWidth,
          heighe: target.clientHeight
        });
      }
      if (!eventStore2.length) {
        eventListener();
      }
      if (!eventStore2.some((item) => item === this)) {
        eventStore2.push(this);
      }
    }
  }
  unobserve(target) {
    import_xe_utils37.default.remove(eventStore2, (item) => item.tarList.some((observer) => observer.target === target));
  }
  disconnect() {
    import_xe_utils37.default.remove(eventStore2, (item) => item === this);
  }
};
function createResizeEvent(callback) {
  if (window.ResizeObserver) {
    return new window.ResizeObserver(callback);
  }
  return new XEResizeObserver(callback);
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/body.js
var import_xe_utils38 = __toESM(require_xe_utils());
var renderType = "body";
var lineOffsetSizes = {
  mini: 3,
  small: 2,
  medium: 1
};
var body_default = defineComponent({
  name: "VxeTableBody",
  props: {
    tableData: Array,
    tableColumn: Array,
    fixedColumn: Array,
    fixedType: { type: String, default: null }
  },
  setup(props) {
    const $xetable = inject("$xetable", {});
    const xesize = inject("xesize", null);
    const { xID, props: tableProps, context: tableContext, reactData: tableReactData, internalData: tableInternalData } = $xetable;
    const { refTableHeader, refTableBody, refTableFooter, refTableLeftBody, refTableRightBody, refValidTooltip } = $xetable.getRefMaps();
    const { computeEditOpts, computeMouseOpts, computeSYOpts, computeEmptyOpts, computeKeyboardOpts, computeTooltipOpts, computeRadioOpts, computeExpandOpts, computeTreeOpts, computeCheckboxOpts, computeValidOpts, computeRowOpts, computeColumnOpts } = $xetable.getComputeMaps();
    const refElem = ref();
    const refBodyTable = ref();
    const refBodyColgroup = ref();
    const refBodyTBody = ref();
    const refBodyXSpace = ref();
    const refBodyYSpace = ref();
    const refBodyEmptyBlock = ref();
    const getOffsetSize = () => {
      if (xesize) {
        const vSize = xesize.value;
        if (vSize) {
          return lineOffsetSizes[vSize] || 0;
        }
      }
      return 0;
    };
    const isVMScrollProcess = () => {
      const { delayHover } = tableProps;
      const { lastScrollTime, _isResize } = tableReactData;
      return !!(_isResize || lastScrollTime && Date.now() < lastScrollTime + delayHover);
    };
    const countTreeExpand = (prevRow, params) => {
      let count = 1;
      if (!prevRow) {
        return count;
      }
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const rowChildren = prevRow[childrenField];
      if (rowChildren && $xetable.isTreeExpandByRow(prevRow)) {
        for (let index = 0; index < rowChildren.length; index++) {
          count += countTreeExpand(rowChildren[index], params);
        }
      }
      return count;
    };
    const calcTreeLine = (params, items, rIndex) => {
      let expandSize = 1;
      if (rIndex) {
        expandSize = countTreeExpand(items[rIndex - 1], params);
      }
      return tableReactData.rowHeight * expandSize - (rIndex ? 1 : 12 - getOffsetSize());
    };
    const renderLine = (params) => {
      const { row, column } = params;
      const { afterFullData } = tableInternalData;
      const { treeConfig } = tableProps;
      const treeOpts = computeTreeOpts.value;
      const { slots, treeNode } = column;
      const { fullAllDataRowIdData } = tableInternalData;
      const rowid = getRowid($xetable, row);
      const rest = fullAllDataRowIdData[rowid];
      let rLevel = 0;
      let rIndex = 0;
      let items = [];
      if (rest) {
        rLevel = rest.level;
        rIndex = rest._index;
        items = rest.items;
      }
      if (slots && slots.line) {
        return $xetable.callSlot(slots.line, params);
      }
      const isFirstRow = $xetable.eqRow(afterFullData[0], row);
      if (treeConfig && treeNode && (treeOpts.showLine || treeOpts.line)) {
        return [
          h("div", {
            class: "vxe-tree--line-wrapper"
          }, [
            h("div", {
              class: "vxe-tree--line",
              style: {
                height: `${isFirstRow ? 1 : calcTreeLine(params, items, rIndex)}px`,
                left: `${rLevel * treeOpts.indent + (rLevel ? 2 - getOffsetSize() : 0) + 16}px`
              }
            })
          ])
        ];
      }
      return [];
    };
    const renderColumn = (seq, rowid, fixedType, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, columns, items) => {
      const { columnKey, height, showOverflow: allColumnOverflow, cellClassName: allCellClassName, cellStyle, align: allAlign, spanMethod, mouseConfig, editConfig, editRules, tooltipConfig } = tableProps;
      const { tableData, overflowX, scrollYLoad, currentColumn, mergeList, editStore, isAllOverflow, validErrorMaps } = tableReactData;
      const { afterFullData } = tableInternalData;
      const validOpts = computeValidOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const editOpts = computeEditOpts.value;
      const tooltipOpts = computeTooltipOpts.value;
      const rowOpts = computeRowOpts.value;
      const sYOpts = computeSYOpts.value;
      const columnOpts = computeColumnOpts.value;
      const { type, cellRender, editRender, align, showOverflow, className, treeNode, slots } = column;
      const { actived } = editStore;
      const { rHeight: scrollYRHeight } = sYOpts;
      const { height: rowHeight } = rowOpts;
      const renderOpts = editRender || cellRender;
      const compConf = renderOpts ? VXETable.renderer.get(renderOpts.name) : null;
      const compCellClassName = compConf ? compConf.cellClassName : "";
      const compCellStyle = compConf ? compConf.cellStyle : "";
      const showAllTip = tooltipOpts.showAll;
      const columnIndex = $xetable.getColumnIndex(column);
      const _columnIndex = $xetable.getVTColumnIndex(column);
      const isEdit = isEnableConf(editRender);
      let fixedHiddenColumn = fixedType ? column.fixed !== fixedType : column.fixed && overflowX;
      const cellOverflow = import_xe_utils38.default.isUndefined(showOverflow) || import_xe_utils38.default.isNull(showOverflow) ? allColumnOverflow : showOverflow;
      let showEllipsis = cellOverflow === "ellipsis";
      const showTitle = cellOverflow === "title";
      const showTooltip = cellOverflow === true || cellOverflow === "tooltip";
      let hasEllipsis = showTitle || showTooltip || showEllipsis;
      let isDirty;
      const tdOns = {};
      const cellAlign = align || allAlign;
      const errorValidItem = validErrorMaps[`${rowid}:${column.id}`];
      const showValidTip = editRules && validOpts.showMessage && (validOpts.message === "default" ? height || tableData.length > 1 : validOpts.message === "inline");
      const attrs = { colid: column.id };
      const params = { $table: $xetable, $grid: $xetable.xegrid, seq, rowid, row, rowIndex, $rowIndex, _rowIndex, column, columnIndex, $columnIndex, _columnIndex, fixed: fixedType, type: renderType, isHidden: fixedHiddenColumn, level: rowLevel, visibleData: afterFullData, data: tableData, items };
      if (scrollYLoad && !hasEllipsis) {
        showEllipsis = hasEllipsis = true;
      }
      if (showTitle || showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseenter = (evnt) => {
          if (isVMScrollProcess()) {
            return;
          }
          if (showTitle) {
            updateCellTitle(evnt.currentTarget, column);
          } else if (showTooltip || showAllTip) {
            $xetable.triggerBodyTooltipEvent(evnt, params);
          }
          $xetable.dispatchEvent("cell-mouseenter", Object.assign({ cell: evnt.currentTarget }, params), evnt);
        };
      }
      if (showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseleave = (evnt) => {
          if (isVMScrollProcess()) {
            return;
          }
          if (showTooltip || showAllTip) {
            $xetable.handleTargetLeaveEvent(evnt);
          }
          $xetable.dispatchEvent("cell-mouseleave", Object.assign({ cell: evnt.currentTarget }, params), evnt);
        };
      }
      if (checkboxOpts.range || mouseConfig) {
        tdOns.onMousedown = (evnt) => {
          $xetable.triggerCellMousedownEvent(evnt, params);
        };
      }
      tdOns.onClick = (evnt) => {
        $xetable.triggerCellClickEvent(evnt, params);
      };
      tdOns.onDblclick = (evnt) => {
        $xetable.triggerCellDblclickEvent(evnt, params);
      };
      if (mergeList.length) {
        const spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);
        if (spanRest) {
          const { rowspan, colspan } = spanRest;
          if (!rowspan || !colspan) {
            return null;
          }
          if (rowspan > 1) {
            attrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            attrs.colspan = colspan;
          }
        }
      } else if (spanMethod) {
        const { rowspan = 1, colspan = 1 } = spanMethod(params) || {};
        if (!rowspan || !colspan) {
          return null;
        }
        if (rowspan > 1) {
          attrs.rowspan = rowspan;
        }
        if (colspan > 1) {
          attrs.colspan = colspan;
        }
      }
      if (fixedHiddenColumn && mergeList) {
        if (attrs.colspan > 1 || attrs.rowspan > 1) {
          fixedHiddenColumn = false;
        }
      }
      if (!fixedHiddenColumn && editConfig && (editRender || cellRender) && (editOpts.showStatus || editOpts.showUpdateStatus)) {
        isDirty = $xetable.isUpdateByRow(row, column.field);
      }
      const tdVNs = [];
      if (fixedHiddenColumn && (allColumnOverflow ? isAllOverflow : allColumnOverflow)) {
        tdVNs.push(h("div", {
          class: ["vxe-cell", {
            "c--title": showTitle,
            "c--tooltip": showTooltip,
            "c--ellipsis": showEllipsis
          }],
          style: {
            maxHeight: hasEllipsis && (scrollYRHeight || rowHeight) ? `${scrollYRHeight || rowHeight}px` : ""
          }
        }));
      } else {
        tdVNs.push(...renderLine(params), h("div", {
          class: ["vxe-cell", {
            "c--title": showTitle,
            "c--tooltip": showTooltip,
            "c--ellipsis": showEllipsis
          }],
          style: {
            maxHeight: hasEllipsis && (scrollYRHeight || rowHeight) ? `${scrollYRHeight || rowHeight}px` : ""
          },
          title: showTitle ? $xetable.getCellLabel(row, column) : null
        }, column.renderCell(params)));
        if (showValidTip && errorValidItem) {
          const errRule = errorValidItem.rule;
          const validSlot = slots ? slots.valid : null;
          const validParams = Object.assign(Object.assign({}, params), errorValidItem);
          tdVNs.push(h("div", {
            class: ["vxe-cell--valid-error-hint", getPropClass(validOpts.className, validParams)],
            style: errRule && errRule.maxWidth ? {
              width: `${errRule.maxWidth}px`
            } : null
          }, validSlot ? $xetable.callSlot(validSlot, validParams) : [
            h("span", {
              class: "vxe-cell--valid-error-msg"
            }, errorValidItem.content)
          ]));
        }
      }
      return h("td", Object.assign(Object.assign(Object.assign({ class: [
        "vxe-body--column",
        column.id,
        {
          [`col--${cellAlign}`]: cellAlign,
          [`col--${type}`]: type,
          "col--last": $columnIndex === columns.length - 1,
          "col--tree-node": treeNode,
          "col--edit": isEdit,
          "col--ellipsis": hasEllipsis,
          "fixed--hidden": fixedHiddenColumn,
          "col--dirty": isDirty,
          "col--active": editConfig && isEdit && (actived.row === row && (actived.column === column || editOpts.mode === "row")),
          "col--valid-error": !!errorValidItem,
          "col--current": currentColumn === column
        },
        getPropClass(compCellClassName, params),
        getPropClass(className, params),
        getPropClass(allCellClassName, params)
      ], key: columnKey || columnOpts.useKey ? column.id : $columnIndex }, attrs), { style: Object.assign({
        height: hasEllipsis && (scrollYRHeight || rowHeight) ? `${scrollYRHeight || rowHeight}px` : ""
      }, import_xe_utils38.default.isFunction(compCellStyle) ? compCellStyle(params) : compCellStyle, import_xe_utils38.default.isFunction(cellStyle) ? cellStyle(params) : cellStyle) }), tdOns), tdVNs);
    };
    const renderRows = (fixedType, tableData, tableColumn) => {
      const { stripe, rowKey, highlightHoverRow, rowClassName, rowStyle, showOverflow: allColumnOverflow, editConfig, treeConfig } = tableProps;
      const { hasFixedColumn, treeExpandedMaps, scrollYLoad, rowExpandedMaps, expandColumn, selectRadioRow, pendingRowMaps, pendingRowList } = tableReactData;
      const { fullAllDataRowIdData } = tableInternalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const radioOpts = computeRadioOpts.value;
      const treeOpts = computeTreeOpts.value;
      const editOpts = computeEditOpts.value;
      const rowOpts = computeRowOpts.value;
      const { transform } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const rows = [];
      tableData.forEach((row, $rowIndex) => {
        const trOn = {};
        let rowIndex = $rowIndex;
        rowIndex = $xetable.getRowIndex(row);
        if (rowOpts.isHover || highlightHoverRow) {
          trOn.onMouseenter = (evnt) => {
            if (isVMScrollProcess()) {
              return;
            }
            $xetable.triggerHoverEvent(evnt, { row, rowIndex });
          };
          trOn.onMouseleave = () => {
            if (isVMScrollProcess()) {
              return;
            }
            $xetable.clearHoverRow();
          };
        }
        const rowid = getRowid($xetable, row);
        const rest = fullAllDataRowIdData[rowid];
        let rowLevel = 0;
        let seq = -1;
        let _rowIndex = 0;
        if (rest) {
          rowLevel = rest.level;
          seq = rest.seq;
          _rowIndex = rest._index;
        }
        const params = { $table: $xetable, seq, rowid, fixed: fixedType, type: renderType, level: rowLevel, row, rowIndex, $rowIndex, _rowIndex };
        const isExpandRow = expandColumn && !!rowExpandedMaps[rowid];
        let isExpandTree = false;
        let rowChildren = [];
        let isNewRow = false;
        if (editConfig) {
          isNewRow = $xetable.isInsertByRow(row);
        }
        if (treeConfig && !scrollYLoad && !transform) {
          rowChildren = row[childrenField];
          isExpandTree = rowChildren && rowChildren.length && !!treeExpandedMaps[rowid];
        }
        rows.push(h("tr", Object.assign({ class: [
          "vxe-body--row",
          treeConfig ? `row--level-${rowLevel}` : "",
          {
            "row--stripe": stripe && ($xetable.getVTRowIndex(row) + 1) % 2 === 0,
            "is--new": isNewRow,
            "is--expand-row": isExpandRow,
            "is--expand-tree": isExpandTree,
            "row--new": isNewRow && (editOpts.showStatus || editOpts.showInsertStatus),
            "row--radio": radioOpts.highlight && $xetable.eqRow(selectRadioRow, row),
            "row--checked": checkboxOpts.highlight && $xetable.isCheckedByCheckboxRow(row),
            "row--pending": pendingRowList.length && !!pendingRowMaps[rowid]
          },
          getPropClass(rowClassName, params)
        ], rowid, style: rowStyle ? import_xe_utils38.default.isFunction(rowStyle) ? rowStyle(params) : rowStyle : null, key: rowKey || rowOpts.useKey || treeConfig ? rowid : $rowIndex }, trOn), tableColumn.map((column, $columnIndex) => {
          return renderColumn(seq, rowid, fixedType, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, tableColumn, tableData);
        })));
        if (isExpandRow) {
          const expandOpts = computeExpandOpts.value;
          const { height: expandHeight } = expandOpts;
          const cellStyle = {};
          if (expandHeight) {
            cellStyle.height = `${expandHeight}px`;
          }
          if (treeConfig) {
            cellStyle.paddingLeft = `${rowLevel * treeOpts.indent + 30}px`;
          }
          const { showOverflow } = expandColumn;
          const hasEllipsis = import_xe_utils38.default.isUndefined(showOverflow) || import_xe_utils38.default.isNull(showOverflow) ? allColumnOverflow : showOverflow;
          const expandParams = { $table: $xetable, seq, column: expandColumn, fixed: fixedType, type: renderType, level: rowLevel, row, rowIndex, $rowIndex, _rowIndex };
          rows.push(h("tr", Object.assign({ class: "vxe-body--expanded-row", key: `expand_${rowid}`, style: rowStyle ? import_xe_utils38.default.isFunction(rowStyle) ? rowStyle(expandParams) : rowStyle : null }, trOn), [
            h("td", {
              class: {
                "vxe-body--expanded-column": 1,
                "fixed--hidden": fixedType && !hasFixedColumn,
                "col--ellipsis": hasEllipsis
              },
              colspan: tableColumn.length
            }, [
              h("div", {
                class: {
                  "vxe-body--expanded-cell": 1,
                  "is--ellipsis": expandHeight
                },
                style: cellStyle
              }, [
                expandColumn.renderData(expandParams)
              ])
            ])
          ]));
        }
        if (isExpandTree) {
          rows.push(...renderRows(fixedType, rowChildren, tableColumn));
        }
      });
      return rows;
    };
    let scrollProcessTimeout;
    const syncBodyScroll = (fixedType, scrollTop, elem1, elem2) => {
      if (elem1 || elem2) {
        if (elem1) {
          removeScrollListener(elem1);
          elem1.scrollTop = scrollTop;
        }
        if (elem2) {
          removeScrollListener(elem2);
          elem2.scrollTop = scrollTop;
        }
        clearTimeout(scrollProcessTimeout);
        scrollProcessTimeout = setTimeout(() => {
          restoreScrollListener(elem1);
          restoreScrollListener(elem2);
          tableReactData.lastScrollTime = Date.now();
        }, 300);
      }
    };
    const scrollLoadingTime = null;
    const scrollEvent = (evnt) => {
      const { fixedType } = props;
      const { highlightHoverRow } = tableProps;
      const { scrollXLoad, scrollYLoad } = tableReactData;
      const { elemStore, lastScrollTop, lastScrollLeft } = tableInternalData;
      const rowOpts = computeRowOpts.value;
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableFooter = refTableFooter.value;
      const leftBody = refTableLeftBody.value;
      const rightBody = refTableRightBody.value;
      const validTip = refValidTooltip.value;
      const scrollBodyElem = refElem.value;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = tableFooter ? tableFooter.$el : null;
      const bodyElem = tableBody.$el;
      const leftElem = leftBody ? leftBody.$el : null;
      const rightElem = rightBody ? rightBody.$el : null;
      const bodyYRef = elemStore["main-body-ySpace"];
      const bodyYElem = bodyYRef ? bodyYRef.value : null;
      const bodyXRef = elemStore["main-body-xSpace"];
      const bodyXElem = bodyXRef ? bodyXRef.value : null;
      const bodyHeight = scrollYLoad && bodyYElem ? bodyYElem.clientHeight : bodyElem.clientHeight;
      const bodyWidth = scrollXLoad && bodyXElem ? bodyXElem.clientWidth : bodyElem.clientWidth;
      let scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = bodyElem.scrollLeft;
      const isRollX = scrollLeft !== lastScrollLeft;
      const isRollY = scrollTop !== lastScrollTop;
      tableInternalData.lastScrollTop = scrollTop;
      tableInternalData.lastScrollLeft = scrollLeft;
      tableReactData.lastScrollTime = Date.now();
      if (rowOpts.isHover || highlightHoverRow) {
        $xetable.clearHoverRow();
      }
      if (leftElem && fixedType === "left") {
        scrollTop = leftElem.scrollTop;
        syncBodyScroll(fixedType, scrollTop, bodyElem, rightElem);
      } else if (rightElem && fixedType === "right") {
        scrollTop = rightElem.scrollTop;
        syncBodyScroll(fixedType, scrollTop, bodyElem, leftElem);
      } else {
        if (isRollX) {
          if (headerElem) {
            headerElem.scrollLeft = bodyElem.scrollLeft;
          }
          if (footerElem) {
            footerElem.scrollLeft = bodyElem.scrollLeft;
          }
        }
        if (leftElem || rightElem) {
          $xetable.checkScrolling();
          if (isRollY) {
            syncBodyScroll(fixedType, scrollTop, leftElem, rightElem);
          }
        }
      }
      if (scrollXLoad && isRollX) {
        $xetable.triggerScrollXEvent(evnt);
      }
      if (scrollYLoad && isRollY) {
        $xetable.triggerScrollYEvent(evnt);
      }
      if (scrollLoadingTime !== null) {
        clearTimeout(scrollLoadingTime);
      }
      if (isRollX && validTip && validTip.reactData.visible) {
        validTip.updatePlacement();
      }
      $xetable.dispatchEvent("scroll", {
        type: renderType,
        fixed: fixedType,
        scrollTop,
        scrollLeft,
        scrollHeight: bodyElem.scrollHeight,
        scrollWidth: bodyElem.scrollWidth,
        bodyHeight,
        bodyWidth,
        isX: isRollX,
        isY: isRollY
      }, evnt);
    };
    let wheelTime;
    let wheelYSize = 0;
    let wheelYInterval = 0;
    let wheelYTotal = 0;
    let isPrevWheelTop = false;
    const handleWheel = (evnt, isTopWheel, deltaTop, isRollX, isRollY) => {
      const { elemStore } = tableInternalData;
      const { scrollXLoad, scrollYLoad } = tableReactData;
      const tableBody = refTableBody.value;
      const leftBody = refTableLeftBody.value;
      const rightBody = refTableRightBody.value;
      const leftElem = leftBody ? leftBody.$el : null;
      const rightElem = rightBody ? rightBody.$el : null;
      const bodyElem = tableBody.$el;
      const bodyYRef = elemStore["main-body-ySpace"];
      const bodyYElem = bodyYRef ? bodyYRef.value : null;
      const bodyXRef = elemStore["main-body-xSpace"];
      const bodyXElem = bodyXRef ? bodyXRef.value : null;
      const bodyHeight = scrollYLoad && bodyYElem ? bodyYElem.clientHeight : bodyElem.clientHeight;
      const bodyWidth = scrollXLoad && bodyXElem ? bodyXElem.clientWidth : bodyElem.clientWidth;
      const remainSize = isPrevWheelTop === isTopWheel ? Math.max(0, wheelYSize - wheelYTotal) : 0;
      isPrevWheelTop = isTopWheel;
      wheelYSize = Math.abs(isTopWheel ? deltaTop - remainSize : deltaTop + remainSize);
      wheelYInterval = 0;
      wheelYTotal = 0;
      clearTimeout(wheelTime);
      const handleSmooth = () => {
        if (wheelYTotal < wheelYSize) {
          const { fixedType } = props;
          wheelYInterval = Math.max(5, Math.floor(wheelYInterval * 1.5));
          wheelYTotal = wheelYTotal + wheelYInterval;
          if (wheelYTotal > wheelYSize) {
            wheelYInterval = wheelYInterval - (wheelYTotal - wheelYSize);
          }
          const { scrollTop, clientHeight, scrollHeight } = bodyElem;
          const targerTop = scrollTop + wheelYInterval * (isTopWheel ? -1 : 1);
          bodyElem.scrollTop = targerTop;
          if (leftElem) {
            leftElem.scrollTop = targerTop;
          }
          if (rightElem) {
            rightElem.scrollTop = targerTop;
          }
          if (isTopWheel ? targerTop < scrollHeight - clientHeight : targerTop >= 0) {
            wheelTime = setTimeout(handleSmooth, 10);
          }
          $xetable.dispatchEvent("scroll", {
            type: renderType,
            fixed: fixedType,
            scrollTop: bodyElem.scrollTop,
            scrollLeft: bodyElem.scrollLeft,
            scrollHeight: bodyElem.scrollHeight,
            scrollWidth: bodyElem.scrollWidth,
            bodyHeight,
            bodyWidth,
            isX: isRollX,
            isY: isRollY
          }, evnt);
        }
      };
      handleSmooth();
    };
    const wheelEvent = (evnt) => {
      const { deltaY, deltaX } = evnt;
      const { highlightHoverRow } = tableProps;
      const { scrollYLoad } = tableReactData;
      const { lastScrollTop, lastScrollLeft } = tableInternalData;
      const rowOpts = computeRowOpts.value;
      const tableBody = refTableBody.value;
      const scrollBodyElem = refElem.value;
      const bodyElem = tableBody.$el;
      const deltaTop = deltaY;
      const deltaLeft = deltaX;
      const isTopWheel = deltaTop < 0;
      if (isTopWheel ? scrollBodyElem.scrollTop <= 0 : scrollBodyElem.scrollTop >= scrollBodyElem.scrollHeight - scrollBodyElem.clientHeight) {
        return;
      }
      const scrollTop = scrollBodyElem.scrollTop + deltaTop;
      const scrollLeft = bodyElem.scrollLeft + deltaLeft;
      const isRollX = scrollLeft !== lastScrollLeft;
      const isRollY = scrollTop !== lastScrollTop;
      if (isRollY) {
        evnt.preventDefault();
        tableInternalData.lastScrollTop = scrollTop;
        tableInternalData.lastScrollLeft = scrollLeft;
        tableReactData.lastScrollTime = Date.now();
        if (rowOpts.isHover || highlightHoverRow) {
          $xetable.clearHoverRow();
        }
        handleWheel(evnt, isTopWheel, deltaTop, isRollX, isRollY);
        if (scrollYLoad) {
          $xetable.triggerScrollYEvent(evnt);
        }
      }
    };
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { elemStore } = tableInternalData;
        const prefix = `${fixedType || "main"}-body-`;
        const el = refElem.value;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}table`] = refBodyTable;
        elemStore[`${prefix}colgroup`] = refBodyColgroup;
        elemStore[`${prefix}list`] = refBodyTBody;
        elemStore[`${prefix}xSpace`] = refBodyXSpace;
        elemStore[`${prefix}ySpace`] = refBodyYSpace;
        elemStore[`${prefix}emptyBlock`] = refBodyEmptyBlock;
        if (el) {
          el.onscroll = scrollEvent;
          el._onscroll = scrollEvent;
        }
      });
    });
    onBeforeUnmount(() => {
      const el = refElem.value;
      clearTimeout(wheelTime);
      if (el) {
        el._onscroll = null;
        el.onscroll = null;
      }
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { elemStore } = tableInternalData;
      const prefix = `${fixedType || "main"}-body-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}ySpace`] = null;
      elemStore[`${prefix}emptyBlock`] = null;
    });
    const renderVN = () => {
      let { fixedColumn, fixedType, tableColumn } = props;
      const { keyboardConfig, showOverflow: allColumnOverflow, spanMethod, mouseConfig } = tableProps;
      const { tableData, mergeList, scrollYLoad, isAllOverflow } = tableReactData;
      const { visibleColumn } = tableInternalData;
      const { slots } = tableContext;
      const sYOpts = computeSYOpts.value;
      const emptyOpts = computeEmptyOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const mouseOpts = computeMouseOpts.value;
      if (fixedType) {
        if (!tableReactData.expandColumn && (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow))) {
          if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {
            tableColumn = fixedColumn;
          } else {
            tableColumn = visibleColumn;
          }
        } else {
          tableColumn = visibleColumn;
        }
      }
      let emptyContent;
      const emptySlot = slots ? slots.empty : null;
      if (emptySlot) {
        emptyContent = $xetable.callSlot(emptySlot, { $table: $xetable, $grid: $xetable.xegrid });
      } else {
        const compConf = emptyOpts.name ? VXETable.renderer.get(emptyOpts.name) : null;
        const renderTableEmptyView = compConf ? compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (renderTableEmptyView) {
          emptyContent = getSlotVNs(renderTableEmptyView(emptyOpts, { $table: $xetable }));
        } else {
          emptyContent = tableProps.emptyText || conf_default.i18n("vxe.table.emptyText");
        }
      }
      return h("div", Object.assign({ ref: refElem, class: ["vxe-table--body-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"], xid: xID }, sYOpts.mode === "wheel" ? { onWheel: wheelEvent } : {}), [
        fixedType ? createCommentVNode() : h("div", {
          ref: refBodyXSpace,
          class: "vxe-body--x-space"
        }),
        h("div", {
          ref: refBodyYSpace,
          class: "vxe-body--y-space"
        }),
        h("table", {
          ref: refBodyTable,
          class: "vxe-table--body",
          xid: xID,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 
           */
          h("colgroup", {
            ref: refBodyColgroup
          }, tableColumn.map((column, $columnIndex) => {
            return h("col", {
              name: column.id,
              key: $columnIndex
            });
          })),
          /**
           * 
           */
          h("tbody", {
            ref: refBodyTBody
          }, renderRows(fixedType, tableData, tableColumn))
        ]),
        h("div", {
          class: "vxe-table--checkbox-range"
        }),
        mouseConfig && mouseOpts.area ? h("div", {
          class: "vxe-table--cell-area"
        }, [
          h("span", {
            class: "vxe-table--cell-main-area"
          }, mouseOpts.extension ? [
            h("span", {
              class: "vxe-table--cell-main-area-btn",
              onMousedown(evnt) {
                $xetable.triggerCellExtendMousedownEvent(evnt, { $table: $xetable, fixed: fixedType, type: renderType });
              }
            })
          ] : []),
          h("span", {
            class: "vxe-table--cell-copy-area"
          }),
          h("span", {
            class: "vxe-table--cell-extend-area"
          }),
          h("span", {
            class: "vxe-table--cell-multi-area"
          }),
          h("span", {
            class: "vxe-table--cell-active-area"
          })
        ]) : null,
        !fixedType ? h("div", {
          class: "vxe-table--empty-block",
          ref: refBodyEmptyBlock
        }, [
          h("div", {
            class: "vxe-table--empty-content"
          }, emptyContent)
        ]) : null
      ]);
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/header.js
var import_xe_utils39 = __toESM(require_xe_utils());
var renderType2 = "header";
var header_default = defineComponent({
  name: "VxeTableHeader",
  props: {
    tableData: Array,
    tableColumn: Array,
    tableGroupColumn: Array,
    fixedColumn: Array,
    fixedType: { type: String, default: null }
  },
  setup(props) {
    const $xetable = inject("$xetable", {});
    const { xID, props: tableProps, reactData: tableReactData, internalData: tableInternalData } = $xetable;
    const { refElem: tableRefElem, refTableBody, refLeftContainer, refRightContainer, refCellResizeBar } = $xetable.getRefMaps();
    const { computeColumnOpts } = $xetable.getComputeMaps();
    const headerColumn = ref([]);
    const refElem = ref();
    const refHeaderTable = ref();
    const refHeaderColgroup = ref();
    const refHeaderTHead = ref();
    const refHeaderXSpace = ref();
    const refHeaderBorderRepair = ref();
    const uploadColumn = () => {
      const { isGroup } = tableReactData;
      headerColumn.value = isGroup ? convertHeaderColumnToRows(props.tableGroupColumn) : [];
    };
    const resizeMousedown = (evnt, params) => {
      const { column } = params;
      const { fixedType } = props;
      const tableBody = refTableBody.value;
      const leftContainerElem = refLeftContainer.value;
      const rightContainerElem = refRightContainer.value;
      const resizeBarElem = refCellResizeBar.value;
      const { clientX: dragClientX } = evnt;
      const wrapperElem = refElem.value;
      const dragBtnElem = evnt.target;
      const cell = params.cell = dragBtnElem.parentNode;
      let dragLeft = 0;
      const tableBodyElem = tableBody.$el;
      const pos = getOffsetPos(dragBtnElem, wrapperElem);
      const dragBtnWidth = dragBtnElem.clientWidth;
      const dragBtnOffsetWidth = Math.floor(dragBtnWidth / 2);
      const minInterval = getColReMinWidth(params) - dragBtnOffsetWidth;
      let dragMinLeft = pos.left - cell.clientWidth + dragBtnWidth + minInterval;
      let dragPosLeft = pos.left + dragBtnOffsetWidth;
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const isLeftFixed = fixedType === "left";
      const isRightFixed = fixedType === "right";
      const tableEl = tableRefElem.value;
      let fixedOffsetWidth = 0;
      if (isLeftFixed || isRightFixed) {
        const siblingProp = isLeftFixed ? "nextElementSibling" : "previousElementSibling";
        let tempCellElem = cell[siblingProp];
        while (tempCellElem) {
          if (hasClass(tempCellElem, "fixed--hidden")) {
            break;
          } else if (!hasClass(tempCellElem, "col--group")) {
            fixedOffsetWidth += tempCellElem.offsetWidth;
          }
          tempCellElem = tempCellElem[siblingProp];
        }
        if (isRightFixed && rightContainerElem) {
          dragPosLeft = rightContainerElem.offsetLeft + fixedOffsetWidth;
        }
      }
      const updateEvent = function(evnt2) {
        evnt2.stopPropagation();
        evnt2.preventDefault();
        const offsetX = evnt2.clientX - dragClientX;
        let left = dragPosLeft + offsetX;
        const scrollLeft = fixedType ? 0 : tableBodyElem.scrollLeft;
        if (isLeftFixed) {
          left = Math.min(left, (rightContainerElem ? rightContainerElem.offsetLeft : tableBodyElem.clientWidth) - fixedOffsetWidth - minInterval);
        } else if (isRightFixed) {
          dragMinLeft = (leftContainerElem ? leftContainerElem.clientWidth : 0) + fixedOffsetWidth + minInterval;
          left = Math.min(left, dragPosLeft + cell.clientWidth - minInterval);
        } else {
          dragMinLeft = Math.max(tableBodyElem.scrollLeft, dragMinLeft);
        }
        dragLeft = Math.max(left, dragMinLeft);
        resizeBarElem.style.left = `${dragLeft - scrollLeft}px`;
      };
      tableReactData._isResize = true;
      addClass(tableEl, "drag--resize");
      resizeBarElem.style.display = "block";
      document.onmousemove = updateEvent;
      document.onmouseup = function(evnt2) {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        const resizeWidth = column.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft);
        column.resizeWidth = resizeWidth;
        resizeBarElem.style.display = "none";
        tableReactData._isResize = false;
        tableInternalData._lastResizeTime = Date.now();
        $xetable.analyColumnWidth();
        $xetable.recalculate(true).then(() => {
          $xetable.saveCustomResizable();
          $xetable.updateCellAreas();
          $xetable.dispatchEvent("resizable-change", Object.assign(Object.assign({}, params), { resizeWidth }), evnt2);
        });
        removeClass(tableEl, "drag--resize");
      };
      updateEvent(evnt);
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
    };
    watch(() => props.tableColumn, uploadColumn);
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { internalData } = $xetable;
        const { elemStore } = internalData;
        const prefix = `${fixedType || "main"}-header-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}table`] = refHeaderTable;
        elemStore[`${prefix}colgroup`] = refHeaderColgroup;
        elemStore[`${prefix}list`] = refHeaderTHead;
        elemStore[`${prefix}xSpace`] = refHeaderXSpace;
        elemStore[`${prefix}repair`] = refHeaderBorderRepair;
        uploadColumn();
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { internalData } = $xetable;
      const { elemStore } = internalData;
      const prefix = `${fixedType || "main"}-header-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}repair`] = null;
    });
    const renderVN = () => {
      const { fixedType, fixedColumn, tableColumn } = props;
      const { resizable, border, columnKey, headerRowClassName, headerCellClassName, headerRowStyle, headerCellStyle, showHeaderOverflow: allColumnHeaderOverflow, headerAlign: allHeaderAlign, align: allAlign, mouseConfig } = tableProps;
      const { isGroup, currentColumn, scrollXLoad, overflowX, scrollbarWidth } = tableReactData;
      const { visibleColumn } = tableInternalData;
      const columnOpts = computeColumnOpts.value;
      let headerGroups = headerColumn.value;
      let renderColumnList = tableColumn;
      if (isGroup) {
        renderColumnList = visibleColumn;
      } else {
        if (fixedType) {
          if (scrollXLoad || allColumnHeaderOverflow) {
            renderColumnList = fixedColumn;
          }
        }
        headerGroups = [renderColumnList];
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table--header-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"],
        xid: xID
      }, [
        fixedType ? createCommentVNode() : h("div", {
          ref: refHeaderXSpace,
          class: "vxe-body--x-space"
        }),
        h("table", {
          ref: refHeaderTable,
          class: "vxe-table--header",
          xid: xID,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 
           */
          h("colgroup", {
            ref: refHeaderColgroup
          }, renderColumnList.map((column, $columnIndex) => {
            return h("col", {
              name: column.id,
              key: $columnIndex
            });
          }).concat(scrollbarWidth ? [
            h("col", {
              name: "col_gutter"
            })
          ] : [])),
          /**
           * 
           */
          h("thead", {
            ref: refHeaderTHead
          }, headerGroups.map((cols, $rowIndex) => {
            return h("tr", {
              class: ["vxe-header--row", headerRowClassName ? import_xe_utils39.default.isFunction(headerRowClassName) ? headerRowClassName({ $table: $xetable, $rowIndex, fixed: fixedType, type: renderType2 }) : headerRowClassName : ""],
              style: headerRowStyle ? import_xe_utils39.default.isFunction(headerRowStyle) ? headerRowStyle({ $table: $xetable, $rowIndex, fixed: fixedType, type: renderType2 }) : headerRowStyle : null
            }, cols.map((column, $columnIndex) => {
              const { type, showHeaderOverflow, headerAlign, align, headerClassName } = column;
              const isColGroup = column.children && column.children.length;
              const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : !!column.fixed && overflowX;
              const headOverflow = import_xe_utils39.default.isUndefined(showHeaderOverflow) || import_xe_utils39.default.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
              const headAlign = headerAlign || align || allHeaderAlign || allAlign;
              let showEllipsis = headOverflow === "ellipsis";
              const showTitle = headOverflow === "title";
              const showTooltip = headOverflow === true || headOverflow === "tooltip";
              let hasEllipsis = showTitle || showTooltip || showEllipsis;
              const hasFilter = column.filters && column.filters.some((item) => item.checked);
              const columnIndex = $xetable.getColumnIndex(column);
              const _columnIndex = $xetable.getVTColumnIndex(column);
              const params = { $table: $xetable, $grid: $xetable.xegrid, $rowIndex, column, columnIndex, $columnIndex, _columnIndex, fixed: fixedType, type: renderType2, isHidden: fixedHiddenColumn, hasFilter };
              const thOns = {
                onClick: (evnt) => $xetable.triggerHeaderCellClickEvent(evnt, params),
                onDblclick: (evnt) => $xetable.triggerHeaderCellDblclickEvent(evnt, params)
              };
              if (scrollXLoad && !hasEllipsis) {
                showEllipsis = hasEllipsis = true;
              }
              if (mouseConfig) {
                thOns.onMousedown = (evnt) => $xetable.triggerHeaderCellMousedownEvent(evnt, params);
              }
              return h("th", Object.assign(Object.assign({ class: [
                "vxe-header--column",
                column.id,
                {
                  [`col--${headAlign}`]: headAlign,
                  [`col--${type}`]: type,
                  "col--last": $columnIndex === cols.length - 1,
                  "col--fixed": column.fixed,
                  "col--group": isColGroup,
                  "col--ellipsis": hasEllipsis,
                  "fixed--hidden": fixedHiddenColumn,
                  "is--sortable": column.sortable,
                  "col--filter": !!column.filters,
                  "is--filter-active": hasFilter,
                  "col--current": currentColumn === column
                },
                headerClassName ? import_xe_utils39.default.isFunction(headerClassName) ? headerClassName(params) : headerClassName : "",
                headerCellClassName ? import_xe_utils39.default.isFunction(headerCellClassName) ? headerCellClassName(params) : headerCellClassName : ""
              ], colid: column.id, colspan: column.colSpan > 1 ? column.colSpan : null, rowspan: column.rowSpan > 1 ? column.rowSpan : null, style: headerCellStyle ? import_xe_utils39.default.isFunction(headerCellStyle) ? headerCellStyle(params) : headerCellStyle : null }, thOns), { key: columnKey || columnOpts.useKey || isColGroup ? column.id : $columnIndex }), [
                h("div", {
                  class: ["vxe-cell", {
                    "c--title": showTitle,
                    "c--tooltip": showTooltip,
                    "c--ellipsis": showEllipsis
                  }]
                }, column.renderHeader(params)),
                /**
                 * 
                 */
                !fixedHiddenColumn && !isColGroup && (import_xe_utils39.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || resizable) ? h("div", {
                  class: ["vxe-resizable", {
                    "is--line": !border || border === "none"
                  }],
                  onMousedown: (evnt) => resizeMousedown(evnt, params)
                }) : null
              ]);
            }).concat(scrollbarWidth ? [
              h("th", {
                class: "vxe-header--gutter col--gutter"
              })
            ] : []));
          }))
        ]),
        /**
         * 
         */
        h("div", {
          ref: refHeaderBorderRepair,
          class: "vxe-table--header-border-line"
        })
      ]);
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/footer.js
var import_xe_utils40 = __toESM(require_xe_utils());
var renderType3 = "footer";
function mergeFooterMethod(mergeFooterList, _rowIndex, _columnIndex) {
  for (let mIndex = 0; mIndex < mergeFooterList.length; mIndex++) {
    const { row: mergeRowIndex, col: mergeColIndex, rowspan: mergeRowspan, colspan: mergeColspan } = mergeFooterList[mIndex];
    if (mergeColIndex > -1 && mergeRowIndex > -1 && mergeRowspan && mergeColspan) {
      if (mergeRowIndex === _rowIndex && mergeColIndex === _columnIndex) {
        return { rowspan: mergeRowspan, colspan: mergeColspan };
      }
      if (_rowIndex >= mergeRowIndex && _rowIndex < mergeRowIndex + mergeRowspan && _columnIndex >= mergeColIndex && _columnIndex < mergeColIndex + mergeColspan) {
        return { rowspan: 0, colspan: 0 };
      }
    }
  }
}
var footer_default = defineComponent({
  name: "VxeTableFooter",
  props: {
    footerTableData: { type: Array, default: () => [] },
    tableColumn: { type: Array, default: () => [] },
    fixedColumn: { type: Array, default: () => [] },
    fixedType: { type: String, default: null }
  },
  setup(props) {
    const $xetable = inject("$xetable", {});
    const { xID, props: tableProps, reactData: tableReactData, internalData: tableInternalData } = $xetable;
    const { refTableHeader, refTableBody, refValidTooltip } = $xetable.getRefMaps();
    const { computeTooltipOpts, computeColumnOpts } = $xetable.getComputeMaps();
    const refElem = ref();
    const refFooterTable = ref();
    const refFooterColgroup = ref();
    const refFooterTFoot = ref();
    const refFooterXSpace = ref();
    const scrollEvent = (evnt) => {
      const { fixedType } = props;
      const { scrollXLoad } = tableReactData;
      const { lastScrollLeft } = tableInternalData;
      const validTip = refValidTooltip.value;
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = refElem.value;
      const bodyElem = tableBody.$el;
      const scrollLeft = footerElem.scrollLeft;
      const isX = scrollLeft !== lastScrollLeft;
      tableInternalData.lastScrollLeft = scrollLeft;
      tableReactData.lastScrollTime = Date.now();
      if (headerElem) {
        headerElem.scrollLeft = scrollLeft;
      }
      if (bodyElem) {
        bodyElem.scrollLeft = scrollLeft;
      }
      if (scrollXLoad && isX) {
        $xetable.triggerScrollXEvent(evnt);
      }
      if (isX && validTip && validTip.reactData.visible) {
        validTip.updatePlacement();
      }
      $xetable.dispatchEvent("scroll", { type: renderType3, fixed: fixedType, scrollTop: bodyElem.scrollTop, scrollLeft, isX, isY: false }, evnt);
    };
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { elemStore } = tableInternalData;
        const prefix = `${fixedType || "main"}-footer-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}table`] = refFooterTable;
        elemStore[`${prefix}colgroup`] = refFooterColgroup;
        elemStore[`${prefix}list`] = refFooterTFoot;
        elemStore[`${prefix}xSpace`] = refFooterXSpace;
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { elemStore } = tableInternalData;
      const prefix = `${fixedType || "main"}-footer-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
    });
    const renderVN = () => {
      let { fixedType, fixedColumn, tableColumn, footerTableData } = props;
      const { footerRowClassName, footerCellClassName, footerRowStyle, footerCellStyle, footerAlign: allFooterAlign, footerSpanMethod, align: allAlign, columnKey, showFooterOverflow: allColumnFooterOverflow } = tableProps;
      const { visibleColumn } = tableInternalData;
      const { scrollXLoad, overflowX, scrollbarWidth, currentColumn, mergeFooterList } = tableReactData;
      const tooltipOpts = computeTooltipOpts.value;
      const columnOpts = computeColumnOpts.value;
      if (fixedType) {
        if (!tableReactData.expandColumn && (scrollXLoad || allColumnFooterOverflow)) {
          if (!mergeFooterList.length || !footerSpanMethod) {
            tableColumn = fixedColumn;
          } else {
            tableColumn = visibleColumn;
          }
        } else {
          tableColumn = visibleColumn;
        }
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table--footer-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"],
        xid: xID,
        onScroll: scrollEvent
      }, [
        fixedType ? createCommentVNode() : h("div", {
          ref: refFooterXSpace,
          class: "vxe-body--x-space"
        }),
        h("table", {
          ref: refFooterTable,
          class: "vxe-table--footer",
          xid: xID,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 
           */
          h("colgroup", {
            ref: refFooterColgroup
          }, tableColumn.map((column, $columnIndex) => {
            return h("col", {
              name: column.id,
              key: $columnIndex
            });
          }).concat(scrollbarWidth ? [
            h("col", {
              name: "col_gutter"
            })
          ] : [])),
          /**
           * 
           */
          h("tfoot", {
            ref: refFooterTFoot
          }, footerTableData.map((list, _rowIndex) => {
            const $rowIndex = _rowIndex;
            const rowParams = { $table: $xetable, row: list, _rowIndex, $rowIndex, fixed: fixedType, type: renderType3 };
            return h("tr", {
              class: ["vxe-footer--row", footerRowClassName ? import_xe_utils40.default.isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ""],
              style: footerRowStyle ? import_xe_utils40.default.isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : null
            }, tableColumn.map((column, $columnIndex) => {
              const { type, showFooterOverflow, footerAlign, align, footerClassName } = column;
              const showAllTip = tooltipOpts.showAll;
              const isColGroup = column.children && column.children.length;
              const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : column.fixed && overflowX;
              const footOverflow = import_xe_utils40.default.isUndefined(showFooterOverflow) || import_xe_utils40.default.isNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
              const footAlign = footerAlign || align || allFooterAlign || allAlign;
              let showEllipsis = footOverflow === "ellipsis";
              const showTitle = footOverflow === "title";
              const showTooltip = footOverflow === true || footOverflow === "tooltip";
              let hasEllipsis = showTitle || showTooltip || showEllipsis;
              const attrs = { colid: column.id };
              const tfOns = {};
              const columnIndex = $xetable.getColumnIndex(column);
              const _columnIndex = $xetable.getVTColumnIndex(column);
              const itemIndex = _columnIndex;
              const cellParams = {
                $table: $xetable,
                $grid: $xetable.xegrid,
                row: list,
                rowIndex: _rowIndex,
                _rowIndex,
                $rowIndex,
                column,
                columnIndex,
                $columnIndex,
                _columnIndex,
                itemIndex,
                items: list,
                fixed: fixedType,
                type: renderType3,
                data: footerTableData
              };
              if (scrollXLoad && !hasEllipsis) {
                showEllipsis = hasEllipsis = true;
              }
              if (showTitle || showTooltip || showAllTip) {
                tfOns.onMouseenter = (evnt) => {
                  if (showTitle) {
                    updateCellTitle(evnt.currentTarget, column);
                  } else if (showTooltip || showAllTip) {
                    $xetable.triggerFooterTooltipEvent(evnt, cellParams);
                  }
                };
              }
              if (showTooltip || showAllTip) {
                tfOns.onMouseleave = (evnt) => {
                  if (showTooltip || showAllTip) {
                    $xetable.handleTargetLeaveEvent(evnt);
                  }
                };
              }
              tfOns.onClick = (evnt) => {
                $xetable.dispatchEvent("footer-cell-click", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
              };
              tfOns.onDblclick = (evnt) => {
                $xetable.dispatchEvent("footer-cell-dblclick", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
              };
              if (mergeFooterList.length) {
                const spanRest = mergeFooterMethod(mergeFooterList, _rowIndex, _columnIndex);
                if (spanRest) {
                  const { rowspan, colspan } = spanRest;
                  if (!rowspan || !colspan) {
                    return null;
                  }
                  if (rowspan > 1) {
                    attrs.rowspan = rowspan;
                  }
                  if (colspan > 1) {
                    attrs.colspan = colspan;
                  }
                }
              } else if (footerSpanMethod) {
                const { rowspan = 1, colspan = 1 } = footerSpanMethod(cellParams) || {};
                if (!rowspan || !colspan) {
                  return null;
                }
                if (rowspan > 1) {
                  attrs.rowspan = rowspan;
                }
                if (colspan > 1) {
                  attrs.colspan = colspan;
                }
              }
              return h("td", Object.assign(Object.assign(Object.assign(Object.assign({ class: ["vxe-footer--column", column.id, {
                [`col--${footAlign}`]: footAlign,
                [`col--${type}`]: type,
                "col--last": $columnIndex === tableColumn.length - 1,
                "fixed--hidden": fixedHiddenColumn,
                "col--ellipsis": hasEllipsis,
                "col--current": currentColumn === column
              }, getPropClass(footerClassName, cellParams), getPropClass(footerCellClassName, cellParams)] }, attrs), { style: footerCellStyle ? import_xe_utils40.default.isFunction(footerCellStyle) ? footerCellStyle(cellParams) : footerCellStyle : null }), tfOns), { key: columnKey || columnOpts.useKey ? column.id : $columnIndex }), [
                h("div", {
                  class: ["vxe-cell", {
                    "c--title": showTitle,
                    "c--tooltip": showTooltip,
                    "c--ellipsis": showEllipsis
                  }]
                }, column.renderFooter(cellParams))
              ]);
            }).concat(scrollbarWidth ? [
              h("td", {
                class: "vxe-footer--gutter col--gutter"
              })
            ] : []));
          }))
        ])
      ]);
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/props.js
var props_default = {
  /**  */
  id: String,
  // 
  data: Array,
  // 
  height: [Number, String],
  // 
  minHeight: { type: [Number, String], default: () => conf_default.table.minHeight },
  // 
  maxHeight: [Number, String],
  //  column-config.resizable 
  resizable: { type: Boolean, default: () => conf_default.table.resizable },
  // 
  stripe: { type: Boolean, default: () => conf_default.table.stripe },
  // 
  border: { type: [Boolean, String], default: () => conf_default.table.border },
  // 
  round: { type: Boolean, default: () => conf_default.table.round },
  // 
  size: { type: String, default: () => conf_default.table.size || conf_default.size },
  // 
  fit: { type: Boolean, default: () => conf_default.table.fit },
  // 
  loading: Boolean,
  // 
  align: { type: String, default: () => conf_default.table.align },
  // 
  headerAlign: { type: String, default: () => conf_default.table.headerAlign },
  // 
  footerAlign: { type: String, default: () => conf_default.table.footerAlign },
  // 
  showHeader: { type: Boolean, default: () => conf_default.table.showHeader },
  // 
  highlightCurrentRow: { type: Boolean, default: () => conf_default.table.highlightCurrentRow },
  // 
  highlightHoverRow: { type: Boolean, default: () => conf_default.table.highlightHoverRow },
  // 
  highlightCurrentColumn: { type: Boolean, default: () => conf_default.table.highlightCurrentColumn },
  // 
  highlightHoverColumn: { type: Boolean, default: () => conf_default.table.highlightHoverColumn },
  // 
  highlightCell: Boolean,
  // 
  showFooter: Boolean,
  // 
  footerData: Array,
  // 
  footerMethod: Function,
  //  className
  rowClassName: [String, Function],
  //  className
  cellClassName: [String, Function],
  //  className
  headerRowClassName: [String, Function],
  //  className
  headerCellClassName: [String, Function],
  //  className
  footerRowClassName: [String, Function],
  //  className
  footerCellClassName: [String, Function],
  // 
  cellStyle: [Object, Function],
  // 
  headerCellStyle: [Object, Function],
  // 
  footerCellStyle: [Object, Function],
  // 
  rowStyle: [Object, Function],
  // 
  headerRowStyle: [Object, Function],
  // 
  footerRowStyle: [Object, Function],
  // 
  mergeCells: Array,
  // 
  mergeFooterItems: Array,
  // 
  spanMethod: Function,
  // 
  footerSpanMethod: Function,
  // 
  showOverflow: { type: [Boolean, String], default: () => conf_default.table.showOverflow },
  // 
  showHeaderOverflow: { type: [Boolean, String], default: () => conf_default.table.showHeaderOverflow },
  // 
  showFooterOverflow: { type: [Boolean, String], default: () => conf_default.table.showFooterOverflow },
  /**  */
  // columnKey  column-config.useKey 
  columnKey: Boolean,
  // rowKey  row-config.useKey 
  rowKey: Boolean,
  // rowId  row-config.keyField 
  rowId: { type: String, default: () => conf_default.table.rowId },
  zIndex: Number,
  emptyText: { type: String, default: () => conf_default.table.emptyText },
  keepSource: { type: Boolean, default: () => conf_default.table.keepSource },
  // 
  autoResize: { type: Boolean, default: () => conf_default.table.autoResize },
  // 
  syncResize: [Boolean, String, Number],
  // 
  resizeConfig: Object,
  // 
  columnConfig: Object,
  // 
  rowConfig: Object,
  // 
  resizableConfig: Object,
  // 
  seqConfig: Object,
  // 
  sortConfig: Object,
  // 
  filterConfig: Object,
  // 
  radioConfig: Object,
  // 
  checkboxConfig: Object,
  // tooltip 
  tooltipConfig: Object,
  // 
  exportConfig: Object,
  // 
  importConfig: Object,
  // 
  printConfig: Object,
  // 
  expandConfig: Object,
  // 
  treeConfig: Object,
  // 
  menuConfig: Object,
  // 
  mouseConfig: Object,
  // 
  areaConfig: Object,
  // 
  keyboardConfig: Object,
  // /
  clipConfig: Object,
  // /
  fnrConfig: Object,
  // 
  editConfig: Object,
  // 
  validConfig: Object,
  // 
  editRules: Object,
  // 
  loadingConfig: Object,
  // 
  emptyRender: Object,
  // 
  customConfig: Object,
  // 
  scrollX: Object,
  // 
  scrollY: Object,
  // 
  animat: { type: Boolean, default: () => conf_default.table.animat },
  // 
  delayHover: { type: Number, default: () => conf_default.table.delayHover },
  // 
  params: Object
};

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/emits.js
var emits_default = [
  "update:data",
  "keydown-start",
  "keydown",
  "keydown-end",
  "paste",
  "copy",
  "cut",
  "current-change",
  "radio-change",
  "checkbox-change",
  "checkbox-all",
  "checkbox-range-start",
  "checkbox-range-change",
  "checkbox-range-end",
  "checkbox-range-select",
  "cell-click",
  "cell-dblclick",
  "cell-menu",
  "cell-mouseenter",
  "cell-mouseleave",
  "cell-selected",
  "cell-delete-value",
  "header-cell-click",
  "header-cell-dblclick",
  "header-cell-menu",
  "footer-cell-click",
  "footer-cell-dblclick",
  "footer-cell-menu",
  "clear-merge",
  "sort-change",
  "clear-sort",
  "filter-change",
  "filter-visible",
  "clear-filter",
  "resizable-change",
  "toggle-row-expand",
  "toggle-tree-expand",
  "menu-click",
  "edit-closed",
  "edit-actived",
  "edit-activated",
  "edit-disabled",
  "valid-error",
  "scroll",
  "custom",
  "change-fnr",
  "open-fnr",
  "show-fnr",
  "hide-fnr",
  "fnr-change",
  "fnr-find",
  "fnr-find-all",
  "fnr-replace",
  "fnr-replace-all",
  "cell-area-copy",
  "cell-area-cut",
  "cell-area-paste",
  "cell-area-merge",
  "clear-cell-area-merge",
  "header-cell-area-selection",
  "cell-area-selection-invalid",
  "cell-area-selection-start",
  "cell-area-selection-drag",
  "cell-area-selection-end",
  "cell-area-extension-start",
  "cell-area-extension-drag",
  "cell-area-extension-end",
  "cell-area-selection-all-start",
  "cell-area-selection-all-end",
  "cell-area-arrows-start",
  "cell-area-arrows-end",
  "active-cell-change-start",
  "active-cell-change-end"
];

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/table.js
var isWebkit = browse["-webkit"] && !browse.edge;
var resizableStorageKey = "VXE_TABLE_CUSTOM_COLUMN_WIDTH";
var visibleStorageKey = "VXE_TABLE_CUSTOM_COLUMN_VISIBLE";
var fixedStorageKey = "VXE_TABLE_CUSTOM_COLUMN_FIXED";
var sortStorageKey = "VXE_TABLE_CUSTOM_COLUMN_SORT";
var table_default = defineComponent({
  name: "VxeTable",
  props: props_default,
  emits: emits_default,
  setup(props, context) {
    const { slots, emit } = context;
    const hasUseTooltip = VXETable.tooltip;
    const xID = import_xe_utils41.default.uniqueId();
    const computeSize = useSize(props);
    const instance = getCurrentInstance();
    const reactData = reactive({
      // 
      staticColumns: [],
      // 
      tableGroupColumn: [],
      // 
      tableColumn: [],
      // 
      tableData: [],
      //  X 
      scrollXLoad: false,
      //  Y 
      scrollYLoad: false,
      // 
      overflowY: true,
      // 
      overflowX: false,
      // 
      scrollbarWidth: 0,
      // 
      scrollbarHeight: 0,
      // 
      lastScrollTime: 0,
      // 
      rowHeight: 0,
      // 
      parentHeight: 0,
      // 
      isGroup: false,
      isAllOverflow: false,
      // 
      isAllSelected: false,
      // 
      isIndeterminate: false,
      // 
      selectCheckboxMaps: {},
      // 
      currentRow: null,
      // 
      currentColumn: null,
      // 
      selectRadioRow: null,
      // 
      footerTableData: [],
      // 
      expandColumn: null,
      // 
      treeNodeColumn: null,
      hasFixedColumn: false,
      // 
      rowExpandedMaps: {},
      // 
      rowExpandLazyLoadedMaps: {},
      // 
      treeExpandedMaps: {},
      // 
      treeExpandLazyLoadedMaps: {},
      // 
      treeIndeterminateMaps: {},
      // 
      mergeList: [],
      // 
      mergeFooterList: [],
      // 
      upDataFlag: 0,
      // 
      reColumnFlag: 0,
      // 
      pendingRowMaps: {},
      // 
      pendingRowList: [],
      // 
      initStore: {
        filter: false,
        import: false,
        export: false,
        custom: false
      },
      // 
      customStore: {
        btnEl: null,
        isAll: false,
        isIndeterminate: false,
        activeBtn: false,
        activeWrapper: false,
        visible: false,
        maxHeight: 0
      },
      customColumnList: [],
      // 
      filterStore: {
        isAllSelected: false,
        isIndeterminate: false,
        style: null,
        options: [],
        column: null,
        multiple: false,
        visible: false,
        maxHeight: null
      },
      // 
      columnStore: {
        leftList: [],
        centerList: [],
        rightList: [],
        resizeList: [],
        pxList: [],
        pxMinList: [],
        scaleList: [],
        scaleMinList: [],
        autoList: []
      },
      // 
      ctxMenuStore: {
        selected: null,
        visible: false,
        showChild: false,
        selectChild: null,
        list: [],
        style: null
      },
      // 
      editStore: {
        indexs: {
          columns: []
        },
        titles: {
          columns: []
        },
        // 
        selected: {
          row: null,
          column: null
        },
        // 
        copyed: {
          cut: false,
          rows: [],
          columns: []
        },
        // 
        actived: {
          row: null,
          column: null
        },
        // 
        focused: {
          row: null,
          column: null
        },
        insertMaps: {},
        removeMaps: {}
      },
      //  tooltip 
      tooltipStore: {
        row: null,
        column: null,
        content: null,
        visible: false
      },
      // 
      validStore: {
        visible: false
      },
      validErrorMaps: {},
      // 
      importStore: {
        inited: false,
        file: null,
        type: "",
        modeList: [],
        typeList: [],
        filename: "",
        visible: false
      },
      importParams: {
        mode: "",
        types: null,
        message: true
      },
      // 
      exportStore: {
        inited: false,
        name: "",
        modeList: [],
        typeList: [],
        columns: [],
        isPrint: false,
        hasFooter: false,
        hasMerge: false,
        hasTree: false,
        hasColgroup: false,
        visible: false
      },
      exportParams: {
        filename: "",
        sheetName: "",
        mode: "",
        type: "",
        isColgroup: false,
        isMerge: false,
        isAllExpand: false,
        useStyle: false,
        original: false,
        message: true,
        isHeader: false,
        isFooter: false
      },
      scrollVMLoading: false,
      _isResize: false
    });
    const internalData = {
      tZindex: 0,
      elemStore: {},
      //  X 
      scrollXStore: {
        offsetSize: 0,
        visibleSize: 0,
        startIndex: 0,
        endIndex: 0
      },
      //  Y 
      scrollYStore: {
        rowHeight: 0,
        offsetSize: 0,
        visibleSize: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 
      tableWidth: 0,
      // 
      tableHeight: 0,
      // 
      headerHeight: 0,
      // 
      footerHeight: 0,
      customHeight: 0,
      customMinHeight: 0,
      customMaxHeight: 0,
      //  hover 
      hoverRow: null,
      // 
      lastScrollLeft: 0,
      lastScrollTop: 0,
      // 
      radioReserveRow: null,
      // 
      checkboxReserveRowMap: {},
      // 
      rowExpandedReserveRowMap: {},
      // 
      treeExpandedReserveRowMap: {},
      // 
      treeIndeterminateRowMaps: {},
      // 
      tableFullData: [],
      afterFullData: [],
      afterTreeFullData: [],
      // 
      afterFullRowMaps: {},
      // 
      tableFullTreeData: [],
      tableSynchData: [],
      tableSourceData: [],
      // 
      collectColumn: [],
      // 
      tableFullColumn: [],
      // 
      visibleColumn: [],
      // 
      fullAllDataRowIdData: {},
      // 
      sourceDataRowIdData: {},
      fullDataRowIdData: {},
      fullColumnIdData: {},
      fullColumnFieldData: {},
      // 
      columnStatusMaps: {},
      // 
      rowStatusMaps: {},
      inited: false,
      tooltipTimeout: null,
      initStatus: false,
      isActivated: false
    };
    let tableMethods = {};
    let tablePrivateMethods = {};
    const refElem = ref();
    const refTooltip = ref();
    const refCommTooltip = ref();
    const refValidTooltip = ref();
    const refTableMenu = ref();
    const refTableFilter = ref();
    const refTableCustom = ref();
    const refTableHeader = ref();
    const refTableBody = ref();
    const refTableFooter = ref();
    const refTableLeftHeader = ref();
    const refTableLeftBody = ref();
    const refTableLeftFooter = ref();
    const refTableRightHeader = ref();
    const refTableRightBody = ref();
    const refTableRightFooter = ref();
    const refLeftContainer = ref();
    const refRightContainer = ref();
    const refCellResizeBar = ref();
    const refEmptyPlaceholder = ref();
    const $xegrid = inject("$xegrid", null);
    let $xetoolbar;
    const computeValidOpts = computed(() => {
      return Object.assign({}, conf_default.table.validConfig, props.validConfig);
    });
    const computeSXOpts = computed(() => {
      return Object.assign({}, conf_default.table.scrollX, props.scrollX);
    });
    const computeSYOpts = computed(() => {
      return Object.assign({}, conf_default.table.scrollY, props.scrollY);
    });
    const computeRowHeightMaps = computed(() => {
      return {
        default: 48,
        medium: 44,
        small: 40,
        mini: 36
      };
    });
    const computeColumnOpts = computed(() => {
      return Object.assign({}, conf_default.table.columnConfig, props.columnConfig);
    });
    const computeRowOpts = computed(() => {
      return Object.assign({}, conf_default.table.rowConfig, props.rowConfig);
    });
    const computeResizeleOpts = computed(() => {
      return Object.assign({}, conf_default.table.resizeConfig, props.resizeConfig);
    });
    const computeResizableOpts = computed(() => {
      return Object.assign({}, conf_default.table.resizableConfig, props.resizableConfig);
    });
    const computeSeqOpts = computed(() => {
      return Object.assign({ startIndex: 0 }, conf_default.table.seqConfig, props.seqConfig);
    });
    const computeRadioOpts = computed(() => {
      return Object.assign({}, conf_default.table.radioConfig, props.radioConfig);
    });
    const computeCheckboxOpts = computed(() => {
      return Object.assign({}, conf_default.table.checkboxConfig, props.checkboxConfig);
    });
    let computeTooltipOpts = ref();
    computeTooltipOpts = computed(() => {
      return Object.assign({}, conf_default.tooltip, conf_default.table.tooltipConfig, props.tooltipConfig);
    });
    const computeTipConfig = computed(() => {
      const tooltipOpts = computeTooltipOpts.value;
      return Object.assign({}, tooltipOpts);
    });
    const computeValidTipOpts = computed(() => {
      const tooltipOpts = computeTooltipOpts.value;
      return Object.assign({ isArrow: false }, tooltipOpts);
    });
    const computeEditOpts = computed(() => {
      return Object.assign({}, conf_default.table.editConfig, props.editConfig);
    });
    const computeSortOpts = computed(() => {
      return Object.assign({ orders: ["asc", "desc", null] }, conf_default.table.sortConfig, props.sortConfig);
    });
    const computeFilterOpts = computed(() => {
      return Object.assign({}, conf_default.table.filterConfig, props.filterConfig);
    });
    const computeMouseOpts = computed(() => {
      return Object.assign({}, conf_default.table.mouseConfig, props.mouseConfig);
    });
    const computeAreaOpts = computed(() => {
      return Object.assign({}, conf_default.table.areaConfig, props.areaConfig);
    });
    const computeKeyboardOpts = computed(() => {
      return Object.assign({}, conf_default.table.keyboardConfig, props.keyboardConfig);
    });
    const computeClipOpts = computed(() => {
      return Object.assign({}, conf_default.table.clipConfig, props.clipConfig);
    });
    const computeFNROpts = computed(() => {
      return Object.assign({}, conf_default.table.fnrConfig, props.fnrConfig);
    });
    const computeMenuOpts = computed(() => {
      return Object.assign({}, conf_default.table.menuConfig, props.menuConfig);
    });
    const computeHeaderMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const headerOpts = menuOpts.header;
      return headerOpts && headerOpts.options ? headerOpts.options : [];
    });
    const computeBodyMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const bodyOpts = menuOpts.body;
      return bodyOpts && bodyOpts.options ? bodyOpts.options : [];
    });
    const computeFooterMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const footerOpts = menuOpts.footer;
      return footerOpts && footerOpts.options ? footerOpts.options : [];
    });
    const computeIsMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const headerMenu = computeHeaderMenu.value;
      const bodyMenu = computeBodyMenu.value;
      const footerMenu = computeFooterMenu.value;
      return !!(props.menuConfig && isEnableConf(menuOpts) && (headerMenu.length || bodyMenu.length || footerMenu.length));
    });
    const computeMenuList = computed(() => {
      const { ctxMenuStore } = reactData;
      const rest = [];
      ctxMenuStore.list.forEach((list) => {
        list.forEach((item) => {
          rest.push(item);
        });
      });
      return rest;
    });
    const computeExportOpts = computed(() => {
      return Object.assign({}, conf_default.table.exportConfig, props.exportConfig);
    });
    const computeImportOpts = computed(() => {
      return Object.assign({}, conf_default.table.importConfig, props.importConfig);
    });
    const computePrintOpts = computed(() => {
      return Object.assign({}, conf_default.table.printConfig, props.printConfig);
    });
    const computeExpandOpts = computed(() => {
      return Object.assign({}, conf_default.table.expandConfig, props.expandConfig);
    });
    const computeTreeOpts = computed(() => {
      return Object.assign({}, conf_default.table.treeConfig, props.treeConfig);
    });
    const computeEmptyOpts = computed(() => {
      return Object.assign({}, conf_default.table.emptyRender, props.emptyRender);
    });
    const computeLoadingOpts = computed(() => {
      return Object.assign({}, conf_default.table.loadingConfig, props.loadingConfig);
    });
    const computeCellOffsetWidth = computed(() => {
      return props.border ? Math.max(2, Math.ceil(reactData.scrollbarWidth / reactData.tableColumn.length)) : 1;
    });
    const computeCustomOpts = computed(() => {
      return Object.assign({}, conf_default.table.customConfig, props.customConfig);
    });
    const computeFixedColumnSize = computed(() => {
      const { collectColumn } = internalData;
      let fixedSize = 0;
      collectColumn.forEach((column) => {
        if (column.fixed) {
          fixedSize++;
        }
      });
      return fixedSize;
    });
    const computeIsMaxFixedColumn = computed(() => {
      const fixedColumnSize = computeFixedColumnSize.value;
      const columnOpts = computeColumnOpts.value;
      const { maxFixedSize } = columnOpts;
      if (maxFixedSize) {
        return fixedColumnSize >= maxFixedSize;
      }
      return false;
    });
    const computeTableBorder = computed(() => {
      const { border } = props;
      if (border === true) {
        return "full";
      }
      if (border) {
        return border;
      }
      return "default";
    });
    const computeIsAllCheckboxDisabled = computed(() => {
      const { treeConfig } = props;
      const { tableData } = reactData;
      const { tableFullData } = internalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const { strict, checkMethod } = checkboxOpts;
      if (strict) {
        if (tableData.length || tableFullData.length) {
          if (checkMethod) {
            if (treeConfig) {
            }
            return tableFullData.every((row) => !checkMethod({ row }));
          }
          return false;
        }
        return true;
      }
      return false;
    });
    const refMaps = {
      refElem,
      refTooltip,
      refValidTooltip,
      refTableFilter,
      refTableCustom,
      refTableMenu,
      refTableHeader,
      refTableBody,
      refTableFooter,
      refTableLeftHeader,
      refTableLeftBody,
      refTableLeftFooter,
      refTableRightHeader,
      refTableRightBody,
      refTableRightFooter,
      refLeftContainer,
      refRightContainer,
      refCellResizeBar
    };
    const computeMaps = {
      computeSize,
      computeValidOpts,
      computeSXOpts,
      computeSYOpts,
      computeColumnOpts,
      computeRowOpts,
      computeResizeleOpts,
      computeResizableOpts,
      computeSeqOpts,
      computeRadioOpts,
      computeCheckboxOpts,
      computeTooltipOpts,
      computeEditOpts,
      computeSortOpts,
      computeFilterOpts,
      computeMouseOpts,
      computeAreaOpts,
      computeKeyboardOpts,
      computeClipOpts,
      computeFNROpts,
      computeHeaderMenu,
      computeBodyMenu,
      computeFooterMenu,
      computeIsMenu,
      computeMenuOpts,
      computeExportOpts,
      computeImportOpts,
      computePrintOpts,
      computeExpandOpts,
      computeTreeOpts,
      computeEmptyOpts,
      computeLoadingOpts,
      computeCustomOpts,
      computeFixedColumnSize,
      computeIsMaxFixedColumn,
      computeIsAllCheckboxDisabled
    };
    const $xetable = {
      xID,
      props,
      context,
      instance,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps,
      xegrid: $xegrid
    };
    const eqCellValue = (row1, row2, field) => {
      const val1 = import_xe_utils41.default.get(row1, field);
      const val2 = import_xe_utils41.default.get(row2, field);
      if (eqEmptyValue(val1) && eqEmptyValue(val2)) {
        return true;
      }
      if (import_xe_utils41.default.isString(val1) || import_xe_utils41.default.isNumber(val1)) {
        return "" + val1 === "" + val2;
      }
      return import_xe_utils41.default.isEqual(val1, val2);
    };
    const getNextSortOrder = (column) => {
      const sortOpts = computeSortOpts.value;
      const { orders } = sortOpts;
      const currOrder = column.order || null;
      const oIndex = orders.indexOf(currOrder) + 1;
      return orders[oIndex < orders.length ? oIndex : 0];
    };
    const getCustomStorageMap = (key) => {
      const version2 = conf_default.version;
      const rest = import_xe_utils41.default.toStringJSON(localStorage.getItem(key) || "");
      return rest && rest._v === version2 ? rest : { _v: version2 };
    };
    const getRecoverRowMaps = (keyMaps) => {
      const { fullAllDataRowIdData } = internalData;
      const restKeys = {};
      import_xe_utils41.default.each(keyMaps, (row, rowid) => {
        if (fullAllDataRowIdData[rowid]) {
          restKeys[rowid] = row;
        }
      });
      return restKeys;
    };
    const handleReserveRow = (reserveRowMap) => {
      const { fullDataRowIdData } = internalData;
      const reserveList = [];
      import_xe_utils41.default.each(reserveRowMap, (item, rowid) => {
        if (fullDataRowIdData[rowid] && $xetable.findRowIndexOf(reserveList, fullDataRowIdData[rowid].row) === -1) {
          reserveList.push(fullDataRowIdData[rowid].row);
        }
      });
      return reserveList;
    };
    const computeVirtualX = () => {
      const { visibleColumn } = internalData;
      const tableBody = refTableBody.value;
      const tableBodyElem = tableBody ? tableBody.$el : null;
      if (tableBodyElem) {
        const { scrollLeft, clientWidth } = tableBodyElem;
        const endWidth = scrollLeft + clientWidth;
        let toVisibleIndex = -1;
        let cWidth = 0;
        let visibleSize = 0;
        for (let colIndex = 0, colLen = visibleColumn.length; colIndex < colLen; colIndex++) {
          cWidth += visibleColumn[colIndex].renderWidth;
          if (toVisibleIndex === -1 && scrollLeft < cWidth) {
            toVisibleIndex = colIndex;
          }
          if (toVisibleIndex >= 0) {
            visibleSize++;
            if (cWidth > endWidth) {
              break;
            }
          }
        }
        return { toVisibleIndex: Math.max(0, toVisibleIndex), visibleSize: Math.max(8, visibleSize) };
      }
      return { toVisibleIndex: 0, visibleSize: 8 };
    };
    const computeVirtualY = () => {
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableBodyElem = tableBody ? tableBody.$el : null;
      const vSize = computeSize.value;
      const rowHeightMaps = computeRowHeightMaps.value;
      if (tableBodyElem) {
        const tableHeaderElem = tableHeader ? tableHeader.$el : null;
        let rowHeight = 0;
        let firstTrElem;
        firstTrElem = tableBodyElem.querySelector("tr");
        if (!firstTrElem && tableHeaderElem) {
          firstTrElem = tableHeaderElem.querySelector("tr");
        }
        if (firstTrElem) {
          rowHeight = firstTrElem.clientHeight;
        }
        if (!rowHeight) {
          rowHeight = rowHeightMaps[vSize || "default"];
        }
        const visibleSize = Math.max(8, Math.ceil(tableBodyElem.clientHeight / rowHeight) + 2);
        return { rowHeight, visibleSize };
      }
      return { rowHeight: 0, visibleSize: 8 };
    };
    const calculateMergerOffserIndex = (list, offsetItem, type) => {
      for (let mcIndex = 0, len = list.length; mcIndex < len; mcIndex++) {
        const mergeItem = list[mcIndex];
        const { startIndex, endIndex } = offsetItem;
        const mergeStartIndex = mergeItem[type];
        const mergeSpanNumber = mergeItem[type + "span"];
        const mergeEndIndex = mergeStartIndex + mergeSpanNumber;
        if (mergeStartIndex < startIndex && startIndex < mergeEndIndex) {
          offsetItem.startIndex = mergeStartIndex;
        }
        if (mergeStartIndex < endIndex && endIndex < mergeEndIndex) {
          offsetItem.endIndex = mergeEndIndex;
        }
        if (offsetItem.startIndex !== startIndex || offsetItem.endIndex !== endIndex) {
          mcIndex = -1;
        }
      }
    };
    const setMerges = (merges, mList, rowList) => {
      if (merges) {
        const { treeConfig } = props;
        const { visibleColumn } = internalData;
        if (!import_xe_utils41.default.isArray(merges)) {
          merges = [merges];
        }
        if (treeConfig && merges.length) {
          errLog("vxe.error.noTree", ["merge-cells | merge-footer-items"]);
        }
        merges.forEach((item) => {
          let { row, col, rowspan, colspan } = item;
          if (rowList && import_xe_utils41.default.isNumber(row)) {
            row = rowList[row];
          }
          if (import_xe_utils41.default.isNumber(col)) {
            col = visibleColumn[col];
          }
          if ((rowList ? row : import_xe_utils41.default.isNumber(row)) && col && (rowspan || colspan)) {
            rowspan = import_xe_utils41.default.toNumber(rowspan) || 1;
            colspan = import_xe_utils41.default.toNumber(colspan) || 1;
            if (rowspan > 1 || colspan > 1) {
              const mcIndex = import_xe_utils41.default.findIndexOf(mList, (item2) => (item2._row === row || getRowid($xetable, item2._row) === getRowid($xetable, row)) && (item2._col.id === col || item2._col.id === col.id));
              const mergeItem = mList[mcIndex];
              if (mergeItem) {
                mergeItem.rowspan = rowspan;
                mergeItem.colspan = colspan;
                mergeItem._rowspan = rowspan;
                mergeItem._colspan = colspan;
              } else {
                const mergeRowIndex = rowList ? $xetable.findRowIndexOf(rowList, row) : row;
                const mergeColIndex = tableMethods.getVTColumnIndex(col);
                mList.push({
                  row: mergeRowIndex,
                  col: mergeColIndex,
                  rowspan,
                  colspan,
                  _row: row,
                  _col: col,
                  _rowspan: rowspan,
                  _colspan: colspan
                });
              }
            }
          }
        });
      }
    };
    const removeMerges = (merges, mList, rowList) => {
      const rest = [];
      if (merges) {
        const { treeConfig } = props;
        const { visibleColumn } = internalData;
        if (!import_xe_utils41.default.isArray(merges)) {
          merges = [merges];
        }
        if (treeConfig && merges.length) {
          errLog("vxe.error.noTree", ["merge-cells | merge-footer-items"]);
        }
        merges.forEach((item) => {
          let { row, col } = item;
          if (rowList && import_xe_utils41.default.isNumber(row)) {
            row = rowList[row];
          }
          if (import_xe_utils41.default.isNumber(col)) {
            col = visibleColumn[col];
          }
          const mcIndex = import_xe_utils41.default.findIndexOf(mList, (item2) => (item2._row === row || getRowid($xetable, item2._row) === getRowid($xetable, row)) && (item2._col.id === col || item2._col.id === col.id));
          if (mcIndex > -1) {
            const rItems = mList.splice(mcIndex, 1);
            rest.push(rItems[0]);
          }
        });
      }
      return rest;
    };
    const clearAllSort = () => {
      const { tableFullColumn } = internalData;
      tableFullColumn.forEach((column) => {
        column.order = null;
      });
    };
    const calcHeight = (key) => {
      const { parentHeight } = reactData;
      const val = props[key];
      let num = 0;
      if (val) {
        if (val === "100%" || val === "auto") {
          num = parentHeight;
        } else {
          const excludeHeight = $xetable.getExcludeHeight();
          if (isScale(val)) {
            num = Math.floor((import_xe_utils41.default.toInteger(val) || 1) / 100 * parentHeight);
          } else {
            num = import_xe_utils41.default.toNumber(val);
          }
          num = Math.max(40, num - excludeHeight);
        }
      }
      return num;
    };
    const restoreCustomStorage = () => {
      const { id, customConfig } = props;
      const customOpts = computeCustomOpts.value;
      const { storage } = customOpts;
      const isAllCustom = storage === true;
      const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
      const isCustomResizable = isAllCustom || storageOpts.resizable;
      const isCustomVisible = isAllCustom || storageOpts.visible;
      const isCustomFixed = isAllCustom || storageOpts.fixed;
      const isCustomSort = isAllCustom || storageOpts.sort;
      if (customConfig && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomSort)) {
        const customMap = {};
        if (!id) {
          errLog("vxe.error.reqProp", ["id"]);
          return;
        }
        if (isCustomResizable) {
          const columnWidthStorage = getCustomStorageMap(resizableStorageKey)[id];
          if (columnWidthStorage) {
            import_xe_utils41.default.each(columnWidthStorage, (resizeWidth, colKey) => {
              customMap[colKey] = { resizeWidth };
            });
          }
        }
        if (isCustomFixed) {
          const columnFixedStorage = getCustomStorageMap(fixedStorageKey)[id];
          if (columnFixedStorage) {
            const colFixeds = columnFixedStorage.split(",");
            colFixeds.forEach((fixConf) => {
              const [colKey, fixed] = fixConf.split("|");
              if (customMap[colKey]) {
                customMap[colKey].fixed = fixed;
              } else {
                customMap[colKey] = { fixed };
              }
            });
          }
        }
        let hasCustomSort = false;
        if (isCustomSort) {
          const columnSortStorage = getCustomStorageMap(sortStorageKey)[id];
          if (columnSortStorage) {
            import_xe_utils41.default.each(columnSortStorage, (renderSortNumber, colKey) => {
              if (customMap[colKey]) {
                customMap[colKey].renderSortNumber = renderSortNumber;
              } else {
                customMap[colKey] = { renderSortNumber };
              }
              if (!hasCustomSort) {
                hasCustomSort = true;
              }
            });
          }
        }
        if (isCustomVisible) {
          const columnVisibleStorage = getCustomStorageMap(visibleStorageKey)[id];
          if (columnVisibleStorage) {
            const colVisibles = columnVisibleStorage.split("|");
            const colHides = colVisibles[0] ? colVisibles[0].split(",") : [];
            const colShows = colVisibles[1] ? colVisibles[1].split(",") : [];
            colHides.forEach((colKey) => {
              if (customMap[colKey]) {
                customMap[colKey].visible = false;
              } else {
                customMap[colKey] = { visible: false };
              }
            });
            colShows.forEach((colKey) => {
              if (customMap[colKey]) {
                customMap[colKey].visible = true;
              } else {
                customMap[colKey] = { visible: true };
              }
            });
          }
        }
        let { collectColumn } = internalData;
        const keyMap = {};
        import_xe_utils41.default.eachTree(collectColumn, (column) => {
          const colKey = column.getKey();
          if (colKey) {
            keyMap[colKey] = column;
          }
        });
        import_xe_utils41.default.each(customMap, ({ visible, resizeWidth, fixed, renderSortNumber }, colKey) => {
          const column = keyMap[colKey];
          if (column) {
            if (import_xe_utils41.default.isNumber(resizeWidth)) {
              column.resizeWidth = resizeWidth;
            }
            if (import_xe_utils41.default.isBoolean(visible)) {
              column.visible = visible;
            }
            if (fixed) {
              column.fixed = fixed;
            }
            if (renderSortNumber) {
              column.renderSortNumber = Number(renderSortNumber);
            }
          }
        });
        if (hasCustomSort) {
          collectColumn = import_xe_utils41.default.orderBy(collectColumn, "renderSortNumber");
          internalData.collectColumn = collectColumn;
          internalData.tableFullColumn = getColumnList(collectColumn);
        }
      }
    };
    const cacheColumnMap = () => {
      const { tableFullColumn, collectColumn } = internalData;
      const fullColumnIdData = internalData.fullColumnIdData = {};
      const fullColumnFieldData = internalData.fullColumnFieldData = {};
      const mouseOpts = computeMouseOpts.value;
      const columnOpts = computeColumnOpts.value;
      const rowOpts = computeRowOpts.value;
      const isGroup = collectColumn.some(hasChildrenList);
      let isAllOverflow = !!props.showOverflow;
      let expandColumn;
      let treeNodeColumn;
      let checkboxColumn;
      let radioColumn;
      let htmlColumn;
      let hasFixed;
      const handleFunc = (column, index, items, path, parent) => {
        const { id: colid, field, fixed, type, treeNode } = column;
        const rest = { column, colid, index, items, parent };
        if (field) {
          if (true) {
            if (fullColumnFieldData[field]) {
              warnLog("vxe.error.colRepet", ["field", field]);
            }
          }
          fullColumnFieldData[field] = rest;
        }
        if (!hasFixed && fixed) {
          hasFixed = fixed;
        }
        if (!htmlColumn && type === "html") {
          htmlColumn = column;
        }
        if (treeNode) {
          if (true) {
            if (treeNodeColumn) {
              warnLog("vxe.error.colRepet", ["tree-node", treeNode]);
            }
          }
          if (!treeNodeColumn) {
            treeNodeColumn = column;
          }
        } else if (type === "expand") {
          if (true) {
            if (expandColumn) {
              warnLog("vxe.error.colRepet", ["type", type]);
            }
          }
          if (!expandColumn) {
            expandColumn = column;
          }
        }
        if (true) {
          if (type === "checkbox") {
            if (checkboxColumn) {
              warnLog("vxe.error.colRepet", ["type", type]);
            }
            if (!checkboxColumn) {
              checkboxColumn = column;
            }
          } else if (type === "radio") {
            if (radioColumn) {
              warnLog("vxe.error.colRepet", ["type", type]);
            }
            if (!radioColumn) {
              radioColumn = column;
            }
          }
        }
        if (isAllOverflow && column.showOverflow === false) {
          isAllOverflow = false;
        }
        if (fullColumnIdData[colid]) {
          errLog("vxe.error.colRepet", ["colId", colid]);
        }
        fullColumnIdData[colid] = rest;
      };
      if (isGroup) {
        import_xe_utils41.default.eachTree(collectColumn, (column, index, items, path, parent, nodes) => {
          column.level = nodes.length;
          handleFunc(column, index, items, path, parent);
        });
      } else {
        tableFullColumn.forEach(handleFunc);
      }
      if (true) {
        if (expandColumn && mouseOpts.area) {
          errLog("vxe.error.errConflicts", ["mouse-config.area", "column.type=expand"]);
        }
      }
      if (true) {
        if (htmlColumn) {
          if (!columnOpts.useKey) {
            errLog("vxe.error.reqProp", ["column-config.useKey", "column.type=html"]);
          }
          if (!rowOpts.useKey) {
            errLog("vxe.error.reqProp", ["row-config.useKey", "column.type=html"]);
          }
        }
      }
      reactData.isGroup = isGroup;
      reactData.treeNodeColumn = treeNodeColumn;
      reactData.expandColumn = expandColumn;
      reactData.isAllOverflow = isAllOverflow;
    };
    const updateHeight = () => {
      internalData.customHeight = calcHeight("height");
      internalData.customMinHeight = calcHeight("minHeight");
      internalData.customMaxHeight = calcHeight("maxHeight");
    };
    const autoCellWidth = () => {
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableFooter = refTableFooter.value;
      const bodyElem = tableBody ? tableBody.$el : null;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = tableFooter ? tableFooter.$el : null;
      if (!bodyElem) {
        return;
      }
      let tableWidth = 0;
      const minCellWidth = 40;
      const bodyWidth = bodyElem.clientWidth - 1;
      let remainWidth = bodyWidth;
      let meanWidth = remainWidth / 100;
      const { fit } = props;
      const { columnStore } = reactData;
      const { resizeList, pxMinList, pxList, scaleList, scaleMinList, autoList } = columnStore;
      pxMinList.forEach((column) => {
        const minWidth = import_xe_utils41.default.toInteger(column.minWidth);
        tableWidth += minWidth;
        column.renderWidth = minWidth;
      });
      scaleMinList.forEach((column) => {
        const scaleWidth = Math.floor(import_xe_utils41.default.toInteger(column.minWidth) * meanWidth);
        tableWidth += scaleWidth;
        column.renderWidth = scaleWidth;
      });
      scaleList.forEach((column) => {
        const scaleWidth = Math.floor(import_xe_utils41.default.toInteger(column.width) * meanWidth);
        tableWidth += scaleWidth;
        column.renderWidth = scaleWidth;
      });
      pxList.forEach((column) => {
        const width = import_xe_utils41.default.toInteger(column.width);
        tableWidth += width;
        column.renderWidth = width;
      });
      resizeList.forEach((column) => {
        const width = import_xe_utils41.default.toInteger(column.resizeWidth);
        tableWidth += width;
        column.renderWidth = width;
      });
      remainWidth -= tableWidth;
      meanWidth = remainWidth > 0 ? Math.floor(remainWidth / (scaleMinList.length + pxMinList.length + autoList.length)) : 0;
      if (fit) {
        if (remainWidth > 0) {
          scaleMinList.concat(pxMinList).forEach((column) => {
            tableWidth += meanWidth;
            column.renderWidth += meanWidth;
          });
        }
      } else {
        meanWidth = minCellWidth;
      }
      autoList.forEach((column) => {
        const width = Math.max(meanWidth, minCellWidth);
        column.renderWidth = width;
        tableWidth += width;
      });
      if (fit) {
        const dynamicList = scaleList.concat(scaleMinList).concat(pxMinList).concat(autoList);
        let dynamicSize = dynamicList.length - 1;
        if (dynamicSize > 0) {
          let odiffer = bodyWidth - tableWidth;
          if (odiffer > 0) {
            while (odiffer > 0 && dynamicSize >= 0) {
              odiffer--;
              dynamicList[dynamicSize--].renderWidth++;
            }
            tableWidth = bodyWidth;
          }
        }
      }
      const tableHeight = bodyElem.offsetHeight;
      const overflowY = bodyElem.scrollHeight > bodyElem.clientHeight;
      let scrollbarWidth = 0;
      if (overflowY) {
        scrollbarWidth = Math.max(bodyElem.offsetWidth - bodyElem.clientWidth, 0);
      }
      reactData.scrollbarWidth = scrollbarWidth;
      reactData.overflowY = overflowY;
      internalData.tableWidth = tableWidth;
      internalData.tableHeight = tableHeight;
      let headerHeight = 0;
      if (headerElem) {
        headerHeight = headerElem.clientHeight;
        nextTick(() => {
          if (headerElem && bodyElem && headerElem.scrollLeft !== bodyElem.scrollLeft) {
            headerElem.scrollLeft = bodyElem.scrollLeft;
          }
        });
      }
      internalData.headerHeight = headerHeight;
      let overflowX = false;
      let footerHeight = 0;
      let scrollbarHeight = 0;
      if (footerElem) {
        footerHeight = footerElem.offsetHeight;
        overflowX = tableWidth > footerElem.clientWidth;
        if (overflowX) {
          scrollbarHeight = Math.max(footerHeight - footerElem.clientHeight, 0);
        }
      } else {
        overflowX = tableWidth > bodyWidth;
        if (overflowX) {
          scrollbarHeight = Math.max(tableHeight - bodyElem.clientHeight, 0);
        }
      }
      internalData.footerHeight = footerHeight;
      reactData.overflowX = overflowX;
      reactData.scrollbarHeight = scrollbarHeight;
      updateHeight();
      reactData.parentHeight = Math.max(internalData.headerHeight + footerHeight + 20, tablePrivateMethods.getParentHeight());
      if (overflowX) {
        tablePrivateMethods.checkScrolling();
      }
    };
    const getOrderField = (column) => {
      const { sortBy, sortType } = column;
      return (row) => {
        let cellValue;
        if (sortBy) {
          cellValue = import_xe_utils41.default.isFunction(sortBy) ? sortBy({ row, column }) : import_xe_utils41.default.get(row, sortBy);
        } else {
          cellValue = tablePrivateMethods.getCellLabel(row, column);
        }
        if (!sortType || sortType === "auto") {
          return isNaN(cellValue) ? cellValue : import_xe_utils41.default.toNumber(cellValue);
        } else if (sortType === "number") {
          return import_xe_utils41.default.toNumber(cellValue);
        } else if (sortType === "string") {
          return import_xe_utils41.default.toValueString(cellValue);
        }
        return cellValue;
      };
    };
    const updateAfterDataIndex = () => {
      const { treeConfig } = props;
      const { afterFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const { afterTreeFullData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const fullMaps = {};
      if (treeConfig) {
        import_xe_utils41.default.eachTree(afterTreeFullData, (row, index, items, path) => {
          const rowid = getRowid($xetable, row);
          const allrest = fullAllDataRowIdData[rowid];
          const seq = path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("");
          if (allrest) {
            allrest.seq = seq;
            allrest._index = index;
          } else {
            const rest = { row, rowid, seq, index: -1, $index: -1, _index: index, items: [], parent: null, level: 0 };
            fullAllDataRowIdData[rowid] = rest;
            fullDataRowIdData[rowid] = rest;
          }
          fullMaps[rowid] = row;
        }, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });
      } else {
        afterFullData.forEach((row, index) => {
          const rowid = getRowid($xetable, row);
          const allrest = fullAllDataRowIdData[rowid];
          const seq = index + 1;
          if (allrest) {
            allrest.seq = seq;
            allrest._index = index;
          } else {
            const rest = { row, rowid, seq, index: -1, $index: -1, _index: index, items: [], parent: null, level: 0 };
            fullAllDataRowIdData[rowid] = rest;
            fullDataRowIdData[rowid] = rest;
          }
          fullMaps[rowid] = row;
        });
      }
      internalData.afterFullRowMaps = fullMaps;
    };
    const handleVirtualTreeToList = () => {
      const { treeConfig } = props;
      const { treeExpandedMaps } = reactData;
      const treeOpts = computeTreeOpts.value;
      if (treeConfig && treeOpts.transform) {
        const fullData = [];
        const expandMaps = {};
        import_xe_utils41.default.eachTree(internalData.afterTreeFullData, (row, index, items, path, parent) => {
          const rowid = getRowid($xetable, row);
          const parentRowid = getRowid($xetable, parent);
          if (!parent || expandMaps[parentRowid] && treeExpandedMaps[parentRowid]) {
            expandMaps[rowid] = 1;
            fullData.push(row);
          }
        }, { children: treeOpts.mapChildrenField });
        internalData.afterFullData = fullData;
        updateScrollYStatus(fullData);
        return fullData;
      }
      return internalData.afterFullData;
    };
    const updateAfterFullData = () => {
      const { treeConfig } = props;
      const { tableFullColumn, tableFullData, tableFullTreeData } = internalData;
      const filterOpts = computeFilterOpts.value;
      const sortOpts = computeSortOpts.value;
      const treeOpts = computeTreeOpts.value;
      const { transform } = treeOpts;
      const { remote: allRemoteFilter, filterMethod: allFilterMethod } = filterOpts;
      const { remote: allRemoteSort, sortMethod: allSortMethod, multiple: sortMultiple, chronological } = sortOpts;
      let tableData = [];
      let tableTree = [];
      if (!allRemoteFilter || !allRemoteSort) {
        const filterColumns = [];
        let orderColumns = [];
        tableFullColumn.forEach((column) => {
          const { field, sortable, order, filters } = column;
          if (!allRemoteFilter && filters && filters.length) {
            const valueList = [];
            const itemList = [];
            filters.forEach((item) => {
              if (item.checked) {
                itemList.push(item);
                valueList.push(item.value);
              }
            });
            if (itemList.length) {
              filterColumns.push({ column, valueList, itemList });
            }
          }
          if (!allRemoteSort && sortable && order) {
            orderColumns.push({ column, field, property: field, order, sortTime: column.sortTime });
          }
        });
        if (sortMultiple && chronological && orderColumns.length > 1) {
          orderColumns = import_xe_utils41.default.orderBy(orderColumns, "sortTime");
        }
        if (!allRemoteFilter && filterColumns.length) {
          const handleFilter = (row) => {
            return filterColumns.every(({ column, valueList, itemList }) => {
              const { filterMethod, filterRender } = column;
              const compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
              const compFilterMethod = compConf ? compConf.filterMethod : null;
              const defaultFilterMethod = compConf ? compConf.defaultFilterMethod : null;
              const cellValue = getCellValue(row, column);
              if (filterMethod) {
                return itemList.some((item) => filterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xetable }));
              } else if (compFilterMethod) {
                return itemList.some((item) => compFilterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xetable }));
              } else if (allFilterMethod) {
                return allFilterMethod({ options: itemList, values: valueList, cellValue, row, column });
              } else if (defaultFilterMethod) {
                return itemList.some((item) => defaultFilterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xetable }));
              }
              return valueList.indexOf(import_xe_utils41.default.get(row, column.field)) > -1;
            });
          };
          if (treeConfig && transform) {
            tableTree = import_xe_utils41.default.searchTree(tableFullTreeData, handleFilter, Object.assign(Object.assign({}, treeOpts), { original: true }));
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.filter(handleFilter) : tableFullData.filter(handleFilter);
            tableTree = tableData;
          }
        } else {
          if (treeConfig && transform) {
            tableTree = import_xe_utils41.default.searchTree(tableFullTreeData, () => true, Object.assign(Object.assign({}, treeOpts), { original: true }));
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
            tableTree = tableData;
          }
        }
        if (!allRemoteSort && orderColumns.length) {
          if (treeConfig && transform) {
            if (allSortMethod) {
              const sortRests = allSortMethod({ data: tableTree, sortList: orderColumns, $table: $xetable });
              tableTree = import_xe_utils41.default.isArray(sortRests) ? sortRests : tableTree;
            } else {
              tableTree = import_xe_utils41.default.orderBy(tableTree, orderColumns.map(({ column, order }) => [getOrderField(column), order]));
            }
            tableData = tableTree;
          } else {
            if (allSortMethod) {
              const sortRests = allSortMethod({ data: tableData, sortList: orderColumns, $table: $xetable });
              tableData = import_xe_utils41.default.isArray(sortRests) ? sortRests : tableData;
            } else {
              tableData = import_xe_utils41.default.orderBy(tableData, orderColumns.map(({ column, order }) => [getOrderField(column), order]));
            }
            tableTree = tableData;
          }
        }
      } else {
        if (treeConfig && transform) {
          tableTree = import_xe_utils41.default.searchTree(tableFullTreeData, () => true, Object.assign(Object.assign({}, treeOpts), { original: true }));
          tableData = tableTree;
        } else {
          tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
          tableTree = tableData;
        }
      }
      internalData.afterFullData = tableData;
      internalData.afterTreeFullData = tableTree;
      updateAfterDataIndex();
    };
    const updateStyle = () => {
      const { border, showFooter, showOverflow: allColumnOverflow, showHeaderOverflow: allColumnHeaderOverflow, showFooterOverflow: allColumnFooterOverflow, mouseConfig, spanMethod, footerSpanMethod, keyboardConfig } = props;
      const { isGroup, currentRow, tableColumn, scrollXLoad, scrollYLoad, scrollbarWidth, scrollbarHeight, columnStore, editStore, mergeList, mergeFooterList, isAllOverflow } = reactData;
      let { visibleColumn, fullColumnIdData, tableHeight, tableWidth, headerHeight, footerHeight, elemStore, customHeight, customMinHeight, customMaxHeight } = internalData;
      const containerList = ["main", "left", "right"];
      const emptyPlaceholderElem = refEmptyPlaceholder.value;
      const cellOffsetWidth = computeCellOffsetWidth.value;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const bodyWrapperRef = elemStore["main-body-wrapper"];
      const bodyWrapperElem = bodyWrapperRef ? bodyWrapperRef.value : null;
      if (emptyPlaceholderElem) {
        emptyPlaceholderElem.style.top = `${headerHeight}px`;
        emptyPlaceholderElem.style.height = bodyWrapperElem ? `${bodyWrapperElem.offsetHeight - scrollbarHeight}px` : "";
      }
      if (customHeight > 0) {
        if (showFooter) {
          customHeight += scrollbarHeight;
        }
      }
      containerList.forEach((name, index) => {
        const fixedType = index > 0 ? name : "";
        const layoutList = ["header", "body", "footer"];
        const isFixedLeft = fixedType === "left";
        let fixedColumn = [];
        let fixedWrapperElem;
        if (fixedType) {
          fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
          fixedWrapperElem = isFixedLeft ? refLeftContainer.value : refRightContainer.value;
        }
        layoutList.forEach((layout) => {
          const wrapperRef = elemStore[`${name}-${layout}-wrapper`];
          const wrapperElem = wrapperRef ? wrapperRef.value : null;
          const tableRef = elemStore[`${name}-${layout}-table`];
          const tableElem = tableRef ? tableRef.value : null;
          if (layout === "header") {
            let tWidth = tableWidth;
            let renderColumnList = tableColumn;
            if (isGroup) {
              renderColumnList = visibleColumn;
            } else {
              if (fixedType) {
                if (scrollXLoad || allColumnHeaderOverflow) {
                  renderColumnList = fixedColumn;
                }
              }
            }
            tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth + scrollbarWidth}px` : "";
            }
            const repairRef = elemStore[`${name}-${layout}-repair`];
            const repairElem = repairRef ? repairRef.value : null;
            if (repairElem) {
              repairElem.style.width = `${tableWidth}px`;
            }
            const listRef = elemStore[`${name}-${layout}-list`];
            const listElem = listRef ? listRef.value : null;
            if (isGroup && listElem) {
              import_xe_utils41.default.arrayEach(listElem.querySelectorAll(".col--group"), (thElem) => {
                const colNode = tableMethods.getColumnNode(thElem);
                if (colNode) {
                  const column = colNode.item;
                  const { showHeaderOverflow } = column;
                  const cellOverflow = import_xe_utils41.default.isBoolean(showHeaderOverflow) ? showHeaderOverflow : allColumnHeaderOverflow;
                  const showEllipsis = cellOverflow === "ellipsis";
                  const showTitle = cellOverflow === "title";
                  const showTooltip = cellOverflow === true || cellOverflow === "tooltip";
                  const hasEllipsis = showTitle || showTooltip || showEllipsis;
                  let childWidth = 0;
                  let countChild = 0;
                  if (hasEllipsis) {
                    import_xe_utils41.default.eachTree(column.children, (item) => {
                      if (!item.children || !column.children.length) {
                        countChild++;
                      }
                      childWidth += item.renderWidth;
                    }, { children: "children" });
                  }
                  thElem.style.width = hasEllipsis ? `${childWidth - countChild - (border ? 2 : 0)}px` : "";
                }
              });
            }
          } else if (layout === "body") {
            const emptyBlockRef = elemStore[`${name}-${layout}-emptyBlock`];
            const emptyBlockElem = emptyBlockRef ? emptyBlockRef.value : null;
            if (isNodeElement(wrapperElem)) {
              let bodyMaxHeight = 0;
              const bodyMinHeight = customMinHeight - headerHeight - footerHeight;
              if (customMaxHeight) {
                bodyMaxHeight = customMaxHeight - headerHeight - footerHeight;
                if (fixedType) {
                  bodyMaxHeight -= showFooter ? 0 : scrollbarHeight;
                }
                bodyMaxHeight = Math.max(bodyMinHeight, bodyMaxHeight);
                wrapperElem.style.maxHeight = `${bodyMaxHeight}px`;
              }
              if (customHeight) {
                let bodyHeight = customHeight - headerHeight - footerHeight;
                if (fixedType) {
                  bodyHeight -= showFooter ? 0 : scrollbarHeight;
                }
                if (bodyMaxHeight) {
                  bodyHeight = Math.min(bodyMaxHeight, bodyHeight);
                }
                wrapperElem.style.height = `${Math.max(bodyMinHeight, bodyHeight)}px`;
              } else {
                wrapperElem.style.height = "";
              }
              wrapperElem.style.minHeight = `${bodyMinHeight}px`;
            }
            if (fixedWrapperElem) {
              if (isNodeElement(wrapperElem)) {
                wrapperElem.style.top = `${headerHeight}px`;
              }
              fixedWrapperElem.style.height = `${(customHeight > 0 ? customHeight - headerHeight - footerHeight : tableHeight) + headerHeight + footerHeight - scrollbarHeight * (showFooter ? 2 : 1)}px`;
              fixedWrapperElem.style.width = `${fixedColumn.reduce((previous, column) => previous + column.renderWidth, isFixedLeft ? 0 : scrollbarWidth)}px`;
            }
            let tWidth = tableWidth;
            let renderColumnList = tableColumn;
            if (fixedType) {
              if (!reactData.expandColumn && (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow))) {
                if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {
                  renderColumnList = fixedColumn;
                } else {
                  renderColumnList = visibleColumn;
                }
              } else {
                renderColumnList = visibleColumn;
              }
            }
            tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth}px` : "";
              tableElem.style.paddingRight = scrollbarWidth && fixedType && (browse["-moz"] || browse.safari) ? `${scrollbarWidth}px` : "";
            }
            if (emptyBlockElem) {
              emptyBlockElem.style.width = tWidth ? `${tWidth}px` : "";
            }
          } else if (layout === "footer") {
            let tWidth = tableWidth;
            let renderColumnList = tableColumn;
            if (fixedType) {
              if (!reactData.expandColumn && (scrollXLoad || allColumnFooterOverflow)) {
                if (!mergeFooterList.length || !footerSpanMethod) {
                  renderColumnList = fixedColumn;
                } else {
                  renderColumnList = visibleColumn;
                }
              } else {
                renderColumnList = visibleColumn;
              }
            }
            tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (isNodeElement(wrapperElem)) {
              if (fixedWrapperElem) {
                wrapperElem.style.top = `${customHeight > 0 ? customHeight - footerHeight : tableHeight + headerHeight}px`;
              }
              wrapperElem.style.marginTop = `${-Math.max(1, scrollbarHeight)}px`;
            }
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth + scrollbarWidth}px` : "";
            }
          }
          const colgroupRef = elemStore[`${name}-${layout}-colgroup`];
          const colgroupElem = colgroupRef ? colgroupRef.value : null;
          if (colgroupElem) {
            import_xe_utils41.default.arrayEach(colgroupElem.children, (colElem) => {
              const colid = colElem.getAttribute("name");
              if (colid === "col_gutter") {
                colElem.style.width = `${scrollbarWidth}px`;
              }
              if (fullColumnIdData[colid]) {
                const column = fullColumnIdData[colid].column;
                const { showHeaderOverflow, showFooterOverflow, showOverflow } = column;
                let cellOverflow;
                colElem.style.width = `${column.renderWidth}px`;
                if (layout === "header") {
                  cellOverflow = import_xe_utils41.default.isUndefined(showHeaderOverflow) || import_xe_utils41.default.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
                } else if (layout === "footer") {
                  cellOverflow = import_xe_utils41.default.isUndefined(showFooterOverflow) || import_xe_utils41.default.isNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
                } else {
                  cellOverflow = import_xe_utils41.default.isUndefined(showOverflow) || import_xe_utils41.default.isNull(showOverflow) ? allColumnOverflow : showOverflow;
                }
                const showEllipsis = cellOverflow === "ellipsis";
                const showTitle = cellOverflow === "title";
                const showTooltip = cellOverflow === true || cellOverflow === "tooltip";
                let hasEllipsis = showTitle || showTooltip || showEllipsis;
                const listRef = elemStore[`${name}-${layout}-list`];
                const listElem = listRef ? listRef.value : null;
                if (scrollYLoad && !hasEllipsis) {
                  hasEllipsis = true;
                }
                if (listElem) {
                  import_xe_utils41.default.arrayEach(listElem.querySelectorAll(`.${column.id}`), (elem) => {
                    const colspan = parseInt(elem.getAttribute("colspan") || 1);
                    const cellElem = elem.querySelector(".vxe-cell");
                    let colWidth = column.renderWidth;
                    if (cellElem) {
                      if (colspan > 1) {
                        const columnIndex = tableMethods.getColumnIndex(column);
                        for (let index2 = 1; index2 < colspan; index2++) {
                          const nextColumn = tableMethods.getColumns(columnIndex + index2);
                          if (nextColumn) {
                            colWidth += nextColumn.renderWidth;
                          }
                        }
                      }
                      cellElem.style.width = hasEllipsis ? `${colWidth - cellOffsetWidth * colspan}px` : "";
                    }
                  });
                }
              }
            });
          }
        });
      });
      if (currentRow) {
        tableMethods.setCurrentRow(currentRow);
      }
      if (mouseConfig && mouseOpts.selected && editStore.selected.row && editStore.selected.column) {
        $xetable.addCellSelectedClass();
      }
      return nextTick();
    };
    const checkValidate = (type) => {
      if ($xetable.triggerValidate) {
        return $xetable.triggerValidate(type);
      }
      return nextTick();
    };
    const handleChangeCell = (evnt, params) => {
      checkValidate("blur").catch((e) => e).then(() => {
        $xetable.handleActived(params, evnt).then(() => checkValidate("change")).catch((e) => e);
      });
    };
    const handleDefaultSort = () => {
      const { sortConfig } = props;
      if (sortConfig) {
        const sortOpts = computeSortOpts.value;
        let { defaultSort } = sortOpts;
        if (defaultSort) {
          if (!import_xe_utils41.default.isArray(defaultSort)) {
            defaultSort = [defaultSort];
          }
          if (defaultSort.length) {
            (sortConfig.multiple ? defaultSort : defaultSort.slice(0, 1)).forEach((item, index) => {
              const { field, order } = item;
              if (field && order) {
                const column = tableMethods.getColumnByField(field);
                if (column && column.sortable) {
                  column.order = order;
                  column.sortTime = Date.now() + index;
                }
              }
            });
            if (!sortOpts.remote) {
              tablePrivateMethods.handleTableData(true).then(updateStyle);
            }
          }
        }
      }
    };
    const handleDefaultSelectionChecked = () => {
      const { checkboxConfig } = props;
      if (checkboxConfig) {
        const { fullDataRowIdData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkAll, checkRowKeys } = checkboxOpts;
        if (checkAll) {
          handleCheckedAllCheckboxRow(true, true);
        } else if (checkRowKeys) {
          const defSelection = [];
          checkRowKeys.forEach((rowid) => {
            if (fullDataRowIdData[rowid]) {
              defSelection.push(fullDataRowIdData[rowid].row);
            }
          });
          handleCheckedCheckboxRow(defSelection, true, true);
        }
      }
    };
    const handleDefaultRadioChecked = () => {
      const { radioConfig } = props;
      if (radioConfig) {
        const { fullDataRowIdData } = internalData;
        const radioOpts = computeRadioOpts.value;
        const { checkRowKey: rowid, reserve } = radioOpts;
        if (rowid) {
          if (fullDataRowIdData[rowid]) {
            handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
          }
          if (reserve) {
            const rowkey = getRowkey($xetable);
            internalData.radioReserveRow = { [rowkey]: rowid };
          }
        }
      }
    };
    const handleDefaultRowExpand = () => {
      const { expandConfig } = props;
      if (expandConfig) {
        const { fullDataRowIdData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { expandAll, expandRowKeys } = expandOpts;
        if (expandAll) {
          tableMethods.setAllRowExpand(true);
        } else if (expandRowKeys) {
          const defExpandeds = [];
          expandRowKeys.forEach((rowid) => {
            if (fullDataRowIdData[rowid]) {
              defExpandeds.push(fullDataRowIdData[rowid].row);
            }
          });
          tableMethods.setRowExpand(defExpandeds, true);
        }
      }
    };
    const handleRadioReserveRow = (row) => {
      const radioOpts = computeRadioOpts.value;
      if (radioOpts.reserve) {
        internalData.radioReserveRow = row;
      }
    };
    const handleCheckboxReserveRow = (row, checked) => {
      const { checkboxReserveRowMap } = internalData;
      const checkboxOpts = computeCheckboxOpts.value;
      if (checkboxOpts.reserve) {
        const rowid = getRowid($xetable, row);
        if (checked) {
          checkboxReserveRowMap[rowid] = row;
        } else if (checkboxReserveRowMap[rowid]) {
          delete checkboxReserveRowMap[rowid];
        }
      }
    };
    const handleCheckedRadioRow = (row, isForce) => {
      const radioOpts = computeRadioOpts.value;
      const { checkMethod } = radioOpts;
      if (row && (isForce || (!checkMethod || checkMethod({ row })))) {
        reactData.selectRadioRow = row;
        handleRadioReserveRow(row);
      }
      return nextTick();
    };
    const handleCheckedCheckboxRow = (rows, value, isForce) => {
      if (rows && !import_xe_utils41.default.isArray(rows)) {
        rows = [rows];
      }
      rows.forEach((row) => tablePrivateMethods.handleSelectRow({ row }, !!value, isForce));
      return nextTick();
    };
    const handleCheckedAllCheckboxRow = (value, isForce) => {
      const { treeConfig } = props;
      const { selectCheckboxMaps } = reactData;
      const { afterFullData, afterFullRowMaps, checkboxReserveRowMap } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkField, reserve, checkStrictly, checkMethod } = checkboxOpts;
      const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
      const selectRowMaps = {};
      if (!treeConfig) {
        import_xe_utils41.default.each(selectCheckboxMaps, (row, rowid) => {
          if (!afterFullRowMaps[rowid]) {
            selectRowMaps[rowid] = row;
          }
        });
      }
      if (checkStrictly) {
        reactData.isAllSelected = value;
      } else {
        if (checkField) {
          const checkValFn = (row) => {
            if (isForce || (!checkMethod || checkMethod({ row }))) {
              if (value) {
                selectRowMaps[getRowid($xetable, row)] = row;
              }
              import_xe_utils41.default.set(row, checkField, value);
            }
            if (treeConfig && indeterminateField) {
              import_xe_utils41.default.set(row, indeterminateField, false);
            }
          };
          if (treeConfig) {
            import_xe_utils41.default.eachTree(afterFullData, checkValFn, { children: childrenField });
          } else {
            afterFullData.forEach(checkValFn);
          }
        } else {
          if (treeConfig) {
            if (value) {
              import_xe_utils41.default.eachTree(afterFullData, (row) => {
                if (isForce || (!checkMethod || checkMethod({ row }))) {
                  selectRowMaps[getRowid($xetable, row)] = row;
                }
              }, { children: childrenField });
            } else {
              if (!isForce && checkMethod) {
                import_xe_utils41.default.eachTree(afterFullData, (row) => {
                  const rowid = getRowid($xetable, row);
                  if (checkMethod({ row }) ? 0 : selectCheckboxMaps[rowid]) {
                    selectRowMaps[rowid] = row;
                  }
                }, { children: childrenField });
              }
            }
          } else {
            if (value) {
              if (!isForce && checkMethod) {
                afterFullData.forEach((row) => {
                  const rowid = getRowid($xetable, row);
                  if (selectCheckboxMaps[rowid] || checkMethod({ row })) {
                    selectRowMaps[rowid] = row;
                  }
                });
              } else {
                afterFullData.forEach((row) => {
                  selectRowMaps[getRowid($xetable, row)] = row;
                });
              }
            } else {
              if (!isForce && checkMethod) {
                afterFullData.forEach((row) => {
                  const rowid = getRowid($xetable, row);
                  if (checkMethod({ row }) ? 0 : selectCheckboxMaps[rowid]) {
                    selectRowMaps[rowid] = row;
                  }
                });
              }
            }
          }
        }
        if (reserve) {
          if (value) {
            import_xe_utils41.default.each(selectRowMaps, (row, rowid) => {
              checkboxReserveRowMap[rowid] = row;
            });
          } else {
            afterFullData.forEach((row) => handleCheckboxReserveRow(row, false));
          }
        }
        reactData.selectCheckboxMaps = checkField ? {} : selectRowMaps;
      }
      reactData.treeIndeterminateMaps = {};
      internalData.treeIndeterminateRowMaps = {};
      tablePrivateMethods.checkSelectionStatus();
      return nextTick();
    };
    const handleReserveStatus = () => {
      const { treeConfig } = props;
      const { expandColumn, currentRow, selectCheckboxMaps, selectRadioRow, rowExpandedMaps, treeExpandedMaps } = reactData;
      const { fullDataRowIdData, fullAllDataRowIdData, radioReserveRow } = internalData;
      const expandOpts = computeExpandOpts.value;
      const treeOpts = computeTreeOpts.value;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      if (selectRadioRow && !fullAllDataRowIdData[getRowid($xetable, selectRadioRow)]) {
        reactData.selectRadioRow = null;
      }
      if (radioOpts.reserve && radioReserveRow) {
        const rowid = getRowid($xetable, radioReserveRow);
        if (fullDataRowIdData[rowid]) {
          handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
        }
      }
      reactData.selectCheckboxMaps = getRecoverRowMaps(selectCheckboxMaps);
      if (checkboxOpts.reserve) {
        handleCheckedCheckboxRow(handleReserveRow(internalData.checkboxReserveRowMap), true, true);
      }
      if (currentRow && !fullAllDataRowIdData[getRowid($xetable, currentRow)]) {
        reactData.currentRow = null;
      }
      reactData.rowExpandedMaps = expandColumn ? getRecoverRowMaps(rowExpandedMaps) : {};
      if (expandColumn && expandOpts.reserve) {
        tableMethods.setRowExpand(handleReserveRow(internalData.rowExpandedReserveRowMap), true);
      }
      reactData.treeExpandedMaps = treeConfig ? getRecoverRowMaps(treeExpandedMaps) : {};
      if (treeConfig && treeOpts.reserve) {
        tableMethods.setTreeExpand(handleReserveRow(internalData.treeExpandedReserveRowMap), true);
      }
    };
    const handleDefaultTreeExpand = () => {
      const { treeConfig } = props;
      if (treeConfig) {
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { expandAll, expandRowKeys } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (expandAll) {
          tableMethods.setAllTreeExpand(true);
        } else if (expandRowKeys) {
          const defExpandeds = [];
          const rowkey = getRowkey($xetable);
          expandRowKeys.forEach((rowid) => {
            const matchObj = import_xe_utils41.default.findTree(tableFullData, (item) => rowid === import_xe_utils41.default.get(item, rowkey), { children: childrenField });
            if (matchObj) {
              defExpandeds.push(matchObj.item);
            }
          });
          tableMethods.setTreeExpand(defExpandeds, true);
        }
      }
    };
    const handleAsyncTreeExpandChilds = (row) => {
      const treeOpts = computeTreeOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const { transform, loadMethod } = treeOpts;
      const { checkStrictly } = checkboxOpts;
      return new Promise((resolve) => {
        if (loadMethod) {
          const { treeExpandLazyLoadedMaps } = reactData;
          const { fullAllDataRowIdData } = internalData;
          const rowid = getRowid($xetable, row);
          const rest = fullAllDataRowIdData[rowid];
          treeExpandLazyLoadedMaps[rowid] = row;
          loadMethod({ $table: $xetable, row }).then((childRecords) => {
            rest.treeLoaded = true;
            if (treeExpandLazyLoadedMaps[rowid]) {
              delete treeExpandLazyLoadedMaps[rowid];
            }
            if (!import_xe_utils41.default.isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return tableMethods.loadTreeChildren(row, childRecords).then((childRows) => {
                const { treeExpandedMaps } = reactData;
                if (childRows.length && !treeExpandedMaps[rowid]) {
                  treeExpandedMaps[rowid] = row;
                }
                if (!checkStrictly && tableMethods.isCheckedByCheckboxRow(row)) {
                  handleCheckedCheckboxRow(childRows, true);
                }
                return nextTick().then(() => {
                  if (transform) {
                    return tablePrivateMethods.handleTableData();
                  }
                });
              });
            }
          }).catch(() => {
            const { treeExpandLazyLoadedMaps: treeExpandLazyLoadedMaps2 } = reactData;
            rest.treeLoaded = false;
            if (treeExpandLazyLoadedMaps2[rowid]) {
              delete treeExpandLazyLoadedMaps2[rowid];
            }
          }).finally(() => {
            nextTick().then(() => tableMethods.recalculate()).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };
    const handleTreeExpandReserve = (row, expanded) => {
      const { treeExpandedReserveRowMap } = internalData;
      const treeOpts = computeTreeOpts.value;
      if (treeOpts.reserve) {
        const rowid = getRowid($xetable, row);
        if (expanded) {
          treeExpandedReserveRowMap[rowid] = row;
        } else if (treeExpandedReserveRowMap[rowid]) {
          delete treeExpandedReserveRowMap[rowid];
        }
      }
    };
    const handleAsyncRowExpand = (row) => {
      return new Promise((resolve) => {
        const expandOpts = computeExpandOpts.value;
        const { loadMethod } = expandOpts;
        if (loadMethod) {
          const { fullAllDataRowIdData } = internalData;
          const { rowExpandLazyLoadedMaps } = reactData;
          const rowid = getRowid($xetable, row);
          const rest = fullAllDataRowIdData[rowid];
          rowExpandLazyLoadedMaps[rowid] = row;
          loadMethod({ $table: $xetable, row, rowIndex: tableMethods.getRowIndex(row), $rowIndex: tableMethods.getVMRowIndex(row) }).then(() => {
            const { rowExpandedMaps } = reactData;
            rest.expandLoaded = true;
            rowExpandedMaps[rowid] = row;
          }).catch(() => {
            rest.expandLoaded = false;
          }).finally(() => {
            const { rowExpandLazyLoadedMaps: rowExpandLazyLoadedMaps2 } = reactData;
            if (rowExpandLazyLoadedMaps2[rowid]) {
              delete rowExpandLazyLoadedMaps2[rowid];
            }
            nextTick().then(() => tableMethods.recalculate()).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };
    const handleRowExpandReserve = (row, expanded) => {
      const { rowExpandedReserveRowMap } = internalData;
      const expandOpts = computeExpandOpts.value;
      if (expandOpts.reserve) {
        const rowid = getRowid($xetable, row);
        if (expanded) {
          rowExpandedReserveRowMap[rowid] = row;
        } else if (rowExpandedReserveRowMap[rowid]) {
          delete rowExpandedReserveRowMap[rowid];
        }
      }
    };
    const handleDefaultMergeCells = () => {
      const { mergeCells } = props;
      if (mergeCells) {
        tableMethods.setMergeCells(mergeCells);
      }
    };
    const handleDefaultMergeFooterItems = () => {
      const { mergeFooterItems } = props;
      if (mergeFooterItems) {
        tableMethods.setMergeFooterItems(mergeFooterItems);
      }
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollXLoad, scrollYLoad } = reactData;
        const { scrollXStore, scrollYStore } = internalData;
        const sYOpts = computeSYOpts.value;
        const sXOpts = computeSXOpts.value;
        if (scrollXLoad) {
          const { visibleSize: visibleXSize } = computeVirtualX();
          const offsetXSize = sXOpts.oSize ? import_xe_utils41.default.toNumber(sXOpts.oSize) : browse.edge ? 5 : 0;
          scrollXStore.offsetSize = offsetXSize;
          scrollXStore.visibleSize = visibleXSize;
          scrollXStore.endIndex = Math.max(scrollXStore.startIndex + scrollXStore.visibleSize + offsetXSize, scrollXStore.endIndex);
          tablePrivateMethods.updateScrollXData();
        } else {
          tablePrivateMethods.updateScrollXSpace();
        }
        const { rowHeight, visibleSize: visibleYSize } = computeVirtualY();
        scrollYStore.rowHeight = rowHeight;
        if (scrollYLoad) {
          const offsetYSize = sYOpts.oSize ? import_xe_utils41.default.toNumber(sYOpts.oSize) : browse.edge ? 10 : 0;
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);
          tablePrivateMethods.updateScrollYData();
        } else {
          tablePrivateMethods.updateScrollYSpace();
        }
        reactData.rowHeight = rowHeight;
        nextTick(updateStyle);
      });
    };
    const loadTableData = (datas) => {
      const { keepSource, treeConfig } = props;
      const { editStore, scrollYLoad: oldScrollYLoad } = reactData;
      const { scrollYStore, scrollXStore, lastScrollLeft, lastScrollTop } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { transform } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      let treeData = [];
      let fullData = reactive(datas ? datas.slice(0) : []);
      if (treeConfig) {
        if (transform) {
          if (true) {
            if (!treeOpts.rowField) {
              errLog("vxe.error.reqProp", ["tree-config.rowField"]);
            }
            if (!treeOpts.parentField) {
              errLog("vxe.error.reqProp", ["tree-config.parentField"]);
            }
            if (!childrenField) {
              errLog("vxe.error.reqProp", ["tree-config.childrenField"]);
            }
            if (!treeOpts.mapChildrenField) {
              errLog("vxe.error.reqProp", ["tree-config.mapChildrenField"]);
            }
            if (childrenField === treeOpts.mapChildrenField) {
              errLog("vxe.error.errConflicts", ["tree-config.childrenField", "tree-config.mapChildrenField"]);
            }
          }
          treeData = import_xe_utils41.default.toArrayTree(fullData, {
            key: treeOpts.rowField,
            parentKey: treeOpts.parentField,
            children: childrenField,
            mapChildren: treeOpts.mapChildrenField
          });
          fullData = treeData.slice(0);
        } else {
          treeData = fullData.slice(0);
        }
      }
      scrollYStore.startIndex = 0;
      scrollYStore.endIndex = 1;
      scrollXStore.startIndex = 0;
      scrollXStore.endIndex = 1;
      reactData.scrollVMLoading = false;
      editStore.insertMaps = {};
      editStore.removeMaps = {};
      const sYLoad = updateScrollYStatus(fullData);
      reactData.scrollYLoad = sYLoad;
      internalData.tableFullData = fullData;
      internalData.tableFullTreeData = treeData;
      tablePrivateMethods.cacheRowMap(true);
      internalData.tableSynchData = datas;
      if (keepSource) {
        tablePrivateMethods.cacheSourceMap(fullData);
      }
      if (sYLoad) {
        if (!(props.height || props.maxHeight)) {
          errLog("vxe.error.reqProp", ["table.height | table.max-height | table.scroll-y={enabled: false}"]);
        }
        if (!props.showOverflow) {
          errLog("vxe.error.reqProp", ["table.show-overflow"]);
        }
        if (true) {
          if (props.spanMethod) {
            warnLog("vxe.error.scrollErrProp", ["table.span-method"]);
          }
        }
      }
      if ($xetable.clearCellAreas && props.mouseConfig) {
        $xetable.clearCellAreas();
        $xetable.clearCopyCellArea();
      }
      tableMethods.clearMergeCells();
      tableMethods.clearMergeFooterItems();
      tablePrivateMethods.handleTableData(true);
      tableMethods.updateFooter();
      return nextTick().then(() => {
        updateHeight();
        updateStyle();
      }).then(() => {
        computeScrollLoad();
      }).then(() => {
        if (sYLoad) {
          scrollYStore.endIndex = scrollYStore.visibleSize;
        }
        handleReserveStatus();
        tablePrivateMethods.checkSelectionStatus();
        return new Promise((resolve) => {
          nextTick().then(() => tableMethods.recalculate()).then(() => {
            let targetScrollLeft = lastScrollLeft;
            let targetScrollTop = lastScrollTop;
            const sXOpts = computeSXOpts.value;
            const sYOpts = computeSYOpts.value;
            if (sXOpts.scrollToLeftOnChange) {
              targetScrollLeft = 0;
            }
            if (sYOpts.scrollToTopOnChange) {
              targetScrollTop = 0;
            }
            if (oldScrollYLoad === sYLoad) {
              restoreScrollLocation($xetable, targetScrollLeft, targetScrollTop).then(resolve);
            } else {
              setTimeout(() => restoreScrollLocation($xetable, targetScrollLeft, targetScrollTop).then(resolve));
            }
          });
        });
      });
    };
    const handleLoadDefaults = () => {
      handleDefaultSelectionChecked();
      handleDefaultRadioChecked();
      handleDefaultRowExpand();
      handleDefaultTreeExpand();
      handleDefaultMergeCells();
      handleDefaultMergeFooterItems();
      nextTick(() => setTimeout(() => tableMethods.recalculate()));
    };
    const handleInitDefaults = () => {
      handleDefaultSort();
    };
    const handleTableColumn = () => {
      const { scrollXLoad } = reactData;
      const { visibleColumn, scrollXStore, fullColumnIdData } = internalData;
      const tableColumn = scrollXLoad ? visibleColumn.slice(scrollXStore.startIndex, scrollXStore.endIndex) : visibleColumn.slice(0);
      tableColumn.forEach((column, $index) => {
        const colid = column.id;
        const rest = fullColumnIdData[colid];
        if (rest) {
          rest.$index = $index;
        }
      });
      reactData.tableColumn = tableColumn;
    };
    const loadScrollXData = () => {
      const { mergeList, mergeFooterList } = reactData;
      const { scrollXStore } = internalData;
      const { startIndex, endIndex, offsetSize } = scrollXStore;
      const { toVisibleIndex, visibleSize } = computeVirtualX();
      const offsetItem = {
        startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),
        endIndex: toVisibleIndex + visibleSize + offsetSize
      };
      calculateMergerOffserIndex(mergeList.concat(mergeFooterList), offsetItem, "col");
      const { startIndex: offsetStartIndex, endIndex: offsetEndIndex } = offsetItem;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollXStore.startIndex = offsetStartIndex;
          scrollXStore.endIndex = offsetEndIndex;
          tablePrivateMethods.updateScrollXData();
        }
      }
      tableMethods.closeTooltip();
    };
    const getColumnList = (columns) => {
      const result = [];
      columns.forEach((column) => {
        result.push(...column.children && column.children.length ? getColumnList(column.children) : [column]);
      });
      return result;
    };
    const parseColumns = () => {
      const leftList = [];
      const centerList = [];
      const rightList = [];
      const { isGroup, columnStore } = reactData;
      const sXOpts = computeSXOpts.value;
      const { collectColumn, tableFullColumn, scrollXStore, fullColumnIdData } = internalData;
      if (isGroup) {
        const leftGroupList = [];
        const centerGroupList = [];
        const rightGroupList = [];
        import_xe_utils41.default.eachTree(collectColumn, (column, index, items, path, parent) => {
          const isColGroup = hasChildrenList(column);
          if (parent && parent.fixed) {
            column.fixed = parent.fixed;
          }
          if (parent && column.fixed !== parent.fixed) {
            errLog("vxe.error.groupFixed");
          }
          if (isColGroup) {
            column.visible = !!import_xe_utils41.default.findTree(column.children, (subColumn) => hasChildrenList(subColumn) ? false : subColumn.visible);
          } else if (column.visible) {
            if (column.fixed === "left") {
              leftList.push(column);
            } else if (column.fixed === "right") {
              rightList.push(column);
            } else {
              centerList.push(column);
            }
          }
        });
        collectColumn.forEach((column) => {
          if (column.visible) {
            if (column.fixed === "left") {
              leftGroupList.push(column);
            } else if (column.fixed === "right") {
              rightGroupList.push(column);
            } else {
              centerGroupList.push(column);
            }
          }
        });
        reactData.tableGroupColumn = leftGroupList.concat(centerGroupList).concat(rightGroupList);
      } else {
        tableFullColumn.forEach((column) => {
          if (column.visible) {
            if (column.fixed === "left") {
              leftList.push(column);
            } else if (column.fixed === "right") {
              rightList.push(column);
            } else {
              centerList.push(column);
            }
          }
        });
      }
      const visibleColumn = leftList.concat(centerList).concat(rightList);
      const scrollXLoad = !!sXOpts.enabled && sXOpts.gt > -1 && (sXOpts.gt === 0 || sXOpts.gt < tableFullColumn.length);
      reactData.hasFixedColumn = leftList.length > 0 || rightList.length > 0;
      Object.assign(columnStore, { leftList, centerList, rightList });
      if (scrollXLoad) {
        if (true) {
          if (props.spanMethod) {
            warnLog("vxe.error.scrollErrProp", ["span-method"]);
          }
          if (props.footerSpanMethod) {
            warnLog("vxe.error.scrollErrProp", ["footer-span-method"]);
          }
        }
        const { visibleSize } = computeVirtualX();
        scrollXStore.startIndex = 0;
        scrollXStore.endIndex = visibleSize;
        scrollXStore.visibleSize = visibleSize;
      }
      if (visibleColumn.length !== internalData.visibleColumn.length || !internalData.visibleColumn.every((column, index) => column === visibleColumn[index])) {
        tableMethods.clearMergeCells();
        tableMethods.clearMergeFooterItems();
      }
      reactData.scrollXLoad = scrollXLoad;
      visibleColumn.forEach((column, index) => {
        const colid = column.id;
        const rest = fullColumnIdData[colid];
        if (rest) {
          rest._index = index;
        }
      });
      internalData.visibleColumn = visibleColumn;
      handleTableColumn();
      return tableMethods.updateFooter().then(() => {
        return tableMethods.recalculate();
      }).then(() => {
        tableMethods.updateCellAreas();
        return tableMethods.recalculate();
      });
    };
    const initColumnSort = () => {
      const { collectColumn } = internalData;
      collectColumn.forEach((column, index) => {
        const sortIndex = index + 1;
        column.sortNumber = sortIndex;
        column.renderSortNumber = sortIndex;
      });
    };
    const handleColumn = (collectColumn) => {
      internalData.collectColumn = collectColumn;
      const tableFullColumn = getColumnList(collectColumn);
      internalData.tableFullColumn = tableFullColumn;
      initColumnSort();
      restoreCustomStorage();
      cacheColumnMap();
      parseColumns().then(() => {
        if (reactData.scrollXLoad) {
          loadScrollXData();
        }
      });
      tableMethods.clearMergeCells();
      tableMethods.clearMergeFooterItems();
      tablePrivateMethods.handleTableData(true);
      if (true) {
        if ((reactData.scrollXLoad || reactData.scrollYLoad) && reactData.expandColumn) {
          warnLog("vxe.error.scrollErrProp", ["column.type=expand"]);
        }
      }
      return nextTick().then(() => {
        if ($xetoolbar) {
          $xetoolbar.syncUpdate({ collectColumn, $table: $xetable });
        }
        return tableMethods.recalculate();
      });
    };
    const updateScrollYStatus = (fullData) => {
      const { treeConfig } = props;
      const sYOpts = computeSYOpts.value;
      const treeOpts = computeTreeOpts.value;
      const { transform } = treeOpts;
      const allList = fullData || internalData.tableFullData;
      const scrollYLoad = (transform || !treeConfig) && !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt < allList.length);
      reactData.scrollYLoad = scrollYLoad;
      return scrollYLoad;
    };
    const handleBaseTreeExpand = (rows, expanded) => {
      const { treeExpandedMaps, treeExpandLazyLoadedMaps, treeNodeColumn } = reactData;
      const treeTempExpandedMaps = Object.assign({}, treeExpandedMaps);
      const { fullAllDataRowIdData, tableFullData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { reserve, lazy, accordion, toggleMethod } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
      const result = [];
      const columnIndex = tableMethods.getColumnIndex(treeNodeColumn);
      const $columnIndex = tableMethods.getVMColumnIndex(treeNodeColumn);
      let validRows = toggleMethod ? rows.filter((row) => toggleMethod({ $table: $xetable, expanded, column: treeNodeColumn, columnIndex, $columnIndex, row })) : rows;
      if (accordion) {
        validRows = validRows.length ? [validRows[validRows.length - 1]] : [];
        const matchObj = import_xe_utils41.default.findTree(tableFullData, (item) => item === validRows[0], { children: childrenField });
        if (matchObj) {
          matchObj.items.forEach((item) => {
            const rowid = getRowid($xetable, item);
            if (treeTempExpandedMaps[rowid]) {
              delete treeTempExpandedMaps[rowid];
            }
          });
        }
      }
      if (expanded) {
        validRows.forEach((row) => {
          const rowid = getRowid($xetable, row);
          if (!treeTempExpandedMaps[rowid]) {
            const rest = fullAllDataRowIdData[rowid];
            const isLoad = lazy && row[hasChildField] && !rest.treeLoaded && !treeExpandLazyLoadedMaps[rowid];
            if (isLoad) {
              result.push(handleAsyncTreeExpandChilds(row));
            } else {
              if (row[childrenField] && row[childrenField].length) {
                treeTempExpandedMaps[rowid] = row;
              }
            }
          }
        });
      } else {
        validRows.forEach((item) => {
          const rowid = getRowid($xetable, item);
          if (treeTempExpandedMaps[rowid]) {
            delete treeTempExpandedMaps[rowid];
          }
        });
      }
      if (reserve) {
        validRows.forEach((row) => handleTreeExpandReserve(row, expanded));
      }
      reactData.treeExpandedMaps = treeTempExpandedMaps;
      return Promise.all(result).then(() => {
        return tableMethods.recalculate();
      });
    };
    const handleVirtualTreeExpand = (rows, expanded) => {
      return handleBaseTreeExpand(rows, expanded).then(() => {
        handleVirtualTreeToList();
        return tablePrivateMethods.handleTableData();
      }).then(() => {
        return tableMethods.recalculate();
      });
    };
    const loadScrollYData = (evnt) => {
      const { mergeList } = reactData;
      const { scrollYStore } = internalData;
      const { startIndex, endIndex, visibleSize, offsetSize, rowHeight } = scrollYStore;
      const scrollBodyElem = evnt.currentTarget || evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetItem = {
        startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),
        endIndex: toVisibleIndex + visibleSize + offsetSize
      };
      calculateMergerOffserIndex(mergeList, offsetItem, "row");
      const { startIndex: offsetStartIndex, endIndex: offsetEndIndex } = offsetItem;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          tablePrivateMethods.updateScrollYData();
        }
      }
    };
    const createGetRowCacheProp = (prop) => {
      return function(row) {
        const { fullAllDataRowIdData } = internalData;
        if (row) {
          const rowid = getRowid($xetable, row);
          const rest = fullAllDataRowIdData[rowid];
          if (rest) {
            return rest[prop];
          }
        }
        return -1;
      };
    };
    const createGetColumnCacheProp = (prop) => {
      return function(column) {
        const { fullColumnIdData } = internalData;
        if (column) {
          const rest = fullColumnIdData[column.id];
          if (rest) {
            return rest[prop];
          }
        }
        return -1;
      };
    };
    const debounceScrollY = import_xe_utils41.default.debounce(function(evnt) {
      loadScrollYData(evnt);
    }, 20, { leading: false, trailing: true });
    let keyCtxTimeout;
    tableMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $table: $xetable, $grid: $xegrid, $event: evnt }, params));
      },
      /**
       * 
       */
      clearAll() {
        return clearTableAllStatus($xetable);
      },
      /**
       *  data 
       * 
       * 
       */
      syncData() {
        warnLog("vxe.error.delFunc", ["syncData", "getData"]);
        return nextTick().then(() => {
          reactData.tableData = [];
          emit("update:data", internalData.tableFullData);
          return nextTick();
        });
      },
      /**
       * 
       * ...
       */
      updateData() {
        const { scrollXLoad, scrollYLoad } = reactData;
        return tablePrivateMethods.handleTableData(true).then(() => {
          tableMethods.updateFooter();
          if (scrollXLoad || scrollYLoad) {
            if (scrollXLoad) {
              tablePrivateMethods.updateScrollXSpace();
            }
            if (scrollYLoad) {
              tablePrivateMethods.updateScrollYSpace();
            }
            return tableMethods.refreshScroll();
          }
        }).then(() => {
          tableMethods.updateCellAreas();
          return tableMethods.recalculate(true);
        }).then(() => {
          setTimeout(() => $xetable.recalculate(), 50);
        });
      },
      /**
       * 
       * @param {Array} datas 
       */
      loadData(datas) {
        const { inited, initStatus } = internalData;
        return loadTableData(datas).then(() => {
          internalData.inited = true;
          internalData.initStatus = true;
          if (!initStatus) {
            handleLoadDefaults();
          }
          if (!inited) {
            handleInitDefaults();
          }
          return tableMethods.recalculate();
        });
      },
      /**
       * 
       * @param {Array} datas 
       */
      reloadData(datas) {
        const { inited } = internalData;
        return tableMethods.clearAll().then(() => {
          internalData.inited = true;
          internalData.initStatus = true;
          return loadTableData(datas);
        }).then(() => {
          handleLoadDefaults();
          if (!inited) {
            handleInitDefaults();
          }
          return tableMethods.recalculate();
        });
      },
      /**
       * 
       */
      setRow(rows, record) {
        if (record) {
          let rest = rows;
          if (!import_xe_utils41.default.isArray(rows)) {
            rest = [rows];
          }
          rest.forEach((item) => Object.assign(item, record));
        }
        return nextTick();
      },
      /**
       * 
       * 
       * @param {Row} row 
       * @param {Object} record 
       * @param {String} field 
       */
      reloadRow(row, record, field) {
        const { keepSource } = props;
        const { tableData } = reactData;
        const { tableSourceData } = internalData;
        if (keepSource) {
          const rowIndex = tableMethods.getRowIndex(row);
          const oRow = tableSourceData[rowIndex];
          if (oRow && row) {
            if (field) {
              const newValue = import_xe_utils41.default.get(record || row, field);
              import_xe_utils41.default.set(row, field, newValue);
              import_xe_utils41.default.set(oRow, field, newValue);
            } else {
              const newRecord = import_xe_utils41.default.clone(Object.assign({}, record), true);
              import_xe_utils41.default.destructuring(oRow, Object.assign(row, newRecord));
            }
          }
          reactData.tableData = tableData.slice(0);
        } else {
          if (true) {
            warnLog("vxe.error.reqProp", ["keep-source"]);
          }
        }
        return nextTick();
      },
      /**
       * 
       */
      loadTreeChildren(row, childRecords) {
        const { keepSource } = props;
        const { tableSourceData, fullDataRowIdData, fullAllDataRowIdData, sourceDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const parentRest = fullAllDataRowIdData[getRowid($xetable, row)];
        const parentLevel = parentRest ? parentRest.level : 0;
        return tableMethods.createData(childRecords).then((rows) => {
          if (keepSource) {
            const rowid = getRowid($xetable, row);
            const matchObj = import_xe_utils41.default.findTree(tableSourceData, (item) => rowid === getRowid($xetable, item), { children: childrenField });
            if (matchObj) {
              matchObj.item[childrenField] = import_xe_utils41.default.clone(rows, true);
            }
            rows.forEach((childRow) => {
              const rowid2 = getRowid($xetable, childRow);
              sourceDataRowIdData[rowid2] = import_xe_utils41.default.clone(childRow, true);
            });
          }
          import_xe_utils41.default.eachTree(rows, (childRow, index, items, path, parent, nodes) => {
            const rowid = getRowid($xetable, childRow);
            const parentRow = parent || parentRest.row;
            const rest = { row: childRow, rowid, seq: -1, index, _index: -1, $index: -1, items, parent: parentRow, level: parentLevel + nodes.length };
            fullDataRowIdData[rowid] = rest;
            fullAllDataRowIdData[rowid] = rest;
          }, { children: childrenField });
          row[childrenField] = rows;
          if (transform) {
            row[mapChildrenField] = rows;
          }
          updateAfterDataIndex();
          return rows;
        });
      },
      /**
       * 
       * 
       * @param {ColumnInfo} columns 
       */
      loadColumn(columns) {
        const collectColumn = import_xe_utils41.default.mapTree(columns, (column) => reactive(cell_default.createColumn($xetable, column)));
        return handleColumn(collectColumn);
      },
      /**
       * 
       * 
       * @param {ColumnInfo} columns 
       */
      reloadColumn(columns) {
        return tableMethods.clearAll().then(() => {
          return tableMethods.loadColumn(columns);
        });
      },
      /**
       *  tr  row 
       * @param {Element} tr 
       */
      getRowNode(tr) {
        if (tr) {
          const { fullAllDataRowIdData } = internalData;
          const rowid = tr.getAttribute("rowid");
          if (rowid) {
            const rest = fullAllDataRowIdData[rowid];
            if (rest) {
              return { rowid: rest.rowid, item: rest.row, index: rest.index, items: rest.items, parent: rest.parent };
            }
          }
        }
        return null;
      },
      /**
       *  th/td  column 
       * @param {Element} cell 
       */
      getColumnNode(cell) {
        if (cell) {
          const { fullColumnIdData } = internalData;
          const colid = cell.getAttribute("colid");
          if (colid) {
            const rest = fullColumnIdData[colid];
            if (rest) {
              return { colid: rest.colid, item: rest.column, index: rest.index, items: rest.items, parent: rest.parent };
            }
          }
        }
        return null;
      },
      /**
       *  row 
       * @param {Row} row 
       */
      getRowSeq: createGetRowCacheProp("seq"),
      /**
       *  row  data 
       * @param {Row} row 
       */
      getRowIndex: createGetRowCacheProp("index"),
      /**
       *  row 
       * @param {Row} row 
       */
      getVTRowIndex: createGetRowCacheProp("_index"),
      /**
       *  row 
       * @param {Row} row 
       */
      getVMRowIndex: createGetRowCacheProp("$index"),
      /**
       *  column  columns 
       * @param {ColumnInfo} column 
       */
      getColumnIndex: createGetColumnCacheProp("index"),
      /**
       *  column 
       * @param {ColumnInfo} column 
       */
      getVTColumnIndex: createGetColumnCacheProp("_index"),
      /**
       *  column 
       * @param {ColumnInfo} column 
       */
      getVMColumnIndex: createGetColumnCacheProp("$index"),
      /**
       *  data 
       * 
       * @param {Array} records 
       */
      createData(records) {
        return nextTick().then(() => {
          return reactive(tablePrivateMethods.defineField(records));
        });
      },
      /**
       *  Row|Rows 
       * 
       * @param {Array/Object} records 
       */
      createRow(records) {
        const isArr = import_xe_utils41.default.isArray(records);
        if (!isArr) {
          records = [records || {}];
        }
        return tableMethods.createData(records).then((rows) => isArr ? rows : rows[0]);
      },
      /**
       * 
       * 
       *  row 
       *  rows 
       *  field 
       */
      revertData(rows, field) {
        const { keepSource } = props;
        const { tableSourceData, sourceDataRowIdData } = internalData;
        if (!keepSource) {
          if (true) {
            warnLog("vxe.error.reqProp", ["keep-source"]);
          }
          return nextTick();
        }
        let targetRows = rows;
        if (rows) {
          if (!import_xe_utils41.default.isArray(rows)) {
            targetRows = [rows];
          }
        } else {
          targetRows = import_xe_utils41.default.toArray($xetable.getUpdateRecords());
        }
        if (targetRows.length) {
          targetRows.forEach((row) => {
            if (!tableMethods.isInsertByRow(row)) {
              const rowid = getRowid($xetable, row);
              const oRow = sourceDataRowIdData[rowid];
              if (oRow && row) {
                if (field) {
                  import_xe_utils41.default.set(row, field, import_xe_utils41.default.clone(import_xe_utils41.default.get(oRow, field), true));
                } else {
                  import_xe_utils41.default.destructuring(row, import_xe_utils41.default.clone(oRow, true));
                }
              }
            }
          });
        }
        if (rows) {
          return nextTick();
        }
        return tableMethods.reloadData(tableSourceData);
      },
      /**
       * 
       * 
       *  row 
       *  rows 
       *  field 
       * @param {Array/Row} rows 
       * @param {String} field 
       */
      clearData(rows, field) {
        const { tableFullData, visibleColumn } = internalData;
        if (!arguments.length) {
          rows = tableFullData;
        } else if (rows && !import_xe_utils41.default.isArray(rows)) {
          rows = [rows];
        }
        if (field) {
          rows.forEach((row) => import_xe_utils41.default.set(row, field, null));
        } else {
          rows.forEach((row) => {
            visibleColumn.forEach((column) => {
              if (column.field) {
                setCellValue(row, column, null);
              }
            });
          });
        }
        return nextTick();
      },
      /**
       * 
       * @param {Row} row 
       */
      isInsertByRow(row) {
        const { editStore } = reactData;
        const rowid = getRowid($xetable, row);
        return editStore.insertMaps[rowid];
      },
      /**
       * 
       * @returns
       */
      removeInsertRow() {
        const { editStore } = reactData;
        editStore.insertMaps = {};
        return $xetable.remove($xetable.getInsertRecords());
      },
      /**
       * 
       * @param {Row} row 
       * @param {String} field 
       */
      isUpdateByRow(row, field) {
        const { keepSource } = props;
        const { tableFullColumn, fullDataRowIdData, sourceDataRowIdData } = internalData;
        if (keepSource) {
          const rowid = getRowid($xetable, row);
          if (!fullDataRowIdData[rowid]) {
            return false;
          }
          const oRow = sourceDataRowIdData[rowid];
          if (oRow) {
            if (arguments.length > 1) {
              return !eqCellValue(oRow, row, field);
            }
            for (let index = 0, len = tableFullColumn.length; index < len; index++) {
              const property = tableFullColumn[index].field;
              if (property && !eqCellValue(oRow, row, property)) {
                return true;
              }
            }
          }
        }
        return false;
      },
      /**
       * 
       * @param {Number} columnIndex 
       */
      getColumns(columnIndex) {
        const columns = internalData.visibleColumn;
        return import_xe_utils41.default.isUndefined(columnIndex) ? columns.slice(0) : columns[columnIndex];
      },
      /**
       * 
       * @param {String} colid 
       */
      getColumnById(colid) {
        const fullColumnIdData = internalData.fullColumnIdData;
        return colid && fullColumnIdData[colid] ? fullColumnIdData[colid].column : null;
      },
      /**
       * 
       * @param {String} field 
       */
      getColumnByField(field) {
        const fullColumnFieldData = internalData.fullColumnFieldData;
        return field && fullColumnFieldData[field] ? fullColumnFieldData[field].column : null;
      },
      /**
       * 
       * 
       */
      getTableColumn() {
        return {
          collectColumn: internalData.collectColumn.slice(0),
          fullColumn: internalData.tableFullColumn.slice(0),
          visibleColumn: internalData.visibleColumn.slice(0),
          tableColumn: reactData.tableColumn.slice(0)
        };
      },
      /**
       *  data 
       */
      getData(rowIndex) {
        const tableSynchData = props.data || internalData.tableSynchData;
        return import_xe_utils41.default.isUndefined(rowIndex) ? tableSynchData.slice(0) : tableSynchData[rowIndex];
      },
      /**
       * 
       */
      getCheckboxRecords(isFull) {
        const { treeConfig } = props;
        const { tableFullData, afterFullData, afterTreeFullData, tableFullTreeData, fullDataRowIdData, afterFullRowMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const { checkField } = checkboxOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let rowList = [];
        const currTableData = isFull ? transform ? tableFullTreeData : tableFullData : transform ? afterTreeFullData : afterFullData;
        if (checkField) {
          if (treeConfig) {
            rowList = import_xe_utils41.default.filterTree(currTableData, (row) => import_xe_utils41.default.get(row, checkField), { children: transform ? mapChildrenField : childrenField });
          } else {
            rowList = currTableData.filter((row) => import_xe_utils41.default.get(row, checkField));
          }
        } else {
          const { selectCheckboxMaps } = reactData;
          import_xe_utils41.default.each(selectCheckboxMaps, (row, rowid) => {
            if (isFull) {
              if (fullDataRowIdData[rowid]) {
                rowList.push(fullDataRowIdData[rowid].row);
              }
            } else {
              if (afterFullRowMaps[rowid]) {
                rowList.push(afterFullRowMaps[rowid]);
              }
            }
          });
        }
        return rowList;
      },
      /**
       *  tree-config 
       */
      getParentRow(rowOrRowid) {
        const { treeConfig } = props;
        const { fullDataRowIdData } = internalData;
        if (rowOrRowid && treeConfig) {
          let rowid;
          if (import_xe_utils41.default.isString(rowOrRowid)) {
            rowid = rowOrRowid;
          } else {
            rowid = getRowid($xetable, rowOrRowid);
          }
          if (rowid) {
            const rest = fullDataRowIdData[rowid];
            return rest ? rest.parent : null;
          }
        }
        return null;
      },
      /**
       * 
       * @param {String/Number} rowid 
       */
      getRowById(cellValue) {
        const { fullDataRowIdData } = internalData;
        const rowid = import_xe_utils41.default.eqNull(cellValue) ? "" : encodeURIComponent(cellValue || "");
        return fullDataRowIdData[rowid] ? fullDataRowIdData[rowid].row : null;
      },
      /**
       * 
       * @param {Row} row 
       */
      getRowid(row) {
        return getRowid($xetable, row);
      },
      /**
       * 
       * 
       * 
       */
      getTableData() {
        const { tableData, footerTableData } = reactData;
        const { tableFullData, afterFullData, tableFullTreeData } = internalData;
        return {
          fullData: props.treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0),
          visibleData: afterFullData.slice(0),
          tableData: tableData.slice(0),
          footerData: footerTableData.slice(0)
        };
      },
      /**
       * 
       */
      setColumnFixed(fieldOrColumn, fixed) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        const targetColumn = getRootColumn($xetable, column);
        const isMaxFixedColumn = computeIsMaxFixedColumn.value;
        const columnOpts = computeColumnOpts.value;
        const { maxFixedSize } = columnOpts;
        if (targetColumn && targetColumn.fixed !== fixed) {
          if (!targetColumn.fixed && isMaxFixedColumn) {
            if (VXETable.modal) {
              VXETable.modal.message({
                status: "error",
                content: conf_default.i18n("vxe.table.maxFixedCol", [maxFixedSize])
              });
            }
            return nextTick();
          }
          import_xe_utils41.default.eachTree([targetColumn], (column2) => {
            column2.fixed = fixed;
          });
          tablePrivateMethods.saveCustomFixed();
          return tableMethods.refreshColumn();
        }
        return nextTick();
      },
      /**
       * 
       */
      clearColumnFixed(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        const targetColumn = getRootColumn($xetable, column);
        if (targetColumn && targetColumn.fixed) {
          import_xe_utils41.default.eachTree([targetColumn], (column2) => {
            column2.fixed = null;
          });
          tablePrivateMethods.saveCustomFixed();
          return tableMethods.refreshColumn();
        }
        return nextTick();
      },
      /**
       * 
       */
      hideColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column && column.visible) {
          column.visible = false;
          return tablePrivateMethods.handleCustom();
        }
        return nextTick();
      },
      /**
       * 
       */
      showColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column && !column.visible) {
          column.visible = true;
          return tablePrivateMethods.handleCustom();
        }
        return nextTick();
      },
      setColumnWidth(fieldOrColumn, width) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column) {
          const colWidth = import_xe_utils41.default.toInteger(width);
          let rdWidth = colWidth;
          if (isScale(width)) {
            const tableBody = refTableBody.value;
            const bodyElem = tableBody ? tableBody.$el : null;
            const bodyWidth = bodyElem ? bodyElem.clientWidth - 1 : 0;
            rdWidth = Math.floor(colWidth * bodyWidth);
          }
          column.renderWidth = rdWidth;
        }
        return nextTick();
      },
      getColumnWidth(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column) {
          return column.renderWidth;
        }
        return 0;
      },
      /**
       * 
       *  true 
       * 
       */
      resetCustom(options) {
        const { collectColumn } = internalData;
        const customOpts = computeCustomOpts.value;
        const { checkMethod } = customOpts;
        const opts = Object.assign({
          visible: true,
          resizable: options === true,
          fixed: options === true,
          sort: options === true
        }, options);
        import_xe_utils41.default.eachTree(collectColumn, (column) => {
          if (opts.resizable) {
            column.resizeWidth = 0;
          }
          if (opts.fixed) {
            column.fixed = column.defaultFixed;
          }
          if (opts.sort) {
            column.renderSortNumber = column.sortNumber;
          }
          if (!checkMethod || checkMethod({ column })) {
            column.visible = column.defaultVisible;
          }
        });
        if (opts.resizable) {
          tablePrivateMethods.saveCustomResizable(true);
        }
        if (opts.sort) {
          tablePrivateMethods.saveCustomSort(true);
        }
        if (opts.fixed) {
          tablePrivateMethods.saveCustomFixed();
        }
        return tablePrivateMethods.handleCustom();
      },
      resetColumn(options) {
        warnLog("vxe.error.delFunc", ["resetColumn", "resetCustom"]);
        return $xetable.resetCustom(options);
      },
      /**
       * 
       * 
       *  true 
       */
      refreshColumn(resiveOrder) {
        if (resiveOrder) {
          const columnList = import_xe_utils41.default.orderBy(internalData.collectColumn, "renderSortNumber");
          internalData.collectColumn = columnList;
          const tableFullColumn = getColumnList(columnList);
          internalData.tableFullColumn = tableFullColumn;
          cacheColumnMap();
        }
        return parseColumns().then(() => {
          return tableMethods.refreshScroll();
        }).then(() => {
          return tableMethods.recalculate();
        });
      },
      /**
       * 
       */
      refreshScroll() {
        const { lastScrollLeft, lastScrollTop } = internalData;
        const tableBody = refTableBody.value;
        const tableFooter = refTableFooter.value;
        const leftBody = refTableLeftBody.value;
        const rightBody = refTableRightBody.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        const leftBodyElem = leftBody ? leftBody.$el : null;
        const rightBodyElem = rightBody ? rightBody.$el : null;
        const tableFooterElem = tableFooter ? tableFooter.$el : null;
        return new Promise((resolve) => {
          if (lastScrollLeft || lastScrollTop) {
            return restoreScrollLocation($xetable, lastScrollLeft, lastScrollTop).then().then(() => {
              setTimeout(resolve, 30);
            });
          }
          setScrollTop(tableBodyElem, lastScrollTop);
          setScrollTop(leftBodyElem, lastScrollTop);
          setScrollTop(rightBodyElem, lastScrollTop);
          setScrollLeft(tableFooterElem, lastScrollLeft);
          setTimeout(resolve, 30);
        });
      },
      /**
       * 
       *  width=? width=?px width=?% min-width=? min-width=?px min-width=?%
       */
      recalculate(refull) {
        autoCellWidth();
        if (refull === true) {
          return computeScrollLoad().then(() => {
            autoCellWidth();
            return computeScrollLoad();
          });
        }
        return computeScrollLoad();
      },
      openTooltip(target, content) {
        const $commTip = refCommTooltip.value;
        if ($commTip) {
          return $commTip.open(target, content);
        }
        return nextTick();
      },
      /**
       *  tooltip
       */
      closeTooltip() {
        const { tooltipStore } = reactData;
        const $tooltip = refTooltip.value;
        const $commTip = refCommTooltip.value;
        if (tooltipStore.visible) {
          Object.assign(tooltipStore, {
            row: null,
            column: null,
            content: null,
            visible: false
          });
          if ($tooltip) {
            $tooltip.close();
          }
        }
        if ($commTip) {
          $commTip.close();
        }
        return nextTick();
      },
      /**
       * 
       */
      isAllCheckboxChecked() {
        return reactData.isAllSelected;
      },
      /**
       * 
       */
      isAllCheckboxIndeterminate() {
        return !reactData.isAllSelected && reactData.isIndeterminate;
      },
      /**
       * 
       */
      getCheckboxIndeterminateRecords(isFull) {
        const { treeConfig } = props;
        const { fullDataRowIdData } = internalData;
        const { treeIndeterminateMaps } = reactData;
        if (treeConfig) {
          const fullRest = [];
          const defRest = [];
          import_xe_utils41.default.each(treeIndeterminateMaps, (item, rowid) => {
            if (item) {
              fullRest.push(item);
              if (fullDataRowIdData[rowid]) {
                defRest.push(item);
              }
            }
          });
          if (isFull) {
            return fullRest;
          }
          return defRest;
        }
        return [];
      },
      /**
       * 
       * @param {Array/Row} rows 
       * @param {Boolean} value 
       */
      setCheckboxRow(rows, value) {
        return handleCheckedCheckboxRow(rows, value, true);
      },
      isCheckedByCheckboxRow(row) {
        const { selectCheckboxMaps } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        if (checkField) {
          return import_xe_utils41.default.get(row, checkField);
        }
        return !!selectCheckboxMaps[getRowid($xetable, row)];
      },
      isIndeterminateByCheckboxRow(row) {
        const { treeIndeterminateMaps } = reactData;
        return !!treeIndeterminateMaps[getRowid($xetable, row)] && !tableMethods.isCheckedByCheckboxRow(row);
      },
      /**
       * 
       */
      toggleCheckboxRow(row) {
        const { selectCheckboxMaps } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        const value = checkField ? !import_xe_utils41.default.get(row, checkField) : !selectCheckboxMaps[getRowid($xetable, row)];
        tablePrivateMethods.handleSelectRow({ row }, value, true);
        return nextTick();
      },
      /**
       * 
       * @param {Boolean} value 
       */
      setAllCheckboxRow(value) {
        return handleCheckedAllCheckboxRow(value, true);
      },
      /**
       * 
       */
      getRadioReserveRecord(isFull) {
        const { treeConfig } = props;
        const { fullDataRowIdData, radioReserveRow, afterFullData } = internalData;
        const radioOpts = computeRadioOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (radioOpts.reserve && radioReserveRow) {
          const rowid = getRowid($xetable, radioReserveRow);
          if (isFull) {
            if (!fullDataRowIdData[rowid]) {
              return radioReserveRow;
            }
          } else {
            const rowkey = getRowkey($xetable);
            if (treeConfig) {
              const matchObj = import_xe_utils41.default.findTree(afterFullData, (row) => rowid === import_xe_utils41.default.get(row, rowkey), { children: childrenField });
              if (matchObj) {
                return radioReserveRow;
              }
            } else {
              if (!afterFullData.some((row) => rowid === import_xe_utils41.default.get(row, rowkey))) {
                return radioReserveRow;
              }
            }
          }
        }
        return null;
      },
      clearRadioReserve() {
        internalData.radioReserveRow = null;
        return nextTick();
      },
      /**
       * 
       */
      getCheckboxReserveRecords(isFull) {
        const { treeConfig } = props;
        const { afterFullData, fullDataRowIdData, checkboxReserveRowMap } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const reserveSelection = [];
        if (checkboxOpts.reserve) {
          const afterFullIdMaps = {};
          if (treeConfig) {
            import_xe_utils41.default.eachTree(afterFullData, (row) => {
              afterFullIdMaps[getRowid($xetable, row)] = 1;
            }, { children: childrenField });
          } else {
            afterFullData.forEach((row) => {
              afterFullIdMaps[getRowid($xetable, row)] = 1;
            });
          }
          import_xe_utils41.default.each(checkboxReserveRowMap, (oldRow, oldRowid) => {
            if (oldRow) {
              if (isFull) {
                if (!fullDataRowIdData[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              } else {
                if (!afterFullIdMaps[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              }
            }
          });
        }
        return reserveSelection;
      },
      clearCheckboxReserve() {
        internalData.checkboxReserveRowMap = {};
        return nextTick();
      },
      /**
       * 
       */
      toggleAllCheckboxRow() {
        tablePrivateMethods.triggerCheckAllEvent(null, !reactData.isAllSelected);
        return nextTick();
      },
      /**
       * 
       * 
       */
      clearCheckboxRow() {
        const { treeConfig } = props;
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, reserve } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        if (checkField) {
          const handleClearChecked = (item) => {
            if (treeConfig && indeterminateField) {
              import_xe_utils41.default.set(item, indeterminateField, false);
            }
            import_xe_utils41.default.set(item, checkField, false);
          };
          if (treeConfig) {
            import_xe_utils41.default.eachTree(tableFullData, handleClearChecked, { children: childrenField });
          } else {
            tableFullData.forEach(handleClearChecked);
          }
        }
        if (reserve) {
          tableFullData.forEach((row) => handleCheckboxReserveRow(row, false));
        }
        reactData.isAllSelected = false;
        reactData.isIndeterminate = false;
        reactData.selectCheckboxMaps = {};
        reactData.treeIndeterminateMaps = {};
        return nextTick();
      },
      /**
       * 
       * @param {Row} row 
       */
      setCurrentRow(row) {
        const rowOpts = computeRowOpts.value;
        const el = refElem.value;
        tableMethods.clearCurrentRow();
        reactData.currentRow = row;
        if (rowOpts.isCurrent || props.highlightCurrentRow) {
          if (el) {
            import_xe_utils41.default.arrayEach(el.querySelectorAll(`[rowid="${getRowid($xetable, row)}"]`), (elem) => addClass(elem, "row--current"));
          }
        }
        return nextTick();
      },
      isCheckedByRadioRow(row) {
        return $xetable.eqRow(reactData.selectRadioRow, row);
      },
      /**
       * 
       * @param {Row} row 
       */
      setRadioRow(row) {
        return handleCheckedRadioRow(row, true);
      },
      /**
       * 
       */
      clearCurrentRow() {
        const el = refElem.value;
        reactData.currentRow = null;
        internalData.hoverRow = null;
        if (el) {
          import_xe_utils41.default.arrayEach(el.querySelectorAll(".row--current"), (elem) => removeClass(elem, "row--current"));
        }
        return nextTick();
      },
      /**
       * 
       */
      clearRadioRow() {
        reactData.selectRadioRow = null;
        return nextTick();
      },
      /**
       * 
       */
      getCurrentRecord() {
        const rowOpts = computeRowOpts.value;
        return rowOpts.isCurrent || props.highlightCurrentRow ? reactData.currentRow : null;
      },
      /**
       * 
       */
      getRadioRecord(isFull) {
        const { fullDataRowIdData, afterFullRowMaps } = internalData;
        const { selectRadioRow } = reactData;
        if (selectRadioRow) {
          const rowid = getRowid($xetable, selectRadioRow);
          if (isFull) {
            if (fullDataRowIdData[rowid]) {
              return selectRadioRow;
            }
          } else {
            if (afterFullRowMaps[rowid]) {
              return selectRadioRow;
            }
          }
        }
        return null;
      },
      getCurrentColumn() {
        const columnOpts = computeColumnOpts.value;
        return columnOpts.isCurrent || props.highlightCurrentColumn ? reactData.currentColumn : null;
      },
      /**
       * 
       */
      setCurrentColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column) {
          tableMethods.clearCurrentColumn();
          reactData.currentColumn = column;
        }
        return nextTick();
      },
      /**
       * 
       */
      clearCurrentColumn() {
        reactData.currentColumn = null;
        return nextTick();
      },
      setPendingRow(rows, status) {
        const pendingMaps = Object.assign({}, reactData.pendingRowMaps);
        const pendingList = [...reactData.pendingRowList];
        if (rows && !import_xe_utils41.default.isArray(rows)) {
          rows = [rows];
        }
        if (status) {
          rows.forEach((row) => {
            const rowid = getRowid($xetable, row);
            if (rowid && !pendingMaps[rowid]) {
              pendingList.push(row);
              pendingMaps[rowid] = row;
            }
          });
        } else {
          rows.forEach((row) => {
            const rowid = getRowid($xetable, row);
            if (rowid && pendingMaps[rowid]) {
              const pendingIndex = $xetable.findRowIndexOf(pendingList, row);
              if (pendingIndex > -1) {
                pendingList.splice(pendingIndex, 1);
              }
              delete pendingMaps[rowid];
            }
          });
        }
        reactData.pendingRowMaps = pendingMaps;
        reactData.pendingRowList = pendingList;
        return nextTick();
      },
      togglePendingRow(rows) {
        const pendingMaps = Object.assign({}, reactData.pendingRowMaps);
        const pendingList = [...reactData.pendingRowList];
        if (rows && !import_xe_utils41.default.isArray(rows)) {
          rows = [rows];
        }
        rows.forEach((row) => {
          const rowid = getRowid($xetable, row);
          if (rowid) {
            if (pendingMaps[rowid]) {
              const pendingIndex = $xetable.findRowIndexOf(pendingList, row);
              if (pendingIndex > -1) {
                pendingList.splice(pendingIndex, 1);
              }
              delete pendingMaps[rowid];
            } else {
              pendingList.push(row);
              pendingMaps[rowid] = row;
            }
          }
        });
        reactData.pendingRowMaps = pendingMaps;
        reactData.pendingRowList = pendingList;
        return nextTick();
      },
      hasPendingByRow(row) {
        const { pendingRowMaps } = reactData;
        const rowid = getRowid($xetable, row);
        return !!pendingRowMaps[rowid];
      },
      getPendingRecords() {
        const { pendingRowList } = reactData;
        return pendingRowList.slice(0);
      },
      clearPendingRow() {
        reactData.pendingRowMaps = {};
        reactData.pendingRowList = [];
        return nextTick();
      },
      sort(sortConfs, sortOrder) {
        const sortOpts = computeSortOpts.value;
        const { multiple, remote, orders } = sortOpts;
        if (sortConfs) {
          if (import_xe_utils41.default.isString(sortConfs)) {
            sortConfs = [
              { field: sortConfs, order: sortOrder }
            ];
          }
        }
        if (!import_xe_utils41.default.isArray(sortConfs)) {
          sortConfs = [sortConfs];
        }
        if (sortConfs.length) {
          if (!multiple) {
            clearAllSort();
          }
          (multiple ? sortConfs : [sortConfs[0]]).forEach((confs, index) => {
            let { field, order } = confs;
            let column = field;
            if (import_xe_utils41.default.isString(field)) {
              column = tableMethods.getColumnByField(field);
            }
            if (column && column.sortable) {
              if (orders.indexOf(order) === -1) {
                order = getNextSortOrder(column);
              }
              if (column.order !== order) {
                column.order = order;
              }
              column.sortTime = Date.now() + index;
            }
          });
          if (!remote) {
            tablePrivateMethods.handleTableData(true);
          }
          return nextTick().then(() => {
            tableMethods.updateCellAreas();
            return updateStyle();
          });
        }
        return nextTick();
      },
      /**
       * 
       * 
       * @param {String} fieldOrColumn 
       */
      clearSort(fieldOrColumn) {
        const sortOpts = computeSortOpts.value;
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xetable, fieldOrColumn);
          if (column) {
            column.order = null;
          }
        } else {
          clearAllSort();
        }
        if (!sortOpts.remote) {
          tablePrivateMethods.handleTableData(true);
        }
        return nextTick().then(updateStyle);
      },
      isSort(fieldOrColumn) {
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xetable, fieldOrColumn);
          return column ? column.sortable && !!column.order : false;
        }
        return tableMethods.getSortColumns().length > 0;
      },
      getSortColumns() {
        const sortOpts = computeSortOpts.value;
        const { multiple, chronological } = sortOpts;
        const sortList = [];
        const { tableFullColumn } = internalData;
        tableFullColumn.forEach((column) => {
          const { field, order } = column;
          if (column.sortable && order) {
            sortList.push({ column, field, property: field, order, sortTime: column.sortTime });
          }
        });
        if (multiple && chronological && sortList.length > 1) {
          return import_xe_utils41.default.orderBy(sortList, "sortTime");
        }
        return sortList;
      },
      /**
       * 
       * @param {Event} evnt 
       */
      closeFilter() {
        const { filterStore } = reactData;
        const { column, visible } = filterStore;
        Object.assign(filterStore, {
          isAllSelected: false,
          isIndeterminate: false,
          options: [],
          visible: false
        });
        if (visible) {
          $xetable.dispatchEvent("filter-visible", { column, property: column.field, field: column.field, filterList: $xetable.getCheckedFilters(), visible: false }, null);
        }
        return nextTick();
      },
      /**
       * 
       * @param {String} fieldOrColumn 
       */
      isActiveFilterByColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column) {
          return column.filters && column.filters.some((option) => option.checked);
        }
        return $xetable.getCheckedFilters().length > 0;
      },
      isFilter(fieldOrColumn) {
        return tableMethods.isActiveFilterByColumn(fieldOrColumn);
      },
      /**
       * 
       * @param {Row} row 
       */
      isRowExpandLoaded(row) {
        const { fullAllDataRowIdData } = internalData;
        const rest = fullAllDataRowIdData[getRowid($xetable, row)];
        return rest && !!rest.expandLoaded;
      },
      clearRowExpandLoaded(row) {
        const { rowExpandLazyLoadedMaps } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { lazy } = expandOpts;
        const rowid = getRowid($xetable, row);
        const rest = fullAllDataRowIdData[rowid];
        if (lazy && rest) {
          rest.expandLoaded = false;
          delete rowExpandLazyLoadedMaps[rowid];
        }
        return nextTick();
      },
      /**
       * 
       * @param {Row} row 
       */
      reloadRowExpand(row) {
        const { rowExpandLazyLoadedMaps } = reactData;
        const expandOpts = computeExpandOpts.value;
        const { lazy } = expandOpts;
        const rowid = getRowid($xetable, row);
        if (lazy && !rowExpandLazyLoadedMaps[rowid]) {
          tableMethods.clearRowExpandLoaded(row).then(() => handleAsyncRowExpand(row));
        }
        return nextTick();
      },
      reloadExpandContent(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["reloadExpandContent", "reloadRowExpand"]);
        }
        return tableMethods.reloadRowExpand(row);
      },
      /**
       * 
       */
      toggleRowExpand(row) {
        return tableMethods.setRowExpand(row, !tableMethods.isRowExpandByRow(row));
      },
      /**
       * 
       * @param {Boolean} expanded 
       */
      setAllRowExpand(expanded) {
        const treeOpts = computeTreeOpts.value;
        const { tableFullData, tableFullTreeData } = internalData;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let expandedRows = [];
        if (props.treeConfig) {
          import_xe_utils41.default.eachTree(tableFullTreeData, (row) => {
            expandedRows.push(row);
          }, { children: childrenField });
        } else {
          expandedRows = tableFullData;
        }
        return tableMethods.setRowExpand(expandedRows, expanded);
      },
      /**
       * 
       * 
       * 
       * @param {Array/Row} rows 
       * @param {Boolean} expanded 
       */
      setRowExpand(rows, expanded) {
        const { rowExpandedMaps, rowExpandLazyLoadedMaps, expandColumn: column } = reactData;
        const { fullAllDataRowIdData } = internalData;
        let rExpandedMaps = Object.assign({}, rowExpandedMaps);
        const expandOpts = computeExpandOpts.value;
        const { reserve, lazy, accordion, toggleMethod } = expandOpts;
        const lazyRests = [];
        const columnIndex = tableMethods.getColumnIndex(column);
        const $columnIndex = tableMethods.getVMColumnIndex(column);
        if (rows) {
          if (!import_xe_utils41.default.isArray(rows)) {
            rows = [rows];
          }
          if (accordion) {
            rExpandedMaps = {};
            rows = rows.slice(rows.length - 1, rows.length);
          }
          const validRows = toggleMethod ? rows.filter((row) => toggleMethod({ $table: $xetable, expanded, column, columnIndex, $columnIndex, row, rowIndex: tableMethods.getRowIndex(row), $rowIndex: tableMethods.getVMRowIndex(row) })) : rows;
          if (expanded) {
            validRows.forEach((row) => {
              const rowid = getRowid($xetable, row);
              if (!rExpandedMaps[rowid]) {
                const rest = fullAllDataRowIdData[rowid];
                const isLoad = lazy && !rest.expandLoaded && !rowExpandLazyLoadedMaps[rowid];
                if (isLoad) {
                  lazyRests.push(handleAsyncRowExpand(row));
                } else {
                  rExpandedMaps[rowid] = row;
                }
              }
            });
          } else {
            validRows.forEach((item) => {
              const rowid = getRowid($xetable, item);
              if (rExpandedMaps[rowid]) {
                delete rExpandedMaps[rowid];
              }
            });
          }
          if (reserve) {
            validRows.forEach((row) => handleRowExpandReserve(row, expanded));
          }
        }
        reactData.rowExpandedMaps = rExpandedMaps;
        return Promise.all(lazyRests).then(() => tableMethods.recalculate());
      },
      /**
       * 
       * @param {Row} row 
       */
      isRowExpandByRow(row) {
        const { rowExpandedMaps } = reactData;
        const rowid = getRowid($xetable, row);
        return !!rowExpandedMaps[rowid];
      },
      isExpandByRow(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["isExpandByRow", "isRowExpandByRow"]);
        }
        return tableMethods.isRowExpandByRow(row);
      },
      /**
       * 
       */
      clearRowExpand() {
        const { tableFullData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { reserve } = expandOpts;
        const expList = tableMethods.getRowExpandRecords();
        reactData.rowExpandedMaps = {};
        if (reserve) {
          tableFullData.forEach((row) => handleRowExpandReserve(row, false));
        }
        return nextTick().then(() => {
          if (expList.length) {
            tableMethods.recalculate();
          }
        });
      },
      clearRowExpandReserve() {
        internalData.rowExpandedReserveRowMap = {};
        return nextTick();
      },
      getRowExpandRecords() {
        const rest = [];
        import_xe_utils41.default.each(reactData.rowExpandedMaps, (item) => {
          if (item) {
            rest.push(item);
          }
        });
        return rest;
      },
      getTreeExpandRecords() {
        const rest = [];
        import_xe_utils41.default.each(reactData.treeExpandedMaps, (item) => {
          if (item) {
            rest.push(item);
          }
        });
        return rest;
      },
      /**
       * 
       * @param {Row} row 
       */
      isTreeExpandLoaded(row) {
        const { fullAllDataRowIdData } = internalData;
        const rest = fullAllDataRowIdData[getRowid($xetable, row)];
        return rest && !!rest.treeLoaded;
      },
      clearTreeExpandLoaded(row) {
        const { treeExpandedMaps } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, lazy } = treeOpts;
        const rowid = getRowid($xetable, row);
        const rest = fullAllDataRowIdData[rowid];
        if (lazy && rest) {
          rest.treeLoaded = false;
          if (treeExpandedMaps[rowid]) {
            delete treeExpandedMaps[rowid];
          }
        }
        if (transform) {
          handleVirtualTreeToList();
          return tablePrivateMethods.handleTableData();
        }
        return nextTick();
      },
      /**
       * 
       * @param {Row} row 
       */
      reloadTreeExpand(row) {
        const { treeExpandLazyLoadedMaps } = reactData;
        const treeOpts = computeTreeOpts.value;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const { transform, lazy } = treeOpts;
        const rowid = getRowid($xetable, row);
        if (lazy && row[hasChildField] && !treeExpandLazyLoadedMaps[rowid]) {
          tableMethods.clearTreeExpandLoaded(row).then(() => {
            return handleAsyncTreeExpandChilds(row);
          }).then(() => {
            if (transform) {
              handleVirtualTreeToList();
              return tablePrivateMethods.handleTableData();
            }
          }).then(() => {
            return tableMethods.recalculate();
          });
        }
        return nextTick();
      },
      reloadTreeChilds(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["reloadTreeChilds", "reloadTreeExpand"]);
        }
        return tableMethods.reloadTreeExpand(row);
      },
      /**
       * /
       */
      toggleTreeExpand(row) {
        return tableMethods.setTreeExpand(row, !tableMethods.isTreeExpandByRow(row));
      },
      /**
       * 
       * @param {Boolean} expanded 
       */
      setAllTreeExpand(expanded) {
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, lazy } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const expandeds = [];
        import_xe_utils41.default.eachTree(tableFullData, (row) => {
          const rowChildren = row[childrenField];
          if (lazy || rowChildren && rowChildren.length) {
            expandeds.push(row);
          }
        }, { children: childrenField });
        return tableMethods.setTreeExpand(expandeds, expanded).then(() => {
          if (transform) {
            handleVirtualTreeToList();
            return tableMethods.recalculate();
          }
        });
      },
      /**
       * 
       * 
       * 
       * @param {Array/Row} rows 
       * @param {Boolean} expanded 
       */
      setTreeExpand(rows, expanded) {
        const treeOpts = computeTreeOpts.value;
        const { transform } = treeOpts;
        if (rows) {
          if (!import_xe_utils41.default.isArray(rows)) {
            rows = [rows];
          }
          if (rows.length) {
            if (transform) {
              return handleVirtualTreeExpand(rows, expanded);
            } else {
              return handleBaseTreeExpand(rows, expanded);
            }
          }
        }
        return nextTick();
      },
      /**
       * 
       * @param {Row} row 
       */
      isTreeExpandByRow(row) {
        const { treeExpandedMaps } = reactData;
        return !!treeExpandedMaps[getRowid($xetable, row)];
      },
      /**
       * 
       */
      clearTreeExpand() {
        const { tableFullTreeData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const { transform, reserve } = treeOpts;
        const expList = tableMethods.getTreeExpandRecords();
        reactData.treeExpandedMaps = {};
        if (reserve) {
          import_xe_utils41.default.eachTree(tableFullTreeData, (row) => handleTreeExpandReserve(row, false), { children: childrenField });
        }
        return tablePrivateMethods.handleTableData().then(() => {
          if (transform) {
            handleVirtualTreeToList();
            return tablePrivateMethods.handleTableData();
          }
        }).then(() => {
          if (expList.length) {
            return tableMethods.recalculate();
          }
        });
      },
      clearTreeExpandReserve() {
        internalData.treeExpandedReserveRowMap = {};
        return nextTick();
      },
      /**
       * 
       */
      getScroll() {
        const { scrollXLoad, scrollYLoad } = reactData;
        const tableBody = refTableBody.value;
        const bodyElem = tableBody.$el;
        return {
          virtualX: scrollXLoad,
          virtualY: scrollYLoad,
          scrollTop: bodyElem.scrollTop,
          scrollLeft: bodyElem.scrollLeft
        };
      },
      /**
       * 
       * @param {Number} scrollLeft 
       * @param {Number} scrollTop 
       */
      scrollTo(scrollLeft, scrollTop) {
        const tableBody = refTableBody.value;
        const tableFooter = refTableFooter.value;
        const rightBody = refTableRightBody.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        const rightBodyElem = rightBody ? rightBody.$el : null;
        const tableFooterElem = tableFooter ? tableFooter.$el : null;
        if (import_xe_utils41.default.isNumber(scrollLeft)) {
          setScrollLeft(tableFooterElem || tableBodyElem, scrollLeft);
        }
        if (import_xe_utils41.default.isNumber(scrollTop)) {
          setScrollTop(rightBodyElem || tableBodyElem, scrollTop);
        }
        if (reactData.scrollXLoad || reactData.scrollYLoad) {
          return new Promise((resolve) => {
            setTimeout(() => {
              nextTick(() => {
                resolve();
              });
            }, 50);
          });
        }
        return nextTick();
      },
      /**
       * 
       * @param {Row} row 
       * @param {ColumnInfo} fieldOrColumn 
       */
      scrollToRow(row, fieldOrColumn) {
        const rest = [];
        if (row) {
          if (props.treeConfig) {
            rest.push(tablePrivateMethods.scrollToTreeRow(row));
          } else {
            rest.push(rowToVisible($xetable, row));
          }
        }
        if (fieldOrColumn) {
          rest.push(tableMethods.scrollToColumn(fieldOrColumn));
        }
        return Promise.all(rest);
      },
      /**
       * 
       */
      scrollToColumn(fieldOrColumn) {
        const { fullColumnIdData } = internalData;
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column && fullColumnIdData[column.id]) {
          return colToVisible($xetable, column);
        }
        return nextTick();
      },
      /**
       * 
       */
      clearScroll() {
        const { scrollXStore, scrollYStore } = internalData;
        const tableBody = refTableBody.value;
        const tableFooter = refTableFooter.value;
        const rightBody = refTableRightBody.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        const rightBodyElem = rightBody ? rightBody.$el : null;
        const tableFooterElem = tableFooter ? tableFooter.$el : null;
        if (rightBodyElem) {
          restoreScrollListener(rightBodyElem);
          rightBodyElem.scrollTop = 0;
        }
        if (tableFooterElem) {
          tableFooterElem.scrollLeft = 0;
        }
        if (tableBodyElem) {
          restoreScrollListener(tableBodyElem);
          tableBodyElem.scrollTop = 0;
          tableBodyElem.scrollLeft = 0;
        }
        scrollXStore.startIndex = 0;
        scrollYStore.startIndex = 0;
        return nextTick();
      },
      /**
       * 
       */
      updateFooter() {
        const { showFooter, footerData, footerMethod } = props;
        const { visibleColumn, afterFullData } = internalData;
        let footData = [];
        if (showFooter && footerData && footerData.length) {
          footData = footerData.slice(0);
        } else if (showFooter && footerMethod) {
          footData = visibleColumn.length ? footerMethod({ columns: visibleColumn, data: afterFullData, $table: $xetable, $grid: $xegrid }) : [];
        }
        reactData.footerTableData = footData;
        return nextTick();
      },
      /**
       *  updateStatus({ row, column }, cellValue)
       *  v-model  change 
       * 
       */
      updateStatus(slotParams, cellValue) {
        const customVal = !import_xe_utils41.default.isUndefined(cellValue);
        return nextTick().then(() => {
          const { editRules } = props;
          const { validStore } = reactData;
          const tableBody = refTableBody.value;
          if (slotParams && tableBody && editRules) {
            const { row, column } = slotParams;
            const type = "change";
            if ($xetable.hasCellRules) {
              if ($xetable.hasCellRules(type, row, column)) {
                const cell = tablePrivateMethods.getCell(row, column);
                if (cell) {
                  return $xetable.validCellRules(type, row, column, cellValue).then(() => {
                    if (customVal && validStore.visible) {
                      setCellValue(row, column, cellValue);
                    }
                    $xetable.clearValidate(row, column);
                  }).catch(({ rule }) => {
                    if (customVal) {
                      setCellValue(row, column, cellValue);
                    }
                    $xetable.showValidTooltip({ rule, row, column, cell });
                  });
                }
              }
            }
          }
        });
      },
      /**
       * 
       * @param {TableMergeConfig[]} merges { row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }
       */
      setMergeCells(merges) {
        if (props.spanMethod) {
          errLog("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        }
        setMerges(merges, reactData.mergeList, internalData.afterFullData);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          return updateStyle();
        });
      },
      /**
       * 
       * @param {TableMergeConfig[]} merges  [{row:Row|number, col:ColumnInfo|number}]
       */
      removeMergeCells(merges) {
        if (props.spanMethod) {
          errLog("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        }
        const rest = removeMerges(merges, reactData.mergeList, internalData.afterFullData);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          updateStyle();
          return rest;
        });
      },
      /**
       * 
       */
      getMergeCells() {
        return reactData.mergeList.slice(0);
      },
      /**
       * 
       */
      clearMergeCells() {
        reactData.mergeList = [];
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      setMergeFooterItems(merges) {
        if (props.footerSpanMethod) {
          errLog("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]);
        }
        setMerges(merges, reactData.mergeFooterList);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          return updateStyle();
        });
      },
      removeMergeFooterItems(merges) {
        if (props.footerSpanMethod) {
          errLog("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]);
        }
        const rest = removeMerges(merges, reactData.mergeFooterList);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          updateStyle();
          return rest;
        });
      },
      /**
       * 
       */
      getMergeFooterItems() {
        return reactData.mergeFooterList.slice(0);
      },
      /**
       * 
       */
      clearMergeFooterItems() {
        reactData.mergeFooterList = [];
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      updateCellAreas() {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        if (mouseConfig && mouseOpts.area && $xetable.handleUpdateCellAreas) {
          return $xetable.handleUpdateCellAreas();
        }
        return nextTick();
      },
      focus() {
        internalData.isActivated = true;
        return nextTick();
      },
      blur() {
        internalData.isActivated = false;
        return nextTick();
      },
      /**
       * 
       * @param $toolbar
       */
      connect($toolbar) {
        if ($toolbar) {
          $xetoolbar = $toolbar;
          $xetoolbar.syncUpdate({ collectColumn: internalData.collectColumn, $table: $xetable });
        } else {
          errLog("vxe.error.barUnableLink");
        }
        return nextTick();
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { editStore, ctxMenuStore, filterStore, customStore } = reactData;
      const { mouseConfig, editRules } = props;
      const el = refElem.value;
      const editOpts = computeEditOpts.value;
      const validOpts = computeValidOpts.value;
      const areaOpts = computeAreaOpts.value;
      const { actived } = editStore;
      const $validTooltip = refValidTooltip.value;
      const tableFilter = refTableFilter.value;
      const tableCustom = refTableCustom.value;
      const tableMenu = refTableMenu.value;
      if (tableFilter) {
        if (getEventTargetNode(evnt, el, "vxe-cell--filter").flag) {
        } else if (getEventTargetNode(evnt, tableFilter.$el).flag) {
        } else {
          if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
            tablePrivateMethods.preventEvent(evnt, "event.clearFilter", filterStore.args, tableMethods.closeFilter);
          }
        }
      }
      if (tableCustom) {
        if (customStore.btnEl === evnt.target || getEventTargetNode(evnt, document.body, "vxe-toolbar-custom-target").flag) {
        } else if (getEventTargetNode(evnt, tableCustom.$el).flag) {
        } else {
          if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
            tablePrivateMethods.preventEvent(evnt, "event.clearCustom", {}, () => {
              if ($xetable.closeCustom) {
                $xetable.closeCustom();
              }
            });
          }
        }
      }
      if (actived.row) {
        if (!(editOpts.autoClear === false)) {
          const cell = actived.args.cell;
          if (!cell || !getEventTargetNode(evnt, cell).flag) {
            if ($validTooltip && getEventTargetNode(evnt, $validTooltip.$el).flag) {
            } else if (!internalData._lastCallTime || internalData._lastCallTime + 50 < Date.now()) {
              if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
                tablePrivateMethods.preventEvent(evnt, "event.clearEdit", actived.args, () => {
                  let isClear;
                  if (editOpts.mode === "row") {
                    const rowTargetNode = getEventTargetNode(evnt, el, "vxe-body--row");
                    const rowNodeRest = rowTargetNode.flag ? tableMethods.getRowNode(rowTargetNode.targetElem) : null;
                    isClear = rowNodeRest ? !$xetable.eqRow(rowNodeRest.item, actived.args.row) : false;
                  } else {
                    isClear = !getEventTargetNode(evnt, el, "col--edit").flag;
                  }
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el, "vxe-header--row").flag;
                  }
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el, "vxe-footer--row").flag;
                  }
                  if (!isClear && props.height && !reactData.overflowY) {
                    const bodyWrapperElem = evnt.target;
                    if (hasClass(bodyWrapperElem, "vxe-table--body-wrapper")) {
                      isClear = evnt.offsetY < bodyWrapperElem.clientHeight;
                    }
                  }
                  if (isClear || // 
                  !getEventTargetNode(evnt, el).flag) {
                    setTimeout(() => $xetable.clearEdit(evnt));
                  }
                });
              }
            }
          }
        }
      } else if (mouseConfig) {
        if (!getEventTargetNode(evnt, el).flag && !($xegrid && getEventTargetNode(evnt, $xegrid.getRefMaps().refElem.value).flag) && !(tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) && !($xetoolbar && getEventTargetNode(evnt, $xetoolbar.getRefMaps().refElem.value).flag)) {
          if ($xetable.clearSelected) {
            $xetable.clearSelected();
          }
          if (areaOpts.autoClear) {
            if ($xetable.clearCellAreas) {
              if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-areas-clear").flag) {
                tablePrivateMethods.preventEvent(evnt, "event.clearAreas", {}, () => {
                  $xetable.clearCellAreas();
                  $xetable.clearCopyCellArea();
                });
              }
            }
          }
        }
      }
      if ($xetable.closeMenu) {
        if (ctxMenuStore.visible && tableMenu && !getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
          $xetable.closeMenu();
        }
      }
      const isActivated = getEventTargetNode(evnt, $xegrid ? $xegrid.getRefMaps().refElem.value : el).flag;
      if (!isActivated && editRules && validOpts.autoClear) {
        reactData.validErrorMaps = {};
      }
      internalData.isActivated = isActivated;
    };
    const handleGlobalBlurEvent = () => {
      tableMethods.closeFilter();
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
    };
    const handleGlobalMousewheelEvent = () => {
      tableMethods.closeTooltip();
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
    };
    const keydownEvent = (evnt) => {
      const { mouseConfig, keyboardConfig } = props;
      const { filterStore, ctxMenuStore, editStore } = reactData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
      if (isEsc) {
        tablePrivateMethods.preventEvent(evnt, "event.keydown", null, () => {
          tableMethods.dispatchEvent("keydown-start", {}, evnt);
          if (keyboardConfig && mouseConfig && mouseOpts.area && $xetable.handleKeyboardEvent) {
            $xetable.handleKeyboardEvent(evnt);
          } else if (actived.row || filterStore.visible || ctxMenuStore.visible) {
            evnt.stopPropagation();
            if ($xetable.closeMenu) {
              $xetable.closeMenu();
            }
            tableMethods.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              if (actived.row) {
                const params = actived.args;
                $xetable.clearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => $xetable.handleSelected(params, evnt));
                }
              }
            }
          }
          tableMethods.dispatchEvent("keydown", {}, evnt);
          tableMethods.dispatchEvent("keydown-end", {}, evnt);
        });
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      if (internalData.isActivated) {
        tablePrivateMethods.preventEvent(evnt, "event.keydown", null, () => {
          const { mouseConfig, keyboardConfig, treeConfig, editConfig, highlightCurrentRow } = props;
          const { ctxMenuStore, editStore, currentRow } = reactData;
          const isMenu = computeIsMenu.value;
          const bodyMenu = computeBodyMenu.value;
          const keyboardOpts = computeKeyboardOpts.value;
          const mouseOpts = computeMouseOpts.value;
          const editOpts = computeEditOpts.value;
          const treeOpts = computeTreeOpts.value;
          const menuList = computeMenuList.value;
          const rowOpts = computeRowOpts.value;
          const { selected, actived } = editStore;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const keyCode = evnt.keyCode;
          const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
          const isBack = hasEventKey(evnt, EVENT_KEYS.BACKSPACE);
          const isTab = hasEventKey(evnt, EVENT_KEYS.TAB);
          const isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);
          const isSpacebar = hasEventKey(evnt, EVENT_KEYS.SPACEBAR);
          const isLeftArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_LEFT);
          const isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
          const isRightArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_RIGHT);
          const isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
          const isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);
          const isF2 = hasEventKey(evnt, EVENT_KEYS.F2);
          const isContextMenu = hasEventKey(evnt, EVENT_KEYS.CONTEXT_MENU);
          const hasMetaKey = evnt.metaKey;
          const hasCtrlKey = evnt.ctrlKey;
          const hasShiftKey = evnt.shiftKey;
          const isAltKey = evnt.altKey;
          const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
          const operCtxMenu = isMenu && ctxMenuStore.visible && (isEnter || isSpacebar || operArrow);
          const isEditStatus = isEnableConf(editConfig) && actived.column && actived.row;
          let params;
          if (operCtxMenu) {
            evnt.preventDefault();
            if (ctxMenuStore.showChild && hasChildrenList(ctxMenuStore.selected)) {
              $xetable.moveCtxMenu(evnt, ctxMenuStore, "selectChild", isLeftArrow, false, ctxMenuStore.selected.children);
            } else {
              $xetable.moveCtxMenu(evnt, ctxMenuStore, "selected", isRightArrow, true, menuList);
            }
          } else if (keyboardConfig && mouseConfig && mouseOpts.area && $xetable.handleKeyboardEvent) {
            $xetable.handleKeyboardEvent(evnt);
          } else if (isEsc) {
            if ($xetable.closeMenu) {
              $xetable.closeMenu();
            }
            tableMethods.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              if (actived.row) {
                const params2 = actived.args;
                $xetable.clearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => $xetable.handleSelected(params2, evnt));
                }
              }
            }
          } else if (isSpacebar && keyboardConfig && keyboardOpts.isChecked && selected.row && selected.column && (selected.column.type === "checkbox" || selected.column.type === "radio")) {
            evnt.preventDefault();
            if (selected.column.type === "checkbox") {
              tablePrivateMethods.handleToggleCheckRowEvent(evnt, selected.args);
            } else {
              tablePrivateMethods.triggerRadioRowEvent(evnt, selected.args);
            }
          } else if (isF2 && isEnableConf(editConfig)) {
            if (!isEditStatus) {
              if (selected.row && selected.column) {
                evnt.preventDefault();
                $xetable.handleActived(selected.args, evnt);
              }
            }
          } else if (isContextMenu) {
            internalData._keyCtx = selected.row && selected.column && bodyMenu.length;
            clearTimeout(keyCtxTimeout);
            keyCtxTimeout = setTimeout(() => {
              internalData._keyCtx = false;
            }, 1e3);
          } else if (isEnter && !isAltKey && keyboardConfig && keyboardOpts.isEnter && (selected.row || actived.row || treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow)) {
            if (hasCtrlKey) {
              if (actived.row) {
                params = actived.args;
                $xetable.clearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => $xetable.handleSelected(params, evnt));
                }
              }
            } else {
              if (selected.row || actived.row) {
                const targetArgs = selected.row ? selected.args : actived.args;
                if (hasShiftKey) {
                  if (keyboardOpts.enterToTab) {
                    $xetable.moveTabSelected(targetArgs, hasShiftKey, evnt);
                  } else {
                    $xetable.moveSelected(targetArgs, isLeftArrow, true, isRightArrow, false, evnt);
                  }
                } else {
                  if (keyboardOpts.enterToTab) {
                    $xetable.moveTabSelected(targetArgs, hasShiftKey, evnt);
                  } else {
                    $xetable.moveSelected(targetArgs, isLeftArrow, false, isRightArrow, true, evnt);
                  }
                }
              } else if (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
                const childrens = currentRow[childrenField];
                if (childrens && childrens.length) {
                  evnt.preventDefault();
                  const targetRow = childrens[0];
                  params = {
                    $table: $xetable,
                    row: targetRow,
                    rowIndex: tableMethods.getRowIndex(targetRow),
                    $rowIndex: tableMethods.getVMRowIndex(targetRow)
                  };
                  tableMethods.setTreeExpand(currentRow, true).then(() => tableMethods.scrollToRow(targetRow)).then(() => tablePrivateMethods.triggerCurrentRowEvent(evnt, params));
                }
              }
            }
          } else if (operArrow && keyboardConfig && keyboardOpts.isArrow) {
            if (!isEditStatus) {
              if (selected.row && selected.column) {
                $xetable.moveSelected(selected.args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt);
              } else if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {
                $xetable.moveCurrentRow(isUpArrow, isDwArrow, evnt);
              }
            }
          } else if (isTab && keyboardConfig && keyboardOpts.isTab) {
            if (selected.row || selected.column) {
              $xetable.moveTabSelected(selected.args, hasShiftKey, evnt);
            } else if (actived.row || actived.column) {
              $xetable.moveTabSelected(actived.args, hasShiftKey, evnt);
            }
          } else if (keyboardConfig && isEnableConf(editConfig) && (isDel || (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow ? isBack && keyboardOpts.isArrow : isBack))) {
            if (!isEditStatus) {
              const { delMethod, backMethod } = keyboardOpts;
              if (keyboardOpts.isDel && (selected.row || selected.column)) {
                const delPaqrams = {
                  row: selected.row,
                  rowIndex: tableMethods.getRowIndex(selected.row),
                  column: selected.column,
                  columnIndex: tableMethods.getColumnIndex(selected.column),
                  $table: $xetable
                };
                if (delMethod) {
                  delMethod(delPaqrams);
                } else {
                  setCellValue(selected.row, selected.column, null);
                }
                if (isBack) {
                  if (backMethod) {
                    backMethod({
                      row: selected.row,
                      rowIndex: tableMethods.getRowIndex(selected.row),
                      column: selected.column,
                      columnIndex: tableMethods.getColumnIndex(selected.column),
                      $table: $xetable
                    });
                  } else {
                    $xetable.handleActived(selected.args, evnt);
                  }
                } else if (isDel) {
                  tableMethods.updateFooter();
                }
                $xetable.dispatchEvent("cell-delete-value", delPaqrams, evnt);
              } else if (isBack && keyboardOpts.isArrow && treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
                const { parent: parentRow } = import_xe_utils41.default.findTree(internalData.afterFullData, (item) => item === currentRow, { children: childrenField });
                if (parentRow) {
                  evnt.preventDefault();
                  params = {
                    $table: $xetable,
                    row: parentRow,
                    rowIndex: tableMethods.getRowIndex(parentRow),
                    $rowIndex: tableMethods.getVMRowIndex(parentRow)
                  };
                  tableMethods.setTreeExpand(parentRow, false).then(() => tableMethods.scrollToRow(parentRow)).then(() => tablePrivateMethods.triggerCurrentRowEvent(evnt, params));
                }
              }
            }
          } else if (keyboardConfig && isEnableConf(editConfig) && keyboardOpts.isEdit && !hasCtrlKey && !hasMetaKey && (isSpacebar || keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 96 && keyCode <= 111 || keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222)) {
            const { editMethod } = keyboardOpts;
            if (selected.column && selected.row && isEnableConf(selected.column.editRender)) {
              const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
              if (!beforeEditMethod || beforeEditMethod(Object.assign(Object.assign({}, selected.args), { $table: $xetable, $grid: $xegrid }))) {
                if (editMethod) {
                  editMethod({
                    row: selected.row,
                    rowIndex: tableMethods.getRowIndex(selected.row),
                    column: selected.column,
                    columnIndex: tableMethods.getColumnIndex(selected.column),
                    $table: $xetable,
                    $grid: $xegrid
                  });
                } else {
                  setCellValue(selected.row, selected.column, null);
                  $xetable.handleActived(selected.args, evnt);
                }
                const afterEditMethod = editOpts.afterEditMethod;
                if (afterEditMethod) {
                  nextTick(() => {
                    afterEditMethod({
                      row: selected.row,
                      rowIndex: tableMethods.getRowIndex(selected.row),
                      column: selected.column,
                      columnIndex: tableMethods.getColumnIndex(selected.column),
                      $table: $xetable,
                      $grid: $xegrid
                    });
                  });
                }
              }
            }
          }
          tableMethods.dispatchEvent("keydown", {}, evnt);
        });
      }
    };
    const handleGlobalPasteEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handlePasteCellAreaEvent) {
            $xetable.handlePasteCellAreaEvent(evnt);
          }
        }
        tableMethods.dispatchEvent("paste", {}, evnt);
      }
    };
    const handleGlobalCopyEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handleCopyCellAreaEvent) {
            $xetable.handleCopyCellAreaEvent(evnt);
          }
        }
        tableMethods.dispatchEvent("copy", {}, evnt);
      }
    };
    const handleGlobalCutEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handleCutCellAreaEvent) {
            $xetable.handleCutCellAreaEvent(evnt);
          }
        }
        tableMethods.dispatchEvent("cut", {}, evnt);
      }
    };
    const handleGlobalResizeEvent = () => {
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
      tableMethods.updateCellAreas();
      tableMethods.recalculate(true);
    };
    const handleTargetEnterEvent = (isClear) => {
      const $tooltip = refTooltip.value;
      clearTimeout(internalData.tooltipTimeout);
      if (isClear) {
        tableMethods.closeTooltip();
      } else {
        if ($tooltip) {
          $tooltip.setActived(true);
        }
      }
    };
    const handleTooltip = (evnt, cell, overflowElem, tipElem, params) => {
      params.cell = cell;
      const { tooltipStore } = reactData;
      const tooltipOpts = computeTooltipOpts.value;
      const { column, row } = params;
      const { showAll, contentMethod } = tooltipOpts;
      const customContent = contentMethod ? contentMethod(params) : null;
      const useCustom = contentMethod && !import_xe_utils41.default.eqNull(customContent);
      const content = useCustom ? customContent : import_xe_utils41.default.toString(column.type === "html" ? overflowElem.innerText : overflowElem.textContent).trim();
      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      if (content && (showAll || useCustom || isCellOverflow)) {
        Object.assign(tooltipStore, {
          row,
          column,
          visible: true
        });
        nextTick(() => {
          const $tooltip = refTooltip.value;
          if ($tooltip) {
            $tooltip.open(isCellOverflow ? overflowElem : tipElem || overflowElem, formatText(content));
          }
        });
      }
      return nextTick();
    };
    tablePrivateMethods = {
      getSetupOptions() {
        return conf_default;
      },
      updateAfterDataIndex,
      callSlot(slotFunc, params) {
        if (slotFunc) {
          if ($xegrid) {
            return $xegrid.callSlot(slotFunc, params);
          }
          if (import_xe_utils41.default.isFunction(slotFunc)) {
            return getSlotVNs(slotFunc(params));
          }
        }
        return [];
      },
      /**
       * 
       */
      getParentElem() {
        const el = refElem.value;
        if ($xegrid) {
          const gridEl = $xegrid.getRefMaps().refElem.value;
          return gridEl ? gridEl.parentNode : null;
        }
        return el ? el.parentNode : null;
      },
      /**
       * 
       */
      getParentHeight() {
        const { height } = props;
        const el = refElem.value;
        if (el) {
          const parentElem = el.parentNode;
          const parentPaddingSize = height === "100%" || height === "auto" ? getPaddingTopBottomSize(parentElem) : 0;
          return Math.floor($xegrid ? $xegrid.getParentHeight() : import_xe_utils41.default.toNumber(getComputedStyle(parentElem).height) - parentPaddingSize);
        }
        return 0;
      },
      /**
       * 
       * 
       * 
       */
      getExcludeHeight() {
        return $xegrid ? $xegrid.getExcludeHeight() : 0;
      },
      /**
       * 
       * @param {Row} records 
       */
      defineField(records) {
        const { treeConfig } = props;
        const expandOpts = computeExpandOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const rowkey = getRowkey($xetable);
        if (!import_xe_utils41.default.isArray(records)) {
          records = [records];
        }
        return records.map((record) => {
          internalData.tableFullColumn.forEach((column) => {
            const { field, editRender } = column;
            if (field && !import_xe_utils41.default.has(record, field) && !record[field]) {
              let cellValue = null;
              if (editRender) {
                const { defaultValue } = editRender;
                if (import_xe_utils41.default.isFunction(defaultValue)) {
                  cellValue = defaultValue({ column });
                } else if (!import_xe_utils41.default.isUndefined(defaultValue)) {
                  cellValue = defaultValue;
                }
              }
              import_xe_utils41.default.set(record, field, cellValue);
            }
          });
          const otherFields = [radioOpts.labelField, checkboxOpts.checkField, checkboxOpts.labelField, expandOpts.labelField];
          otherFields.forEach((key) => {
            if (key && eqEmptyValue(import_xe_utils41.default.get(record, key))) {
              import_xe_utils41.default.set(record, key, null);
            }
          });
          if (treeConfig && treeOpts.lazy && import_xe_utils41.default.isUndefined(record[childrenField])) {
            record[childrenField] = null;
          }
          if (eqEmptyValue(import_xe_utils41.default.get(record, rowkey))) {
            import_xe_utils41.default.set(record, rowkey, getRowUniqueId());
          }
          return record;
        });
      },
      handleTableData(force) {
        const { scrollYLoad } = reactData;
        const { scrollYStore, fullDataRowIdData } = internalData;
        let fullList = internalData.afterFullData;
        if (force) {
          updateAfterFullData();
          fullList = handleVirtualTreeToList();
        }
        const tableData = scrollYLoad ? fullList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullList.slice(0);
        tableData.forEach((row, $index) => {
          const rowid = getRowid($xetable, row);
          const rest = fullDataRowIdData[rowid];
          if (rest) {
            rest.$index = $index;
          }
        });
        reactData.tableData = tableData;
        return nextTick();
      },
      /**
       *  Map
       * 
       */
      cacheRowMap(isSource) {
        const { treeConfig } = props;
        const treeOpts = computeTreeOpts.value;
        const { fullAllDataRowIdData, tableFullData, tableFullTreeData } = internalData;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const rowkey = getRowkey($xetable);
        const isLazy = treeConfig && treeOpts.lazy;
        const fullAllDataRowIdMaps = {};
        const fullDataRowIdMaps = {};
        const handleRow = (row, index, items, path, parent, nodes) => {
          let rowid = getRowid($xetable, row);
          const seq = treeConfig && path ? toTreePathSeq(path) : index + 1;
          const level = nodes ? nodes.length - 1 : 0;
          if (eqEmptyValue(rowid)) {
            rowid = getRowUniqueId();
            import_xe_utils41.default.set(row, rowkey, rowid);
          }
          if (isLazy && row[hasChildField] && import_xe_utils41.default.isUndefined(row[childrenField])) {
            row[childrenField] = null;
          }
          let cacheItem = fullAllDataRowIdData[rowid];
          if (!cacheItem) {
            cacheItem = { row, rowid, seq, index: -1, _index: -1, $index: -1, items, parent, level };
          }
          if (isSource) {
            cacheItem.index = treeConfig && parent ? -1 : index;
            fullDataRowIdMaps[rowid] = cacheItem;
          }
          fullAllDataRowIdMaps[rowid] = cacheItem;
        };
        if (isSource) {
          internalData.fullDataRowIdData = fullDataRowIdMaps;
        }
        internalData.fullAllDataRowIdData = fullAllDataRowIdMaps;
        if (treeConfig) {
          import_xe_utils41.default.eachTree(tableFullTreeData, handleRow, { children: childrenField });
        } else {
          tableFullData.forEach(handleRow);
        }
      },
      cacheSourceMap(fullData) {
        const { treeConfig } = props;
        const treeOpts = computeTreeOpts.value;
        let { sourceDataRowIdData } = internalData;
        const sourceData = import_xe_utils41.default.clone(fullData, true);
        const rowkey = getRowkey($xetable);
        sourceDataRowIdData = internalData.sourceDataRowIdData = {};
        const handleSourceRow = (row) => {
          let rowid = getRowid($xetable, row);
          if (eqEmptyValue(rowid)) {
            rowid = getRowUniqueId();
            import_xe_utils41.default.set(row, rowkey, rowid);
          }
          sourceDataRowIdData[rowid] = row;
        };
        if (treeConfig) {
          const childrenField = treeOpts.children || treeOpts.childrenField;
          import_xe_utils41.default.eachTree(sourceData, handleSourceRow, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });
        } else {
          sourceData.forEach(handleSourceRow);
        }
        internalData.tableSourceData = sourceData;
      },
      /**
       * 
       */
      analyColumnWidth() {
        const { tableFullColumn } = internalData;
        const columnOpts = computeColumnOpts.value;
        const { width: defaultWidth, minWidth: defaultMinWidth } = columnOpts;
        const resizeList = [];
        const pxList = [];
        const pxMinList = [];
        const scaleList = [];
        const scaleMinList = [];
        const autoList = [];
        tableFullColumn.forEach((column) => {
          if (defaultWidth && !column.width) {
            column.width = defaultWidth;
          }
          if (defaultMinWidth && !column.minWidth) {
            column.minWidth = defaultMinWidth;
          }
          if (column.visible) {
            if (column.resizeWidth) {
              resizeList.push(column);
            } else if (isPx(column.width)) {
              pxList.push(column);
            } else if (isScale(column.width)) {
              scaleList.push(column);
            } else if (isPx(column.minWidth)) {
              pxMinList.push(column);
            } else if (isScale(column.minWidth)) {
              scaleMinList.push(column);
            } else {
              autoList.push(column);
            }
          }
        });
        Object.assign(reactData.columnStore, { resizeList, pxList, pxMinList, scaleList, scaleMinList, autoList });
      },
      saveCustomResizable(isReset) {
        const { id, customConfig } = props;
        const customOpts = computeCustomOpts.value;
        const { collectColumn } = internalData;
        const { storage } = customOpts;
        const isAllStorage = storage === true;
        const storageOpts = isAllStorage ? {} : Object.assign({}, storage || {});
        const isResizable = isAllStorage || storageOpts.resizable;
        if (customConfig && isResizable) {
          const columnWidthStorageMap = getCustomStorageMap(resizableStorageKey);
          let columnWidthStorage;
          if (!id) {
            errLog("vxe.error.reqProp", ["id"]);
            return;
          }
          if (!isReset) {
            columnWidthStorage = import_xe_utils41.default.isPlainObject(columnWidthStorageMap[id]) ? columnWidthStorageMap[id] : {};
            import_xe_utils41.default.eachTree(collectColumn, (column) => {
              if (column.resizeWidth) {
                const colKey = column.getKey();
                if (colKey) {
                  columnWidthStorage[colKey] = column.renderWidth;
                }
              }
            });
          }
          columnWidthStorageMap[id] = import_xe_utils41.default.isEmpty(columnWidthStorage) ? void 0 : columnWidthStorage;
          localStorage.setItem(resizableStorageKey, import_xe_utils41.default.toJSONString(columnWidthStorageMap));
        }
      },
      saveCustomSort(isReset) {
        const { id, customConfig } = props;
        const customOpts = computeCustomOpts.value;
        const { collectColumn } = internalData;
        const { storage } = customOpts;
        const isAllStorage = storage === true;
        const storageOpts = isAllStorage ? {} : Object.assign({}, storage || {});
        const isSort = isAllStorage || storageOpts.sort;
        if (customConfig && isSort) {
          const columnSortStorageMap = getCustomStorageMap(sortStorageKey);
          let columnWidthStorage;
          if (!id) {
            errLog("vxe.error.reqProp", ["id"]);
            return;
          }
          if (!isReset) {
            columnWidthStorage = import_xe_utils41.default.isPlainObject(columnSortStorageMap[id]) ? columnSortStorageMap[id] : {};
            collectColumn.forEach((column) => {
              if (column.sortNumber !== column.renderSortNumber) {
                const colKey = column.getKey();
                if (colKey) {
                  columnWidthStorage[colKey] = column.renderSortNumber;
                }
              }
            });
          }
          columnSortStorageMap[id] = import_xe_utils41.default.isEmpty(columnWidthStorage) ? void 0 : columnWidthStorage;
          localStorage.setItem(sortStorageKey, import_xe_utils41.default.toJSONString(columnSortStorageMap));
        }
      },
      saveCustomFixed() {
        const { id, customConfig } = props;
        const { collectColumn } = internalData;
        const customOpts = computeCustomOpts.value;
        const { storage } = customOpts;
        const isAllStorage = storage === true;
        const storageOpts = isAllStorage ? {} : Object.assign({}, storage || {});
        const isCustomFixed = isAllStorage || storageOpts.fixed;
        if (customConfig && isCustomFixed) {
          const columnFixedStorageMap = getCustomStorageMap(fixedStorageKey);
          const colFixeds = [];
          if (!id) {
            errLog("vxe.error.reqProp", ["id"]);
            return;
          }
          import_xe_utils41.default.eachTree(collectColumn, (column) => {
            if (column.fixed && column.fixed !== column.defaultFixed) {
              const colKey = column.getKey();
              if (colKey) {
                colFixeds.push(`${colKey}|${column.fixed}`);
              }
            }
          });
          columnFixedStorageMap[id] = colFixeds.join(",") || void 0;
          localStorage.setItem(fixedStorageKey, import_xe_utils41.default.toJSONString(columnFixedStorageMap));
        }
      },
      saveCustomVisible() {
        const { id, customConfig } = props;
        const { collectColumn } = internalData;
        const customOpts = computeCustomOpts.value;
        const { checkMethod, storage } = customOpts;
        const isAllStorage = storage === true;
        const storageOpts = isAllStorage ? {} : Object.assign({}, storage || {});
        const isCustomVisible = isAllStorage || storageOpts.visible;
        if (customConfig && isCustomVisible) {
          const columnVisibleStorageMap = getCustomStorageMap(visibleStorageKey);
          const colHides = [];
          const colShows = [];
          if (!id) {
            errLog("vxe.error.reqProp", ["id"]);
            return;
          }
          import_xe_utils41.default.eachTree(collectColumn, (column) => {
            if (!checkMethod || checkMethod({ column })) {
              if (!column.visible && column.defaultVisible) {
                const colKey = column.getKey();
                if (colKey) {
                  colHides.push(colKey);
                }
              } else if (column.visible && !column.defaultVisible) {
                const colKey = column.getKey();
                if (colKey) {
                  colShows.push(colKey);
                }
              }
            }
          });
          columnVisibleStorageMap[id] = [colHides.join(",")].concat(colShows.length ? [colShows.join(",")] : []).join("|") || void 0;
          localStorage.setItem(visibleStorageKey, import_xe_utils41.default.toJSONString(columnVisibleStorageMap));
        }
      },
      handleCustom() {
        const { mouseConfig } = props;
        if (mouseConfig) {
          if ($xetable.clearSelected) {
            $xetable.clearSelected();
          }
          if ($xetable.clearCellAreas) {
            $xetable.clearCellAreas();
            $xetable.clearCopyCellArea();
          }
        }
        tablePrivateMethods.saveCustomVisible();
        tablePrivateMethods.saveCustomSort();
        tablePrivateMethods.analyColumnWidth();
        return tableMethods.refreshColumn(true);
      },
      handleUpdateDataQueue() {
        reactData.upDataFlag++;
      },
      handleRefreshColumnQueue() {
        reactData.reColumnFlag++;
      },
      preventEvent(evnt, type, args, next, end) {
        let evntList = VXETable.interceptor.get(type);
        if (!evntList.length && type === "event.clearEdit") {
          evntList = VXETable.interceptor.get("event.clearActived");
          if (true) {
            if (evntList.length) {
              warnLog("vxe.error.delEvent", ["event.clearActived", "event.clearEdit"]);
            }
          }
        }
        let rest;
        if (!evntList.some((func) => func(Object.assign({ $grid: $xegrid, $table: $xetable, $event: evnt }, args)) === false)) {
          if (next) {
            rest = next();
          }
        }
        if (end) {
          end();
        }
        return rest;
      },
      checkSelectionStatus() {
        const { treeConfig } = props;
        const { selectCheckboxMaps, treeIndeterminateMaps } = reactData;
        const { afterFullData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkStrictly, checkMethod } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        if (!checkStrictly) {
          const disableRows = [];
          const checkRows = [];
          let isAllResolve = false;
          let isAllSelected = false;
          let isIndeterminate = false;
          if (checkField) {
            isAllResolve = afterFullData.every(checkMethod ? (row) => {
              if (!checkMethod({ row })) {
                disableRows.push(row);
                return true;
              }
              if (import_xe_utils41.default.get(row, checkField)) {
                checkRows.push(row);
                return true;
              }
              return false;
            } : (row) => import_xe_utils41.default.get(row, checkField));
            isAllSelected = isAllResolve && afterFullData.length !== disableRows.length;
            if (treeConfig) {
              if (indeterminateField) {
                isIndeterminate = !isAllSelected && afterFullData.some((row) => import_xe_utils41.default.get(row, checkField) || import_xe_utils41.default.get(row, indeterminateField) || !!treeIndeterminateMaps[getRowid($xetable, row)]);
              } else {
                isIndeterminate = !isAllSelected && afterFullData.some((row) => import_xe_utils41.default.get(row, checkField) || !!treeIndeterminateMaps[getRowid($xetable, row)]);
              }
            } else {
              if (indeterminateField) {
                isIndeterminate = !isAllSelected && afterFullData.some((row) => import_xe_utils41.default.get(row, checkField) || import_xe_utils41.default.get(row, indeterminateField));
              } else {
                isIndeterminate = !isAllSelected && afterFullData.some((row) => import_xe_utils41.default.get(row, checkField));
              }
            }
          } else {
            isAllResolve = afterFullData.every(checkMethod ? (row) => {
              if (!checkMethod({ row })) {
                disableRows.push(row);
                return true;
              }
              if (selectCheckboxMaps[getRowid($xetable, row)]) {
                checkRows.push(row);
                return true;
              }
              return false;
            } : (row) => selectCheckboxMaps[getRowid($xetable, row)]);
            isAllSelected = isAllResolve && afterFullData.length !== disableRows.length;
            if (treeConfig) {
              isIndeterminate = !isAllSelected && afterFullData.some((row) => {
                const itemRid = getRowid($xetable, row);
                return treeIndeterminateMaps[itemRid] || selectCheckboxMaps[itemRid];
              });
            } else {
              isIndeterminate = !isAllSelected && afterFullData.some((row) => selectCheckboxMaps[getRowid($xetable, row)]);
            }
          }
          reactData.isAllSelected = isAllSelected;
          reactData.isIndeterminate = isIndeterminate;
        }
      },
      /**
       * 
       * value true false -1
       */
      handleSelectRow({ row }, value, isForce) {
        const { treeConfig } = props;
        const { selectCheckboxMaps, treeIndeterminateMaps } = reactData;
        const selectRowMaps = Object.assign({}, selectCheckboxMaps);
        const { afterFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkStrictly, checkMethod } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        const rowid = getRowid($xetable, row);
        if (checkField) {
          if (treeConfig && !checkStrictly) {
            if (value === -1) {
              if (!treeIndeterminateMaps[rowid]) {
                if (indeterminateField) {
                  import_xe_utils41.default.set(row, indeterminateField, true);
                }
                treeIndeterminateMaps[rowid] = row;
              }
              import_xe_utils41.default.set(row, checkField, false);
            } else {
              import_xe_utils41.default.eachTree([row], (item) => {
                if ($xetable.eqRow(item, row) || (isForce || (!checkMethod || checkMethod({ row: item })))) {
                  import_xe_utils41.default.set(item, checkField, value);
                  if (indeterminateField) {
                    import_xe_utils41.default.set(row, indeterminateField, false);
                  }
                  delete treeIndeterminateMaps[getRowid($xetable, item)];
                  handleCheckboxReserveRow(row, value);
                }
              }, { children: childrenField });
            }
            const matchObj = import_xe_utils41.default.findTree(afterFullData, (item) => $xetable.eqRow(item, row), { children: childrenField });
            if (matchObj && matchObj.parent) {
              let parentStatus;
              const vItems = [];
              const vItemMaps = {};
              if (!isForce && checkMethod) {
                matchObj.items.forEach((item) => {
                  if (checkMethod({ row: item })) {
                    const itemRid = getRowid($xetable, item);
                    vItemMaps[itemRid] = item;
                    vItems.push(item);
                  }
                });
              } else {
                matchObj.items.forEach((item) => {
                  const itemRid = getRowid($xetable, item);
                  vItemMaps[itemRid] = item;
                  vItems.push(item);
                });
              }
              const indeterminatesItem = import_xe_utils41.default.find(matchObj.items, (item) => !!treeIndeterminateMaps[getRowid($xetable, item)]);
              if (indeterminatesItem) {
                parentStatus = -1;
              } else {
                const selectItems = [];
                matchObj.items.forEach((item) => {
                  if (import_xe_utils41.default.get(item, checkField)) {
                    selectItems.push(item);
                  }
                });
                parentStatus = selectItems.filter((item) => vItemMaps[getRowid($xetable, item)]).length === vItems.length ? true : selectItems.length || value === -1 ? -1 : false;
              }
              reactData.selectCheckboxMaps = selectRowMaps;
              return tablePrivateMethods.handleSelectRow({ row: matchObj.parent }, parentStatus, isForce);
            }
          } else {
            if (isForce || (!checkMethod || checkMethod({ row }))) {
              import_xe_utils41.default.set(row, checkField, value);
              handleCheckboxReserveRow(row, value);
            }
          }
        } else {
          if (treeConfig && !checkStrictly) {
            if (value === -1) {
              if (!treeIndeterminateMaps[rowid]) {
                if (indeterminateField) {
                  import_xe_utils41.default.set(row, indeterminateField, true);
                }
                treeIndeterminateMaps[rowid] = row;
              }
              if (selectRowMaps[rowid]) {
                delete selectRowMaps[rowid];
              }
            } else {
              import_xe_utils41.default.eachTree([row], (item) => {
                const itemRid = getRowid($xetable, item);
                if ($xetable.eqRow(item, row) || (isForce || (!checkMethod || checkMethod({ row: item })))) {
                  if (value) {
                    selectRowMaps[itemRid] = item;
                  } else {
                    if (selectRowMaps[itemRid]) {
                      delete selectRowMaps[itemRid];
                    }
                  }
                  if (indeterminateField) {
                    import_xe_utils41.default.set(row, indeterminateField, false);
                  }
                  delete treeIndeterminateMaps[getRowid($xetable, item)];
                  handleCheckboxReserveRow(row, value);
                }
              }, { children: childrenField });
            }
            const matchObj = import_xe_utils41.default.findTree(afterFullData, (item) => $xetable.eqRow(item, row), { children: childrenField });
            if (matchObj && matchObj.parent) {
              let parentStatus;
              const vItems = [];
              const vItemMaps = {};
              if (!isForce && checkMethod) {
                matchObj.items.forEach((item) => {
                  if (checkMethod({ row: item })) {
                    const itemRid = getRowid($xetable, item);
                    vItemMaps[itemRid] = item;
                    vItems.push(item);
                  }
                });
              } else {
                matchObj.items.forEach((item) => {
                  const itemRid = getRowid($xetable, item);
                  vItemMaps[itemRid] = item;
                  vItems.push(item);
                });
              }
              const indeterminatesItem = import_xe_utils41.default.find(matchObj.items, (item) => !!treeIndeterminateMaps[getRowid($xetable, item)]);
              if (indeterminatesItem) {
                parentStatus = -1;
              } else {
                const selectItems = [];
                matchObj.items.forEach((item) => {
                  const itemRid = getRowid($xetable, item);
                  if (selectRowMaps[itemRid]) {
                    selectItems.push(item);
                  }
                });
                parentStatus = selectItems.filter((item) => vItemMaps[getRowid($xetable, item)]).length === vItems.length ? true : selectItems.length || value === -1 ? -1 : false;
              }
              reactData.selectCheckboxMaps = selectRowMaps;
              return tablePrivateMethods.handleSelectRow({ row: matchObj.parent }, parentStatus, isForce);
            }
          } else {
            if (isForce || (!checkMethod || checkMethod({ row }))) {
              if (value) {
                if (!selectRowMaps[rowid]) {
                  selectRowMaps[rowid] = row;
                }
              } else {
                if (selectRowMaps[rowid]) {
                  delete selectRowMaps[rowid];
                }
              }
              handleCheckboxReserveRow(row, value);
            }
          }
        }
        reactData.selectCheckboxMaps = selectRowMaps;
        tablePrivateMethods.checkSelectionStatus();
      },
      triggerHeaderTitleEvent(evnt, iconParams, params) {
        const tipContent = iconParams.content || iconParams.message;
        if (tipContent) {
          const { tooltipStore } = reactData;
          const { column } = params;
          const content = getFuncText(tipContent);
          handleTargetEnterEvent(true);
          tooltipStore.row = null;
          tooltipStore.column = column;
          tooltipStore.visible = true;
          nextTick(() => {
            const $tooltip = refTooltip.value;
            if ($tooltip) {
              $tooltip.open(evnt.currentTarget, content);
            }
          });
        }
      },
      /**
       *  tooltip 
       */
      triggerHeaderTooltipEvent(evnt, params) {
        const { tooltipStore } = reactData;
        const { column } = params;
        const titleElem = evnt.currentTarget;
        handleTargetEnterEvent(true);
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          handleTooltip(evnt, titleElem, titleElem, null, params);
        }
      },
      /**
       *  tooltip 
       */
      triggerBodyTooltipEvent(evnt, params) {
        const { editConfig } = props;
        const { editStore } = reactData;
        const { tooltipStore } = reactData;
        const editOpts = computeEditOpts.value;
        const { actived } = editStore;
        const { row, column } = params;
        const cell = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column || tooltipStore.row !== row);
        if (column.editRender && isEnableConf(editConfig)) {
          if (editOpts.mode === "row" && actived.row === row) {
            return;
          }
          if (actived.row === row && actived.column === column) {
            return;
          }
        }
        if (tooltipStore.column !== column || tooltipStore.row !== row || !tooltipStore.visible) {
          let overflowElem;
          let tipElem;
          if (column.treeNode) {
            overflowElem = cell.querySelector(".vxe-tree-cell");
            if (column.type === "html") {
              tipElem = cell.querySelector(".vxe-cell--html");
            }
          } else {
            tipElem = cell.querySelector(column.type === "html" ? ".vxe-cell--html" : ".vxe-cell--label");
          }
          handleTooltip(evnt, cell, overflowElem || cell.children[0], tipElem, params);
        }
      },
      /**
       *  tooltip 
       */
      triggerFooterTooltipEvent(evnt, params) {
        const { column } = params;
        const { tooltipStore } = reactData;
        const cell = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column || !!tooltipStore.row);
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          handleTooltip(evnt, cell, cell.querySelector(".vxe-cell--item") || cell.children[0], null, params);
        }
      },
      handleTargetLeaveEvent() {
        const tooltipOpts = computeTooltipOpts.value;
        let $tooltip = refTooltip.value;
        if ($tooltip) {
          $tooltip.setActived(false);
        }
        if (tooltipOpts.enterable) {
          internalData.tooltipTimeout = setTimeout(() => {
            $tooltip = refTooltip.value;
            if ($tooltip && !$tooltip.isActived()) {
              tableMethods.closeTooltip();
            }
          }, tooltipOpts.leaveDelay);
        } else {
          tableMethods.closeTooltip();
        }
      },
      triggerHeaderCellClickEvent(evnt, params) {
        const { _lastResizeTime } = internalData;
        const sortOpts = computeSortOpts.value;
        const columnOpts = computeColumnOpts.value;
        const { column } = params;
        const cell = evnt.currentTarget;
        const triggerResizable = _lastResizeTime && _lastResizeTime > Date.now() - 300;
        const triggerSort = getEventTargetNode(evnt, cell, "vxe-cell--sort").flag;
        const triggerFilter = getEventTargetNode(evnt, cell, "vxe-cell--filter").flag;
        if (sortOpts.trigger === "cell" && !(triggerResizable || triggerSort || triggerFilter)) {
          tablePrivateMethods.triggerSortEvent(evnt, column, getNextSortOrder(column));
        }
        tableMethods.dispatchEvent("header-cell-click", Object.assign({ triggerResizable, triggerSort, triggerFilter, cell }, params), evnt);
        if (columnOpts.isCurrent || props.highlightCurrentColumn) {
          tableMethods.setCurrentColumn(column);
        }
      },
      triggerHeaderCellDblclickEvent(evnt, params) {
        tableMethods.dispatchEvent("header-cell-dblclick", Object.assign({ cell: evnt.currentTarget }, params), evnt);
      },
      /**
       * 
       * 
       * 
       */
      triggerCellClickEvent(evnt, params) {
        const { highlightCurrentRow, editConfig } = props;
        const { editStore } = reactData;
        const expandOpts = computeExpandOpts.value;
        const editOpts = computeEditOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const keyboardOpts = computeKeyboardOpts.value;
        const rowOpts = computeRowOpts.value;
        const { actived, focused } = editStore;
        const { row, column } = params;
        const { type, treeNode } = column;
        const isRadioType = type === "radio";
        const isCheckboxType = type === "checkbox";
        const isExpandType = type === "expand";
        const cell = evnt.currentTarget;
        const triggerRadio = isRadioType && getEventTargetNode(evnt, cell, "vxe-cell--radio").flag;
        const triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, "vxe-tree--btn-wrapper").flag;
        const triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, "vxe-table--expanded").flag;
        params = Object.assign({ cell, triggerRadio, triggerCheckbox, triggerTreeNode, triggerExpandNode }, params);
        if (!triggerCheckbox && !triggerRadio) {
          if (!triggerExpandNode && (expandOpts.trigger === "row" || isExpandType && expandOpts.trigger === "cell")) {
            tablePrivateMethods.triggerRowExpandEvent(evnt, params);
          }
          if (treeOpts.trigger === "row" || treeNode && treeOpts.trigger === "cell") {
            tablePrivateMethods.triggerTreeExpandEvent(evnt, params);
          }
        }
        if (!triggerTreeNode) {
          if (!triggerExpandNode) {
            if (rowOpts.isCurrent || highlightCurrentRow) {
              if (!triggerCheckbox && !triggerRadio) {
                tablePrivateMethods.triggerCurrentRowEvent(evnt, params);
              }
            }
            if (!triggerRadio && (radioOpts.trigger === "row" || isRadioType && radioOpts.trigger === "cell")) {
              tablePrivateMethods.triggerRadioRowEvent(evnt, params);
            }
            if (!triggerCheckbox && (checkboxOpts.trigger === "row" || isCheckboxType && checkboxOpts.trigger === "cell")) {
              tablePrivateMethods.handleToggleCheckRowEvent(evnt, params);
            }
          }
          if (isEnableConf(editConfig)) {
            if (keyboardOpts.arrowCursorLock && evnt && editOpts.mode === "cell" && evnt.target && /^input|textarea$/i.test(evnt.target.tagName)) {
              focused.column = column;
              focused.row = row;
            }
            if (editOpts.trigger === "manual") {
              if (actived.args && actived.row === row && column !== actived.column) {
                handleChangeCell(evnt, params);
              }
            } else if (!actived.args || row !== actived.row || column !== actived.column) {
              if (editOpts.trigger === "click") {
                handleChangeCell(evnt, params);
              } else if (editOpts.trigger === "dblclick") {
                if (editOpts.mode === "row" && actived.row === row) {
                  handleChangeCell(evnt, params);
                }
              }
            }
          }
        }
        tableMethods.dispatchEvent("cell-click", params, evnt);
      },
      /**
       * 
       * 
       */
      triggerCellDblclickEvent(evnt, params) {
        const { editConfig } = props;
        const { editStore } = reactData;
        const editOpts = computeEditOpts.value;
        const { actived } = editStore;
        const cell = evnt.currentTarget;
        params = Object.assign({ cell }, params);
        if (isEnableConf(editConfig) && editOpts.trigger === "dblclick") {
          if (!actived.args || evnt.currentTarget !== actived.args.cell) {
            if (editOpts.mode === "row") {
              checkValidate("blur").catch((e) => e).then(() => {
                $xetable.handleActived(params, evnt).then(() => checkValidate("change")).catch((e) => e);
              });
            } else if (editOpts.mode === "cell") {
              $xetable.handleActived(params, evnt).then(() => checkValidate("change")).catch((e) => e);
            }
          }
        }
        tableMethods.dispatchEvent("cell-dblclick", params, evnt);
      },
      handleToggleCheckRowEvent(evnt, params) {
        const { selectCheckboxMaps } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        const { row } = params;
        let value = false;
        if (checkField) {
          value = !import_xe_utils41.default.get(row, checkField);
        } else {
          value = !selectCheckboxMaps[getRowid($xetable, row)];
        }
        if (evnt) {
          tablePrivateMethods.triggerCheckRowEvent(evnt, params, value);
        } else {
          tablePrivateMethods.handleSelectRow(params, value);
        }
      },
      triggerCheckRowEvent(evnt, params, value) {
        const checkboxOpts = computeCheckboxOpts.value;
        const { row } = params;
        const { afterFullData } = internalData;
        const { checkMethod } = checkboxOpts;
        if (checkboxOpts.isShiftKey && evnt.shiftKey && !props.treeConfig) {
          const checkboxRecords = tableMethods.getCheckboxRecords();
          if (checkboxRecords.length) {
            const firstRow = checkboxRecords[0];
            const _rowIndex = tableMethods.getVTRowIndex(row);
            const _firstRowIndex = tableMethods.getVTRowIndex(firstRow);
            if (_rowIndex !== _firstRowIndex) {
              tableMethods.setAllCheckboxRow(false);
              const rangeRows = _rowIndex < _firstRowIndex ? afterFullData.slice(_rowIndex, _firstRowIndex + 1) : afterFullData.slice(_firstRowIndex, _rowIndex + 1);
              handleCheckedCheckboxRow(rangeRows, true, false);
              tableMethods.dispatchEvent("checkbox-range-select", Object.assign({ rangeRecords: rangeRows }, params), evnt);
              return;
            }
          }
        }
        if (!checkMethod || checkMethod({ row })) {
          tablePrivateMethods.handleSelectRow(params, value);
          tableMethods.dispatchEvent("checkbox-change", Object.assign({
            records: tableMethods.getCheckboxRecords(),
            reserves: tableMethods.getCheckboxReserveRecords(),
            indeterminates: tableMethods.getCheckboxIndeterminateRecords(),
            checked: value
          }, params), evnt);
        }
      },
      /**
       * 
       */
      triggerCheckAllEvent(evnt, value) {
        handleCheckedAllCheckboxRow(value);
        if (evnt) {
          tableMethods.dispatchEvent("checkbox-all", {
            records: tableMethods.getCheckboxRecords(),
            reserves: tableMethods.getCheckboxReserveRecords(),
            indeterminates: tableMethods.getCheckboxIndeterminateRecords(),
            checked: value
          }, evnt);
        }
      },
      /**
       * 
       */
      triggerRadioRowEvent(evnt, params) {
        const { selectRadioRow: oldValue } = reactData;
        const { row } = params;
        const radioOpts = computeRadioOpts.value;
        let newValue = row;
        let isChange = oldValue !== newValue;
        if (isChange) {
          handleCheckedRadioRow(newValue);
        } else if (!radioOpts.strict) {
          isChange = oldValue === newValue;
          if (isChange) {
            newValue = null;
            tableMethods.clearRadioRow();
          }
        }
        if (isChange) {
          tableMethods.dispatchEvent("radio-change", Object.assign({ oldValue, newValue }, params), evnt);
        }
      },
      triggerCurrentRowEvent(evnt, params) {
        const { currentRow: oldValue } = reactData;
        const { row: newValue } = params;
        const isChange = oldValue !== newValue;
        tableMethods.setCurrentRow(newValue);
        if (isChange) {
          tableMethods.dispatchEvent("current-change", Object.assign({ oldValue, newValue }, params), evnt);
        }
      },
      /**
       * 
       */
      triggerRowExpandEvent(evnt, params) {
        const { rowExpandLazyLoadedMaps, expandColumn: column } = reactData;
        const expandOpts = computeExpandOpts.value;
        const { row } = params;
        const { lazy } = expandOpts;
        const rowid = getRowid($xetable, row);
        if (!lazy || !rowExpandLazyLoadedMaps[rowid]) {
          const expanded = !tableMethods.isRowExpandByRow(row);
          const columnIndex = tableMethods.getColumnIndex(column);
          const $columnIndex = tableMethods.getVMColumnIndex(column);
          tableMethods.setRowExpand(row, expanded);
          tableMethods.dispatchEvent("toggle-row-expand", {
            expanded,
            column,
            columnIndex,
            $columnIndex,
            row,
            rowIndex: tableMethods.getRowIndex(row),
            $rowIndex: tableMethods.getVMRowIndex(row)
          }, evnt);
        }
      },
      /**
       * 
       */
      triggerTreeExpandEvent(evnt, params) {
        const { treeExpandLazyLoadedMaps } = reactData;
        const treeOpts = computeTreeOpts.value;
        const { row, column } = params;
        const { lazy } = treeOpts;
        const rowid = getRowid($xetable, row);
        if (!lazy || !treeExpandLazyLoadedMaps[rowid]) {
          const expanded = !tableMethods.isTreeExpandByRow(row);
          const columnIndex = tableMethods.getColumnIndex(column);
          const $columnIndex = tableMethods.getVMColumnIndex(column);
          tableMethods.setTreeExpand(row, expanded);
          tableMethods.dispatchEvent("toggle-tree-expand", { expanded, column, columnIndex, $columnIndex, row }, evnt);
        }
      },
      /**
       * 
       */
      triggerSortEvent(evnt, column, order) {
        const { mouseConfig } = props;
        const sortOpts = computeSortOpts.value;
        const mouseOpts = computeMouseOpts.value;
        const { field, sortable } = column;
        if (sortable) {
          if (!order || column.order === order) {
            tableMethods.clearSort(sortOpts.multiple ? column : null);
          } else {
            tableMethods.sort({ field, order });
          }
          const params = { $table: $xetable, $event: evnt, column, field, property: field, order: column.order, sortList: tableMethods.getSortColumns(), sortTime: column.sortTime };
          if (mouseConfig && mouseOpts.area && $xetable.handleSortEvent) {
            $xetable.handleSortEvent(evnt, params);
          }
          tableMethods.dispatchEvent("sort-change", params, evnt);
        }
      },
      /**
       *  X 
       */
      triggerScrollXEvent() {
        loadScrollXData();
      },
      /**
       *  Y 
       */
      triggerScrollYEvent(evnt) {
        const { scrollYStore } = internalData;
        const { adaptive, offsetSize, visibleSize } = scrollYStore;
        if (isWebkit && adaptive && offsetSize * 2 + visibleSize <= 40) {
          loadScrollYData(evnt);
        } else {
          debounceScrollY(evnt);
        }
      },
      /**
       * 
       * 
       * @param {Row} row 
       */
      scrollToTreeRow(row) {
        const { treeConfig } = props;
        const { tableFullData } = internalData;
        const rests = [];
        if (treeConfig) {
          const treeOpts = computeTreeOpts.value;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const matchObj = import_xe_utils41.default.findTree(tableFullData, (item) => $xetable.eqRow(item, row), { children: childrenField });
          if (matchObj) {
            const nodes = matchObj.nodes;
            nodes.forEach((row2, index) => {
              if (index < nodes.length - 1 && !tableMethods.isTreeExpandByRow(row2)) {
                rests.push(tableMethods.setTreeExpand(row2, true));
              }
            });
          }
        }
        return Promise.all(rests).then(() => rowToVisible($xetable, row));
      },
      updateScrollYStatus,
      //  X 
      updateScrollXSpace() {
        const { isGroup, scrollXLoad, scrollbarWidth } = reactData;
        const { visibleColumn, scrollXStore, elemStore, tableWidth } = internalData;
        const tableHeader = refTableHeader.value;
        const tableBody = refTableBody.value;
        const tableFooter = refTableFooter.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        if (tableBodyElem) {
          const tableHeaderElem = tableHeader ? tableHeader.$el : null;
          const tableFooterElem = tableFooter ? tableFooter.$el : null;
          const headerElem = tableHeaderElem ? tableHeaderElem.querySelector(".vxe-table--header") : null;
          const bodyElem = tableBodyElem.querySelector(".vxe-table--body");
          const footerElem = tableFooterElem ? tableFooterElem.querySelector(".vxe-table--footer") : null;
          const leftSpaceWidth = visibleColumn.slice(0, scrollXStore.startIndex).reduce((previous, column) => previous + column.renderWidth, 0);
          let marginLeft = "";
          if (scrollXLoad) {
            marginLeft = `${leftSpaceWidth}px`;
          }
          if (headerElem) {
            headerElem.style.marginLeft = isGroup ? "" : marginLeft;
          }
          bodyElem.style.marginLeft = marginLeft;
          if (footerElem) {
            footerElem.style.marginLeft = marginLeft;
          }
          const containerList = ["main"];
          containerList.forEach((name) => {
            const layoutList = ["header", "body", "footer"];
            layoutList.forEach((layout) => {
              const xSpaceRef = elemStore[`${name}-${layout}-xSpace`];
              const xSpaceElem = xSpaceRef ? xSpaceRef.value : null;
              if (xSpaceElem) {
                xSpaceElem.style.width = scrollXLoad ? `${tableWidth + (layout === "header" ? scrollbarWidth : 0)}px` : "";
              }
            });
          });
          nextTick(updateStyle);
        }
      },
      //  Y 
      updateScrollYSpace() {
        const { scrollYLoad } = reactData;
        const { scrollYStore, elemStore, afterFullData } = internalData;
        const { startIndex, rowHeight } = scrollYStore;
        const bodyHeight = afterFullData.length * rowHeight;
        const topSpaceHeight = Math.max(0, startIndex * rowHeight);
        const containerList = ["main", "left", "right"];
        let marginTop = "";
        let ySpaceHeight = "";
        if (scrollYLoad) {
          marginTop = `${topSpaceHeight}px`;
          ySpaceHeight = `${bodyHeight}px`;
        }
        containerList.forEach((name) => {
          const layoutList = ["header", "body", "footer"];
          const tableRef = elemStore[`${name}-body-table`];
          const tableElem = tableRef ? tableRef.value : null;
          if (tableElem) {
            tableElem.style.marginTop = marginTop;
          }
          layoutList.forEach((layout) => {
            const ySpaceRef = elemStore[`${name}-${layout}-ySpace`];
            const ySpaceElem = ySpaceRef ? ySpaceRef.value : null;
            if (ySpaceElem) {
              ySpaceElem.style.height = ySpaceHeight;
            }
          });
        });
        nextTick(updateStyle);
      },
      updateScrollXData() {
        nextTick(() => {
          handleTableColumn();
          tablePrivateMethods.updateScrollXSpace();
        });
      },
      updateScrollYData() {
        nextTick(() => {
          tablePrivateMethods.handleTableData();
          tablePrivateMethods.updateScrollYSpace();
        });
      },
      /**
       * 
       */
      checkScrolling() {
        const leftContainerElem = refLeftContainer.value;
        const rightContainerElem = refRightContainer.value;
        const tableBody = refTableBody.value;
        const bodyElem = tableBody ? tableBody.$el : null;
        if (bodyElem) {
          if (leftContainerElem) {
            if (bodyElem.scrollLeft > 0) {
              addClass(leftContainerElem, "scrolling--middle");
            } else {
              removeClass(leftContainerElem, "scrolling--middle");
            }
          }
          if (rightContainerElem) {
            if (bodyElem.clientWidth < bodyElem.scrollWidth - Math.ceil(bodyElem.scrollLeft)) {
              addClass(rightContainerElem, "scrolling--middle");
            } else {
              removeClass(rightContainerElem, "scrolling--middle");
            }
          }
        }
      },
      updateZindex() {
        if (props.zIndex) {
          internalData.tZindex = props.zIndex;
        } else if (internalData.tZindex < getLastZIndex()) {
          internalData.tZindex = nextZIndex();
        }
      },
      handleCheckedCheckboxRow,
      /**
       *  hover 
       */
      triggerHoverEvent(evnt, { row }) {
        tablePrivateMethods.setHoverRow(row);
      },
      setHoverRow(row) {
        const rowid = getRowid($xetable, row);
        const el = refElem.value;
        tablePrivateMethods.clearHoverRow();
        if (el) {
          import_xe_utils41.default.arrayEach(el.querySelectorAll(`[rowid="${rowid}"]`), (elem) => addClass(elem, "row--hover"));
        }
        internalData.hoverRow = row;
      },
      clearHoverRow() {
        const el = refElem.value;
        if (el) {
          import_xe_utils41.default.arrayEach(el.querySelectorAll(".vxe-body--row.row--hover"), (elem) => removeClass(elem, "row--hover"));
        }
        internalData.hoverRow = null;
      },
      getCell(row, column) {
        const rowid = getRowid($xetable, row);
        const tableBody = refTableBody.value;
        const leftBody = refTableLeftBody.value;
        const rightBody = refTableRightBody.value;
        let bodyElem;
        if (column) {
          if (column.fixed) {
            if (column.fixed === "left") {
              if (leftBody) {
                bodyElem = leftBody.$el;
              }
            } else {
              if (rightBody) {
                bodyElem = rightBody.$el;
              }
            }
          }
          if (!bodyElem) {
            bodyElem = tableBody.$el;
          }
          if (bodyElem) {
            return bodyElem.querySelector(`.vxe-body--row[rowid="${rowid}"] .${column.id}`);
          }
        }
        return null;
      },
      getCellLabel(row, column) {
        const formatter = column.formatter;
        const cellValue = getCellValue(row, column);
        let cellLabel = cellValue;
        if (formatter) {
          let formatData;
          const { fullAllDataRowIdData } = internalData;
          const rowid = getRowid($xetable, row);
          const colid = column.id;
          const rest = fullAllDataRowIdData[rowid];
          if (rest) {
            formatData = rest.formatData;
            if (!formatData) {
              formatData = fullAllDataRowIdData[rowid].formatData = {};
            }
            if (rest && formatData[colid]) {
              if (formatData[colid].value === cellValue) {
                return formatData[colid].label;
              }
            }
          }
          const formatParams = { cellValue, row, rowIndex: tableMethods.getRowIndex(row), column, columnIndex: tableMethods.getColumnIndex(column) };
          if (import_xe_utils41.default.isString(formatter)) {
            const gFormatOpts = VXETable.formats.get(formatter);
            const tcFormatMethod = gFormatOpts ? gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod : null;
            cellLabel = tcFormatMethod ? tcFormatMethod(formatParams) : "";
          } else if (import_xe_utils41.default.isArray(formatter)) {
            const gFormatOpts = VXETable.formats.get(formatter[0]);
            const tcFormatMethod = gFormatOpts ? gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod : null;
            cellLabel = tcFormatMethod ? tcFormatMethod(formatParams, ...formatter.slice(1)) : "";
          } else {
            cellLabel = formatter(formatParams);
          }
          if (formatData) {
            formatData[colid] = { value: cellValue, label: cellLabel };
          }
        }
        return cellLabel;
      },
      findRowIndexOf(list, row) {
        return row ? import_xe_utils41.default.findIndexOf(list, (item) => $xetable.eqRow(item, row)) : -1;
      },
      eqRow(row1, row2) {
        if (row1 && row2) {
          if (row1 === row2) {
            return true;
          }
          return getRowid($xetable, row1) === getRowid($xetable, row2);
        }
        return false;
      }
    };
    if (true) {
      "openExport,openPrint,exportData,openImport,importData,saveFile,readFile,importByFile,print".split(",").forEach((name) => {
        $xetable[name] = function() {
          errLog("vxe.error.reqModule", ["VxeTableExportModule"]);
        };
      });
      "clearValidate,fullValidate,validate".split(",").forEach((name) => {
        $xetable[name] = function() {
          errLog("vxe.error.reqModule", ["VxeTableValidatorModule"]);
        };
      });
    }
    Object.assign($xetable, tableMethods, tablePrivateMethods);
    const renderFixed = (fixedType) => {
      const { showHeader, showFooter } = props;
      const { tableData, tableColumn, tableGroupColumn, columnStore, footerTableData } = reactData;
      const isFixedLeft = fixedType === "left";
      const fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
      return h("div", {
        ref: isFixedLeft ? refLeftContainer : refRightContainer,
        class: `vxe-table--fixed-${fixedType}-wrapper`
      }, [
        showHeader ? h(header_default, {
          ref: isFixedLeft ? refTableLeftHeader : refTableRightHeader,
          fixedType,
          tableData,
          tableColumn,
          tableGroupColumn,
          fixedColumn
        }) : createCommentVNode(),
        h(body_default, {
          ref: isFixedLeft ? refTableLeftBody : refTableRightBody,
          fixedType,
          tableData,
          tableColumn,
          fixedColumn
        }),
        showFooter ? h(footer_default, {
          ref: isFixedLeft ? refTableLeftFooter : refTableRightFooter,
          footerTableData,
          tableColumn,
          fixedColumn,
          fixedType
        }) : createCommentVNode()
      ]);
    };
    const renderEmptyContenet = () => {
      const emptyOpts = computeEmptyOpts.value;
      const params = { $table: $xetable };
      if (slots.empty) {
        return slots.empty(params);
      } else {
        const compConf = emptyOpts.name ? VXETable.renderer.get(emptyOpts.name) : null;
        const renderTableEmptyView = compConf ? compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (renderTableEmptyView) {
          return getSlotVNs(renderTableEmptyView(emptyOpts, params));
        }
      }
      return getFuncText(props.emptyText) || conf_default.i18n("vxe.table.emptyText");
    };
    function handleUupdateResize() {
      const el = refElem.value;
      if (el && el.clientWidth && el.clientHeight) {
        tableMethods.recalculate();
      }
    }
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      const { inited, initStatus } = internalData;
      loadTableData(props.data || []).then(() => {
        const { scrollXLoad, scrollYLoad, expandColumn } = reactData;
        internalData.inited = true;
        internalData.initStatus = true;
        if (!initStatus) {
          handleLoadDefaults();
        }
        if (!inited) {
          handleInitDefaults();
        }
        if (true) {
          if ((scrollXLoad || scrollYLoad) && expandColumn) {
            warnLog("vxe.error.scrollErrProp", ["column.type=expand"]);
          }
        }
        tableMethods.recalculate();
      });
    });
    const staticColumnFlag = ref(0);
    watch(() => reactData.staticColumns.length, () => {
      staticColumnFlag.value++;
    });
    watch(() => reactData.staticColumns, () => {
      staticColumnFlag.value++;
    });
    watch(staticColumnFlag, () => {
      handleColumn(reactData.staticColumns);
    });
    const tableColumnFlag = ref(0);
    watch(() => reactData.tableColumn.length, () => {
      tableColumnFlag.value++;
    });
    watch(() => reactData.tableColumn, () => {
      tableColumnFlag.value++;
    });
    watch(tableColumnFlag, () => {
      tablePrivateMethods.analyColumnWidth();
    });
    watch(() => reactData.upDataFlag, () => {
      nextTick(() => {
        tableMethods.updateData();
      });
    });
    watch(() => reactData.reColumnFlag, () => {
      nextTick(() => {
        tableMethods.refreshColumn();
      });
    });
    watch(() => props.showHeader, () => {
      nextTick(() => {
        tableMethods.recalculate(true).then(() => tableMethods.refreshScroll());
      });
    });
    watch(() => props.showFooter, () => {
      nextTick(() => {
        tableMethods.recalculate(true).then(() => tableMethods.refreshScroll());
      });
    });
    const footFlag = ref(0);
    watch(() => props.footerData ? props.footerData.length : -1, () => {
      footFlag.value++;
    });
    watch(() => props.footerData, () => {
      footFlag.value++;
    });
    watch(footFlag, () => {
      tableMethods.updateFooter();
    });
    watch(() => props.height, () => {
      nextTick(() => tableMethods.recalculate(true));
    });
    watch(() => props.maxHeight, () => {
      nextTick(() => tableMethods.recalculate(true));
    });
    watch(() => props.syncResize, (value) => {
      if (value) {
        handleUupdateResize();
        nextTick(() => {
          handleUupdateResize();
          setTimeout(() => handleUupdateResize());
        });
      }
    });
    const mergeCellFlag = ref(0);
    watch(() => props.mergeCells ? props.mergeCells.length : -1, () => {
      mergeCellFlag.value++;
    });
    watch(() => props.mergeCells, () => {
      mergeCellFlag.value++;
    });
    watch(mergeCellFlag, () => {
      tableMethods.clearMergeCells();
      nextTick(() => {
        if (props.mergeCells) {
          tableMethods.setMergeCells(props.mergeCells);
        }
      });
    });
    const mergeFooterItemFlag = ref(0);
    watch(() => props.mergeFooterItems ? props.mergeFooterItems.length : -1, () => {
      mergeFooterItemFlag.value++;
    });
    watch(() => props.mergeFooterItems, () => {
      mergeFooterItemFlag.value++;
    });
    watch(mergeFooterItemFlag, () => {
      tableMethods.clearMergeFooterItems();
      nextTick(() => {
        if (props.mergeFooterItems) {
          tableMethods.setMergeFooterItems(props.mergeFooterItems);
        }
      });
    });
    VXETable.hooks.forEach((options) => {
      const { setupTable } = options;
      if (setupTable) {
        const hookRest = setupTable($xetable);
        if (hookRest && import_xe_utils41.default.isObject(hookRest)) {
          Object.assign($xetable, hookRest);
        }
      }
    });
    tablePrivateMethods.preventEvent(null, "created", { $table: $xetable });
    let resizeObserver;
    onActivated(() => {
      tableMethods.recalculate().then(() => tableMethods.refreshScroll());
      tablePrivateMethods.preventEvent(null, "activated", { $table: $xetable });
    });
    onDeactivated(() => {
      internalData.isActivated = false;
      tablePrivateMethods.preventEvent(null, "deactivated", { $table: $xetable });
    });
    onMounted(() => {
      nextTick(() => {
        const { data, treeConfig, showOverflow } = props;
        const { scrollXStore, scrollYStore } = internalData;
        const sYOpts = computeSYOpts.value;
        const editOpts = computeEditOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const expandOpts = computeExpandOpts.value;
        const rowOpts = computeRowOpts.value;
        if (true) {
          if (props.rowId) {
            warnLog("vxe.error.delProp", ["row-id", "row-config.keyField"]);
          }
          if (props.rowKey) {
            warnLog("vxe.error.delProp", ["row-key", "row-config.useKey"]);
          }
          if (props.columnKey) {
            warnLog("vxe.error.delProp", ["column-id", "column-config.useKey"]);
          }
          if (!(props.rowId || rowOpts.keyField) && (checkboxOpts.reserve || checkboxOpts.checkRowKeys || radioOpts.reserve || radioOpts.checkRowKey || expandOpts.expandRowKeys || treeOpts.expandRowKeys)) {
            warnLog("vxe.error.reqProp", ["row-config.keyField"]);
          }
          if (props.editConfig && (editOpts.showStatus || editOpts.showUpdateStatus || editOpts.showInsertStatus) && !props.keepSource) {
            warnLog("vxe.error.reqProp", ["keep-source"]);
          }
          if (treeConfig && (treeOpts.showLine || treeOpts.line) && (!(props.rowKey || rowOpts.useKey) || !showOverflow)) {
            warnLog("vxe.error.reqProp", ["row-config.useKey | show-overflow"]);
          }
          if (treeConfig && props.stripe) {
            warnLog("vxe.error.noTree", ["stripe"]);
          }
          if (props.showFooter && !(props.footerMethod || props.footerData)) {
            warnLog("vxe.error.reqProp", ["footer-data | footer-method"]);
          }
          const { exportConfig, importConfig } = props;
          const exportOpts = computeExportOpts.value;
          const importOpts = computeImportOpts.value;
          if (importConfig && importOpts.types && !importOpts.importMethod && !import_xe_utils41.default.includeArrays(VXETable.globalConfs.importTypes, importOpts.types)) {
            warnLog("vxe.error.errProp", [`export-config.types=${importOpts.types.join(",")}`, importOpts.types.filter((type) => import_xe_utils41.default.includes(VXETable.globalConfs.importTypes, type)).join(",") || VXETable.globalConfs.importTypes.join(",")]);
          }
          if (exportConfig && exportOpts.types && !exportOpts.exportMethod && !import_xe_utils41.default.includeArrays(VXETable.globalConfs.exportTypes, exportOpts.types)) {
            warnLog("vxe.error.errProp", [`export-config.types=${exportOpts.types.join(",")}`, exportOpts.types.filter((type) => import_xe_utils41.default.includes(VXETable.globalConfs.exportTypes, type)).join(",") || VXETable.globalConfs.exportTypes.join(",")]);
          }
        }
        if (true) {
          const customOpts = computeCustomOpts.value;
          const mouseOpts = computeMouseOpts.value;
          const rowOpts2 = computeRowOpts.value;
          if (!props.id && props.customConfig && (customOpts.storage === true || customOpts.storage && customOpts.storage.resizable || customOpts.storage && customOpts.storage.visible)) {
            errLog("vxe.error.reqProp", ["id"]);
          }
          if (props.treeConfig && checkboxOpts.range) {
            errLog("vxe.error.noTree", ["checkbox-config.range"]);
          }
          if (rowOpts2.height && !props.showOverflow) {
            warnLog("vxe.error.notProp", ["table.show-overflow"]);
          }
          if (!$xetable.handleUpdateCellAreas) {
            if (props.clipConfig) {
              warnLog("vxe.error.notProp", ["clip-config"]);
            }
            if (props.fnrConfig) {
              warnLog("vxe.error.notProp", ["fnr-config"]);
            }
            if (mouseOpts.area) {
              errLog("vxe.error.notProp", ["mouse-config.area"]);
              return;
            }
          }
          if (props.treeConfig && treeOpts.children) {
            warnLog("vxe.error.delProp", ["tree-config.children", "tree-config.childrenField"]);
          }
          if (props.treeConfig && treeOpts.line) {
            warnLog("vxe.error.delProp", ["tree-config.line", "tree-config.showLine"]);
          }
          if (mouseOpts.area && mouseOpts.selected) {
            warnLog("vxe.error.errConflicts", ["mouse-config.area", "mouse-config.selected"]);
          }
          if (mouseOpts.area && checkboxOpts.range) {
            warnLog("vxe.error.errConflicts", ["mouse-config.area", "checkbox-config.range"]);
          }
          if (props.treeConfig && mouseOpts.area) {
            errLog("vxe.error.noTree", ["mouse-config.area"]);
          }
          if (props.editConfig && editOpts.activeMethod) {
            warnLog("vxe.error.delProp", ["edit-config.activeMethod", "edit-config.beforeEditMethod"]);
          }
          if (props.treeConfig && checkboxOpts.isShiftKey) {
            errLog("vxe.error.errConflicts", ["tree-config", "checkbox-config.isShiftKey"]);
          }
          if (checkboxOpts.halfField) {
            warnLog("vxe.error.delProp", ["checkbox-config.halfField", "checkbox-config.indeterminateField"]);
          }
        }
        if (true) {
          if (props.editConfig && !$xetable.insert) {
            errLog("vxe.error.reqModule", ["Edit"]);
          }
          if (props.editRules && !$xetable.validate) {
            errLog("vxe.error.reqModule", ["Validator"]);
          }
          if ((checkboxOpts.range || props.keyboardConfig || props.mouseConfig) && !$xetable.triggerCellMousedownEvent) {
            errLog("vxe.error.reqModule", ["Keyboard"]);
          }
          if ((props.printConfig || props.importConfig || props.exportConfig) && !$xetable.exportData) {
            errLog("vxe.error.reqModule", ["Export"]);
          }
        }
        Object.assign(scrollYStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0,
          adaptive: sYOpts.adaptive !== false
        });
        Object.assign(scrollXStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0
        });
        loadTableData(data || []).then(() => {
          if (data && data.length) {
            internalData.inited = true;
            internalData.initStatus = true;
            handleLoadDefaults();
            handleInitDefaults();
          }
          updateStyle();
        });
        if (props.autoResize) {
          const resizeOpts = computeResizeleOpts.value;
          const { refreshDelay } = resizeOpts;
          const el = refElem.value;
          const parentEl = tablePrivateMethods.getParentElem();
          const handleOptimizeResize = refreshDelay ? import_xe_utils41.default.throttle(() => tableMethods.recalculate(true), refreshDelay, { leading: true, trailing: true }) : null;
          resizeObserver = createResizeEvent(handleOptimizeResize ? () => {
            if (props.autoResize) {
              requestAnimationFrame(handleOptimizeResize);
            }
          } : () => {
            if (props.autoResize) {
              tableMethods.recalculate(true);
            }
          });
          if (el) {
            resizeObserver.observe(el);
          }
          if (parentEl) {
            resizeObserver.observe(parentEl);
          }
        }
      });
      GlobalEvent.on($xetable, "paste", handleGlobalPasteEvent);
      GlobalEvent.on($xetable, "copy", handleGlobalCopyEvent);
      GlobalEvent.on($xetable, "cut", handleGlobalCutEvent);
      GlobalEvent.on($xetable, "mousedown", handleGlobalMousedownEvent);
      GlobalEvent.on($xetable, "blur", handleGlobalBlurEvent);
      GlobalEvent.on($xetable, "mousewheel", handleGlobalMousewheelEvent);
      GlobalEvent.on($xetable, "keydown", handleGlobalKeydownEvent);
      GlobalEvent.on($xetable, "resize", handleGlobalResizeEvent);
      if ($xetable.handleGlobalContextmenuEvent) {
        GlobalEvent.on($xetable, "contextmenu", $xetable.handleGlobalContextmenuEvent);
      }
      tablePrivateMethods.preventEvent(null, "mounted", { $table: $xetable });
    });
    onBeforeUnmount(() => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      tableMethods.closeFilter();
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
      tablePrivateMethods.preventEvent(null, "beforeUnmount", { $table: $xetable });
    });
    onUnmounted(() => {
      GlobalEvent.off($xetable, "paste");
      GlobalEvent.off($xetable, "copy");
      GlobalEvent.off($xetable, "cut");
      GlobalEvent.off($xetable, "mousedown");
      GlobalEvent.off($xetable, "blur");
      GlobalEvent.off($xetable, "mousewheel");
      GlobalEvent.off($xetable, "keydown");
      GlobalEvent.off($xetable, "resize");
      GlobalEvent.off($xetable, "contextmenu");
      tablePrivateMethods.preventEvent(null, "unmounted", { $table: $xetable });
    });
    const renderVN = () => {
      const { loading, stripe, showHeader, height, treeConfig, mouseConfig, showFooter, highlightCell, highlightHoverRow, highlightHoverColumn, editConfig, editRules } = props;
      const { isGroup, overflowX, overflowY, scrollXLoad, scrollYLoad, scrollbarHeight, tableData, tableColumn, tableGroupColumn, footerTableData, initStore, columnStore, filterStore, customStore } = reactData;
      const { leftList, rightList } = columnStore;
      const loadingSlot = slots.loading;
      const tipConfig = computeTipConfig.value;
      const validOpts = computeValidOpts.value;
      const treeOpts = computeTreeOpts.value;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const vSize = computeSize.value;
      const tableBorder = computeTableBorder.value;
      const mouseOpts = computeMouseOpts.value;
      const validTipOpts = computeValidTipOpts.value;
      const loadingOpts = computeLoadingOpts.value;
      const isMenu = computeIsMenu.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-table", "vxe-table--render-default", `tid_${xID}`, `border--${tableBorder}`, {
          [`size--${vSize}`]: vSize,
          [`valid-msg--${validOpts.msgMode}`]: !!editRules,
          "vxe-editable": !!editConfig,
          "old-cell-valid": editRules && conf_default.cellVaildMode === "obsolete",
          "cell--highlight": highlightCell,
          "cell--selected": mouseConfig && mouseOpts.selected,
          "cell--area": mouseConfig && mouseOpts.area,
          "row--highlight": rowOpts.isHover || highlightHoverRow,
          "column--highlight": columnOpts.isHover || highlightHoverColumn,
          "is--header": showHeader,
          "is--footer": showFooter,
          "is--group": isGroup,
          "is--tree-line": treeConfig && (treeOpts.showLine || treeOpts.line),
          "is--fixed-left": leftList.length,
          "is--fixed-right": rightList.length,
          "is--animat": !!props.animat,
          "is--round": props.round,
          "is--stripe": !treeConfig && stripe,
          "is--loading": loading,
          "is--empty": !loading && !tableData.length,
          "is--scroll-y": overflowY,
          "is--scroll-x": overflowX,
          "is--virtual-x": scrollXLoad,
          "is--virtual-y": scrollYLoad
        }],
        onKeydown: keydownEvent
      }, [
        /**
         * 
         */
        h("div", {
          class: "vxe-table-slots"
        }, slots.default ? slots.default({}) : []),
        h("div", {
          class: "vxe-table--render-wrapper"
        }, [
          h("div", {
            class: "vxe-table--main-wrapper"
          }, [
            /**
             * 
             */
            showHeader ? h(header_default, {
              ref: refTableHeader,
              tableData,
              tableColumn,
              tableGroupColumn
            }) : createCommentVNode(),
            /**
             * 
             */
            h(body_default, {
              ref: refTableBody,
              tableData,
              tableColumn
            }),
            /**
             * 
             */
            showFooter ? h(footer_default, {
              ref: refTableFooter,
              footerTableData,
              tableColumn
            }) : createCommentVNode()
          ]),
          h("div", {
            class: "vxe-table--fixed-wrapper"
          }, [
            /**
             * 
             */
            leftList && leftList.length && overflowX ? renderFixed("left") : createCommentVNode(),
            /**
             * 
             */
            rightList && rightList.length && overflowX ? renderFixed("right") : createCommentVNode()
          ])
        ]),
        /**
         * 
         */
        h("div", {
          ref: refEmptyPlaceholder,
          class: "vxe-table--empty-placeholder"
        }, [
          h("div", {
            class: "vxe-table--empty-content"
          }, renderEmptyContenet())
        ]),
        /**
         * 
         */
        h("div", {
          class: "vxe-table--border-line"
        }),
        /**
         * 
         */
        h("div", {
          ref: refCellResizeBar,
          class: "vxe-table--resizable-bar",
          style: overflowX ? {
            "padding-bottom": `${scrollbarHeight}px`
          } : null
        }),
        /**
         * 
         */
        h(loading_default2, {
          class: "vxe-table--loading",
          modelValue: loading,
          icon: loadingOpts.icon,
          text: loadingOpts.text
        }, loadingSlot ? {
          default: () => loadingSlot({ $table: $xetable, $grid: $xegrid })
        } : {}),
        /**
         * 
         */
        initStore.custom ? h(resolveComponent("vxe-table-custom-panel"), {
          ref: refTableCustom,
          customStore
        }) : createCommentVNode(),
        /**
         * 
         */
        initStore.filter ? h(resolveComponent("vxe-table-filter-panel"), {
          ref: refTableFilter,
          filterStore
        }) : createCommentVNode(),
        /**
         * 
         */
        initStore.import && props.importConfig ? h(resolveComponent("vxe-table-import-panel"), {
          defaultOptions: reactData.importParams,
          storeData: reactData.importStore
        }) : createCommentVNode(),
        /**
         * /
         */
        initStore.export && (props.exportConfig || props.printConfig) ? h(resolveComponent("vxe-table-export-panel"), {
          defaultOptions: reactData.exportParams,
          storeData: reactData.exportStore
        }) : createCommentVNode(),
        /**
         * 
         */
        isMenu ? h(resolveComponent("vxe-table-menu-panel"), {
          ref: refTableMenu
        }) : createCommentVNode(),
        /**
         * 
         */
        hasUseTooltip ? h(resolveComponent("vxe-tooltip"), {
          ref: refCommTooltip,
          isArrow: false,
          enterable: false
        }) : createCommentVNode(),
        /**
         * 
         */
        hasUseTooltip ? h(resolveComponent("vxe-tooltip"), Object.assign({ ref: refTooltip }, tipConfig)) : createCommentVNode(),
        /**
         * 
         */
        hasUseTooltip && props.editRules && validOpts.showMessage && (validOpts.message === "default" ? !height : validOpts.message === "tooltip") ? h(resolveComponent("vxe-tooltip"), Object.assign({ ref: refValidTooltip, class: [{
          "old-cell-valid": editRules && conf_default.cellVaildMode === "obsolete"
        }, "vxe-table--valid-error"] }, validOpts.message === "tooltip" || tableData.length === 1 ? validTipOpts : {})) : createCommentVNode()
      ]);
    };
    $xetable.renderVN = renderVN;
    provide("xecolgroup", null);
    provide("$xetable", $xetable);
    return $xetable;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/index.js
var VxeTable = Object.assign(table_default, {
  install: function(app) {
    app.component(table_default.name, table_default);
  }
});
var Table = VxeTable;
dynamicApp.component(table_default.name, table_default);
var table_default2 = VxeTable;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/pager/src/pager.js
var import_xe_utils42 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/select/index.js
var VxeSelect = Object.assign(select_default, {
  install: function(app) {
    app.component(select_default.name, select_default);
  }
});
var Select = VxeSelect;
dynamicApp.component(select_default.name, select_default);
var select_default2 = VxeSelect;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/pager/src/pager.js
var pager_default = defineComponent({
  name: "VxePager",
  props: {
    size: { type: String, default: () => conf_default.pager.size || conf_default.size },
    // 
    layouts: { type: Array, default: () => conf_default.pager.layouts || ["PrevJump", "PrevPage", "Jump", "PageCount", "NextPage", "NextJump", "Sizes", "Total"] },
    // 
    currentPage: { type: Number, default: 1 },
    // 
    loading: Boolean,
    // 
    pageSize: { type: Number, default: () => conf_default.pager.pageSize || 10 },
    // 
    total: { type: Number, default: 0 },
    // 
    pagerCount: { type: Number, default: () => conf_default.pager.pagerCount || 7 },
    // 
    pageSizes: { type: Array, default: () => conf_default.pager.pageSizes || [10, 15, 20, 50, 100] },
    // 
    align: { type: String, default: () => conf_default.pager.align },
    // 
    border: { type: Boolean, default: () => conf_default.pager.border },
    // 
    background: { type: Boolean, default: () => conf_default.pager.background },
    // 
    perfect: { type: Boolean, default: () => conf_default.pager.perfect },
    // 
    autoHidden: { type: Boolean, default: () => conf_default.pager.autoHidden },
    transfer: { type: Boolean, default: () => conf_default.pager.transfer },
    className: [String, Function],
    // 
    iconPrevPage: String,
    iconJumpPrev: String,
    iconJumpNext: String,
    iconNextPage: String,
    iconJumpMore: String,
    iconHomePage: String,
    iconEndPage: String
  },
  emits: [
    "update:pageSize",
    "update:currentPage",
    "page-change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils42.default.uniqueId();
    const computeSize = useSize(props);
    const $xegrid = inject("$xegrid", null);
    const reactData = reactive({
      inpCurrPage: props.currentPage
    });
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xepager = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    let pagerMethods = {};
    let pagerPrivateMethods = {};
    const getPageCount = (total, size) => {
      return Math.max(Math.ceil(total / size), 1);
    };
    const computePageCount = computed(() => {
      return getPageCount(props.total, props.pageSize);
    });
    const jumpPageEvent = (evnt, currentPage) => {
      emit("update:currentPage", currentPage);
      if (evnt && currentPage !== props.currentPage) {
        pagerMethods.dispatchEvent("page-change", { type: "current", pageSize: props.pageSize, currentPage }, evnt);
      }
    };
    const changeCurrentPage = (currentPage, evnt) => {
      emit("update:currentPage", currentPage);
      if (evnt && currentPage !== props.currentPage) {
        pagerMethods.dispatchEvent("page-change", { type: "current", pageSize: props.pageSize, currentPage }, evnt);
      }
    };
    const triggerJumpEvent = (evnt) => {
      const inputElem = evnt.target;
      const inpValue = import_xe_utils42.default.toInteger(inputElem.value);
      const pageCount = computePageCount.value;
      const current = inpValue <= 0 ? 1 : inpValue >= pageCount ? pageCount : inpValue;
      const currPage = import_xe_utils42.default.toValueString(current);
      inputElem.value = currPage;
      reactData.inpCurrPage = currPage;
      changeCurrentPage(current, evnt);
    };
    const computeNumList = computed(() => {
      const { pagerCount } = props;
      const pageCount = computePageCount.value;
      const len = pageCount > pagerCount ? pagerCount - 2 : pagerCount;
      const rest = [];
      for (let index = 0; index < len; index++) {
        rest.push(index);
      }
      return rest;
    });
    const computeOffsetNumber = computed(() => {
      return Math.floor((props.pagerCount - 2) / 2);
    });
    const computeSizeList = computed(() => {
      return props.pageSizes.map((item) => {
        if (import_xe_utils42.default.isNumber(item)) {
          return {
            value: item,
            label: `${conf_default.i18n("vxe.pager.pagesize", [item])}`
          };
        }
        return Object.assign({ value: "", label: "" }, item);
      });
    });
    const handleHomePage = (evnt) => {
      const { currentPage } = props;
      if (currentPage > 1) {
        changeCurrentPage(1, evnt);
      }
    };
    const handleEndPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        changeCurrentPage(pageCount, evnt);
      }
    };
    const handlePrevPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage > 1) {
        changeCurrentPage(Math.min(pageCount, Math.max(currentPage - 1, 1)), evnt);
      }
    };
    const handleNextPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        changeCurrentPage(Math.min(pageCount, currentPage + 1), evnt);
      }
    };
    const handlePrevJump = (evnt) => {
      const numList = computeNumList.value;
      changeCurrentPage(Math.max(props.currentPage - numList.length, 1), evnt);
    };
    const handleNextJump = (evnt) => {
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      changeCurrentPage(Math.min(props.currentPage + numList.length, pageCount), evnt);
    };
    const pageSizeEvent = (params) => {
      const { value } = params;
      const pageSize = import_xe_utils42.default.toNumber(value);
      const pageCount = getPageCount(props.total, pageSize);
      let currentPage = props.currentPage;
      if (currentPage > pageCount) {
        currentPage = pageCount;
        emit("update:currentPage", pageCount);
      }
      emit("update:pageSize", pageSize);
      pagerMethods.dispatchEvent("page-change", { type: "size", pageSize, currentPage });
    };
    const jumpInputEvent = (evnt) => {
      const inputElem = evnt.target;
      reactData.inpCurrPage = inputElem.value;
    };
    const jumpKeydownEvent = (evnt) => {
      if (hasEventKey(evnt, EVENT_KEYS.ENTER)) {
        triggerJumpEvent(evnt);
      } else if (hasEventKey(evnt, EVENT_KEYS.ARROW_UP)) {
        evnt.preventDefault();
        handleNextPage(evnt);
      } else if (hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN)) {
        evnt.preventDefault();
        handlePrevPage(evnt);
      }
    };
    const renderHomePage = () => {
      return h("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: conf_default.i18n("vxe.pager.homePageTitle"),
        onClick: handleHomePage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconHomePage || conf_default.icon.PAGER_HOME]
        })
      ]);
    };
    const renderPrevPage = () => {
      return h("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: conf_default.i18n("vxe.pager.prevPageTitle"),
        onClick: handlePrevPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconPrevPage || conf_default.icon.PAGER_PREV_PAGE]
        })
      ]);
    };
    const renderPrevJump = (tagName) => {
      return h(tagName || "button", {
        class: ["vxe-pager--jump-prev", {
          "is--fixed": !tagName,
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: conf_default.i18n("vxe.pager.prevJumpTitle"),
        onClick: handlePrevJump
      }, [
        tagName ? h("i", {
          class: ["vxe-pager--jump-more-icon", props.iconJumpMore || conf_default.icon.PAGER_JUMP_MORE]
        }) : null,
        h("i", {
          class: ["vxe-pager--jump-icon", props.iconJumpPrev || conf_default.icon.PAGER_JUMP_PREV]
        })
      ]);
    };
    const renderNextJump = (tagName) => {
      const pageCount = computePageCount.value;
      return h(tagName || "button", {
        class: ["vxe-pager--jump-next", {
          "is--fixed": !tagName,
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: conf_default.i18n("vxe.pager.nextJumpTitle"),
        onClick: handleNextJump
      }, [
        tagName ? h("i", {
          class: ["vxe-pager--jump-more-icon", props.iconJumpMore || conf_default.icon.PAGER_JUMP_MORE]
        }) : null,
        h("i", {
          class: ["vxe-pager--jump-icon", props.iconJumpNext || conf_default.icon.PAGER_JUMP_NEXT]
        })
      ]);
    };
    const renderNextPage = () => {
      const pageCount = computePageCount.value;
      return h("button", {
        class: ["vxe-pager--next-btn", {
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: conf_default.i18n("vxe.pager.nextPageTitle"),
        onClick: handleNextPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconNextPage || conf_default.icon.PAGER_NEXT_PAGE]
        })
      ]);
    };
    const renderEndPage = () => {
      const pageCount = computePageCount.value;
      return h("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: conf_default.i18n("vxe.pager.endPageTitle"),
        onClick: handleEndPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconEndPage || conf_default.icon.PAGER_END]
        })
      ]);
    };
    const renderNumber = (showJump) => {
      const { currentPage, pagerCount } = props;
      const nums = [];
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      const offsetNumber = computeOffsetNumber.value;
      const isOv = pageCount > pagerCount;
      const isLt = isOv && currentPage > offsetNumber + 1;
      const isGt = isOv && currentPage < pageCount - offsetNumber;
      let startNumber = 1;
      if (isOv) {
        if (currentPage >= pageCount - offsetNumber) {
          startNumber = Math.max(pageCount - numList.length + 1, 1);
        } else {
          startNumber = Math.max(currentPage - offsetNumber, 1);
        }
      }
      if (showJump && isLt) {
        nums.push(h("button", {
          class: "vxe-pager--num-btn",
          type: "button",
          onClick: (evnt) => jumpPageEvent(evnt, 1)
        }, 1), renderPrevJump("span"));
      }
      numList.forEach((item, index) => {
        const number = startNumber + index;
        if (number <= pageCount) {
          nums.push(h("button", {
            key: number,
            class: ["vxe-pager--num-btn", {
              "is--active": currentPage === number
            }],
            type: "button",
            onClick: (evnt) => jumpPageEvent(evnt, number)
          }, number));
        }
      });
      if (showJump && isGt) {
        nums.push(renderNextJump("button"), h("button", {
          class: "vxe-pager--num-btn",
          type: "button",
          onClick: (evnt) => jumpPageEvent(evnt, pageCount)
        }, pageCount));
      }
      return h("span", {
        class: "vxe-pager--btn-wrapper"
      }, nums);
    };
    const renderJumpNumber = () => {
      return renderNumber(true);
    };
    const renderSizes = () => {
      const sizeList = computeSizeList.value;
      return h(select_default2, {
        class: "vxe-pager--sizes",
        modelValue: props.pageSize,
        placement: "top",
        transfer: props.transfer,
        options: sizeList,
        onChange: pageSizeEvent
      });
    };
    const renderJump = (isFull) => {
      return h("span", {
        class: "vxe-pager--jump"
      }, [
        isFull ? h("span", {
          class: "vxe-pager--goto-text"
        }, conf_default.i18n("vxe.pager.goto")) : null,
        h("input", {
          class: "vxe-pager--goto",
          value: reactData.inpCurrPage,
          type: "text",
          autocomplete: "off",
          onInput: jumpInputEvent,
          onKeydown: jumpKeydownEvent,
          onBlur: triggerJumpEvent
        }),
        isFull ? h("span", {
          class: "vxe-pager--classifier-text"
        }, conf_default.i18n("vxe.pager.pageClassifier")) : null
      ]);
    };
    const renderFullJump = () => {
      return renderJump(true);
    };
    const renderPageCount = () => {
      const pageCount = computePageCount.value;
      return h("span", {
        class: "vxe-pager--count"
      }, [
        h("span", {
          class: "vxe-pager--separator"
        }),
        h("span", pageCount)
      ]);
    };
    const renderTotal = () => {
      return h("span", {
        class: "vxe-pager--total"
      }, conf_default.i18n("vxe.pager.total", [props.total]));
    };
    pagerMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $pager: $xepager, $event: evnt }, params));
      },
      homePage() {
        handleHomePage();
        return nextTick();
      },
      endPage() {
        handleEndPage();
        return nextTick();
      },
      prevPage() {
        handlePrevPage();
        return nextTick();
      },
      nextPage() {
        handleNextPage();
        return nextTick();
      },
      prevJump() {
        handlePrevJump();
        return nextTick();
      },
      nextJump() {
        handleNextJump();
        return nextTick();
      }
    };
    pagerPrivateMethods = {
      handlePrevPage,
      handleNextPage,
      handlePrevJump,
      handleNextJump
    };
    Object.assign($xepager, pagerMethods, pagerPrivateMethods);
    watch(() => props.currentPage, (value) => {
      reactData.inpCurrPage = value;
    });
    const renderVN = () => {
      const { align, layouts, className } = props;
      const childNodes = [];
      const vSize = computeSize.value;
      const pageCount = computePageCount.value;
      if (slots.left) {
        childNodes.push(h("span", {
          class: "vxe-pager--left-wrapper"
        }, slots.left({ $grid: $xegrid })));
      }
      layouts.forEach((name) => {
        let renderFn;
        switch (name) {
          case "Home":
            renderFn = renderHomePage;
            break;
          case "PrevJump":
            renderFn = renderPrevJump;
            break;
          case "PrevPage":
            renderFn = renderPrevPage;
            break;
          case "Number":
            renderFn = renderNumber;
            break;
          case "JumpNumber":
            renderFn = renderJumpNumber;
            break;
          case "NextPage":
            renderFn = renderNextPage;
            break;
          case "NextJump":
            renderFn = renderNextJump;
            break;
          case "End":
            renderFn = renderEndPage;
            break;
          case "Sizes":
            renderFn = renderSizes;
            break;
          case "FullJump":
            renderFn = renderFullJump;
            break;
          case "Jump":
            renderFn = renderJump;
            break;
          case "PageCount":
            renderFn = renderPageCount;
            break;
          case "Total":
            renderFn = renderTotal;
            break;
        }
        if (renderFn) {
          childNodes.push(renderFn());
        } else {
          if (true) {
            errLog("vxe.error.notProp", [`layouts -> ${name}`]);
          }
        }
      });
      if (slots.right) {
        childNodes.push(h("span", {
          class: "vxe-pager--right-wrapper"
        }, slots.right({ $grid: $xegrid })));
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-pager", className ? import_xe_utils42.default.isFunction(className) ? className({ $pager: $xepager }) : className : "", {
          [`size--${vSize}`]: vSize,
          [`align--${align}`]: align,
          "is--border": props.border,
          "is--background": props.background,
          "is--perfect": props.perfect,
          "is--hidden": props.autoHidden && pageCount === 1,
          "is--loading": props.loading
        }]
      }, [
        h("div", {
          class: "vxe-pager--wrapper"
        }, childNodes)
      ]);
    };
    $xepager.renderVN = renderVN;
    return $xepager;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/pager/index.js
var VxePager = Object.assign(pager_default, {
  install: function(app) {
    app.component(pager_default.name, pager_default);
  }
});
var Pager = VxePager;
dynamicApp.component(pager_default.name, pager_default);
var pager_default2 = VxePager;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/toolbar/src/toolbar.js
var import_xe_utils43 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/button/index.js
var VxeButton = Object.assign(button_default, {
  install(app) {
    app.component(button_default.name, button_default);
  }
});
var Button = VxeButton;
dynamicApp.component(button_default.name, button_default);
var button_default3 = VxeButton;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/toolbar/src/toolbar.js
var toolbar_default = defineComponent({
  name: "VxeToolbar",
  props: {
    loading: Boolean,
    refresh: [Boolean, Object],
    import: [Boolean, Object],
    export: [Boolean, Object],
    print: [Boolean, Object],
    zoom: [Boolean, Object],
    custom: [Boolean, Object],
    buttons: { type: Array, default: () => conf_default.toolbar.buttons },
    tools: { type: Array, default: () => conf_default.toolbar.tools },
    perfect: { type: Boolean, default: () => conf_default.toolbar.perfect },
    size: { type: String, default: () => conf_default.toolbar.size || conf_default.size },
    className: [String, Function]
  },
  emits: [
    "button-click",
    "tool-click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils43.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      isRefresh: false,
      columns: []
    });
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xetoolbar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let toolbarMethods = {};
    const $xegrid = inject("$xegrid", null);
    let $xetable;
    const connectFlag = ref(0);
    const computeRefreshOpts = computed(() => {
      return Object.assign({}, conf_default.toolbar.refresh, props.refresh);
    });
    const computeImportOpts = computed(() => {
      return Object.assign({}, conf_default.toolbar.import, props.import);
    });
    const computeExportOpts = computed(() => {
      return Object.assign({}, conf_default.toolbar.export, props.export);
    });
    const computePrintOpts = computed(() => {
      return Object.assign({}, conf_default.toolbar.print, props.print);
    });
    const computeZoomOpts = computed(() => {
      return Object.assign({}, conf_default.toolbar.zoom, props.zoom);
    });
    const computeCustomOpts = computed(() => {
      return Object.assign({}, conf_default.toolbar.custom, props.custom);
    });
    const computeTableCustomOpts = computed(() => {
      if (connectFlag.value || $xetable) {
        if ($xetable) {
          const { computeCustomOpts: computeCustomOpts2 } = $xetable.getComputeMaps();
          return computeCustomOpts2.value;
        }
      }
      return {};
    });
    const computeTrigger = computed(() => {
      const tableCustomOpts = computeTableCustomOpts.value;
      return tableCustomOpts.trigger;
    });
    const checkTable = () => {
      if ($xetable) {
        return true;
      }
      errLog("vxe.error.barUnableLink");
    };
    const handleClickSettingEvent = ({ $event }) => {
      if ($xetable) {
        if ($xetable.triggerCustomEvent) {
          $xetable.triggerCustomEvent($event);
        } else {
          errLog("vxe.error.reqModule", ["VxeTableCustomModule"]);
        }
      }
    };
    const handleMouseenterSettingEvent = ({ $event }) => {
      if ($xetable) {
        $xetable.customOpenEvent($event);
      } else {
        errLog("vxe.error.reqModule", ["VxeTableCustomModule"]);
      }
    };
    const handleMouseleaveSettingEvent = ({ $event }) => {
      const { customStore } = $xetable.reactData;
      customStore.activeBtn = false;
      setTimeout(() => {
        if (!customStore.activeBtn && !customStore.activeWrapper) {
          $xetable.customColseEvent($event);
        }
      }, 350);
    };
    const refreshEvent = (evnt) => {
      const { isRefresh } = reactData;
      const refreshOpts = computeRefreshOpts.value;
      if (!isRefresh) {
        const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
        if (queryMethod) {
          reactData.isRefresh = true;
          try {
            Promise.resolve(queryMethod({})).catch((e) => e).then(() => {
              reactData.isRefresh = false;
            });
          } catch (e) {
            reactData.isRefresh = false;
          }
        } else if ($xegrid) {
          reactData.isRefresh = true;
          $xegrid.triggerToolbarCommitEvent({ code: refreshOpts.code || "reload" }, evnt).catch((e) => e).then(() => {
            reactData.isRefresh = false;
          });
        }
      }
    };
    const zoomEvent = (evnt) => {
      if ($xegrid) {
        $xegrid.triggerZoomEvent(evnt);
      }
    };
    const btnEvent = (evnt, item) => {
      const { code } = item;
      if (code) {
        if ($xegrid) {
          $xegrid.triggerToolbarBtnEvent(item, evnt);
        } else {
          const gCommandOpts = VXETable.commands.get(code);
          const params = { code, button: item, $table: $xetable, $grid: $xegrid, $event: evnt };
          if (gCommandOpts) {
            if (gCommandOpts.commandMethod) {
              gCommandOpts.commandMethod(params);
            } else {
              if (true) {
                errLog("vxe.error.notCommands", [code]);
              }
            }
          }
          $xetoolbar.dispatchEvent("button-click", params, evnt);
        }
      }
    };
    const tolEvent = (evnt, item) => {
      const { code } = item;
      if (code) {
        if ($xegrid) {
          $xegrid.triggerToolbarTolEvent(item, evnt);
        } else {
          const gCommandOpts = VXETable.commands.get(code);
          const params = { code, tool: item, $table: $xetable, $grid: $xegrid, $event: evnt };
          if (gCommandOpts) {
            if (gCommandOpts.commandMethod) {
              gCommandOpts.commandMethod(params);
            } else {
              if (true) {
                errLog("vxe.error.notCommands", [code]);
              }
            }
          }
          $xetoolbar.dispatchEvent("tool-click", params, evnt);
        }
      }
    };
    const importEvent = () => {
      if (checkTable()) {
        $xetable.openImport();
      }
    };
    const exportEvent = () => {
      if (checkTable()) {
        $xetable.openExport();
      }
    };
    const printEvent = () => {
      if (checkTable()) {
        $xetable.openPrint();
      }
    };
    const renderDropdowns = (item, isBtn) => {
      const { dropdowns } = item;
      const downVNs = [];
      if (dropdowns) {
        return dropdowns.map((child, index) => {
          if (child.visible === false) {
            return createCommentVNode();
          }
          return h(button_default3, {
            key: index,
            disabled: child.disabled,
            loading: child.loading,
            type: child.type,
            icon: child.icon,
            circle: child.circle,
            round: child.round,
            status: child.status,
            content: child.name,
            onClick: (evnt) => isBtn ? btnEvent(evnt, child) : tolEvent(evnt, child)
          });
        });
      }
      return downVNs;
    };
    const renderBtns = () => {
      const { buttons } = props;
      const buttonsSlot = slots.buttons;
      if (buttonsSlot) {
        return getSlotVNs(buttonsSlot({ $grid: $xegrid, $table: $xetable }));
      }
      const btnVNs = [];
      if (buttons) {
        buttons.forEach((item) => {
          const { dropdowns, buttonRender } = item;
          if (item.visible !== false) {
            const compConf = buttonRender ? VXETable.renderer.get(buttonRender.name) : null;
            if (buttonRender && compConf && compConf.renderToolbarButton) {
              const toolbarButtonClassName = compConf.toolbarButtonClassName;
              const params = { $grid: $xegrid, $table: $xetable, button: item };
              btnVNs.push(h("span", {
                class: ["vxe-button--item", toolbarButtonClassName ? import_xe_utils43.default.isFunction(toolbarButtonClassName) ? toolbarButtonClassName(params) : toolbarButtonClassName : ""]
              }, getSlotVNs(compConf.renderToolbarButton(buttonRender, params))));
            } else {
              btnVNs.push(h(button_default3, {
                disabled: item.disabled,
                loading: item.loading,
                type: item.type,
                icon: item.icon,
                circle: item.circle,
                round: item.round,
                status: item.status,
                content: item.name,
                destroyOnClose: item.destroyOnClose,
                placement: item.placement,
                transfer: item.transfer,
                onClick: (evnt) => btnEvent(evnt, item)
              }, dropdowns && dropdowns.length ? {
                dropdowns: () => renderDropdowns(item, true)
              } : {}));
            }
          }
        });
      }
      return btnVNs;
    };
    const renderRightTools = () => {
      const { tools } = props;
      const toolsSlot = slots.tools;
      if (toolsSlot) {
        return getSlotVNs(toolsSlot({ $grid: $xegrid, $table: $xetable }));
      }
      const btnVNs = [];
      if (tools) {
        tools.forEach((item, tIndex) => {
          const { dropdowns, toolRender } = item;
          if (item.visible !== false) {
            const rdName = toolRender ? toolRender.name : null;
            const compConf = toolRender ? VXETable.renderer.get(rdName) : null;
            if (toolRender && compConf && compConf.renderToolbarTool) {
              const toolbarToolClassName = compConf.toolbarToolClassName;
              const params = { $grid: $xegrid, $table: $xetable, tool: item };
              btnVNs.push(h("span", {
                key: rdName,
                class: ["vxe-tool--item", toolbarToolClassName ? import_xe_utils43.default.isFunction(toolbarToolClassName) ? toolbarToolClassName(params) : toolbarToolClassName : ""]
              }, getSlotVNs(compConf.renderToolbarTool(toolRender, params))));
            } else {
              btnVNs.push(h(button_default3, {
                key: tIndex,
                disabled: item.disabled,
                loading: item.loading,
                type: item.type,
                icon: item.icon,
                circle: item.circle,
                round: item.round,
                status: item.status,
                content: item.name,
                destroyOnClose: item.destroyOnClose,
                placement: item.placement,
                transfer: item.transfer,
                onClick: (evnt) => tolEvent(evnt, item)
              }, dropdowns && dropdowns.length ? {
                dropdowns: () => renderDropdowns(item, false)
              } : {}));
            }
          }
        });
      }
      return btnVNs;
    };
    const renderToolImport = () => {
      const importOpts = computeImportOpts.value;
      return h(button_default3, {
        key: "import",
        circle: true,
        icon: importOpts.icon || conf_default.icon.TOOLBAR_TOOLS_IMPORT,
        title: conf_default.i18n("vxe.toolbar.import"),
        onClick: importEvent
      });
    };
    const renderToolExport = () => {
      const exportOpts = computeExportOpts.value;
      return h(button_default3, {
        key: "export",
        circle: true,
        icon: exportOpts.icon || conf_default.icon.TOOLBAR_TOOLS_EXPORT,
        title: conf_default.i18n("vxe.toolbar.export"),
        onClick: exportEvent
      });
    };
    const renderToolPrint = () => {
      const printOpts = computePrintOpts.value;
      return h(button_default3, {
        key: "print",
        circle: true,
        icon: printOpts.icon || conf_default.icon.TOOLBAR_TOOLS_PRINT,
        title: conf_default.i18n("vxe.toolbar.print"),
        onClick: printEvent
      });
    };
    const renderToolRefresh = () => {
      const refreshOpts = computeRefreshOpts.value;
      return h(button_default3, {
        key: "refresh",
        circle: true,
        icon: reactData.isRefresh ? refreshOpts.iconLoading || conf_default.icon.TOOLBAR_TOOLS_REFRESH_LOADING : refreshOpts.icon || conf_default.icon.TOOLBAR_TOOLS_REFRESH,
        title: conf_default.i18n("vxe.toolbar.refresh"),
        onClick: refreshEvent
      });
    };
    const renderToolZoom = () => {
      const zoomOpts = computeZoomOpts.value;
      return $xegrid ? h(button_default3, {
        key: "zoom",
        circle: true,
        icon: $xegrid.isMaximized() ? zoomOpts.iconOut || conf_default.icon.TOOLBAR_TOOLS_MINIMIZE : zoomOpts.iconIn || conf_default.icon.TOOLBAR_TOOLS_FULLSCREEN,
        title: conf_default.i18n(`vxe.toolbar.zoom${$xegrid.isMaximized() ? "Out" : "In"}`),
        onClick: zoomEvent
      }) : createCommentVNode();
    };
    const renderToolCustom = () => {
      const customOpts = computeCustomOpts.value;
      const btnTrigger = computeTrigger.value;
      const customBtnOns = {};
      if (btnTrigger === "manual") {
      } else if (btnTrigger === "hover") {
        customBtnOns.onMouseenter = handleMouseenterSettingEvent;
        customBtnOns.onMouseleave = handleMouseleaveSettingEvent;
      } else {
        customBtnOns.onClick = handleClickSettingEvent;
      }
      return h(button_default3, Object.assign({ key: "custom", circle: true, icon: customOpts.icon || conf_default.icon.TOOLBAR_TOOLS_CUSTOM, title: conf_default.i18n("vxe.toolbar.custom"), className: "vxe-toolbar-custom-target" }, customBtnOns));
    };
    toolbarMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $toolbar: $xetoolbar, $event: evnt }, params));
      },
      syncUpdate(params) {
        const { collectColumn } = params;
        $xetable = params.$table;
        reactData.columns = collectColumn;
        connectFlag.value++;
      }
    };
    Object.assign($xetoolbar, toolbarMethods);
    nextTick(() => {
      const { refresh } = props;
      const refreshOpts = computeRefreshOpts.value;
      const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
      if (refresh && !$xegrid && !queryMethod) {
        warnLog("vxe.error.notFunc", ["queryMethod"]);
      }
      const customOpts = computeCustomOpts.value;
      if (true) {
        if (customOpts.isFooter) {
          warnLog("vxe.error.delProp", ["toolbar.custom.isFooter", "table.custom-config.showFooter"]);
        }
        if (customOpts.showFooter) {
          warnLog("vxe.error.delProp", ["toolbar.custom.showFooter", "table.custom-config.showFooter"]);
        }
        if (customOpts.immediate) {
          warnLog("vxe.error.delProp", ["toolbar.custom.immediate", "table.custom-config.immediate"]);
        }
        if (customOpts.trigger) {
          warnLog("vxe.error.delProp", ["toolbar.custom.trigger", "table.custom-config.trigger"]);
        }
      }
    });
    const renderVN = () => {
      const { perfect, loading, refresh, zoom, custom, className } = props;
      const vSize = computeSize.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-toolbar", className ? import_xe_utils43.default.isFunction(className) ? className({ $toolbar: $xetoolbar }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--perfect": perfect,
          "is--loading": loading
        }]
      }, [
        h("div", {
          class: "vxe-buttons--wrapper"
        }, renderBtns()),
        h("div", {
          class: "vxe-tools--wrapper"
        }, renderRightTools()),
        h("div", {
          class: "vxe-tools--operate"
        }, [
          props.import ? renderToolImport() : createCommentVNode(),
          props.export ? renderToolExport() : createCommentVNode(),
          props.print ? renderToolPrint() : createCommentVNode(),
          refresh ? renderToolRefresh() : createCommentVNode(),
          zoom && $xegrid ? renderToolZoom() : createCommentVNode(),
          custom ? renderToolCustom() : createCommentVNode()
        ])
      ]);
    };
    $xetoolbar.renderVN = renderVN;
    return $xetoolbar;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/toolbar/index.js
var VxeToolbar = Object.assign(toolbar_default, {
  install: function(app) {
    app.component(toolbar_default.name, toolbar_default);
  }
});
var Toolbar = VxeToolbar;
dynamicApp.component(toolbar_default.name, toolbar_default);
var toolbar_default2 = VxeToolbar;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/form.js
var import_xe_utils47 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/util.js
var import_xe_utils45 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/itemInfo.js
var import_xe_utils44 = __toESM(require_xe_utils());
var ItemInfo = class {
  constructor($xeform, item) {
    Object.assign(this, {
      id: import_xe_utils44.default.uniqueId("item_"),
      title: item.title,
      field: item.field,
      span: item.span,
      align: item.align,
      titleAlign: item.titleAlign,
      titleWidth: item.titleWidth,
      titleColon: item.titleColon,
      titleAsterisk: item.titleAsterisk,
      titlePrefix: item.titlePrefix,
      titleSuffix: item.titleSuffix,
      titleOverflow: item.titleOverflow,
      showTitle: item.showTitle,
      resetValue: item.resetValue,
      visibleMethod: item.visibleMethod,
      visible: item.visible,
      folding: item.folding,
      collapseNode: item.collapseNode,
      className: item.className,
      contentClassName: item.contentClassName,
      contentStyle: item.contentStyle,
      titleClassName: item.titleClassName,
      titleStyle: item.titleStyle,
      itemRender: item.itemRender,
      rules: item.rules,
      // 
      showError: false,
      errRule: null,
      slots: item.slots,
      children: []
    });
  }
  update(name, value) {
    this[name] = value;
  }
};

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/util.js
function isFormItem(item) {
  return item instanceof ItemInfo;
}
function createItem($xeform, _vm) {
  return isFormItem(_vm) ? _vm : new ItemInfo($xeform, _vm);
}
function handleFieldOrItem($xeform, fieldOrItem) {
  if (fieldOrItem) {
    return import_xe_utils45.default.isString(fieldOrItem) ? $xeform.getItemByField(fieldOrItem) : fieldOrItem;
  }
  return null;
}
function isHiddenItem($xeform, formItem) {
  const { reactData } = $xeform;
  const { collapseAll } = reactData;
  const { folding, visible } = formItem;
  return visible === false || folding && collapseAll;
}
function isActivetem($xeform, formItem) {
  let { visibleMethod, itemRender, visible, field } = formItem;
  if (visible === false) {
    return visible;
  }
  const compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;
  if (!visibleMethod && compConf && compConf.itemVisibleMethod) {
    visibleMethod = compConf.itemVisibleMethod;
  }
  if (!visibleMethod) {
    return true;
  }
  const { data } = $xeform.props;
  return visibleMethod({ data, field, property: field, item: formItem, $form: $xeform, $grid: $xeform.xegrid });
}
function watchItem(props, formItem) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      formItem.update(name, value);
    });
  });
}
function assemItem($xeform, el, formItem, formGather) {
  const { reactData } = $xeform;
  const { staticItems } = reactData;
  const parentElem = el.parentNode;
  const parentItem = formGather ? formGather.formItem : null;
  const parentItems = parentItem ? parentItem.children : staticItems;
  if (parentElem) {
    parentItems.splice(import_xe_utils45.default.arrayIndexOf(parentElem.children, el), 0, formItem);
    reactData.staticItems = staticItems.slice(0);
  }
}
function destroyItem($xeform, formItem) {
  const { reactData } = $xeform;
  const { staticItems } = reactData;
  const index = import_xe_utils45.default.findIndexOf(staticItems, (item) => item.id === formItem.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  reactData.staticItems = staticItems.slice(0);
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/tooltip/index.js
var VxeTooltip = Object.assign(tooltip_default, {
  install: function(app) {
    VXETable.tooltip = true;
    app.component(tooltip_default.name, tooltip_default);
  }
});
var Tooltip = VxeTooltip;
dynamicApp.component(tooltip_default.name, tooltip_default);
var tooltip_default2 = VxeTooltip;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/form-config-item.js
var import_xe_utils46 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/render.js
function renderPrefixIcon(titlePrefix) {
  return h("span", {
    class: "vxe-form--item-title-prefix"
  }, [
    h("i", {
      class: titlePrefix.icon || conf_default.icon.FORM_PREFIX
    })
  ]);
}
function renderSuffixIcon(titleSuffix) {
  return h("span", {
    class: "vxe-form--item-title-suffix"
  }, [
    h("i", {
      class: titleSuffix.icon || conf_default.icon.FORM_SUFFIX
    })
  ]);
}
function renderTitle($xeform, item) {
  const { data } = $xeform.props;
  const { computeTooltipOpts } = $xeform.getComputeMaps();
  const { slots, field, itemRender, titlePrefix, titleSuffix } = item;
  const tooltipOpts = computeTooltipOpts.value;
  const compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;
  const params = { data, field, property: field, item, $form: $xeform, $grid: $xeform.xegrid };
  const titleSlot = slots ? slots.title : null;
  const contVNs = [];
  const titVNs = [];
  if (titlePrefix) {
    titVNs.push(titlePrefix.content || titlePrefix.message ? h(tooltip_default2, Object.assign(Object.assign(Object.assign({}, tooltipOpts), titlePrefix), { content: getFuncText(titlePrefix.content || titlePrefix.message) }), {
      default: () => renderPrefixIcon(titlePrefix)
    }) : renderPrefixIcon(titlePrefix));
  }
  titVNs.push(h("span", {
    class: "vxe-form--item-title-label"
  }, compConf && compConf.renderItemTitle ? getSlotVNs(compConf.renderItemTitle(itemRender, params)) : titleSlot ? $xeform.callSlot(titleSlot, params) : getFuncText(item.title)));
  contVNs.push(h("div", {
    class: "vxe-form--item-title-content"
  }, titVNs));
  const fixVNs = [];
  if (titleSuffix) {
    fixVNs.push(titleSuffix.content || titleSuffix.message ? h(tooltip_default2, Object.assign(Object.assign(Object.assign({}, tooltipOpts), titleSuffix), { content: getFuncText(titleSuffix.content || titleSuffix.message) }), {
      default: () => renderSuffixIcon(titleSuffix)
    }) : renderSuffixIcon(titleSuffix));
  }
  contVNs.push(h("div", {
    class: "vxe-form--item-title-postfix"
  }, fixVNs));
  return contVNs;
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/form-config-item.js
var VxeFormConfigItem = defineComponent({
  name: "VxeFormConfigItem",
  props: {
    itemConfig: Object
  },
  setup(props) {
    const $xeform = inject("$xeform", {});
    const xeformiteminfo = { itemConfig: props.itemConfig };
    provide("$xeformiteminfo", xeformiteminfo);
    provide("$xeformgather", null);
    const renderVN = () => {
      const { reactData } = $xeform;
      const { data, rules, span: allSpan, align: allAlign, titleAlign: allTitleAlign, titleWidth: allTitleWidth, titleColon: allTitleColon, titleAsterisk: allTitleAsterisk, titleOverflow: allTitleOverflow, vertical: allVertical } = $xeform.props;
      const { computeValidOpts } = $xeform.getComputeMaps();
      const item = props.itemConfig;
      const { collapseAll } = reactData;
      const validOpts = computeValidOpts.value;
      const { slots, title, visible, folding, field, collapseNode, itemRender, showError, errRule, className, titleOverflow, vertical, children, showTitle, contentClassName, contentStyle, titleClassName, titleStyle } = item;
      const compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;
      const itemClassName = compConf ? compConf.itemClassName : "";
      const itemStyle = compConf ? compConf.itemStyle : null;
      const itemContentClassName = compConf ? compConf.itemContentClassName : "";
      const itemContentStyle = compConf ? compConf.itemContentStyle : null;
      const itemTitleClassName = compConf ? compConf.itemTitleClassName : "";
      const itemTitleStyle = compConf ? compConf.itemTitleStyle : null;
      const defaultSlot = slots ? slots.default : null;
      const titleSlot = slots ? slots.title : null;
      const span = item.span || allSpan;
      const align = item.align || allAlign;
      const titleAlign = import_xe_utils46.default.eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
      const titleWidth = import_xe_utils46.default.eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
      const titleColon = import_xe_utils46.default.eqNull(item.titleColon) ? allTitleColon : item.titleColon;
      const titleAsterisk = import_xe_utils46.default.eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
      const itemOverflow = import_xe_utils46.default.isUndefined(titleOverflow) || import_xe_utils46.default.isNull(titleOverflow) ? allTitleOverflow : titleOverflow;
      const itemVertical = import_xe_utils46.default.isUndefined(vertical) || import_xe_utils46.default.isNull(vertical) ? allVertical : vertical;
      const ovEllipsis = itemOverflow === "ellipsis";
      const ovTitle = itemOverflow === "title";
      const ovTooltip = itemOverflow === true || itemOverflow === "tooltip";
      const hasEllipsis = ovTitle || ovTooltip || ovEllipsis;
      const params = { data, field, property: field, item, $form: $xeform, $grid: $xeform.xegrid };
      if (visible === false) {
        return createCommentVNode();
      }
      let isRequired = false;
      if (rules) {
        const itemRules = rules[field];
        if (itemRules) {
          isRequired = itemRules.some((rule) => rule.required);
        }
      }
      const isGather = children && children.length > 0;
      if (isGather) {
        const childVNs = children.map((childItem, index) => {
          return h(VxeFormConfigItem, {
            key: index,
            itemConfig: childItem
          });
        });
        return childVNs.length ? h("div", {
          class: ["vxe-form--gather vxe-form--item-row", item.id, span ? `vxe-form--item-col_${span} is--span` : "", className ? import_xe_utils46.default.isFunction(className) ? className(params) : className : ""]
        }, childVNs) : createCommentVNode();
      }
      let contentVNs = [];
      if (defaultSlot) {
        contentVNs = $xeform.callSlot(defaultSlot, params);
      } else if (compConf && compConf.renderItemContent) {
        contentVNs = getSlotVNs(compConf.renderItemContent(itemRender, params));
      } else if (field) {
        contentVNs = [import_xe_utils46.default.toValueString(import_xe_utils46.default.get(data, field))];
      }
      if (collapseNode) {
        contentVNs.push(h("div", {
          class: "vxe-form--item-trigger-node",
          onClick: $xeform.toggleCollapseEvent
        }, [
          h("span", {
            class: "vxe-form--item-trigger-text"
          }, collapseAll ? conf_default.i18n("vxe.form.unfolding") : conf_default.i18n("vxe.form.folding")),
          h("i", {
            class: ["vxe-form--item-trigger-icon", collapseAll ? conf_default.icon.FORM_FOLDING : conf_default.icon.FORM_UNFOLDING]
          })
        ]));
      }
      if (errRule && validOpts.showMessage) {
        contentVNs.push(h("div", {
          class: "vxe-form--item-valid",
          style: errRule.maxWidth ? {
            width: `${errRule.maxWidth}px`
          } : null
        }, errRule.content));
      }
      const ons = ovTooltip ? {
        onMouseenter(evnt) {
          $xeform.triggerTitleTipEvent(evnt, params);
        },
        onMouseleave: $xeform.handleTitleTipLeaveEvent
      } : {};
      return h("div", {
        class: [
          "vxe-form--item",
          item.id,
          span ? `vxe-form--item-col_${span} is--span` : "",
          className ? import_xe_utils46.default.isFunction(className) ? className(params) : className : "",
          itemClassName ? import_xe_utils46.default.isFunction(itemClassName) ? itemClassName(params) : itemClassName : "",
          {
            "is--title": title,
            "is--colon": titleColon,
            "is--vertical": itemVertical,
            "is--asterisk": titleAsterisk,
            "is--required": isRequired,
            "is--hidden": folding && collapseAll,
            "is--active": isActivetem($xeform, item),
            "is--error": showError
          }
        ],
        style: import_xe_utils46.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        h("div", {
          class: "vxe-form--item-inner"
        }, [
          showTitle !== false && (title || titleSlot) ? h("div", Object.assign({ class: [
            "vxe-form--item-title",
            titleAlign ? `align--${titleAlign}` : "",
            hasEllipsis ? "is--ellipsis" : "",
            itemTitleClassName ? import_xe_utils46.default.isFunction(itemTitleClassName) ? itemTitleClassName(params) : itemTitleClassName : "",
            titleClassName ? import_xe_utils46.default.isFunction(titleClassName) ? titleClassName(params) : titleClassName : ""
          ], style: Object.assign({}, import_xe_utils46.default.isFunction(itemTitleStyle) ? itemTitleStyle(params) : itemTitleStyle, import_xe_utils46.default.isFunction(titleStyle) ? titleStyle(params) : titleStyle, titleWidth ? {
            width: isNaN(titleWidth) ? titleWidth : `${titleWidth}px`
          } : null), title: ovTitle ? getFuncText(title) : null }, ons), renderTitle($xeform, item)) : null,
          h("div", {
            class: [
              "vxe-form--item-content",
              align ? `align--${align}` : "",
              itemContentClassName ? import_xe_utils46.default.isFunction(itemContentClassName) ? itemContentClassName(params) : itemContentClassName : "",
              contentClassName ? import_xe_utils46.default.isFunction(contentClassName) ? contentClassName(params) : contentClassName : ""
            ],
            style: Object.assign({}, import_xe_utils46.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils46.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
          }, contentVNs)
        ])
      ]);
    };
    const $xeformconfigitem = {
      renderVN
    };
    return $xeformconfigitem;
  },
  render() {
    return this.renderVN();
  }
});
var form_config_item_default = VxeFormConfigItem;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/form.js
var Rule2 = class {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.min,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
};
var validErrorRuleValue = (rule, val) => {
  const { type, min, max, pattern } = rule;
  const isNumType = type === "number";
  const numVal = isNumType ? import_xe_utils47.default.toNumber(val) : import_xe_utils47.default.getSize(val);
  if (isNumType && isNaN(val)) {
    return true;
  }
  if (!import_xe_utils47.default.eqNull(min) && numVal < import_xe_utils47.default.toNumber(min)) {
    return true;
  }
  if (!import_xe_utils47.default.eqNull(max) && numVal > import_xe_utils47.default.toNumber(max)) {
    return true;
  }
  if (pattern && !(import_xe_utils47.default.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
    return true;
  }
  return false;
};
function getResetValue(value, resetValue) {
  if (import_xe_utils47.default.isArray(value)) {
    resetValue = [];
  }
  return resetValue;
}
var form_default = defineComponent({
  name: "VxeForm",
  props: {
    collapseStatus: { type: Boolean, default: true },
    loading: Boolean,
    data: Object,
    size: { type: String, default: () => conf_default.form.size || conf_default.size },
    span: { type: [String, Number], default: () => conf_default.form.span },
    align: { type: String, default: () => conf_default.form.align },
    titleAlign: { type: String, default: () => conf_default.form.titleAlign },
    titleWidth: { type: [String, Number], default: () => conf_default.form.titleWidth },
    titleColon: { type: Boolean, default: () => conf_default.form.titleColon },
    titleAsterisk: { type: Boolean, default: () => conf_default.form.titleAsterisk },
    titleOverflow: { type: [Boolean, String], default: null },
    vertical: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    readonly: Boolean,
    items: Array,
    rules: Object,
    preventSubmit: { type: Boolean, default: () => conf_default.form.preventSubmit },
    validConfig: Object,
    tooltipConfig: Object,
    customLayout: { type: Boolean, default: () => conf_default.form.customLayout }
  },
  emits: [
    "update:collapseStatus",
    "collapse",
    "toggle-collapse",
    "submit",
    "submit-invalid",
    "reset"
  ],
  setup(props, context) {
    const hasUseTooltip = VXETable.tooltip;
    const { slots, emit } = context;
    const xID = import_xe_utils47.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      collapseAll: props.collapseStatus,
      staticItems: [],
      formItems: []
    });
    const internalData = reactive({
      tooltipTimeout: null,
      tooltipStore: {
        item: null,
        visible: false
      }
    });
    const $xegrid = inject("$xegrid", null);
    const refElem = ref();
    const refTooltip = ref();
    let formMethods = {};
    const computeValidOpts = computed(() => {
      return Object.assign({}, conf_default.form.validConfig, props.validConfig);
    });
    const computeTooltipOpts = computed(() => {
      return Object.assign({}, conf_default.tooltip, conf_default.form.tooltipConfig, props.tooltipConfig);
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize,
      computeValidOpts,
      computeTooltipOpts
    };
    const $xeform = {
      xID,
      props,
      context,
      reactData,
      xegrid: $xegrid,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils47.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils47.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const loadItem = (list) => {
      if (list.length) {
        if (true) {
          list.forEach((item) => {
            if (item.slots) {
              import_xe_utils47.default.each(item.slots, (func) => {
                if (!import_xe_utils47.default.isFunction(func)) {
                  if (!slots[func]) {
                    errLog("vxe.error.notSlot", [func]);
                  }
                }
              });
            }
          });
        }
      }
      reactData.staticItems = import_xe_utils47.default.mapTree(list, (item) => createItem($xeform, item), { children: "children" });
      return nextTick();
    };
    const getItems = () => {
      const itemList = [];
      import_xe_utils47.default.eachTree(reactData.formItems, (item) => {
        itemList.push(item);
      }, { children: "children" });
      return itemList;
    };
    const getItemByField = (field) => {
      const rest = import_xe_utils47.default.findTree(reactData.formItems, (item) => item.field === field, { children: "children" });
      return rest ? rest.item : null;
    };
    const getCollapseStatus = () => {
      return reactData.collapseAll;
    };
    const toggleCollapse = () => {
      const status = !getCollapseStatus();
      reactData.collapseAll = status;
      emit("update:collapseStatus", status);
      return nextTick();
    };
    const toggleCollapseEvent = (evnt) => {
      toggleCollapse();
      const status = getCollapseStatus();
      formMethods.dispatchEvent("toggle-collapse", { status, collapse: status, data: props.data }, evnt);
      formMethods.dispatchEvent("collapse", { status, collapse: status, data: props.data }, evnt);
    };
    const clearValidate = (fieldOrItem) => {
      if (fieldOrItem) {
        let fields = fieldOrItem;
        if (!import_xe_utils47.default.isArray(fieldOrItem)) {
          fields = [fieldOrItem];
        }
        fields.forEach((field) => {
          if (field) {
            const item = handleFieldOrItem($xeform, field);
            if (item) {
              item.showError = false;
            }
          }
        });
      } else {
        getItems().forEach((item) => {
          item.showError = false;
        });
      }
      return nextTick();
    };
    const reset = () => {
      const { data } = props;
      const itemList = getItems();
      if (data) {
        itemList.forEach((item) => {
          const { field, resetValue, itemRender } = item;
          if (isEnableConf(itemRender)) {
            const compConf = VXETable.renderer.get(itemRender.name);
            if (compConf && compConf.itemResetMethod) {
              compConf.itemResetMethod({ data, field, property: field, item, $form: $xeform, $grid: $xeform.xegrid });
            } else if (field) {
              import_xe_utils47.default.set(data, field, resetValue === null ? getResetValue(import_xe_utils47.default.get(data, field), void 0) : import_xe_utils47.default.clone(resetValue, true));
            }
          }
        });
      }
      return clearValidate();
    };
    const resetEvent = (evnt) => {
      evnt.preventDefault();
      reset();
      formMethods.dispatchEvent("reset", { data: props.data }, evnt);
    };
    const handleFocus = (fields) => {
      const el = refElem.value;
      for (let i = 0; i < fields.length; i++) {
        const property = fields[i];
        const item = getItemByField(property);
        if (item && isEnableConf(item.itemRender)) {
          const { itemRender } = item;
          const compConf = VXETable.renderer.get(itemRender.name);
          let inputElem = null;
          if (!i) {
            scrollToView(el.querySelector(`.${item.id}`));
          }
          if (itemRender.autofocus) {
            inputElem = el.querySelector(`.${item.id} ${itemRender.autofocus}`);
          }
          if (!inputElem && compConf && compConf.autofocus) {
            inputElem = el.querySelector(`.${item.id} ${compConf.autofocus}`);
          }
          if (inputElem) {
            inputElem.focus();
            break;
          }
        }
      }
    };
    const validItemRules = (validType, fields, val) => {
      const { data, rules: formRules } = props;
      const errorMaps = {};
      if (!import_xe_utils47.default.isArray(fields)) {
        fields = [fields];
      }
      return Promise.all(fields.map((property) => {
        const errorRules = [];
        const syncVailds = [];
        if (property && formRules) {
          const rules = import_xe_utils47.default.get(formRules, property);
          if (rules) {
            const itemValue = import_xe_utils47.default.isUndefined(val) ? import_xe_utils47.default.get(data, property) : val;
            rules.forEach((rule) => {
              const { type, trigger, required, validator } = rule;
              if (validType === "all" || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    itemValue,
                    rule,
                    rules,
                    data,
                    field: property,
                    property,
                    $form: $xeform
                  };
                  let customValid;
                  if (import_xe_utils47.default.isString(validator)) {
                    const gvItem = VXETable.validators.get(validator);
                    if (gvItem) {
                      if (gvItem.itemValidatorMethod) {
                        customValid = gvItem.itemValidatorMethod(validParams);
                      } else {
                        if (true) {
                          warnLog("vxe.error.notValidators", [validator]);
                        }
                      }
                    } else {
                      if (true) {
                        errLog("vxe.error.notValidators", [validator]);
                      }
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (import_xe_utils47.default.isError(customValid)) {
                      errorRules.push(new Rule2({ type: "custom", trigger, content: customValid.message, rule: new Rule2(rule) }));
                    } else if (customValid.catch) {
                      syncVailds.push(customValid.catch((e) => {
                        errorRules.push(new Rule2({ type: "custom", trigger, content: e ? e.message : rule.content || rule.message, rule: new Rule2(rule) }));
                      }));
                    }
                  }
                } else {
                  const isArrType = type === "array";
                  const isArrVal = import_xe_utils47.default.isArray(itemValue);
                  let hasEmpty = true;
                  if (isArrType || isArrVal) {
                    hasEmpty = !isArrVal || !itemValue.length;
                  } else if (import_xe_utils47.default.isString(itemValue)) {
                    hasEmpty = eqEmptyValue(itemValue.trim());
                  } else {
                    hasEmpty = eqEmptyValue(itemValue);
                  }
                  if (required ? hasEmpty || validErrorRuleValue(rule, itemValue) : !hasEmpty && validErrorRuleValue(rule, itemValue)) {
                    errorRules.push(new Rule2(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncVailds).then(() => {
          if (errorRules.length) {
            errorMaps[property] = errorRules.map((rule) => {
              return {
                $form: $xeform,
                rule,
                data,
                field: property,
                property
              };
            });
          }
        });
      })).then(() => {
        if (!import_xe_utils47.default.isEmpty(errorMaps)) {
          return Promise.reject(errorMaps);
        }
      });
    };
    let showErrTime;
    const beginValidate = (itemList, type, callback) => {
      const { data, rules: formRules } = props;
      const validOpts = computeValidOpts.value;
      const validRest = {};
      const validFields = [];
      const itemValids = [];
      clearTimeout(showErrTime);
      if (data && formRules) {
        itemList.forEach((item) => {
          const { field } = item;
          if (field && !isHiddenItem($xeform, item) && isActivetem($xeform, item)) {
            itemValids.push(validItemRules(type || "all", field).then(() => {
              item.errRule = null;
            }).catch((errorMaps) => {
              const rest = errorMaps[field];
              if (!validRest[field]) {
                validRest[field] = [];
              }
              validRest[field].push(rest);
              validFields.push(field);
              item.errRule = rest[0].rule;
              return Promise.reject(rest);
            }));
          }
        });
        return Promise.all(itemValids).then(() => {
          if (callback) {
            callback();
          }
        }).catch(() => {
          return new Promise((resolve) => {
            showErrTime = window.setTimeout(() => {
              itemList.forEach((item) => {
                if (item.errRule) {
                  item.showError = true;
                }
              });
            }, 20);
            if (validOpts.autoPos !== false) {
              nextTick(() => {
                handleFocus(validFields);
              });
            }
            if (callback) {
              callback(validRest);
              resolve();
            } else {
              resolve(validRest);
            }
          });
        });
      }
      if (callback) {
        callback();
      }
      return Promise.resolve();
    };
    const validate = (callback) => {
      clearValidate();
      return beginValidate(getItems(), "", callback);
    };
    const validateField = (fieldOrItem, callback) => {
      let fields = [];
      if (import_xe_utils47.default.isArray(fieldOrItem)) {
        fields = fieldOrItem;
      } else {
        fields = [fieldOrItem];
      }
      return beginValidate(fields.map((field) => handleFieldOrItem($xeform, field)), "", callback);
    };
    const submitEvent = (evnt) => {
      evnt.preventDefault();
      if (!props.preventSubmit) {
        clearValidate();
        beginValidate(getItems()).then((errMap) => {
          if (errMap) {
            formMethods.dispatchEvent("submit-invalid", { data: props.data, errMap }, evnt);
          } else {
            formMethods.dispatchEvent("submit", { data: props.data }, evnt);
          }
        });
      }
    };
    const closeTooltip = () => {
      const { tooltipStore } = internalData;
      const $tooltip = refTooltip.value;
      if (tooltipStore.visible) {
        Object.assign(tooltipStore, {
          item: null,
          visible: false
        });
        if ($tooltip) {
          $tooltip.close();
        }
      }
      return nextTick();
    };
    const triggerTitleTipEvent = (evnt, params) => {
      const { item } = params;
      const { tooltipStore } = internalData;
      const $tooltip = refTooltip.value;
      const overflowElem = evnt.currentTarget.children[0];
      const content = (overflowElem.textContent || "").trim();
      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      clearTimeout(internalData.tooltipTimeout);
      if (tooltipStore.item !== item) {
        closeTooltip();
      }
      if (content && isCellOverflow) {
        Object.assign(tooltipStore, {
          item,
          visible: true
        });
        if ($tooltip) {
          $tooltip.open(overflowElem, content);
        }
      }
    };
    const handleTitleTipLeaveEvent = () => {
      const tooltipOpts = computeTooltipOpts.value;
      let $tooltip = refTooltip.value;
      if ($tooltip) {
        $tooltip.setActived(false);
      }
      if (tooltipOpts.enterable) {
        internalData.tooltipTimeout = setTimeout(() => {
          $tooltip = refTooltip.value;
          if ($tooltip && !$tooltip.isActived()) {
            closeTooltip();
          }
        }, tooltipOpts.leaveDelay);
      } else {
        closeTooltip();
      }
    };
    const triggerItemEvent = (evnt, field, itemValue) => {
      if (field) {
        return validItemRules(evnt ? ["blur"].includes(evnt.type) ? "blur" : "change" : "all", field, itemValue).then(() => {
          clearValidate(field);
        }).catch((errorMaps) => {
          const rest = errorMaps[field];
          const item = getItemByField(field);
          if (rest && item) {
            item.showError = true;
            item.errRule = rest[0].rule;
          }
        });
      }
      return nextTick();
    };
    const updateStatus = (scope, itemValue) => {
      const { field } = scope;
      return triggerItemEvent(new Event("change"), field, itemValue);
    };
    formMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $form: $xeform, $grid: $xegrid, $event: evnt }, params));
      },
      reset,
      validate,
      validateField,
      clearValidate,
      updateStatus,
      toggleCollapse,
      getItems,
      getItemByField,
      closeTooltip
    };
    const formPrivateMethods = {
      callSlot,
      triggerItemEvent,
      toggleCollapseEvent,
      triggerTitleTipEvent,
      handleTitleTipLeaveEvent
    };
    Object.assign($xeform, formMethods, formPrivateMethods);
    const staticItemFlag = ref(0);
    watch(() => reactData.staticItems.length, () => {
      staticItemFlag.value++;
    });
    watch(() => reactData.staticItems, () => {
      staticItemFlag.value++;
    });
    watch(staticItemFlag, () => {
      reactData.formItems = reactData.staticItems;
    });
    const itemFlag = ref(0);
    watch(() => props.items ? props.items.length : -1, () => {
      itemFlag.value++;
    });
    watch(() => props.items, () => {
      itemFlag.value++;
    });
    watch(itemFlag, () => {
      loadItem(props.items || []);
    });
    watch(() => props.collapseStatus, (value) => {
      reactData.collapseAll = !!value;
    });
    const renderVN = () => {
      const { loading, className, data, customLayout } = props;
      const { formItems } = reactData;
      const vSize = computeSize.value;
      const tooltipOpts = computeTooltipOpts.value;
      const defaultSlot = slots.default;
      return h("form", {
        ref: refElem,
        class: ["vxe-form", className ? import_xe_utils47.default.isFunction(className) ? className({ items: formItems, data, $form: $xeform }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading
        }],
        onSubmit: submitEvent,
        onReset: resetEvent
      }, [
        h("div", {
          class: "vxe-form--wrapper vxe-form--item-row"
        }, customLayout ? defaultSlot ? defaultSlot({}) : [] : formItems.map((item, index) => {
          return h(form_config_item_default, {
            key: index,
            itemConfig: item
          });
        })),
        h("div", {
          class: "vxe-form-slots",
          ref: "hideItem"
        }, customLayout ? [] : defaultSlot ? defaultSlot({}) : []),
        /**
         * 
         */
        h(loading_default2, {
          class: "vxe-form--loading",
          modelValue: loading
        }),
        /**
         * 
         */
        hasUseTooltip ? h(tooltip_default2, Object.assign({ ref: refTooltip }, tooltipOpts)) : createCommentVNode()
      ]);
    };
    $xeform.renderVN = renderVN;
    if (props.items) {
      loadItem(props.items);
    }
    provide("$xeform", $xeform);
    provide("$xeformgather", null);
    provide("$xeformitem", null);
    provide("$xeformiteminfo", null);
    return $xeform;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/index.js
var VxeForm = Object.assign(form_default, {
  install(app) {
    app.component(form_default.name, form_default);
  }
});
var Form = VxeForm;
dynamicApp.component(form_default.name, form_default);
var form_default2 = VxeForm;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/grid/src/grid.js
var tableComponentPropKeys = Object.keys(props_default);
var tableComponentMethodKeys = ["clearAll", "syncData", "updateData", "loadData", "reloadData", "reloadRow", "loadColumn", "reloadColumn", "getRowNode", "getColumnNode", "getRowIndex", "getVTRowIndex", "getVMRowIndex", "getColumnIndex", "getVTColumnIndex", "getVMColumnIndex", "createData", "createRow", "revertData", "clearData", "isInsertByRow", "isUpdateByRow", "getColumns", "getColumnById", "getColumnByField", "getTableColumn", "getData", "getCheckboxRecords", "getParentRow", "getRowSeq", "getRowById", "getRowid", "getTableData", "setColumnFixed", "clearColumnFixed", "setColumnWidth", "getColumnWidth", "hideColumn", "showColumn", "resetColumn", "refreshColumn", "refreshScroll", "recalculate", "closeTooltip", "isAllCheckboxChecked", "isAllCheckboxIndeterminate", "getCheckboxIndeterminateRecords", "setCheckboxRow", "isCheckedByCheckboxRow", "isIndeterminateByCheckboxRow", "toggleCheckboxRow", "setAllCheckboxRow", "getRadioReserveRecord", "clearRadioReserve", "getCheckboxReserveRecords", "clearCheckboxReserve", "toggleAllCheckboxRow", "clearCheckboxRow", "setCurrentRow", "isCheckedByRadioRow", "setRadioRow", "clearCurrentRow", "clearRadioRow", "getCurrentRecord", "getRadioRecord", "getCurrentColumn", "setCurrentColumn", "clearCurrentColumn", "setPendingRow", "togglePendingRow", "getPendingRecords", "clearPendingRow", "sort", "clearSort", "isSort", "getSortColumns", "closeFilter", "isFilter", "isActiveFilterByColumn", "isRowExpandLoaded", "clearRowExpandLoaded", "reloadRowExpand", "reloadRowExpand", "toggleRowExpand", "setAllRowExpand", "setRowExpand", "isExpandByRow", "isRowExpandByRow", "clearRowExpand", "clearRowExpandReserve", "getRowExpandRecords", "getTreeExpandRecords", "isTreeExpandLoaded", "clearTreeExpandLoaded", "reloadTreeExpand", "reloadTreeChilds", "toggleTreeExpand", "setAllTreeExpand", "setTreeExpand", "isTreeExpandByRow", "clearTreeExpand", "clearTreeExpandReserve", "getScroll", "scrollTo", "scrollToRow", "scrollToColumn", "clearScroll", "updateFooter", "updateStatus", "setMergeCells", "removeInsertRow", "removeMergeCells", "getMergeCells", "clearMergeCells", "setMergeFooterItems", "removeMergeFooterItems", "getMergeFooterItems", "clearMergeFooterItems", "openTooltip", "focus", "blur", "connect"];
var gridComponentEmits = [
  ...emits_default,
  "page-change",
  "form-submit",
  "form-submit-invalid",
  "form-reset",
  "form-collapse",
  "form-toggle-collapse",
  "proxy-query",
  "proxy-delete",
  "proxy-save",
  "toolbar-button-click",
  "toolbar-tool-click",
  "zoom"
];
var grid_default = defineComponent({
  name: "VxeGrid",
  props: Object.assign(Object.assign({}, props_default), { layouts: Array, columns: Array, pagerConfig: Object, proxyConfig: Object, toolbarConfig: Object, formConfig: Object, zoomConfig: Object, size: { type: String, default: () => conf_default.grid.size || conf_default.size } }),
  emits: gridComponentEmits,
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils48.default.uniqueId();
    const instance = getCurrentInstance();
    const computeSize = useSize(props);
    const reactData = reactive({
      tableLoading: false,
      proxyInited: false,
      isZMax: false,
      tableData: [],
      filterData: [],
      formData: {},
      sortData: [],
      tZindex: 0,
      tablePage: {
        total: 0,
        pageSize: conf_default.pager.pageSize || 10,
        currentPage: 1
      }
    });
    const refElem = ref();
    const refTable = ref();
    const refForm = ref();
    const refToolbar = ref();
    const refPager = ref();
    const refFormWrapper = ref();
    const refToolbarWrapper = ref();
    const refTopWrapper = ref();
    const refBottomWrapper = ref();
    const refPagerWrapper = ref();
    const extendTableMethods = (methodKeys) => {
      const funcs = {};
      methodKeys.forEach((name) => {
        funcs[name] = (...args) => {
          const $xetable = refTable.value;
          if ($xetable && $xetable[name]) {
            return $xetable[name](...args);
          }
        };
      });
      return funcs;
    };
    const gridExtendTableMethods = extendTableMethods(tableComponentMethodKeys);
    tableComponentMethodKeys.forEach((name) => {
      gridExtendTableMethods[name] = (...args) => {
        const $xetable = refTable.value;
        if ($xetable && $xetable[name]) {
          return $xetable && $xetable[name](...args);
        }
      };
    });
    const computeProxyOpts = computed(() => {
      return Object.assign({}, conf_default.grid.proxyConfig, props.proxyConfig);
    });
    const computeIsMsg = computed(() => {
      const proxyOpts = computeProxyOpts.value;
      return proxyOpts.message !== false;
    });
    const computePagerOpts = computed(() => {
      return Object.assign({}, conf_default.grid.pagerConfig, props.pagerConfig);
    });
    const computeFormOpts = computed(() => {
      return Object.assign({}, conf_default.grid.formConfig, props.formConfig);
    });
    const computeToolbarOpts = computed(() => {
      return Object.assign({}, conf_default.grid.toolbarConfig, props.toolbarConfig);
    });
    const computeZoomOpts = computed(() => {
      return Object.assign({}, conf_default.grid.zoomConfig, props.zoomConfig);
    });
    const computeStyles = computed(() => {
      return reactData.isZMax ? { zIndex: reactData.tZindex } : null;
    });
    const computeTableExtendProps = computed(() => {
      const rest = {};
      const gridProps = props;
      tableComponentPropKeys.forEach((key) => {
        rest[key] = gridProps[key];
      });
      return rest;
    });
    const refMaps = {
      refElem,
      refTable,
      refForm,
      refToolbar,
      refPager
    };
    const computeMaps = {
      computeProxyOpts,
      computePagerOpts,
      computeFormOpts,
      computeToolbarOpts,
      computeZoomOpts
    };
    const $xegrid = {
      xID,
      props,
      context,
      instance,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    let gridMethods = {};
    const computeTableProps = computed(() => {
      const { seqConfig, pagerConfig, loading, editConfig, proxyConfig } = props;
      const { isZMax, tableLoading, tablePage, tableData } = reactData;
      const tableExtendProps = computeTableExtendProps.value;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      const tableProps = Object.assign({}, tableExtendProps);
      if (isZMax) {
        if (tableExtendProps.maxHeight) {
          tableProps.maxHeight = "100%";
        } else {
          tableProps.height = "100%";
        }
      }
      if (proxyConfig && isEnableConf(proxyOpts)) {
        tableProps.loading = loading || tableLoading;
        tableProps.data = tableData;
        if (pagerConfig && proxyOpts.seq && isEnableConf(pagerOpts)) {
          tableProps.seqConfig = Object.assign({}, seqConfig, { startIndex: (tablePage.currentPage - 1) * tablePage.pageSize });
        }
      }
      if (editConfig) {
        tableProps.editConfig = Object.assign({}, editConfig);
      }
      return tableProps;
    });
    const initToolbar = () => {
      const toolbarOpts = computeToolbarOpts.value;
      if (props.toolbarConfig && isEnableConf(toolbarOpts)) {
        nextTick(() => {
          const $xetable = refTable.value;
          const $xetoolbar = refToolbar.value;
          if ($xetable && $xetoolbar) {
            $xetable.connect($xetoolbar);
          }
        });
      }
    };
    const initPages = () => {
      const { tablePage } = reactData;
      const { pagerConfig } = props;
      const pagerOpts = computePagerOpts.value;
      const { currentPage, pageSize } = pagerOpts;
      if (pagerConfig && isEnableConf(pagerOpts)) {
        if (currentPage) {
          tablePage.currentPage = currentPage;
        }
        if (pageSize) {
          tablePage.pageSize = pageSize;
        }
      }
    };
    const triggerPendingEvent = (code) => {
      const isMsg = computeIsMsg.value;
      const $xetable = refTable.value;
      const selectRecords = $xetable.getCheckboxRecords();
      if (selectRecords.length) {
        $xetable.togglePendingRow(selectRecords);
        gridExtendTableMethods.clearCheckboxRow();
      } else {
        if (isMsg) {
          if (true) {
            if (!VXETable.modal) {
              errLog("vxe.error.reqModule", ["Modal"]);
            }
          }
          VXETable.modal.message({ id: code, content: conf_default.i18n("vxe.grid.selectOneRecord"), status: "warning" });
        }
      }
    };
    const getRespMsg = (rest, defaultMsg) => {
      const proxyOpts = computeProxyOpts.value;
      const resConfigs = proxyOpts.response || proxyOpts.props || {};
      const messageProp = resConfigs.message;
      let msg;
      if (rest && messageProp) {
        msg = import_xe_utils48.default.isFunction(messageProp) ? messageProp({ data: rest, $grid: $xegrid }) : import_xe_utils48.default.get(rest, messageProp);
      }
      return msg || conf_default.i18n(defaultMsg);
    };
    const handleDeleteRow = (code, alertKey, callback) => {
      const isMsg = computeIsMsg.value;
      const selectRecords = gridExtendTableMethods.getCheckboxRecords();
      if (isMsg) {
        if (selectRecords.length) {
          return VXETable.modal.confirm({ id: `cfm_${code}`, content: conf_default.i18n(alertKey), escClosable: true }).then((type) => {
            if (type === "confirm") {
              return callback();
            }
          });
        } else {
          if (true) {
            if (!VXETable.modal) {
              errLog("vxe.error.reqModule", ["Modal"]);
            }
          }
          VXETable.modal.message({ id: `msg_${code}`, content: conf_default.i18n("vxe.grid.selectOneRecord"), status: "warning" });
        }
      } else {
        if (selectRecords.length) {
          callback();
        }
      }
      return Promise.resolve();
    };
    const pageChangeEvent = (params) => {
      const { proxyConfig } = props;
      const { tablePage } = reactData;
      const { currentPage, pageSize } = params;
      const proxyOpts = computeProxyOpts.value;
      tablePage.currentPage = currentPage;
      tablePage.pageSize = pageSize;
      gridMethods.dispatchEvent("page-change", params);
      if (proxyConfig && isEnableConf(proxyOpts)) {
        gridMethods.commitProxy("query").then((rest) => {
          gridMethods.dispatchEvent("proxy-query", rest, params.$event);
        });
      }
    };
    const sortChangeEvent = (params) => {
      const $xetable = refTable.value;
      const { proxyConfig } = props;
      const { computeSortOpts } = $xetable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const sortOpts = computeSortOpts.value;
      if (sortOpts.remote) {
        reactData.sortData = params.sortList;
        if (proxyConfig && isEnableConf(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy("query").then((rest) => {
            gridMethods.dispatchEvent("proxy-query", rest, params.$event);
          });
        }
      }
      gridMethods.dispatchEvent("sort-change", params);
    };
    const filterChangeEvent = (params) => {
      const $xetable = refTable.value;
      const { proxyConfig } = props;
      const { computeFilterOpts } = $xetable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const filterOpts = computeFilterOpts.value;
      if (filterOpts.remote) {
        reactData.filterData = params.filterList;
        if (proxyConfig && isEnableConf(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy("query").then((rest) => {
            gridMethods.dispatchEvent("proxy-query", rest, params.$event);
          });
        }
      }
      gridMethods.dispatchEvent("filter-change", params);
    };
    const submitFormEvent = (params) => {
      const { proxyConfig } = props;
      const proxyOpts = computeProxyOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        gridMethods.commitProxy("reload").then((rest) => {
          gridMethods.dispatchEvent("proxy-query", Object.assign(Object.assign({}, rest), { isReload: true }), params.$event);
        });
      }
      gridMethods.dispatchEvent("form-submit", params);
    };
    const resetFormEvent = (params) => {
      const { proxyConfig } = props;
      const proxyOpts = computeProxyOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        gridMethods.commitProxy("reload").then((rest) => {
          gridMethods.dispatchEvent("proxy-query", Object.assign(Object.assign({}, rest), { isReload: true }), params.$event);
        });
      }
      gridMethods.dispatchEvent("form-reset", params);
    };
    const submitInvalidEvent = (params) => {
      gridMethods.dispatchEvent("form-submit-invalid", params);
    };
    const collapseEvent = (params) => {
      nextTick(() => gridExtendTableMethods.recalculate(true));
      gridMethods.dispatchEvent("form-toggle-collapse", params);
      gridMethods.dispatchEvent("form-collapse", params);
    };
    const handleZoom = (isMax) => {
      const { isZMax } = reactData;
      if (isMax ? !isZMax : isZMax) {
        reactData.isZMax = !isZMax;
        if (reactData.tZindex < getLastZIndex()) {
          reactData.tZindex = nextZIndex();
        }
      }
      return nextTick().then(() => gridExtendTableMethods.recalculate(true)).then(() => reactData.isZMax);
    };
    const getFuncSlot = (optSlots, slotKey) => {
      const funcSlot = optSlots[slotKey];
      if (funcSlot) {
        if (import_xe_utils48.default.isString(funcSlot)) {
          if (slots[funcSlot]) {
            return slots[funcSlot];
          } else {
            if (true) {
              errLog("vxe.error.notSlot", [funcSlot]);
            }
          }
        } else {
          return funcSlot;
        }
      }
      return null;
    };
    const renderForms = () => {
      const { formConfig, proxyConfig } = props;
      const { formData } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      const restVNs = [];
      if (formConfig && isEnableConf(formOpts) || slots.form) {
        let slotVNs = [];
        if (slots.form) {
          slotVNs = slots.form({ $grid: $xegrid });
        } else {
          if (formOpts.items) {
            const formSlots = {};
            if (!formOpts.inited) {
              formOpts.inited = true;
              const beforeItem = proxyOpts.beforeItem;
              if (proxyOpts && beforeItem) {
                formOpts.items.forEach((item) => {
                  beforeItem({ $grid: $xegrid, item });
                });
              }
            }
            formOpts.items.forEach((item) => {
              import_xe_utils48.default.each(item.slots, (func) => {
                if (!import_xe_utils48.default.isFunction(func)) {
                  if (slots[func]) {
                    formSlots[func] = slots[func];
                  }
                }
              });
            });
            slotVNs.push(h(form_default2, Object.assign(Object.assign({ ref: refForm }, Object.assign({}, formOpts, {
              data: proxyConfig && isEnableConf(proxyOpts) && proxyOpts.form ? formData : formOpts.data
            })), { onSubmit: submitFormEvent, onReset: resetFormEvent, onSubmitInvalid: submitInvalidEvent, onCollapse: collapseEvent }), formSlots));
          }
        }
        restVNs.push(h("div", {
          ref: refFormWrapper,
          key: "form",
          class: "vxe-grid--form-wrapper"
        }, slotVNs));
      }
      return restVNs;
    };
    const renderToolbars = () => {
      const { toolbarConfig } = props;
      const toolbarOpts = computeToolbarOpts.value;
      const restVNs = [];
      if (toolbarConfig && isEnableConf(toolbarOpts) || slots.toolbar) {
        let slotVNs = [];
        if (slots.toolbar) {
          slotVNs = slots.toolbar({ $grid: $xegrid });
        } else {
          const toolbarOptSlots = toolbarOpts.slots;
          let buttonsSlot;
          let toolsSlot;
          const toolbarSlots = {};
          if (toolbarOptSlots) {
            buttonsSlot = getFuncSlot(toolbarOptSlots, "buttons");
            toolsSlot = getFuncSlot(toolbarOptSlots, "tools");
            if (buttonsSlot) {
              toolbarSlots.buttons = buttonsSlot;
            }
            if (toolsSlot) {
              toolbarSlots.tools = toolsSlot;
            }
          }
          slotVNs.push(h(toolbar_default2, Object.assign({ ref: refToolbar }, toolbarOpts), toolbarSlots));
        }
        restVNs.push(h("div", {
          ref: refToolbarWrapper,
          key: "toolbar",
          class: "vxe-grid--toolbar-wrapper"
        }, slotVNs));
      }
      return restVNs;
    };
    const renderTops = () => {
      if (slots.top) {
        return [
          h("div", {
            ref: refTopWrapper,
            key: "top",
            class: "vxe-grid--top-wrapper"
          }, slots.top({ $grid: $xegrid }))
        ];
      }
      return [];
    };
    const defaultLayouts = ["Form", "Toolbar", "Top", "Table", "Bottom", "Pager"];
    const renderLayout = () => {
      const { layouts } = props;
      const vns = [];
      const currLayouts = layouts && layouts.length ? layouts : conf_default.grid.layouts || defaultLayouts;
      currLayouts.forEach((name) => {
        switch (name) {
          case "Form":
            vns.push(renderForms());
            break;
          case "Toolbar":
            vns.push(renderToolbars());
            break;
          case "Top":
            vns.push(renderTops());
            break;
          case "Table":
            vns.push(renderTables());
            break;
          case "Bottom":
            vns.push(renderBottoms());
            break;
          case "Pager":
            vns.push(renderPagers());
            break;
          default:
            if (true) {
              errLog("vxe.error.notProp", [`layouts -> ${name}`]);
            }
            break;
        }
      });
      return vns;
    };
    const tableCompEvents = {};
    emits_default.forEach((name) => {
      const type = import_xe_utils48.default.camelCase(`on-${name}`);
      tableCompEvents[type] = (...args) => emit(name, ...args);
    });
    const renderTables = () => {
      const { proxyConfig } = props;
      const tableProps = computeTableProps.value;
      const proxyOpts = computeProxyOpts.value;
      const tableOns = Object.assign({}, tableCompEvents);
      const emptySlot = slots.empty;
      const loadingSlot = slots.loading;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if (proxyOpts.sort) {
          tableOns.onSortChange = sortChangeEvent;
        }
        if (proxyOpts.filter) {
          tableOns.onFilterChange = filterChangeEvent;
        }
      }
      const slotObj = {};
      if (emptySlot) {
        slotObj.empty = () => emptySlot({});
      }
      if (loadingSlot) {
        slotObj.loading = () => loadingSlot({});
      }
      return [
        h(table_default2, Object.assign(Object.assign({ ref: refTable, key: "table" }, tableProps), tableOns), slotObj)
      ];
    };
    const renderBottoms = () => {
      if (slots.bottom) {
        return [
          h("div", {
            ref: refBottomWrapper,
            key: "bottom",
            class: "vxe-grid--bottom-wrapper"
          }, slots.bottom({ $grid: $xegrid }))
        ];
      }
      return [];
    };
    const renderPagers = () => {
      const { proxyConfig, pagerConfig } = props;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      const restVNs = [];
      if (pagerConfig && isEnableConf(pagerOpts) || slots.pager) {
        let slotVNs = [];
        if (slots.pager) {
          slotVNs = slots.pager({ $grid: $xegrid });
        } else {
          const pagerOptSlots = pagerOpts.slots;
          const pagerSlots = {};
          let leftSlot;
          let rightSlot;
          if (pagerOptSlots) {
            leftSlot = getFuncSlot(pagerOptSlots, "left");
            rightSlot = getFuncSlot(pagerOptSlots, "right");
            if (leftSlot) {
              pagerSlots.left = leftSlot;
            }
            if (rightSlot) {
              pagerSlots.right = rightSlot;
            }
          }
          slotVNs.push(h(pager_default2, Object.assign(Object.assign(Object.assign({ ref: refPager }, pagerOpts), proxyConfig && isEnableConf(proxyOpts) ? reactData.tablePage : {}), { onPageChange: pageChangeEvent }), pagerSlots));
        }
        restVNs.push(h("div", {
          ref: refPagerWrapper,
          key: "pager",
          class: "vxe-grid--pager-wrapper"
        }, slotVNs));
      }
      return restVNs;
    };
    const initProxy = () => {
      const { proxyConfig, formConfig } = props;
      const { proxyInited } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if (formConfig && isEnableConf(formOpts) && proxyOpts.form && formOpts.items) {
          const formData = {};
          formOpts.items.forEach((item) => {
            const { field, itemRender } = item;
            if (field) {
              let itemValue = null;
              if (itemRender) {
                const { defaultValue } = itemRender;
                if (import_xe_utils48.default.isFunction(defaultValue)) {
                  itemValue = defaultValue({ item });
                } else if (!import_xe_utils48.default.isUndefined(defaultValue)) {
                  itemValue = defaultValue;
                }
              }
              formData[field] = itemValue;
            }
          });
          reactData.formData = formData;
        }
        if (!proxyInited) {
          reactData.proxyInited = true;
          if (proxyOpts.autoLoad !== false) {
            nextTick().then(() => gridMethods.commitProxy("_init")).then((rest) => {
              gridMethods.dispatchEvent("proxy-query", Object.assign(Object.assign({}, rest), { isInited: true }), new Event("init"));
            });
          }
        }
      }
    };
    gridMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $grid: $xegrid, $event: evnt }, params));
      },
      /**
       *  code  button
       * @param {String/Object} code 
       */
      commitProxy(proxyTarget, ...args) {
        const { toolbarConfig, pagerConfig, editRules, validConfig } = props;
        const { tablePage, formData } = reactData;
        const isMsg = computeIsMsg.value;
        const proxyOpts = computeProxyOpts.value;
        const pagerOpts = computePagerOpts.value;
        const toolbarOpts = computeToolbarOpts.value;
        const { beforeQuery, afterQuery, beforeDelete, afterDelete, beforeSave, afterSave, ajax = {} } = proxyOpts;
        const resConfigs = proxyOpts.response || proxyOpts.props || {};
        const $xetable = refTable.value;
        let button = null;
        let code = null;
        if (import_xe_utils48.default.isString(proxyTarget)) {
          const { buttons } = toolbarOpts;
          const matchObj = toolbarConfig && isEnableConf(toolbarOpts) && buttons ? import_xe_utils48.default.findTree(buttons, (item) => item.code === proxyTarget, { children: "dropdowns" }) : null;
          button = matchObj ? matchObj.item : null;
          code = proxyTarget;
        } else {
          button = proxyTarget;
          code = button.code;
        }
        const btnParams = button ? button.params : null;
        switch (code) {
          case "insert":
            return $xetable.insert({});
          case "insert_edit":
            return $xetable.insert({}).then(({ row }) => $xetable.setEditRow(row));
          // 
          case "insert_actived":
            return $xetable.insert({}).then(({ row }) => $xetable.setEditRow(row));
          // 
          case "mark_cancel":
            triggerPendingEvent(code);
            break;
          case "remove":
            return handleDeleteRow(code, "vxe.grid.removeSelectRecord", () => $xetable.removeCheckboxRow());
          case "import":
            $xetable.importData(btnParams);
            break;
          case "open_import":
            $xetable.openImport(btnParams);
            break;
          case "export":
            $xetable.exportData(btnParams);
            break;
          case "open_export":
            $xetable.openExport(btnParams);
            break;
          case "reset_custom":
            return $xetable.resetColumn(true);
          case "_init":
          case "reload":
          case "query": {
            const ajaxMethods = ajax.query;
            if (ajaxMethods) {
              const isInited = code === "_init";
              const isReload = code === "reload";
              let sortList = [];
              let filterList = [];
              let pageParams = {};
              if (pagerConfig) {
                if (isInited || isReload) {
                  tablePage.currentPage = 1;
                }
                if (isEnableConf(pagerOpts)) {
                  pageParams = Object.assign({}, tablePage);
                }
              }
              if (isInited) {
                const { computeSortOpts } = $xetable.getComputeMaps();
                const sortOpts = computeSortOpts.value;
                let defaultSort = sortOpts.defaultSort;
                if (defaultSort) {
                  if (!import_xe_utils48.default.isArray(defaultSort)) {
                    defaultSort = [defaultSort];
                  }
                  sortList = defaultSort.map((item) => {
                    return {
                      field: item.field,
                      property: item.field,
                      order: item.order
                    };
                  });
                }
                filterList = $xetable.getCheckedFilters();
              } else {
                if (isReload) {
                  $xetable.clearAll();
                } else {
                  sortList = $xetable.getSortColumns();
                  filterList = $xetable.getCheckedFilters();
                }
              }
              const commitParams = {
                code,
                button,
                isInited,
                isReload,
                $grid: $xegrid,
                page: pageParams,
                sort: sortList.length ? sortList[0] : {},
                sorts: sortList,
                filters: filterList,
                form: formData,
                options: ajaxMethods
              };
              reactData.sortData = sortList;
              reactData.filterData = filterList;
              reactData.tableLoading = true;
              const applyArgs = [commitParams].concat(args);
              return Promise.resolve((beforeQuery || ajaxMethods)(...applyArgs)).then((rest) => {
                reactData.tableLoading = false;
                if (rest) {
                  if (pagerConfig && isEnableConf(pagerOpts)) {
                    const totalProp = resConfigs.total;
                    const total = (import_xe_utils48.default.isFunction(totalProp) ? totalProp({ data: rest, $grid: $xegrid }) : import_xe_utils48.default.get(rest, totalProp || "page.total")) || 0;
                    tablePage.total = import_xe_utils48.default.toNumber(total);
                    const resultProp = resConfigs.result;
                    reactData.tableData = (import_xe_utils48.default.isFunction(resultProp) ? resultProp({ data: rest, $grid: $xegrid }) : import_xe_utils48.default.get(rest, resultProp || "result")) || [];
                    const pageCount = Math.max(Math.ceil(total / tablePage.pageSize), 1);
                    if (tablePage.currentPage > pageCount) {
                      tablePage.currentPage = pageCount;
                    }
                  } else {
                    const listProp = resConfigs.list;
                    reactData.tableData = (listProp ? import_xe_utils48.default.isFunction(listProp) ? listProp({ data: rest, $grid: $xegrid }) : import_xe_utils48.default.get(rest, listProp) : rest) || [];
                  }
                } else {
                  reactData.tableData = [];
                }
                if (afterQuery) {
                  afterQuery(...applyArgs);
                }
                return { status: true };
              }).catch(() => {
                reactData.tableLoading = false;
                return { status: false };
              });
            } else {
              if (true) {
                errLog("vxe.error.notFunc", ["proxy-config.ajax.query"]);
              }
            }
            break;
          }
          case "delete": {
            const ajaxMethods = ajax.delete;
            if (ajaxMethods) {
              const selectRecords = gridExtendTableMethods.getCheckboxRecords();
              const removeRecords = selectRecords.filter((row) => !$xetable.isInsertByRow(row));
              const body = { removeRecords };
              const commitParams = { $grid: $xegrid, code, button, body, form: formData, options: ajaxMethods };
              const applyArgs = [commitParams].concat(args);
              if (selectRecords.length) {
                return handleDeleteRow(code, "vxe.grid.deleteSelectRecord", () => {
                  if (!removeRecords.length) {
                    return $xetable.remove(selectRecords);
                  }
                  reactData.tableLoading = true;
                  return Promise.resolve((beforeDelete || ajaxMethods)(...applyArgs)).then((rest) => {
                    reactData.tableLoading = false;
                    $xetable.setPendingRow(removeRecords, false);
                    if (isMsg) {
                      if (true) {
                        if (!VXETable.modal) {
                          errLog("vxe.error.reqModule", ["Modal"]);
                        }
                      }
                      VXETable.modal.message({ content: getRespMsg(rest, "vxe.grid.delSuccess"), status: "success" });
                    }
                    if (afterDelete) {
                      afterDelete(...applyArgs);
                    } else {
                      gridMethods.commitProxy("query");
                    }
                    return { status: true };
                  }).catch((rest) => {
                    reactData.tableLoading = false;
                    if (isMsg) {
                      if (true) {
                        if (!VXETable.modal.message) {
                          errLog("vxe.error.reqModule", ["Modal"]);
                        }
                      }
                      VXETable.modal.message({ id: code, content: getRespMsg(rest, "vxe.grid.operError"), status: "error" });
                    }
                    return { status: false };
                  });
                });
              } else {
                if (isMsg) {
                  if (true) {
                    if (!VXETable.modal) {
                      errLog("vxe.error.reqModule", ["Modal"]);
                    }
                  }
                  VXETable.modal.message({ id: code, content: conf_default.i18n("vxe.grid.selectOneRecord"), status: "warning" });
                }
              }
            } else {
              if (true) {
                errLog("vxe.error.notFunc", ["proxy-config.ajax.delete"]);
              }
            }
            break;
          }
          case "save": {
            const ajaxMethods = ajax.save;
            if (ajaxMethods) {
              const body = $xetable.getRecordset();
              const { insertRecords, removeRecords, updateRecords, pendingRecords } = body;
              const commitParams = { $grid: $xegrid, code, button, body, form: formData, options: ajaxMethods };
              const applyArgs = [commitParams].concat(args);
              if (insertRecords.length) {
                body.pendingRecords = pendingRecords.filter((row) => $xetable.findRowIndexOf(insertRecords, row) === -1);
              }
              if (pendingRecords.length) {
                body.insertRecords = insertRecords.filter((row) => $xetable.findRowIndexOf(pendingRecords, row) === -1);
              }
              let restPromise = Promise.resolve();
              if (editRules) {
                restPromise = $xetable[validConfig && validConfig.msgMode === "full" ? "fullValidate" : "validate"](body.insertRecords.concat(updateRecords));
              }
              return restPromise.then((errMap) => {
                if (errMap) {
                  return;
                }
                if (body.insertRecords.length || removeRecords.length || updateRecords.length || body.pendingRecords.length) {
                  reactData.tableLoading = true;
                  return Promise.resolve((beforeSave || ajaxMethods)(...applyArgs)).then((rest) => {
                    reactData.tableLoading = false;
                    $xetable.clearPendingRow();
                    if (isMsg) {
                      if (true) {
                        if (!VXETable.modal) {
                          errLog("vxe.error.reqModule", ["Modal"]);
                        }
                      }
                      VXETable.modal.message({ content: getRespMsg(rest, "vxe.grid.saveSuccess"), status: "success" });
                    }
                    if (afterSave) {
                      afterSave(...applyArgs);
                    } else {
                      gridMethods.commitProxy("query");
                    }
                    return { status: true };
                  }).catch((rest) => {
                    reactData.tableLoading = false;
                    if (isMsg) {
                      if (true) {
                        if (!VXETable.modal) {
                          errLog("vxe.error.reqModule", ["Modal"]);
                        }
                      }
                      VXETable.modal.message({ id: code, content: getRespMsg(rest, "vxe.grid.operError"), status: "error" });
                    }
                    return { status: false };
                  });
                } else {
                  if (isMsg) {
                    if (true) {
                      if (!VXETable.modal) {
                        errLog("vxe.error.reqModule", ["Modal"]);
                      }
                    }
                    VXETable.modal.message({ id: code, content: conf_default.i18n("vxe.grid.dataUnchanged"), status: "info" });
                  }
                }
              });
            } else {
              if (true) {
                errLog("vxe.error.notFunc", ["proxy-config.ajax.save"]);
              }
            }
            break;
          }
          default: {
            const gCommandOpts = VXETable.commands.get(code);
            if (gCommandOpts) {
              if (gCommandOpts.commandMethod) {
                gCommandOpts.commandMethod({ code, button, $grid: $xegrid, $table: $xetable }, ...args);
              } else {
                if (true) {
                  errLog("vxe.error.notCommands", [code]);
                }
              }
            }
          }
        }
        return nextTick();
      },
      zoom() {
        if (reactData.isZMax) {
          return gridMethods.revert();
        }
        return gridMethods.maximize();
      },
      isMaximized() {
        return reactData.isZMax;
      },
      maximize() {
        return handleZoom(true);
      },
      revert() {
        return handleZoom();
      },
      getFormItems(itemIndex) {
        const formOpts = computeFormOpts.value;
        const { formConfig } = props;
        const { items } = formOpts;
        const itemList = [];
        import_xe_utils48.default.eachTree(formConfig && isEnableConf(formOpts) && items ? items : [], (item) => {
          itemList.push(item);
        }, { children: "children" });
        return import_xe_utils48.default.isUndefined(itemIndex) ? itemList : itemList[itemIndex];
      },
      getProxyInfo() {
        const $xetable = refTable.value;
        if (props.proxyConfig) {
          const { sortData } = reactData;
          return {
            data: reactData.tableData,
            filter: reactData.filterData,
            form: reactData.formData,
            sort: sortData.length ? sortData[0] : {},
            sorts: sortData,
            pager: reactData.tablePage,
            pendingRecords: $xetable ? $xetable.getPendingRecords() : []
          };
        }
        return null;
      }
      // setProxyInfo (options) {
      //   if (props.proxyConfig && options) {
      //     const { pager, form } = options
      //     const proxyOpts = computeProxyOpts.value
      //     if (pager) {
      //       if (pager.currentPage) {
      //         reactData.tablePage.currentPage = Number(pager.currentPage)
      //       }
      //       if (pager.pageSize) {
      //         reactData.tablePage.pageSize = Number(pager.pageSize)
      //       }
      //     }
      //     if (proxyOpts.form && form) {
      //       Object.assign(reactData.formData, form)
      //     }
      //   }
      //   return nextTick()
      // }
    };
    if (true) {
      gridMethods.loadColumn = (columns) => {
        const $xetable = refTable.value;
        import_xe_utils48.default.eachTree(columns, (column) => {
          if (column.slots) {
            import_xe_utils48.default.each(column.slots, (func) => {
              if (!import_xe_utils48.default.isFunction(func)) {
                if (!slots[func]) {
                  errLog("vxe.error.notSlot", [func]);
                }
              }
            });
          }
        });
        if ($xetable) {
          return $xetable.loadColumn(columns);
        }
        return nextTick();
      };
      gridMethods.reloadColumn = (columns) => {
        gridExtendTableMethods.clearAll();
        return gridMethods.loadColumn(columns);
      };
    }
    const gridPrivateMethods = {
      extendTableMethods,
      callSlot(slotFunc, params) {
        if (slotFunc) {
          if (import_xe_utils48.default.isString(slotFunc)) {
            slotFunc = slots[slotFunc] || null;
          }
          if (import_xe_utils48.default.isFunction(slotFunc)) {
            return getSlotVNs(slotFunc(params));
          }
        }
        return [];
      },
      /**
       * 
       */
      getExcludeHeight() {
        const { height } = props;
        const { isZMax } = reactData;
        const el = refElem.value;
        const formWrapper = refFormWrapper.value;
        const toolbarWrapper = refToolbarWrapper.value;
        const topWrapper = refTopWrapper.value;
        const bottomWrapper = refBottomWrapper.value;
        const pagerWrapper = refPagerWrapper.value;
        const parentPaddingSize = isZMax || !(height === "auto" || height === "100%") ? 0 : getPaddingTopBottomSize(el.parentNode);
        return parentPaddingSize + getPaddingTopBottomSize(el) + getOffsetHeight(formWrapper) + getOffsetHeight(toolbarWrapper) + getOffsetHeight(topWrapper) + getOffsetHeight(bottomWrapper) + getOffsetHeight(pagerWrapper);
      },
      getParentHeight() {
        const el = refElem.value;
        if (el) {
          return (reactData.isZMax ? getDomNode().visibleHeight : import_xe_utils48.default.toNumber(getComputedStyle(el.parentNode).height)) - gridPrivateMethods.getExcludeHeight();
        }
        return 0;
      },
      triggerToolbarCommitEvent(params, evnt) {
        const { code } = params;
        return gridMethods.commitProxy(params, evnt).then((rest) => {
          if (code && rest && rest.status && ["query", "reload", "delete", "save"].includes(code)) {
            gridMethods.dispatchEvent(code === "delete" || code === "save" ? `proxy-${code}` : "proxy-query", Object.assign(Object.assign({}, rest), { isReload: code === "reload" }), evnt);
          }
        });
      },
      triggerToolbarBtnEvent(button, evnt) {
        gridPrivateMethods.triggerToolbarCommitEvent(button, evnt);
        gridMethods.dispatchEvent("toolbar-button-click", { code: button.code, button }, evnt);
      },
      triggerToolbarTolEvent(tool, evnt) {
        gridPrivateMethods.triggerToolbarCommitEvent(tool, evnt);
        gridMethods.dispatchEvent("toolbar-tool-click", { code: tool.code, tool, $event: evnt });
      },
      triggerZoomEvent(evnt) {
        gridMethods.zoom();
        gridMethods.dispatchEvent("zoom", { type: reactData.isZMax ? "max" : "revert" }, evnt);
      }
    };
    Object.assign($xegrid, gridExtendTableMethods, gridMethods, gridPrivateMethods);
    const columnFlag = ref(0);
    watch(() => props.columns ? props.columns.length : -1, () => {
      columnFlag.value++;
    });
    watch(() => props.columns, () => {
      columnFlag.value++;
    });
    watch(columnFlag, () => {
      nextTick(() => $xegrid.loadColumn(props.columns || []));
    });
    watch(() => props.toolbarConfig, () => {
      initToolbar();
    });
    watch(() => props.pagerConfig, () => {
      initPages();
    });
    watch(() => props.proxyConfig, () => {
      initProxy();
    });
    const handleGlobalKeydownEvent = (evnt) => {
      const zoomOpts = computeZoomOpts.value;
      const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
      if (isEsc && reactData.isZMax && zoomOpts.escRestore !== false) {
        gridPrivateMethods.triggerZoomEvent(evnt);
      }
    };
    VXETable.hooks.forEach((options) => {
      const { setupGrid } = options;
      if (setupGrid) {
        const hookRest = setupGrid($xegrid);
        if (hookRest && import_xe_utils48.default.isObject(hookRest)) {
          Object.assign($xegrid, hookRest);
        }
      }
    });
    initPages();
    onMounted(() => {
      nextTick(() => {
        const { data, columns, proxyConfig } = props;
        const proxyOpts = computeProxyOpts.value;
        const formOpts = computeFormOpts.value;
        if (isEnableConf(proxyConfig) && (data || proxyOpts.form && formOpts.data)) {
          errLog("vxe.error.errConflicts", ["grid.data", "grid.proxy-config"]);
        }
        if (columns && columns.length) {
          $xegrid.loadColumn(columns);
        }
        initToolbar();
      });
      GlobalEvent.on($xegrid, "keydown", handleGlobalKeydownEvent);
    });
    onUnmounted(() => {
      GlobalEvent.off($xegrid, "keydown");
    });
    nextTick(() => {
      initProxy();
    });
    const renderVN = () => {
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-grid", {
          [`size--${vSize}`]: vSize,
          "is--animat": !!props.animat,
          "is--round": props.round,
          "is--maximize": reactData.isZMax,
          "is--loading": props.loading || reactData.tableLoading
        }],
        style: styles
      }, renderLayout());
    };
    $xegrid.renderVN = renderVN;
    provide("$xegrid", $xegrid);
    return $xegrid;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/grid/index.js
var VxeGrid = Object.assign(grid_default, {
  install(app) {
    app.component(grid_default.name, grid_default);
  }
});
var Grid = VxeGrid;
dynamicApp.component(grid_default.name, grid_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/checkbox/index.js
var VxeCheckbox = Object.assign(checkbox_default, {
  install(app) {
    app.component(checkbox_default.name, checkbox_default);
  }
});
var Checkbox = VxeCheckbox;
dynamicApp.component(checkbox_default.name, checkbox_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/checkbox/src/group.js
var import_xe_utils49 = __toESM(require_xe_utils());
var group_default3 = defineComponent({
  name: "VxeCheckboxGroup",
  props: {
    modelValue: Array,
    options: Array,
    optionProps: Object,
    disabled: Boolean,
    max: { type: [String, Number], default: null },
    size: { type: String, default: () => conf_default.checkboxGroup.size || conf_default.size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils49.default.uniqueId();
    const computeIsMaximize = computed(() => {
      const { modelValue, max } = props;
      if (max) {
        return (modelValue ? modelValue.length : 0) >= import_xe_utils49.default.toNumber(max);
      }
      return false;
    });
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeDisabledField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || "disabled";
    });
    const computeMaps = {
      computeIsMaximize
    };
    const $xecheckboxgroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const checkboxGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $checkboxGroup: $xecheckboxgroup, $event: evnt }, params));
      }
    };
    const checkboxGroupPrivateMethods = {
      handleChecked(params, evnt) {
        const { checked, label } = params;
        const checklist = props.modelValue || [];
        const checkIndex = checklist.indexOf(label);
        if (checked) {
          if (checkIndex === -1) {
            checklist.push(label);
          }
        } else {
          checklist.splice(checkIndex, 1);
        }
        emit("update:modelValue", checklist);
        $xecheckboxgroup.dispatchEvent("change", Object.assign({ checklist }, params), evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, checklist);
        }
      }
    };
    Object.assign($xecheckboxgroup, checkboxGroupMethods, checkboxGroupPrivateMethods);
    const renderVN = () => {
      const { options } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      return h("div", {
        class: "vxe-checkbox-group"
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item) => {
        return h(checkbox_default, {
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    $xecheckboxgroup.renderVN = renderVN;
    provide("$xecheckboxgroup", $xecheckboxgroup);
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/checkbox-group/index.js
var VxeCheckboxGroup = Object.assign(group_default3, {
  install(app) {
    app.component(group_default3.name, group_default3);
  }
});
var CheckboxGroup = VxeCheckboxGroup;
dynamicApp.component(group_default3.name, group_default3);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/radio/index.js
var VxeRadio = Object.assign(radio_default, {
  install: function(app) {
    app.component(radio_default.name, radio_default);
  }
});
var Radio = VxeRadio;
dynamicApp.component(radio_default.name, radio_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/radio-group/index.js
var VxeRadioGroup = Object.assign(group_default, {
  install: function(app) {
    app.component(group_default.name, group_default);
  }
});
var RadioGroup = VxeRadioGroup;
dynamicApp.component(group_default.name, group_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/radio-button/index.js
var VxeRadioButton = Object.assign(button_default2, {
  install: function(app) {
    app.component(button_default2.name, button_default2);
  }
});
var RadioButton = VxeRadioButton;
dynamicApp.component(button_default2.name, button_default2);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/input/index.js
var VxeInput = Object.assign(input_default, {
  install(app) {
    app.component(input_default.name, input_default);
  }
});
var Input = VxeInput;
dynamicApp.component(input_default.name, input_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/textarea/src/textarea.js
var import_xe_utils50 = __toESM(require_xe_utils());
var autoTxtElem;
var textarea_default = defineComponent({
  name: "VxeTextarea",
  props: {
    modelValue: [String, Number],
    className: String,
    immediate: { type: Boolean, default: true },
    name: String,
    readonly: Boolean,
    disabled: Boolean,
    placeholder: {
      type: String,
      default: () => import_xe_utils50.default.eqNull(conf_default.textarea.placeholder) ? conf_default.i18n("vxe.base.pleaseInput") : conf_default.textarea.placeholder
    },
    maxlength: [String, Number],
    rows: { type: [String, Number], default: 2 },
    cols: { type: [String, Number], default: null },
    showWordCount: Boolean,
    countMethod: Function,
    autosize: [Boolean, Object],
    form: String,
    resize: { type: String, default: () => conf_default.textarea.resize },
    size: { type: String, default: () => conf_default.textarea.size || conf_default.size }
  },
  emits: [
    "update:modelValue",
    "input",
    "keydown",
    "keyup",
    "click",
    "change",
    "focus",
    "blur"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils50.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      inputValue: props.modelValue
    });
    const refElem = ref();
    const refTextarea = ref();
    const refMaps = {
      refElem,
      refTextarea
    };
    const $xetextarea = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let textareaMethods = {};
    const computeInputCount = computed(() => {
      return import_xe_utils50.default.getSize(reactData.inputValue);
    });
    const computeIsCountError = computed(() => {
      const inputCount = computeInputCount.value;
      return props.maxlength && inputCount > import_xe_utils50.default.toNumber(props.maxlength);
    });
    const computeSizeOpts = computed(() => {
      return Object.assign({ minRows: 1, maxRows: 10 }, conf_default.textarea.autosize, props.autosize);
    });
    const updateAutoTxt = () => {
      const { size, autosize } = props;
      const { inputValue } = reactData;
      if (autosize) {
        if (!autoTxtElem) {
          autoTxtElem = document.createElement("div");
        }
        if (!autoTxtElem.parentNode) {
          document.body.appendChild(autoTxtElem);
        }
        const textElem = refTextarea.value;
        const textStyle = getComputedStyle(textElem);
        autoTxtElem.className = ["vxe-textarea--autosize", size ? `size--${size}` : ""].join(" ");
        autoTxtElem.style.width = `${textElem.clientWidth}px`;
        autoTxtElem.style.padding = textStyle.padding;
        autoTxtElem.innerText = ("" + (inputValue || "")).replace(/\n$/, "\n");
      }
    };
    const handleResize = () => {
      if (props.autosize) {
        nextTick(() => {
          const sizeOpts = computeSizeOpts.value;
          const { minRows, maxRows } = sizeOpts;
          const textElem = refTextarea.value;
          const sizeHeight = autoTxtElem.clientHeight;
          const textStyle = getComputedStyle(textElem);
          const lineHeight = import_xe_utils50.default.toNumber(textStyle.lineHeight);
          const paddingTop = import_xe_utils50.default.toNumber(textStyle.paddingTop);
          const paddingBottom = import_xe_utils50.default.toNumber(textStyle.paddingBottom);
          const borderTopWidth = import_xe_utils50.default.toNumber(textStyle.borderTopWidth);
          const borderBottomWidth = import_xe_utils50.default.toNumber(textStyle.borderBottomWidth);
          const intervalHeight = paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
          const rowNum = (sizeHeight - intervalHeight) / lineHeight;
          const textRows = rowNum && /[0-9]/.test("" + rowNum) ? rowNum : Math.floor(rowNum) + 1;
          let vaildRows = textRows;
          if (textRows < minRows) {
            vaildRows = minRows;
          } else if (textRows > maxRows) {
            vaildRows = maxRows;
          }
          textElem.style.height = `${vaildRows * lineHeight + intervalHeight}px`;
        });
      }
    };
    const triggerEvent3 = (evnt) => {
      const value = reactData.inputValue;
      $xetextarea.dispatchEvent(evnt.type, { value }, evnt);
    };
    const emitUpdate = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      if (import_xe_utils50.default.toValueString(props.modelValue) !== value) {
        textareaMethods.dispatchEvent("change", { value }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, value);
        }
      }
    };
    const inputEvent = (evnt) => {
      const { immediate } = props;
      const textElem = evnt.target;
      const value = textElem.value;
      reactData.inputValue = value;
      if (immediate) {
        emitUpdate(value, evnt);
      }
      $xetextarea.dispatchEvent("input", { value }, evnt);
      handleResize();
    };
    const changeEvent = (evnt) => {
      const { immediate } = props;
      if (immediate) {
        triggerEvent3(evnt);
      } else {
        emitUpdate(reactData.inputValue, evnt);
      }
    };
    const blurEvent = (evnt) => {
      const { immediate } = props;
      const { inputValue } = reactData;
      if (!immediate) {
        emitUpdate(inputValue, evnt);
      }
      $xetextarea.dispatchEvent("blur", { value: inputValue }, evnt);
    };
    textareaMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $textarea: $xetextarea, $event: evnt }, params));
      },
      focus() {
        const textElem = refTextarea.value;
        textElem.focus();
        return nextTick();
      },
      blur() {
        const textElem = refTextarea.value;
        textElem.blur();
        return nextTick();
      }
    };
    Object.assign($xetextarea, textareaMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      updateAutoTxt();
    });
    nextTick(() => {
      const { autosize } = props;
      if (autosize) {
        updateAutoTxt();
        handleResize();
      }
    });
    const renderVN = () => {
      const { className, resize, placeholder, disabled, maxlength, autosize, showWordCount, countMethod, rows, cols } = props;
      const { inputValue } = reactData;
      const vSize = computeSize.value;
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-textarea", className, {
          [`size--${vSize}`]: vSize,
          "is--autosize": autosize,
          "is--count": showWordCount,
          "is--disabled": disabled,
          "def--rows": !import_xe_utils50.default.eqNull(rows),
          "def--cols": !import_xe_utils50.default.eqNull(cols)
        }]
      }, [
        h("textarea", {
          ref: refTextarea,
          class: "vxe-textarea--inner",
          value: inputValue,
          name: props.name,
          placeholder: placeholder ? getFuncText(placeholder) : null,
          maxlength,
          readonly: props.readonly,
          disabled,
          rows,
          cols,
          style: resize ? {
            resize
          } : null,
          onInput: inputEvent,
          onChange: changeEvent,
          onKeydown: triggerEvent3,
          onKeyup: triggerEvent3,
          onClick: triggerEvent3,
          onFocus: triggerEvent3,
          onBlur: blurEvent
        }),
        showWordCount ? h("span", {
          class: ["vxe-textarea--count", {
            "is--error": isCountError
          }]
        }, countMethod ? `${countMethod({ value: inputValue })}` : `${inputCount}${maxlength ? `/${maxlength}` : ""}`) : null
      ]);
    };
    $xetextarea.renderVN = renderVN;
    return $xetextarea;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/textarea/index.js
var VxeTextarea = Object.assign(textarea_default, {
  install: function(app) {
    app.component(textarea_default.name, textarea_default);
  }
});
var Textarea = VxeTextarea;
dynamicApp.component(textarea_default.name, textarea_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/button/src/group.js
var import_xe_utils51 = __toESM(require_xe_utils());
var group_default4 = defineComponent({
  name: "VxeButtonGroup",
  props: {
    options: Array,
    mode: String,
    status: String,
    round: Boolean,
    circle: Boolean,
    className: [String, Function],
    disabled: Boolean,
    size: { type: String, default: () => conf_default.buttonGroup.size || conf_default.size }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils51.default.uniqueId();
    const computeMaps = {};
    const $xebuttongroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const buttonGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $buttonGroup: $xebuttongroup, $event: evnt }, params));
      }
    };
    const buttonGroupPrivateMethods = {
      handleClick(params, evnt) {
        const { options } = props;
        const { name } = params;
        const option = options ? options.find((item) => item.name === name) : null;
        buttonGroupMethods.dispatchEvent("click", Object.assign(Object.assign({}, params), { option }), evnt);
      }
    };
    Object.assign($xebuttongroup, buttonGroupMethods, buttonGroupPrivateMethods);
    const renderVN = () => {
      const { className, options } = props;
      const defaultSlot = slots.default;
      return h("div", {
        class: ["vxe-button-group", className ? import_xe_utils51.default.isFunction(className) ? className({ $buttonGroup: $xebuttongroup }) : className : ""]
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item, index) => {
        return h(button_default, Object.assign({ key: index }, item));
      }) : []);
    };
    $xebuttongroup.renderVN = renderVN;
    provide("$xebuttongroup", $xebuttongroup);
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/button-group/index.js
var VxeButtonGroup = Object.assign(group_default4, {
  install(app) {
    app.component(group_default4.name, group_default4);
  }
});
var ButtonGroup = VxeButtonGroup;
dynamicApp.component(group_default4.name, group_default4);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/modal/index.js
var import_xe_utils52 = __toESM(require_xe_utils());
function openModal(options) {
  checkDynamic();
  return new Promise((resolve) => {
    if (options && options.id && allActiveModals.some((comp) => comp.props.id === options.id)) {
      resolve("exist");
    } else {
      const _onHide = options.onHide;
      const modalOpts = Object.assign(options, {
        key: import_xe_utils52.default.uniqueId(),
        modelValue: true,
        onHide(params) {
          const modalList = dynamicStore.modals;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.modals = modalList.filter((item) => item.key !== modalOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.modals.push(modalOpts);
    }
  });
}
function getModal(id) {
  return import_xe_utils52.default.find(allActiveModals, ($modal) => $modal.props.id === id);
}
function closeModal(id) {
  const modals = id ? [getModal(id)] : allActiveModals;
  const restPromises = [];
  modals.forEach(($modal) => {
    if ($modal) {
      restPromises.push($modal.close());
    }
  });
  return Promise.all(restPromises);
}
function handleOpen(defOpts, content, title, options) {
  let opts;
  if (import_xe_utils52.default.isObject(content)) {
    opts = content;
  } else {
    opts = { content: import_xe_utils52.default.toValueString(content), title };
  }
  return openModal(Object.assign(Object.assign(Object.assign({}, defOpts), options), opts));
}
function openAlert(content, title, options) {
  return handleOpen({
    type: "alert",
    showFooter: true
  }, content, title, options);
}
function openConfirm(content, title, options) {
  return handleOpen({
    type: "confirm",
    status: "question",
    showFooter: true
  }, content, title, options);
}
function openMessage(content, options) {
  return handleOpen({
    type: "message",
    mask: false,
    lockView: false,
    showHeader: false
  }, content, "", options);
}
var ModalController = {
  get: getModal,
  close: closeModal,
  open: openModal,
  alert: openAlert,
  confirm: openConfirm,
  message: openMessage
};
var modal = ModalController;
var VxeModal = Object.assign(modal_default, {
  install: function(app) {
    app.component(modal_default.name, modal_default);
    VXETable.modal = ModalController;
  }
});
var Modal = VxeModal;
dynamicApp.component(modal_default.name, modal_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/drawer/index.js
var import_xe_utils54 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/drawer/src/modal.js
var import_xe_utils53 = __toESM(require_xe_utils());
var allActiveDrawers = [];
var modal_default2 = defineComponent({
  name: "VxeDrawer",
  props: {
    modelValue: Boolean,
    id: String,
    title: String,
    loading: { type: Boolean, default: null },
    className: String,
    position: [String, Object],
    lockView: { type: Boolean, default: () => conf_default.drawer.lockView },
    lockScroll: Boolean,
    mask: { type: Boolean, default: () => conf_default.drawer.mask },
    maskClosable: { type: Boolean, default: () => conf_default.drawer.maskClosable },
    escClosable: { type: Boolean, default: () => conf_default.drawer.escClosable },
    showHeader: { type: Boolean, default: () => conf_default.drawer.showHeader },
    showFooter: { type: Boolean, default: () => conf_default.drawer.showFooter },
    showClose: { type: Boolean, default: () => conf_default.drawer.showClose },
    content: [Number, String],
    showCancelButton: { type: Boolean, default: null },
    cancelButtonText: { type: String, default: () => conf_default.drawer.cancelButtonText },
    showConfirmButton: { type: Boolean, default: () => conf_default.drawer.showConfirmButton },
    confirmButtonText: { type: String, default: () => conf_default.drawer.confirmButtonText },
    destroyOnClose: { type: Boolean, default: () => conf_default.drawer.destroyOnClose },
    showTitleOverflow: { type: Boolean, default: () => conf_default.drawer.showTitleOverflow },
    width: [Number, String],
    height: [Number, String],
    zIndex: Number,
    transfer: { type: Boolean, default: () => conf_default.drawer.transfer },
    size: { type: String, default: () => conf_default.drawer.size || conf_default.size },
    beforeHideMethod: { type: Function, default: () => conf_default.drawer.beforeHideMethod },
    slots: Number
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils53.default.uniqueId();
    const computeSize = useSize(props);
    const refElem = ref();
    const refDrawerBox = ref();
    const refConfirmBtn = ref();
    const refCancelBtn = ref();
    const reactData = reactive({
      inited: false,
      visible: false,
      contentVisible: false,
      drawerZIndex: 0,
      firstOpen: true
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeDrawer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getBox = () => {
      const boxElem = refDrawerBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const { width, height } = props;
      const boxElem = getBox();
      boxElem.style.width = `${width ? isNaN(width) ? width : `${width}px` : ""}`;
      boxElem.style.height = `${height ? isNaN(height) ? height : `${height}px` : ""}`;
      return nextTick();
    };
    const updateZindex = () => {
      const { zIndex } = props;
      const { drawerZIndex } = reactData;
      if (zIndex) {
        reactData.drawerZIndex = zIndex;
      } else if (drawerZIndex < getLastZIndex()) {
        reactData.drawerZIndex = nextZIndex();
      }
    };
    const updatePosition = () => {
      return nextTick().then(() => {
      });
    };
    const closeDrawer2 = (type) => {
      const { beforeHideMethod } = props;
      const { visible } = reactData;
      const params = { type };
      if (visible) {
        Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then((rest) => {
          if (!import_xe_utils53.default.isError(rest)) {
            reactData.contentVisible = false;
            import_xe_utils53.default.remove(allActiveDrawers, (item) => item === $xeDrawer);
            drawerMethods.dispatchEvent("before-hide", params);
            setTimeout(() => {
              reactData.visible = false;
              emit("update:modelValue", false);
              drawerMethods.dispatchEvent("hide", params);
            }, 200);
          }
        }).catch((e) => e);
      }
      return nextTick();
    };
    const closeEvent = (evnt) => {
      const type = "close";
      drawerMethods.dispatchEvent(type, { type }, evnt);
      closeDrawer2(type);
    };
    const confirmEvent = (evnt) => {
      const type = "confirm";
      drawerMethods.dispatchEvent(type, { type }, evnt);
      closeDrawer2(type);
    };
    const cancelEvent = (evnt) => {
      const type = "cancel";
      drawerMethods.dispatchEvent(type, { type }, evnt);
      closeDrawer2(type);
    };
    const openDrawer2 = () => {
      const { showFooter } = props;
      const { inited, visible } = reactData;
      if (!inited) {
        reactData.inited = true;
      }
      if (!visible) {
        recalculate();
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveDrawers.push($xeDrawer);
        setTimeout(() => {
          reactData.contentVisible = true;
          nextTick(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = "";
            const params = { type };
            emit("update:modelValue", true);
            drawerMethods.dispatchEvent("show", params);
          });
        }, 10);
        nextTick(() => {
          const { firstOpen } = reactData;
          if (firstOpen) {
            updatePosition().then(() => {
              setTimeout(() => updatePosition(), 20);
            });
          }
          if (firstOpen) {
            reactData.firstOpen = false;
          }
        });
      }
      return nextTick();
    };
    const drawerMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $drawer: $xeDrawer, $event: evnt }, params));
      },
      open: openDrawer2,
      close() {
        return closeDrawer2("close");
      },
      getBox
    };
    const selfClickEvent = (evnt) => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = "mask";
        closeDrawer2(type);
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastDrawer = import_xe_utils53.default.max(allActiveDrawers, (item) => item.reactData.drawerZIndex);
        if (lastDrawer) {
          setTimeout(() => {
            if (lastDrawer === $xeDrawer && lastDrawer.props.escClosable) {
              closeDrawer2("exit");
            }
          }, 10);
        }
      }
    };
    const boxMousedownEvent = () => {
      const { drawerZIndex } = reactData;
      if (allActiveDrawers.some((comp) => comp.reactData.visible && comp.reactData.drawerZIndex > drawerZIndex)) {
        updateZindex();
      }
    };
    const formDesignPrivateMethods = {};
    Object.assign($xeDrawer, drawerMethods, formDesignPrivateMethods);
    const renderTitles = () => {
      const { slots: propSlots = {}, showClose, title } = props;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      const titVNs = [
        h("div", {
          class: "vxe-drawer--header-title"
        }, titleSlot ? getSlotVNs(titleSlot({ $drawer: $xeDrawer })) : title ? getFuncText(title) : conf_default.i18n("vxe.alert.title"))
      ];
      const rightVNs = [];
      if (cornerSlot) {
        rightVNs.push(h("span", {
          class: "vxe-drawer--corner-wrapper"
        }, getSlotVNs(cornerSlot({ $drawer: $xeDrawer }))));
      }
      if (showClose) {
        rightVNs.push(h("i", {
          class: ["vxe-drawer--close-btn", "trigger--btn", conf_default.icon.MODAL_CLOSE],
          title: conf_default.i18n("vxe.drawer.close"),
          onClick: closeEvent
        }));
      }
      titVNs.push(h("div", {
        class: "vxe-drawer--header-right"
      }, rightVNs));
      return titVNs;
    };
    const renderHeader = () => {
      const { slots: propSlots = {}, showTitleOverflow } = props;
      const headerSlot = slots.header || propSlots.header;
      const headVNs = [];
      if (props.showHeader) {
        headVNs.push(h("div", {
          class: ["vxe-drawer--header", {
            "is--ellipsis": showTitleOverflow
          }]
        }, headerSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(headerSlot({ $drawer: $xeDrawer })) : renderTitles()));
      }
      return headVNs;
    };
    const renderBody = () => {
      const { slots: propSlots = {}, content } = props;
      const defaultSlot = slots.default || propSlots.default;
      return [
        h("div", {
          class: "vxe-drawer--body"
        }, [
          h("div", {
            class: "vxe-drawer--content"
          }, defaultSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(defaultSlot({ $drawer: $xeDrawer })) : getFuncText(content)),
          h(loading_default2, {
            class: "vxe-drawer--loading",
            modelValue: props.loading
          })
        ])
      ];
    };
    const renderBtns = () => {
      const { showCancelButton, showConfirmButton } = props;
      const btnVNs = [];
      if (showCancelButton) {
        btnVNs.push(h(button_default, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || conf_default.i18n("vxe.button.cancel"),
          onClick: cancelEvent
        }));
      }
      if (showConfirmButton) {
        btnVNs.push(h(button_default, {
          key: 2,
          ref: refConfirmBtn,
          status: "primary",
          content: props.confirmButtonText || conf_default.i18n("vxe.button.confirm"),
          onClick: confirmEvent
        }));
      }
      return btnVNs;
    };
    const renderFooter = () => {
      const { slots: propSlots = {} } = props;
      const footerSlot = slots.footer || propSlots.footer;
      const footVNs = [];
      if (props.showFooter) {
        footVNs.push(h("div", {
          class: "vxe-drawer--footer"
        }, footerSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(footerSlot({ $drawer: $xeDrawer })) : renderBtns()));
      }
      return footVNs;
    };
    const renderVN = () => {
      const { className, position, loading, lockScroll, lockView, mask } = props;
      const { inited, contentVisible, visible } = reactData;
      const vSize = computeSize.value;
      return h(Teleport, {
        to: "body",
        disabled: props.transfer ? !inited : true
      }, [
        h("div", {
          ref: refElem,
          class: ["vxe-drawer--wrapper", `pos--${position}`, className || "", {
            [`size--${vSize}`]: vSize,
            "lock--scroll": lockScroll,
            "lock--view": lockView,
            "is--mask": mask,
            "is--visible": contentVisible,
            "is--active": visible,
            "is--loading": loading
          }],
          style: {
            zIndex: reactData.drawerZIndex
          },
          onClick: selfClickEvent
        }, [
          h("div", {
            ref: refDrawerBox,
            class: "vxe-drawer--box",
            onMousedown: boxMousedownEvent
          }, renderHeader().concat(renderBody(), renderFooter()))
        ])
      ]);
    };
    $xeDrawer.renderVN = renderVN;
    watch(() => props.width, recalculate);
    watch(() => props.height, recalculate);
    watch(() => props.modelValue, (value) => {
      if (value) {
        openDrawer2();
      } else {
        closeDrawer2("model");
      }
    });
    onMounted(() => {
      nextTick(() => {
        if (props.modelValue) {
          openDrawer2();
        }
        recalculate();
      });
      if (props.escClosable) {
        GlobalEvent.on($xeDrawer, "keydown", handleGlobalKeydownEvent);
      }
    });
    onUnmounted(() => {
      GlobalEvent.off($xeDrawer, "keydown");
    });
    return $xeDrawer;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/drawer/index.js
function openDrawer(options) {
  checkDynamic();
  return new Promise((resolve) => {
    if (options && options.id && allActiveDrawers.some((comp) => comp.props.id === options.id)) {
      resolve("exist");
    } else {
      const _onHide = options.onHide;
      const drawerOpts = Object.assign(options, {
        key: import_xe_utils54.default.uniqueId(),
        modelValue: true,
        onHide(params) {
          const drawerList = dynamicStore.drawers;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.drawers = drawerList.filter((item) => item.key !== drawerOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.drawers.push(drawerOpts);
    }
  });
}
function getDrawer(id) {
  return import_xe_utils54.default.find(allActiveDrawers, ($drawer) => $drawer.props.id === id);
}
function closeDrawer(id) {
  const drawers = id ? [getDrawer(id)] : allActiveDrawers;
  const restPromises = [];
  drawers.forEach(($drawer) => {
    if ($drawer) {
      restPromises.push($drawer.close());
    }
  });
  return Promise.all(restPromises);
}
var DrawerController = {
  get: getDrawer,
  close: closeDrawer,
  open: openDrawer
};
var drawer = DrawerController;
var VxeDrawer = Object.assign(modal_default2, {
  install: function(app) {
    app.component(modal_default2.name, modal_default2);
    VXETable.drawer = DrawerController;
  }
});
dynamicApp.component(modal_default2.name, modal_default2);
var Drawer = VxeDrawer;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/form-item.js
var import_xe_utils55 = __toESM(require_xe_utils());
var formItemProps = {
  title: String,
  field: String,
  span: [String, Number],
  align: String,
  titleAlign: {
    type: String,
    default: null
  },
  titleWidth: {
    type: [String, Number],
    default: null
  },
  titleColon: {
    type: Boolean,
    default: null
  },
  titleAsterisk: {
    type: Boolean,
    default: null
  },
  showTitle: {
    type: Boolean,
    default: true
  },
  vertical: {
    type: Boolean,
    default: null
  },
  className: [String, Function],
  contentClassName: [String, Function],
  contentStyle: [Object, Function],
  titleClassName: [String, Function],
  titleStyle: [Object, Function],
  titleOverflow: {
    type: [Boolean, String],
    default: null
  },
  titlePrefix: Object,
  titleSuffix: Object,
  resetValue: { default: null },
  visibleMethod: Function,
  visible: { type: Boolean, default: null },
  folding: Boolean,
  collapseNode: Boolean,
  itemRender: Object,
  rules: Array
};
var form_item_default = defineComponent({
  name: "VxeFormItem",
  props: formItemProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xeform = inject("$xeform", {});
    const formGather = inject("$xeformgather", null);
    const formItem = reactive(createItem($xeform, props));
    const xeformitem = { formItem };
    const xeformiteminfo = { itemConfig: formItem };
    formItem.slots = slots;
    provide("$xeformiteminfo", xeformiteminfo);
    provide("$xeformitem", xeformitem);
    provide("$xeformgather", null);
    watchItem(props, formItem);
    onMounted(() => {
      assemItem($xeform, refElem.value, formItem, formGather);
    });
    onUnmounted(() => {
      destroyItem($xeform, formItem);
    });
    const renderItem = ($xeform2, item) => {
      const { props: props2, reactData } = $xeform2;
      const { data, rules, titleAlign: allTitleAlign, titleWidth: allTitleWidth, titleColon: allTitleColon, titleAsterisk: allTitleAsterisk, titleOverflow: allTitleOverflow, vertical: allVertical } = props2;
      const { collapseAll } = reactData;
      const { computeValidOpts } = $xeform2.getComputeMaps();
      const validOpts = computeValidOpts.value;
      const { slots: slots2, title, visible, folding, field, collapseNode, itemRender, showError, errRule, className, titleOverflow, vertical, showTitle, contentClassName, contentStyle, titleClassName, titleStyle } = item;
      const compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;
      const itemClassName = compConf ? compConf.itemClassName : "";
      const itemStyle = compConf ? compConf.itemStyle : null;
      const itemContentClassName = compConf ? compConf.itemContentClassName : "";
      const itemContentStyle = compConf ? compConf.itemContentStyle : null;
      const itemTitleClassName = compConf ? compConf.itemTitleClassName : "";
      const itemTitleStyle = compConf ? compConf.itemTitleStyle : null;
      const defaultSlot = slots2 ? slots2.default : null;
      const titleSlot = slots2 ? slots2.title : null;
      const span = item.span || props2.span;
      const align = item.align || props2.align;
      const titleAlign = import_xe_utils55.default.eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
      const titleWidth = import_xe_utils55.default.eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
      const titleColon = import_xe_utils55.default.eqNull(item.titleColon) ? allTitleColon : item.titleColon;
      const titleAsterisk = import_xe_utils55.default.eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
      const itemOverflow = import_xe_utils55.default.isUndefined(titleOverflow) || import_xe_utils55.default.isNull(titleOverflow) ? allTitleOverflow : titleOverflow;
      const itemVertical = import_xe_utils55.default.isUndefined(vertical) || import_xe_utils55.default.isNull(vertical) ? allVertical : vertical;
      const ovEllipsis = itemOverflow === "ellipsis";
      const ovTitle = itemOverflow === "title";
      const ovTooltip = itemOverflow === true || itemOverflow === "tooltip";
      const hasEllipsis = ovTitle || ovTooltip || ovEllipsis;
      const params = { data, field, property: field, item, $form: $xeform2, $grid: $xeform2.xegrid };
      let isRequired = false;
      if (visible === false) {
        return createCommentVNode();
      }
      if (rules) {
        const itemRules = rules[field];
        if (itemRules) {
          isRequired = itemRules.some((rule) => rule.required);
        }
      }
      let contentVNs = [];
      if (defaultSlot) {
        contentVNs = $xeform2.callSlot(defaultSlot, params);
      } else if (compConf && compConf.renderItemContent) {
        contentVNs = getSlotVNs(compConf.renderItemContent(itemRender, params));
      } else if (field) {
        contentVNs = [`${import_xe_utils55.default.get(data, field)}`];
      }
      if (collapseNode) {
        contentVNs.push(h("div", {
          class: "vxe-form--item-trigger-node",
          onClick: $xeform2.toggleCollapseEvent
        }, [
          h("span", {
            class: "vxe-form--item-trigger-text"
          }, collapseAll ? conf_default.i18n("vxe.form.unfolding") : conf_default.i18n("vxe.form.folding")),
          h("i", {
            class: ["vxe-form--item-trigger-icon", collapseAll ? conf_default.icon.FORM_FOLDING : conf_default.icon.FORM_UNFOLDING]
          })
        ]));
      }
      if (errRule && validOpts.showMessage) {
        contentVNs.push(h("div", {
          class: "vxe-form--item-valid",
          style: errRule.maxWidth ? {
            width: `${errRule.maxWidth}px`
          } : null
        }, errRule.message));
      }
      const ons = ovTooltip ? {
        onMouseenter(evnt) {
          $xeform2.triggerTitleTipEvent(evnt, params);
        },
        onMouseleave: $xeform2.handleTitleTipLeaveEvent
      } : {};
      return h("div", {
        ref: refElem,
        class: [
          "vxe-form--item",
          item.id,
          span ? `vxe-form--item-col--${span} is--span` : "",
          className ? import_xe_utils55.default.isFunction(className) ? className(params) : className : "",
          itemClassName ? import_xe_utils55.default.isFunction(itemClassName) ? itemClassName(params) : itemClassName : "",
          {
            "is--title": title,
            "is--colon": titleColon,
            "is--vertical": itemVertical,
            "is--asterisk": titleAsterisk,
            "is--required": isRequired,
            "is--hidden": folding && collapseAll,
            "is--active": isActivetem($xeform2, item),
            "is--error": showError
          }
        ],
        style: import_xe_utils55.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        h("div", {
          class: "vxe-form--item-inner"
        }, [
          showTitle !== false && (title || titleSlot) ? h("div", Object.assign({ class: [
            "vxe-form--item-title",
            titleAlign ? `align--${titleAlign}` : "",
            hasEllipsis ? "is--ellipsis" : "",
            itemTitleClassName ? import_xe_utils55.default.isFunction(itemTitleClassName) ? itemTitleClassName(params) : itemTitleClassName : "",
            titleClassName ? import_xe_utils55.default.isFunction(titleClassName) ? titleClassName(params) : titleClassName : ""
          ], style: Object.assign({}, import_xe_utils55.default.isFunction(itemTitleStyle) ? itemTitleStyle(params) : itemTitleStyle, import_xe_utils55.default.isFunction(titleStyle) ? titleStyle(params) : titleStyle, titleWidth ? {
            width: isNaN(titleWidth) ? titleWidth : `${titleWidth}px`
          } : null), title: ovTitle ? getFuncText(title) : null }, ons), renderTitle($xeform2, item)) : null,
          h("div", {
            class: [
              "vxe-form--item-content",
              align ? `align--${align}` : "",
              itemContentClassName ? import_xe_utils55.default.isFunction(itemContentClassName) ? itemContentClassName(params) : itemContentClassName : "",
              contentClassName ? import_xe_utils55.default.isFunction(contentClassName) ? contentClassName(params) : contentClassName : ""
            ],
            style: Object.assign({}, import_xe_utils55.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils55.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
          }, contentVNs)
        ])
      ]);
    };
    const renderVN = () => {
      const formProps = $xeform ? $xeform.props : null;
      return formProps && formProps.customLayout ? renderItem($xeform, formItem) : h("div", {
        ref: refElem
      });
    };
    const $xeformitem = {
      renderVN
    };
    return $xeformitem;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form-item/index.js
var VxeFormItem = Object.assign(form_item_default, {
  install(app) {
    app.component(form_item_default.name, form_item_default);
  }
});
var FormItem = VxeFormItem;
dynamicApp.component(form_item_default.name, form_item_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/form-gather.js
var import_xe_utils56 = __toESM(require_xe_utils());
var form_gather_default = defineComponent({
  name: "VxeFormGather",
  props: formItemProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xeform = inject("$xeform", {});
    const formGather = inject("$xeformgather", null);
    const formItem = reactive(createItem($xeform, props));
    const xeformitem = { formItem };
    const xeformiteminfo = { itemConfig: formItem };
    formItem.children = [];
    provide("$xeformiteminfo", xeformiteminfo);
    provide("$xeformgather", xeformitem);
    provide("$xeformitem", null);
    watchItem(props, formItem);
    onMounted(() => {
      assemItem($xeform, refElem.value, formItem, formGather);
    });
    onUnmounted(() => {
      destroyItem($xeform, formItem);
    });
    const renderVN = () => {
      const { className, field } = props;
      const span = props.span || ($xeform ? $xeform.props.span : null);
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-form--gather vxe-form--item-row", formItem.id, span ? `vxe-form--item-col_${span} is--span` : "", className ? import_xe_utils56.default.isFunction(className) ? className({ $form: $xeform, data: $xeform ? $xeform.props.data : {}, item: formItem, field, property: field }) : className : ""]
      }, defaultSlot ? defaultSlot() : []);
    };
    const $xeformgather = {
      renderVN
    };
    return $xeformgather;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form-gather/index.js
var VxeFormGather = Object.assign(form_gather_default, {
  install(app) {
    app.component(form_gather_default.name, form_gather_default);
  }
});
var FormGather = VxeFormGather;
dynamicApp.component(form_gather_default.name, form_gather_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/select/src/util.js
var import_xe_utils58 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/select/src/optionInfo.js
var import_xe_utils57 = __toESM(require_xe_utils());
var OptionInfo = class {
  constructor($xeselect, _vm) {
    Object.assign(this, {
      id: import_xe_utils57.default.uniqueId("option_"),
      value: _vm.value,
      label: _vm.label,
      visible: _vm.visible,
      className: _vm.className,
      disabled: _vm.disabled
    });
  }
  update(name, value) {
    this[name] = value;
  }
};

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/select/src/util.js
function isOption(option) {
  return option instanceof OptionInfo;
}
function createOption($xeselect, _vm) {
  return isOption(_vm) ? _vm : new OptionInfo($xeselect, _vm);
}
function watchOption(props, option) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      option.update(name, value);
    });
  });
}
function assemOption($xeselect, el, option, optgroup) {
  const { reactData } = $xeselect;
  const { staticOptions } = reactData;
  const parentElem = el.parentNode;
  const parentOption = optgroup ? optgroup.option : null;
  const parentCols = parentOption ? parentOption.options : staticOptions;
  if (parentElem && parentCols) {
    parentCols.splice(import_xe_utils58.default.arrayIndexOf(parentElem.children, el), 0, option);
    reactData.staticOptions = staticOptions.slice(0);
  }
}
function destroyOption($xeselect, option) {
  const { reactData } = $xeselect;
  const { staticOptions } = reactData;
  const matchObj = import_xe_utils58.default.findTree(staticOptions, (item) => item.id === option.id, { children: "options" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticOptions = staticOptions.slice(0);
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/select/src/optgroup.js
var optgroup_default = defineComponent({
  name: "VxeOptgroup",
  props: {
    label: { type: [String, Number, Boolean], default: "" },
    visible: { type: Boolean, default: null },
    className: [String, Function],
    disabled: Boolean
  },
  setup(props, { slots }) {
    const elem = ref();
    const $xeselect = inject("$xeselect", {});
    const option = createOption($xeselect, props);
    const xeoption = { option };
    option.options = [];
    provide("xeoptgroup", xeoption);
    watchOption(props, option);
    onMounted(() => {
      assemOption($xeselect, elem.value, option);
    });
    onUnmounted(() => {
      destroyOption($xeselect, option);
    });
    return () => {
      return h("div", {
        ref: elem
      }, slots.default ? slots.default() : []);
    };
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/optgroup/index.js
var VxeOptgroup = Object.assign(optgroup_default, {
  install: function(app) {
    app.component(optgroup_default.name, optgroup_default);
  }
});
var Optgroup = VxeOptgroup;
dynamicApp.component(optgroup_default.name, optgroup_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/select/src/option.js
var option_default = defineComponent({
  name: "VxeOption",
  props: {
    value: null,
    label: { type: [String, Number, Boolean], default: "" },
    visible: { type: Boolean, default: null },
    className: [String, Function],
    disabled: Boolean
  },
  setup(props, { slots }) {
    const elem = ref();
    const $xeselect = inject("$xeselect", {});
    const optgroup = inject("xeoptgroup", null);
    const option = createOption($xeselect, props);
    option.slots = slots;
    watchOption(props, option);
    onMounted(() => {
      assemOption($xeselect, elem.value, option, optgroup);
    });
    onUnmounted(() => {
      destroyOption($xeselect, option);
    });
    return () => {
      return h("div", {
        ref: elem
      });
    };
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/option/index.js
var VxeOption = Object.assign(option_default, {
  install: function(app) {
    app.component(option_default.name, option_default);
  }
});
var Option = VxeOption;
dynamicApp.component(option_default.name, option_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/switch/src/switch.js
var import_xe_utils59 = __toESM(require_xe_utils());
var switch_default = defineComponent({
  name: "VxeSwitch",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: Boolean,
    size: { type: String, default: () => conf_default.switch.size || conf_default.size },
    openLabel: String,
    closeLabel: String,
    openValue: { type: [String, Number, Boolean], default: true },
    closeValue: { type: [String, Number, Boolean], default: false },
    openIcon: String,
    closeIcon: String,
    openActiveIcon: String,
    closeActiveIcon: String
  },
  emits: [
    "update:modelValue",
    "change",
    "focus",
    "blur"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils59.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      isActivated: false,
      hasAnimat: false,
      offsetLeft: 0
    });
    const $xeswitch = {
      xID,
      props,
      context,
      reactData
    };
    const refButton = ref();
    let switchMethods = {};
    const computeOnShowLabel = computed(() => {
      return getFuncText(props.openLabel);
    });
    const computeOffShowLabel = computed(() => {
      return getFuncText(props.closeLabel);
    });
    const computeIsChecked = computed(() => {
      return props.modelValue === props.openValue;
    });
    let _atimeout;
    const clickEvent = (evnt) => {
      if (!props.disabled) {
        const isChecked = computeIsChecked.value;
        clearTimeout(_atimeout);
        const value = isChecked ? props.closeValue : props.openValue;
        reactData.hasAnimat = true;
        emit("update:modelValue", value);
        switchMethods.dispatchEvent("change", { value }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, value);
        }
        _atimeout = setTimeout(() => {
          reactData.hasAnimat = false;
        }, 400);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      switchMethods.dispatchEvent("focus", { value: props.modelValue }, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      switchMethods.dispatchEvent("blur", { value: props.modelValue }, evnt);
    };
    switchMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $switch: $xeswitch, $event: evnt }, params));
      },
      focus() {
        const btnElem = refButton.value;
        reactData.isActivated = true;
        btnElem.focus();
        return nextTick();
      },
      blur() {
        const btnElem = refButton.value;
        btnElem.blur();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xeswitch, switchMethods);
    const renderVN = () => {
      const { disabled, openIcon, closeIcon, openActiveIcon, closeActiveIcon } = props;
      const isChecked = computeIsChecked.value;
      const vSize = computeSize.value;
      const onShowLabel = computeOnShowLabel.value;
      const offShowLabel = computeOffShowLabel.value;
      return h("div", {
        class: ["vxe-switch", isChecked ? "is--on" : "is--off", {
          [`size--${vSize}`]: vSize,
          "is--disabled": disabled,
          "is--animat": reactData.hasAnimat
        }]
      }, [
        h("button", {
          ref: refButton,
          class: "vxe-switch--button",
          type: "button",
          disabled,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent
        }, [
          h("span", {
            class: "vxe-switch--label vxe-switch--label-on"
          }, [
            openIcon ? h("i", {
              class: ["vxe-switch--label-icon", openIcon]
            }) : createCommentVNode(),
            onShowLabel
          ]),
          h("span", {
            class: "vxe-switch--label vxe-switch--label-off"
          }, [
            closeIcon ? h("i", {
              class: ["vxe-switch--label-icon", closeIcon]
            }) : createCommentVNode(),
            offShowLabel
          ]),
          h("span", {
            class: "vxe-switch--icon"
          }, openActiveIcon || closeActiveIcon ? [
            h("i", {
              class: isChecked ? openActiveIcon : closeActiveIcon
            })
          ] : [])
        ])
      ]);
    };
    $xeswitch.renderVN = renderVN;
    return $xeswitch;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/switch/index.js
var VxeSwitch = Object.assign(switch_default, {
  install: function(app) {
    app.component(switch_default.name, switch_default);
  }
});
var Switch = VxeSwitch;
dynamicApp.component(switch_default.name, switch_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/list/src/list.js
var import_xe_utils60 = __toESM(require_xe_utils());
var list_default = defineComponent({
  name: "VxeList",
  props: {
    data: Array,
    height: [Number, String],
    maxHeight: [Number, String],
    loading: Boolean,
    className: [String, Function],
    size: { type: String, default: () => conf_default.list.size || conf_default.size },
    autoResize: { type: Boolean, default: () => conf_default.list.autoResize },
    syncResize: [Boolean, String, Number],
    scrollY: Object
  },
  emits: [
    "scroll"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils60.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      scrollYLoad: false,
      bodyHeight: 0,
      rowHeight: 0,
      topSpaceHeight: 0,
      items: []
    });
    const refElem = ref();
    const refVirtualWrapper = ref();
    const refVirtualBody = ref();
    const internalData = {
      fullData: [],
      lastScrollLeft: 0,
      lastScrollTop: 0,
      scrollYStore: {
        startIndex: 0,
        endIndex: 0,
        visibleSize: 0,
        offsetSize: 0,
        rowHeight: 0
      }
    };
    const refMaps = {
      refElem
    };
    const $xelist = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let listMethods = {};
    const computeSYOpts = computed(() => {
      return Object.assign({}, conf_default.list.scrollY, props.scrollY);
    });
    const computeStyles = computed(() => {
      const { height, maxHeight } = props;
      const style = {};
      if (height) {
        style.height = `${isNaN(height) ? height : `${height}px`}`;
      } else if (maxHeight) {
        style.height = "auto";
        style.maxHeight = `${isNaN(maxHeight) ? maxHeight : `${maxHeight}px`}`;
      }
      return style;
    });
    const updateYSpace = () => {
      const { scrollYLoad } = reactData;
      const { scrollYStore, fullData } = internalData;
      reactData.bodyHeight = scrollYLoad ? fullData.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const handleData = () => {
      const { scrollYLoad } = reactData;
      const { fullData, scrollYStore } = internalData;
      reactData.items = scrollYLoad ? fullData.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullData.slice(0);
      return nextTick();
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollYLoad } = reactData;
        const { scrollYStore } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const sYOpts = computeSYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (sYOpts.sItem) {
            firstItemElem = virtualBodyElem.querySelector(sYOpts.sItem);
          }
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, Math.ceil(scrollBodyElem.clientHeight / rowHeight));
          const offsetYSize = sYOpts.oSize ? import_xe_utils60.default.toNumber(sYOpts.oSize) : browse.edge ? 10 : 0;
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
        reactData.rowHeight = rowHeight;
      });
    };
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
      }
      return nextTick();
    };
    const scrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (import_xe_utils60.default.isNumber(scrollLeft)) {
        scrollBodyElem.scrollLeft = scrollLeft;
      }
      if (import_xe_utils60.default.isNumber(scrollTop)) {
        scrollBodyElem.scrollTop = scrollTop;
      }
      if (reactData.scrollYLoad) {
        return new Promise((resolve) => {
          setTimeout(() => {
            nextTick(() => {
              resolve();
            });
          }, 50);
        });
      }
      return nextTick();
    };
    const refreshScroll = () => {
      const { lastScrollLeft, lastScrollTop } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    const recalculate = () => {
      const el = refElem.value;
      if (el.clientWidth && el.clientHeight) {
        return computeScrollLoad();
      }
      return Promise.resolve();
    };
    const loadYData = (evnt) => {
      const { scrollYStore } = internalData;
      const { startIndex, endIndex, visibleSize, offsetSize, rowHeight } = scrollYStore;
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const scrollEvent = (evnt) => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      listMethods.dispatchEvent("scroll", { scrollLeft, scrollTop, isX, isY }, evnt);
    };
    listMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $list: $xelist, $event: evnt }, params));
      },
      /**
       * 
       * @param {Array} datas 
       */
      loadData(datas) {
        const { scrollYStore } = internalData;
        const sYOpts = computeSYOpts.value;
        const fullData = datas || [];
        Object.assign(scrollYStore, {
          startIndex: 0,
          endIndex: 1,
          visibleSize: 0
        });
        internalData.fullData = fullData;
        reactData.scrollYLoad = !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt <= fullData.length);
        handleData();
        return computeScrollLoad().then(() => {
          refreshScroll();
        });
      },
      /**
       * 
       * @param {Array} datas 
       */
      reloadData(datas) {
        clearScroll();
        return listMethods.loadData(datas);
      },
      recalculate,
      scrollTo,
      refreshScroll,
      clearScroll
    };
    Object.assign($xelist, listMethods);
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      listMethods.loadData(props.data || []);
    });
    watch(() => props.syncResize, (value) => {
      if (value) {
        recalculate();
        nextTick(() => setTimeout(() => recalculate()));
      }
    });
    onActivated(() => {
      recalculate().then(() => refreshScroll());
    });
    let resizeObserver;
    nextTick(() => {
      GlobalEvent.on($xelist, "resize", () => {
        recalculate();
      });
      if (props.autoResize) {
        const el = refElem.value;
        resizeObserver = createResizeEvent(() => recalculate());
        resizeObserver.observe(el);
      }
      listMethods.loadData(props.data || []);
    });
    onUnmounted(() => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      GlobalEvent.off($xelist, "resize");
    });
    const renderVN = () => {
      const { className, loading } = props;
      const { bodyHeight, topSpaceHeight, items } = reactData;
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-list", className ? import_xe_utils60.default.isFunction(className) ? className({ $list: $xelist }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading
        }]
      }, [
        h("div", {
          ref: refVirtualWrapper,
          class: "vxe-list--virtual-wrapper",
          style: styles,
          onScroll: scrollEvent
        }, [
          h("div", {
            class: "vxe-list--y-space",
            style: {
              height: bodyHeight ? `${bodyHeight}px` : ""
            }
          }),
          h("div", {
            ref: refVirtualBody,
            class: "vxe-list--body",
            style: {
              marginTop: topSpaceHeight ? `${topSpaceHeight}px` : ""
            }
          }, slots.default ? slots.default({ items, $list: $xelist }) : [])
        ]),
        /**
         * 
         */
        h(loading_default2, {
          class: "vxe-list--loading",
          modelValue: loading
        })
      ]);
    };
    $xelist.renderVN = renderVN;
    return $xelist;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/list/index.js
var VxeList = Object.assign(list_default, {
  install(app) {
    app.component(list_default.name, list_default);
  }
});
var List = VxeList;
dynamicApp.component(list_default.name, list_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/pulldown/src/pulldown.js
var import_xe_utils61 = __toESM(require_xe_utils());
var pulldown_default = defineComponent({
  name: "VxePulldown",
  props: {
    modelValue: Boolean,
    disabled: Boolean,
    placement: String,
    size: { type: String, default: () => conf_default.size },
    className: [String, Function],
    popupClassName: [String, Function],
    destroyOnClose: Boolean,
    transfer: Boolean
  },
  emits: [
    "update:modelValue",
    "hide-panel"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils61.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      inited: false,
      panelIndex: 0,
      panelStyle: null,
      panelPlacement: null,
      visiblePanel: false,
      animatVisible: false,
      isActivated: false
    });
    const refElem = ref();
    const refPulldowContent = ref();
    const refPulldowPnanel = ref();
    const refMaps = {
      refElem
    };
    const $xepulldown = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let pulldownMethods = {};
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const isPanelVisible = () => {
      return reactData.visiblePanel;
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { transfer, placement } = props;
        const { panelIndex, visiblePanel } = reactData;
        if (visiblePanel) {
          const targetElem = refPulldowContent.value;
          const panelElem = refPulldowPnanel.value;
          if (panelElem && targetElem) {
            const targetHeight = targetElem.offsetHeight;
            const targetWidth = targetElem.offsetWidth;
            const panelHeight = panelElem.offsetHeight;
            const panelWidth = panelElem.offsetWidth;
            const marginSize = 5;
            const panelStyle = {
              zIndex: panelIndex
            };
            const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(targetElem);
            let panelPlacement = "bottom";
            if (transfer) {
              let left = boundingLeft;
              let top = boundingTop + targetHeight;
              if (placement === "top") {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              } else if (!placement) {
                if (top + panelHeight + marginSize > visibleHeight) {
                  panelPlacement = "top";
                  top = boundingTop - panelHeight;
                }
                if (top < marginSize) {
                  panelPlacement = "bottom";
                  top = boundingTop + targetHeight;
                }
              }
              if (left + panelWidth + marginSize > visibleWidth) {
                left -= left + panelWidth + marginSize - visibleWidth;
              }
              if (left < marginSize) {
                left = marginSize;
              }
              Object.assign(panelStyle, {
                left: `${left}px`,
                top: `${top}px`,
                minWidth: `${targetWidth}px`
              });
            } else {
              if (placement === "top") {
                panelPlacement = "top";
                panelStyle.bottom = `${targetHeight}px`;
              } else if (!placement) {
                if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                  if (boundingTop - targetHeight - panelHeight > marginSize) {
                    panelPlacement = "top";
                    panelStyle.bottom = `${targetHeight}px`;
                  }
                }
              }
            }
            reactData.panelStyle = panelStyle;
            reactData.panelPlacement = panelPlacement;
          }
        }
        return nextTick();
      });
    };
    let hidePanelTimeout;
    const showPanel = () => {
      if (!reactData.inited) {
        reactData.inited = true;
      }
      return new Promise((resolve) => {
        if (!props.disabled) {
          clearTimeout(hidePanelTimeout);
          reactData.isActivated = true;
          reactData.animatVisible = true;
          setTimeout(() => {
            reactData.visiblePanel = true;
            emit("update:modelValue", true);
            updatePlacement();
            setTimeout(() => {
              resolve(updatePlacement());
            }, 40);
          }, 10);
          updateZindex();
        } else {
          nextTick(() => {
            resolve();
          });
        }
      });
    };
    const hidePanel = () => {
      reactData.visiblePanel = false;
      emit("update:modelValue", false);
      return new Promise((resolve) => {
        if (reactData.animatVisible) {
          hidePanelTimeout = window.setTimeout(() => {
            reactData.animatVisible = false;
            nextTick(() => {
              resolve();
            });
          }, 350);
        } else {
          nextTick(() => {
            resolve();
          });
        }
      });
    };
    const togglePanel = () => {
      if (reactData.visiblePanel) {
        return hidePanel();
      }
      return showPanel();
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      const panelElem = refPulldowPnanel.value;
      if (!disabled) {
        if (visiblePanel) {
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            pulldownMethods.dispatchEvent("hide-panel", {}, evnt);
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      const el = refElem.value;
      const panelElem = refPulldowPnanel.value;
      if (!disabled) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hidePanel();
          pulldownMethods.dispatchEvent("hide-panel", {}, evnt);
        }
      }
    };
    const handleGlobalBlurEvent = (evnt) => {
      if (reactData.visiblePanel) {
        reactData.isActivated = false;
        hidePanel();
        pulldownMethods.dispatchEvent("hide-panel", {}, evnt);
      }
    };
    pulldownMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $pulldown: $xepulldown, $event: evnt }, params));
      },
      isPanelVisible,
      togglePanel,
      showPanel,
      hidePanel
    };
    Object.assign($xepulldown, pulldownMethods);
    watch(() => props.modelValue, (value) => {
      if (value) {
        showPanel();
      } else {
        hidePanel();
      }
    });
    nextTick(() => {
      GlobalEvent.on($xepulldown, "mousewheel", handleGlobalMousewheelEvent);
      GlobalEvent.on($xepulldown, "mousedown", handleGlobalMousedownEvent);
      GlobalEvent.on($xepulldown, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      GlobalEvent.off($xepulldown, "mousewheel");
      GlobalEvent.off($xepulldown, "mousedown");
      GlobalEvent.off($xepulldown, "blur");
    });
    const renderVN = () => {
      const { className, popupClassName, destroyOnClose, transfer, disabled } = props;
      const { inited, isActivated, animatVisible, visiblePanel, panelStyle, panelPlacement } = reactData;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const dropdownSlot = slots.dropdown;
      return h("div", {
        ref: refElem,
        class: ["vxe-pulldown", className ? import_xe_utils61.default.isFunction(className) ? className({ $pulldown: $xepulldown }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visivle": visiblePanel,
          "is--disabled": disabled,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          ref: refPulldowContent,
          class: "vxe-pulldown--content"
        }, defaultSlot ? defaultSlot({ $pulldown: $xepulldown }) : []),
        h(Teleport, {
          to: "body",
          disabled: transfer ? !inited : true
        }, [
          h("div", {
            ref: refPulldowPnanel,
            class: ["vxe-table--ignore-clear vxe-pulldown--panel", popupClassName ? import_xe_utils61.default.isFunction(popupClassName) ? popupClassName({ $pulldown: $xepulldown }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": transfer,
              "animat--leave": animatVisible,
              "animat--enter": visiblePanel
            }],
            placement: panelPlacement,
            style: panelStyle
          }, dropdownSlot ? [
            h("div", {
              class: "vxe-pulldown--panel-wrapper"
            }, !inited || destroyOnClose && !visiblePanel && !animatVisible ? [] : [
              headerSlot ? h("div", {
                class: "vxe-pulldown--panel-header"
              }, headerSlot({ $pulldown: $xepulldown })) : createCommentVNode(),
              h("div", {
                class: "vxe-pulldown--panel-body"
              }, dropdownSlot({ $pulldown: $xepulldown })),
              footerSlot ? h("div", {
                class: "vxe-pulldown--panel-footer"
              }, footerSlot({ $pulldown: $xepulldown })) : createCommentVNode()
            ])
          ] : [])
        ])
      ]);
    };
    $xepulldown.renderVN = renderVN;
    return $xepulldown;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/pulldown/index.js
var VxePulldown = Object.assign(pulldown_default, {
  install: function(app) {
    app.component(pulldown_default.name, pulldown_default);
  }
});
var Pulldown = VxePulldown;
dynamicApp.component(pulldown_default.name, pulldown_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/locale/lang/zh-CN.js
var zh_CN_default = {
  vxe: {
    base: {
      pleaseInput: "",
      pleaseSelect: "",
      comma: "",
      fullStop: ""
    },
    loading: {
      text: "..."
    },
    error: {
      downErr: "",
      groupFixed: "",
      groupMouseRange: ' "{0}" ',
      groupTag: ' "{0}"  "{1}"',
      scrollErrProp: ' "{0}"',
      errConflicts: ' "{0}"  "{1}" ',
      unableInsert: "",
      useErr: ' "{0}"  Table ',
      barUnableLink: "",
      expandContent: ' "content"',
      reqComp: ' "{0}"  https://vxeui.com/#/start/useGlobal',
      reqModule: ' "{0}" ',
      reqProp: ' "{0}" ',
      emptyProp: ' "{0}" ',
      errProp: ' "{0}" "{1}"',
      colRepet: 'column.{0}="{1}" ',
      notFunc: ' "{0}" ',
      errFunc: ' "{0}" ',
      notValidators: ' "{0}" ',
      notFormats: ' "{0}" ',
      notCommands: ' "{0}" ',
      notSlot: ' "{0}" ',
      noTree: ' "{0}"',
      notProp: ' "{0}"',
      checkProp: ' "{0}" ',
      coverProp: '"{0}"  "{1}" ',
      uniField: ' "{0}" ',
      delFunc: ' "{0}"  "{1}"',
      delProp: ' "{0}"  "{1}"',
      delEvent: ' "{0}"  "{1}"',
      removeProp: ' "{0}" ',
      errFormat: ' "VXETable.formats"  "formatter={0}" ',
      notType: ' "{0}"',
      notExp: "/",
      impFields: "",
      treeNotImp: ""
    },
    table: {
      emptyText: "",
      allTitle: "/",
      seqTitle: "",
      actionTitle: "",
      confirmFilter: "",
      resetFilter: "",
      allFilter: "",
      sortAsc: "",
      sortDesc: "",
      filter: "",
      impSuccess: " {0} ",
      expLoading: "",
      expSuccess: "",
      expFilename: "_{0}",
      expOriginFilename: "__{0}",
      customTitle: "",
      customAll: "",
      customConfirm: "",
      customClose: "",
      customCancel: "",
      customRestore: "",
      maxFixedCol: " {0} "
    },
    grid: {
      selectOneRecord: "",
      deleteSelectRecord: "",
      removeSelectRecord: "",
      dataUnchanged: "",
      delSuccess: "",
      saveSuccess: "",
      operError: ""
    },
    select: {
      search: "",
      loadingText: "",
      emptyText: ""
    },
    pager: {
      goto: "",
      gotoTitle: "",
      pagesize: "{0}/",
      total: " {0} ",
      pageClassifier: "",
      homePage: "",
      homePageTitle: "",
      prevPage: "",
      prevPageTitle: "",
      nextPage: "",
      nextPageTitle: "",
      prevJump: "",
      prevJumpTitle: "",
      nextJump: "",
      nextJumpTitle: "",
      endPage: "",
      endPageTitle: ""
    },
    alert: {
      title: ""
    },
    button: {
      confirm: "",
      cancel: ""
    },
    filter: {
      search: ""
    },
    custom: {
      cstmTitle: "",
      cstmRestore: "",
      cstmCancel: "",
      cstmConfirm: "",
      cstmConfirmRestore: "",
      cstmDragTarget: "{0}",
      setting: {
        colSort: "",
        sortHelpTip: "",
        colTitle: "",
        colResizable: "",
        colVisible: "",
        colFixed: "",
        colFixedMax: " {0} ",
        fixedLeft: "",
        fixedUnset: "",
        fixedRight: ""
      }
    },
    import: {
      modes: {
        covering: "",
        insert: "",
        insertTop: "",
        insertBottom: ""
      },
      impTitle: "",
      impFile: "",
      impSelect: "",
      impType: "",
      impOpts: "",
      impMode: "",
      impConfirm: "",
      impCancel: ""
    },
    export: {
      types: {
        csv: "CSV ()(*.csv)",
        html: "(*.html)",
        xml: "XML (*.xml)",
        txt: "()(*.txt)",
        xls: "Excel 97-2003 (*.xls)",
        xlsx: "Excel (*.xlsx)",
        pdf: "PDF (*.pdf)"
      },
      modes: {
        current: "",
        selected: "",
        all: ""
      },
      printTitle: "",
      expTitle: "",
      expName: "",
      expNamePlaceholder: "",
      expSheetName: "",
      expSheetNamePlaceholder: "",
      expType: "",
      expMode: "",
      expCurrentColumn: "",
      expColumn: "",
      expOpts: "",
      expOptHeader: "",
      expHeaderTitle: "",
      expOptFooter: "",
      expFooterTitle: "",
      expOptColgroup: "",
      expColgroupTitle: "",
      expOptMerge: "",
      expMergeTitle: "",
      expOptAllExpand: "",
      expAllExpandTitle: "",
      expOptUseStyle: "",
      expUseStyleTitle: "",
      expOptOriginal: "",
      expOriginalTitle: "",
      expPrint: "",
      expConfirm: "",
      expCancel: ""
    },
    modal: {
      errTitle: "",
      zoomMin: "",
      zoomIn: "",
      zoomOut: "",
      close: "",
      miniMaxSize: " {0} ",
      footPropErr: "show-footer  show-confirm-button | show-cancel-button | "
    },
    drawer: {
      close: ""
    },
    form: {
      folding: "",
      unfolding: ""
    },
    toolbar: {
      import: "",
      export: "",
      print: "",
      refresh: "",
      zoomIn: "",
      zoomOut: "",
      custom: "",
      customAll: "",
      customConfirm: "",
      customRestore: "",
      fixedLeft: "",
      fixedRight: "",
      cancelFixed: ""
    },
    input: {
      date: {
        m1: "01 ",
        m2: "02 ",
        m3: "03 ",
        m4: "04 ",
        m5: "05 ",
        m6: "06 ",
        m7: "07 ",
        m8: "08 ",
        m9: "09 ",
        m10: "10 ",
        m11: "11 ",
        m12: "12 ",
        quarterLabel: "{0} ",
        monthLabel: "{0} ",
        dayLabel: "{0}  {1}",
        labelFormat: {
          date: "yyyy-MM-dd",
          time: "HH:mm:ss",
          datetime: "yyyy-MM-dd HH:mm:ss",
          week: "yyyy  WW ",
          month: "yyyy-MM",
          quarter: "yyyy  q ",
          year: "yyyy"
        },
        weeks: {
          w: "",
          w0: "",
          w1: "",
          w2: "",
          w3: "",
          w4: "",
          w5: "",
          w6: ""
        },
        months: {
          m0: "",
          m1: "",
          m2: "",
          m3: "",
          m4: "",
          m5: "",
          m6: "",
          m7: "",
          m8: "",
          m9: "",
          m10: "",
          m11: ""
        },
        quarters: {
          q1: "",
          q2: "",
          q3: "",
          q4: ""
        }
      }
    },
    imagePreview: {
      popupTitle: "",
      operBtn: {
        zoomOut: "",
        zoomIn: "",
        pctFull: "",
        pct11: "",
        rotateLeft: "",
        rotateRight: "",
        print: "",
        download: ""
      }
    },
    upload: {
      fileBtnText: "",
      imgBtnText: "",
      dragPlaceholder: "",
      imgSizeHint: "{0}",
      imgCountHint: "{0}",
      fileTypeHint: " {0} ",
      fileSizeHint: "{0}",
      fileCountHint: "{0}",
      overCountErr: "{0}",
      overCountExtraErr: "{0}{1}",
      overSizeErr: "{0}",
      reUpload: "",
      uploadProgress: " {0}%",
      uploadErr: "",
      uploadSuccess: "",
      moreBtnText: "{0}",
      viewItemTitle: "",
      morePopup: {
        readTitle: "",
        imageTitle: "",
        fileTitle: ""
      }
    },
    formDesign: {
      formName: "",
      defFormTitle: "",
      widgetPropTab: "",
      widgetFormTab: "",
      error: {
        wdFormUni: "",
        wdSubUni: ""
      },
      styleSetting: {
        btn: "",
        title: "",
        layoutTitle: "",
        verticalLayout: "",
        horizontalLayout: "",
        styleTitle: "",
        boldTitle: "",
        fontBold: "",
        fontNormal: "",
        colonTitle: "",
        colonVisible: "",
        colonHidden: "",
        alignTitle: "",
        widthTitle: "",
        alignLeft: "",
        alignRight: "",
        unitPx: "",
        unitPct: ""
      },
      widget: {
        group: {
          base: "",
          layout: "",
          system: "",
          module: "",
          chart: "",
          advanced: ""
        },
        copyTitle: "_{0}",
        component: {
          input: "",
          textarea: "",
          select: "",
          row: "",
          title: "",
          text: "",
          subtable: "",
          VxeSwitch: "/",
          VxeInput: "",
          VxeNumberInput: "",
          VxeDatePicker: "",
          VxeTextarea: "",
          VxeSelect: "",
          VxeTreeSelect: "",
          VxeRadioGroup: "",
          VxeCheckboxGroup: "",
          VxeUploadFile: "",
          VxeUploadImage: ""
        }
      },
      widgetProp: {
        name: "",
        placeholder: "",
        required: "",
        multiple: "",
        displaySetting: {
          name: "",
          pc: "",
          mobile: "",
          visible: "",
          hidden: ""
        },
        dataSource: {
          name: "",
          defValue: "{0}",
          addOption: "",
          batchEditOption: "",
          batchEditTip: "ExcelWPS ",
          batchEditSubTip: "ExcelWPS ",
          buildOption: ""
        },
        rowProp: {
          colSize: "",
          col2: "",
          col3: "",
          col4: "",
          col6: "",
          layout: ""
        },
        textProp: {
          name: "",
          alignTitle: "",
          alignLeft: "",
          alignCenter: "",
          alignRight: "",
          colorTitle: "",
          sizeTitle: "",
          boldTitle: "",
          fontNormal: "",
          fontBold: ""
        },
        subtableProp: {
          seqTitle: "",
          showSeq: "",
          showCheckbox: "",
          errSubDrag: "",
          colPlace: ""
        },
        uploadProp: {
          limitFileCount: "",
          limitFileSize: "",
          multiFile: "",
          limitImgCount: "",
          limitImgSize: "",
          multiImg: ""
        }
      }
    },
    listDesign: {
      fieldSettingTab: "",
      listSettingTab: "",
      searchTitle: "",
      listTitle: "",
      searchField: "",
      listField: "",
      activeBtn: {
        ActionButtonUpdate: "",
        ActionButtonDelete: ""
      },
      search: {
        addBtn: "",
        emptyText: "",
        editPopupTitle: ""
      },
      searchPopup: {
        colTitle: "",
        saveBtn: ""
      }
    },
    text: {
      copySuccess: "",
      copyError: ""
    },
    countdown: {
      formats: {
        yyyy: "",
        MM: "",
        dd: "",
        HH: "",
        mm: "",
        ss: ""
      }
    },
    /**
     * 
     */
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: "",
          multiErr: "",
          extendErr: "",
          pasteMultiErr: "",
          cpInvalidErr: "{0}"
        },
        fnr: {
          title: "",
          findLabel: "",
          replaceLabel: "",
          findTitle: "",
          replaceTitle: "",
          tabs: {
            find: "",
            replace: ""
          },
          filter: {
            re: "",
            whole: "",
            sensitive: ""
          },
          btns: {
            findNext: "",
            findAll: "",
            replace: "",
            replaceAll: "",
            cancel: ""
          },
          header: {
            seq: "#",
            cell: "",
            value: ""
          },
          empty: "()",
          reError: "",
          recordCount: " {0} ",
          notCell: "",
          replaceSuccess: " {0} "
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: "",
          fixedGroup: "",
          cancelFixed: "",
          fixedLeft: "",
          fixedRight: ""
        },
        cases: {
          equal: "",
          gt: "",
          lt: "",
          begin: "",
          endin: "",
          include: "",
          isSensitive: ""
        }
      },
      filterCombination: {
        menus: {
          clearSort: "",
          sortAsc: "",
          sortDesc: "",
          fixedColumn: "",
          fixedGroup: "",
          cancelFixed: "",
          fixedLeft: "",
          fixedRight: "",
          clearFilter: "",
          textOption: "",
          numberOption: ""
        },
        popup: {
          title: "",
          currColumnTitle: "",
          and: "",
          or: "",
          describeHtml: " ? <br/> * "
        },
        cases: {
          equal: "",
          unequal: "",
          gt: "",
          ge: "",
          lt: "",
          le: "",
          begin: "",
          notbegin: "",
          endin: "",
          notendin: "",
          include: "",
          exclude: "",
          between: "",
          custom: "",
          insensitive: "",
          isSensitive: ""
        },
        empty: "()",
        notData: ""
      }
    },
    /**
     * 
     * @deprecated
     */
    pro: {
      area: {
        mergeErr: "",
        multiErr: "",
        extendErr: "",
        pasteMultiErr: ""
      },
      fnr: {
        title: "",
        findLabel: "",
        replaceLabel: "",
        findTitle: "",
        replaceTitle: "",
        tabs: {
          find: "",
          replace: ""
        },
        filter: {
          re: "",
          whole: "",
          sensitive: ""
        },
        btns: {
          findNext: "",
          findAll: "",
          replace: "",
          replaceAll: "",
          cancel: ""
        },
        header: {
          seq: "#",
          cell: "",
          value: ""
        },
        empty: "()",
        reError: "",
        recordCount: " {0} ",
        notCell: "",
        replaceSuccess: " {0} "
      }
    },
    renderer: {
      search: "",
      cases: {
        equal: "",
        unequal: "",
        gt: "",
        ge: "",
        lt: "",
        le: "",
        begin: "",
        notbegin: "",
        endin: "",
        notendin: "",
        include: "",
        exclude: "",
        between: "",
        custom: "",
        insensitive: "",
        isSensitive: ""
      },
      combination: {
        menus: {
          clearSort: "",
          sortAsc: "",
          sortDesc: "",
          fixedColumn: "",
          fixedGroup: "",
          cancelFixed: "",
          fixedLeft: "",
          fixedRight: "",
          clearFilter: "",
          textOption: "",
          numberOption: ""
        },
        popup: {
          title: "",
          currColumnTitle: "",
          and: "",
          or: "",
          describeHtml: " ? <br/> * "
        },
        empty: "()",
        notData: ""
      }
    }
  }
};

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/all.js
var components2 = [
  // 
  VxeTableFilterModule,
  VxeTableMenuModule,
  VxeTableEditModule,
  VxeTableExportModule,
  VxeTableKeyboardModule,
  VxeTableValidatorModule,
  VxeTableCustomModule,
  // 
  VxeIcon,
  VxeColumn,
  VxeColgroup,
  VxeGrid,
  VxeToolbar,
  VxePager,
  VxeCheckbox,
  VxeCheckboxGroup,
  VxeRadio,
  VxeRadioGroup,
  VxeRadioButton,
  VxeInput,
  VxeTextarea,
  VxeButton,
  VxeButtonGroup,
  VxeModal,
  VxeDrawer,
  VxeTooltip,
  VxeForm,
  VxeFormItem,
  VxeFormGather,
  VxeSelect,
  VxeOptgroup,
  VxeOption,
  VxeSwitch,
  VxeList,
  VxePulldown,
  // 
  VxeTable
];
setConfig({
  i18n: (key, args) => import_xe_utils62.default.toFormatString(import_xe_utils62.default.get(zh_CN_default, key), args)
});
function install(app, options) {
  if (import_xe_utils62.default.isPlainObject(options)) {
    setConfig(options);
    if (options.theme) {
      setTheme(options.theme);
    }
  }
  components2.forEach((component2) => component2.install(app));
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/index.esm.js
var index_esm_default2 = all_exports;
export {
  Button,
  ButtonGroup,
  Checkbox,
  CheckboxGroup,
  Colgroup,
  Column,
  Custom,
  Drawer,
  Edit,
  Export,
  Filter,
  Form,
  FormGather,
  FormItem,
  Grid,
  Icon,
  Input,
  Keyboard,
  List,
  Menu,
  Modal,
  Optgroup,
  Option,
  Pager,
  Pulldown,
  Radio,
  RadioButton,
  RadioGroup,
  Select,
  Switch,
  Table,
  Textarea,
  Toolbar,
  Tooltip,
  VXETable,
  Validator,
  VxeButton,
  VxeButtonGroup,
  VxeCheckbox,
  VxeCheckboxGroup,
  VxeColgroup,
  VxeColumn,
  VxeDrawer,
  VxeForm,
  VxeFormGather,
  VxeFormItem,
  VxeGrid,
  VxeIcon,
  VxeInput,
  VxeList,
  VxeModal,
  VxeOptgroup,
  VxeOption,
  VxePager,
  VxePulldown,
  VxeRadio,
  VxeRadioButton,
  VxeRadioGroup,
  VxeSelect,
  VxeSwitch,
  VxeTable,
  VxeTableCustomModule,
  VxeTableEditModule,
  VxeTableExportModule,
  VxeTableFilterModule,
  VxeTableKeyboardModule,
  VxeTableMenuModule,
  VxeTableValidatorModule,
  VxeTextarea,
  VxeToolbar,
  VxeTooltip,
  VxeUI,
  _t,
  commands,
  component,
  config,
  index_esm_default2 as default,
  drawer,
  formats,
  getComponent,
  globalConfs,
  globalStore,
  hooks,
  install,
  interceptor,
  menus,
  modal,
  print,
  readLocalFile as readFile,
  renderer,
  saveLocalFile as saveFile,
  setConfig,
  setIcon,
  setup,
  t,
  tableVersion,
  use,
  v,
  validators,
  version
};
//# sourceMappingURL=vxe-table.js.map
