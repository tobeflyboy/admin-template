import {
  Teleport,
  TransitionGroup,
  computed,
  createApp,
  createCommentVNode,
  defineComponent,
  getCurrentInstance,
  h,
  inject,
  nextTick,
  onActivated,
  onBeforeUnmount,
  onDeactivated,
  onMounted,
  onUnmounted,
  provide,
  reactive,
  ref,
  resolveComponent,
  watch
} from "./chunk-GUB7NKQY.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-PR4QN5HX.js";

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/setupDefaults.js
var require_setupDefaults = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/setupDefaults.js"(exports, module) {
    "use strict";
    var setupDefaults = {
      keyId: 1,
      cookies: {
        path: "/"
      },
      treeOptions: {
        parentKey: "parentId",
        key: "id",
        children: "children"
      },
      parseDateFormat: "yyyy-MM-dd HH:mm:ss",
      firstDayOfWeek: 1
    };
    module.exports = setupDefaults;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/arrayEach.js"(exports, module) {
    function arrayEach(list, iterate, context) {
      if (list) {
        if (list.forEach) {
          list.forEach(iterate, context);
        } else {
          for (var index = 0, len = list.length; index < len; index++) {
            iterate.call(context, list[index], index, list);
          }
        }
      }
    }
    module.exports = arrayEach;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticObjectToString.js
var require_staticObjectToString = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticObjectToString.js"(exports, module) {
    var objectToString = Object.prototype.toString;
    module.exports = objectToString;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateInInObjectString.js
var require_helperCreateInInObjectString = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateInInObjectString.js"(exports, module) {
    var objectToString = require_staticObjectToString();
    function helperCreateInInObjectString(type) {
      return function(obj) {
        return "[object " + type + "]" === objectToString.call(obj);
      };
    }
    module.exports = helperCreateInInObjectString;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isArray.js
var require_isArray = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isArray.js"(exports, module) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isArray = Array.isArray || helperCreateInInObjectString("Array");
    module.exports = isArray;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/hasOwnProp.js
var require_hasOwnProp = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/hasOwnProp.js"(exports, module) {
    function hasOwnProp(obj, key) {
      return obj && obj.hasOwnProperty ? obj.hasOwnProperty(key) : false;
    }
    module.exports = hasOwnProp;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/objectEach.js
var require_objectEach = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/objectEach.js"(exports, module) {
    var hasOwnProp = require_hasOwnProp();
    function objectEach(obj, iterate, context) {
      if (obj) {
        for (var key in obj) {
          if (hasOwnProp(obj, key)) {
            iterate.call(context, obj[key], key, obj);
          }
        }
      }
    }
    module.exports = objectEach;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/each.js
var require_each = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/each.js"(exports, module) {
    var isArray = require_isArray();
    var arrayEach = require_arrayEach();
    var objectEach = require_objectEach();
    function each(obj, iterate, context) {
      if (obj) {
        return (isArray(obj) ? arrayEach : objectEach)(obj, iterate, context);
      }
      return obj;
    }
    module.exports = each;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateInTypeof.js
var require_helperCreateInTypeof = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateInTypeof.js"(exports, module) {
    function helperCreateInTypeof(type) {
      return function(obj) {
        return typeof obj === type;
      };
    }
    module.exports = helperCreateInTypeof;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isFunction.js"(exports, module) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isFunction = helperCreateInTypeof("function");
    module.exports = isFunction;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateGetObjects.js
var require_helperCreateGetObjects = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateGetObjects.js"(exports, module) {
    var each = require_each();
    function helperCreateGetObjects(name, getIndex) {
      var proMethod = Object[name];
      return function(obj) {
        var result = [];
        if (obj) {
          if (proMethod) {
            return proMethod(obj);
          }
          each(obj, getIndex > 1 ? function(key) {
            result.push(["" + key, obj[key]]);
          } : function() {
            result.push(arguments[getIndex]);
          });
        }
        return result;
      };
    }
    module.exports = helperCreateGetObjects;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/keys.js
var require_keys = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/keys.js"(exports, module) {
    var helperCreateGetObjects = require_helperCreateGetObjects();
    var keys = helperCreateGetObjects("keys", 1);
    module.exports = keys;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/clone.js
var require_clone = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/clone.js"(exports, module) {
    var objectToString = require_staticObjectToString();
    var objectEach = require_objectEach();
    var arrayEach = require_arrayEach();
    function getCativeCtor(val, args) {
      var Ctor = val.__proto__.constructor;
      return args ? new Ctor(args) : new Ctor();
    }
    function handleValueClone(item, isDeep) {
      return isDeep ? copyValue(item, isDeep) : item;
    }
    function copyValue(val, isDeep) {
      if (val) {
        switch (objectToString.call(val)) {
          case "[object Object]": {
            var restObj = Object.create(Object.getPrototypeOf(val));
            objectEach(val, function(item, key) {
              restObj[key] = handleValueClone(item, isDeep);
            });
            return restObj;
          }
          case "[object Date]":
          case "[object RegExp]": {
            return getCativeCtor(val, val.valueOf());
          }
          case "[object Array]":
          case "[object Arguments]": {
            var restArr = [];
            arrayEach(val, function(item) {
              restArr.push(handleValueClone(item, isDeep));
            });
            return restArr;
          }
          case "[object Set]": {
            var restSet = getCativeCtor(val);
            restSet.forEach(function(item) {
              restSet.add(handleValueClone(item, isDeep));
            });
            return restSet;
          }
          case "[object Map]": {
            var restMap = getCativeCtor(val);
            restMap.forEach(function(item, key) {
              restMap.set(key, handleValueClone(item, isDeep));
            });
            return restMap;
          }
        }
      }
      return val;
    }
    function clone(obj, deep) {
      if (obj) {
        return copyValue(obj, deep);
      }
      return obj;
    }
    module.exports = clone;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/assign.js
var require_assign = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/assign.js"(exports, module) {
    var arrayEach = require_arrayEach();
    var keys = require_keys();
    var isArray = require_isArray();
    var clone = require_clone();
    var objectAssignFns = Object.assign;
    function handleAssign(destination, args, isClone) {
      var len = args.length;
      for (var source, index = 1; index < len; index++) {
        source = args[index];
        arrayEach(keys(args[index]), isClone ? function(key) {
          destination[key] = clone(source[key], isClone);
        } : function(key) {
          destination[key] = source[key];
        });
      }
      return destination;
    }
    var assign = function(target) {
      if (target) {
        var args = arguments;
        if (target === true) {
          if (args.length > 1) {
            target = isArray(target[1]) ? [] : {};
            return handleAssign(target, args, true);
          }
        } else {
          return objectAssignFns ? objectAssignFns.apply(Object, args) : handleAssign(target, args);
        }
      }
      return target;
    };
    module.exports = assign;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/ctor.js
var require_ctor = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/ctor.js"(exports, module) {
    "use strict";
    var setupDefaults = require_setupDefaults();
    var arrayEach = require_arrayEach();
    var each = require_each();
    var isFunction = require_isFunction();
    var assign = require_assign();
    var XEUtils63 = function() {
    };
    function mixin() {
      arrayEach(arguments, function(methods) {
        each(methods, function(fn, name) {
          XEUtils63[name] = isFunction(fn) ? function() {
            var result = fn.apply(XEUtils63.$context, arguments);
            XEUtils63.$context = null;
            return result;
          } : fn;
        });
      });
    }
    function setConfig2(options) {
      return assign(setupDefaults, options);
    }
    function getConfig() {
      return setupDefaults;
    }
    var version2 = "3.7.4";
    XEUtils63.VERSION = version2;
    XEUtils63.version = version2;
    XEUtils63.mixin = mixin;
    XEUtils63.setup = setConfig2;
    XEUtils63.setConfig = setConfig2;
    XEUtils63.getConfig = getConfig;
    module.exports = XEUtils63;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastArrayEach.js
var require_lastArrayEach = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastArrayEach.js"(exports, module) {
    function lastArrayEach(obj, iterate, context) {
      for (var len = obj.length - 1; len >= 0; len--) {
        iterate.call(context, obj[len], len, obj);
      }
    }
    module.exports = lastArrayEach;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastObjectEach.js
var require_lastObjectEach = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastObjectEach.js"(exports, module) {
    var lastArrayEach = require_lastArrayEach();
    var keys = require_keys();
    function lastObjectEach(obj, iterate, context) {
      lastArrayEach(keys(obj), function(key) {
        iterate.call(context, obj[key], key, obj);
      });
    }
    module.exports = lastObjectEach;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isNull.js
var require_isNull = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isNull.js"(exports, module) {
    function isNull(obj) {
      return obj === null;
    }
    module.exports = isNull;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/property.js
var require_property = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/property.js"(exports, module) {
    var isNull = require_isNull();
    function property(name, defs) {
      return function(obj) {
        return isNull(obj) ? defs : obj[name];
      };
    }
    module.exports = property;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/objectMap.js
var require_objectMap = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/objectMap.js"(exports, module) {
    var each = require_each();
    var isFunction = require_isFunction();
    var property = require_property();
    function objectMap(obj, iterate, context) {
      var result = {};
      if (obj) {
        if (iterate) {
          if (!isFunction(iterate)) {
            iterate = property(iterate);
          }
          each(obj, function(val, index) {
            result[index] = iterate.call(context, val, index, obj);
          });
        } else {
          return obj;
        }
      }
      return result;
    }
    module.exports = objectMap;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isPlainObject.js"(exports, module) {
    function isPlainObject(obj) {
      return obj ? obj.constructor === Object : false;
    }
    module.exports = isPlainObject;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCheckCopyKey.js
var require_helperCheckCopyKey = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCheckCopyKey.js"(exports, module) {
    function helperCheckCopyKey(key) {
      return key !== "__proto__" && key !== "constructor";
    }
    module.exports = helperCheckCopyKey;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/merge.js
var require_merge = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/merge.js"(exports, module) {
    var isArray = require_isArray();
    var isPlainObject = require_isPlainObject();
    var isFunction = require_isFunction();
    var each = require_each();
    var helperCheckCopyKey = require_helperCheckCopyKey();
    function handleMerge(target, source) {
      if (isPlainObject(target) && isPlainObject(source) || isArray(target) && isArray(source)) {
        each(source, function(val, key) {
          if (helperCheckCopyKey(key)) {
            target[key] = isFunction(source) ? val : handleMerge(target[key], val);
          }
        });
        return target;
      }
      return source;
    }
    var merge = function(target) {
      if (!target) {
        target = {};
      }
      var args = arguments;
      var len = args.length;
      for (var source, index = 1; index < len; index++) {
        source = args[index];
        if (source) {
          handleMerge(target, source);
        }
      }
      return target;
    };
    module.exports = merge;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/map.js
var require_map = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/map.js"(exports, module) {
    var each = require_each();
    function map(obj, iterate, context) {
      var result = [];
      if (obj && arguments.length > 1) {
        if (obj.map) {
          return obj.map(iterate, context);
        } else {
          each(obj, function() {
            result.push(iterate.apply(context, arguments));
          });
        }
      }
      return result;
    }
    module.exports = map;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateIterateHandle.js
var require_helperCreateIterateHandle = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateIterateHandle.js"(exports, module) {
    var hasOwnProp = require_hasOwnProp();
    var isArray = require_isArray();
    function helperCreateIterateHandle(prop, useArray, restIndex, matchValue, defaultValue) {
      return function(obj, iterate, context) {
        if (obj && iterate) {
          if (prop && obj[prop]) {
            return obj[prop](iterate, context);
          } else {
            if (useArray && isArray(obj)) {
              for (var index = 0, len = obj.length; index < len; index++) {
                if (!!iterate.call(context, obj[index], index, obj) === matchValue) {
                  return [true, false, index, obj[index]][restIndex];
                }
              }
            } else {
              for (var key in obj) {
                if (hasOwnProp(obj, key)) {
                  if (!!iterate.call(context, obj[key], key, obj) === matchValue) {
                    return [true, false, key, obj[key]][restIndex];
                  }
                }
              }
            }
          }
        }
        return defaultValue;
      };
    }
    module.exports = helperCreateIterateHandle;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/some.js
var require_some = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/some.js"(exports, module) {
    var helperCreateIterateHandle = require_helperCreateIterateHandle();
    var some = helperCreateIterateHandle("some", 1, 0, true, false);
    module.exports = some;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/every.js
var require_every = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/every.js"(exports, module) {
    var helperCreateIterateHandle = require_helperCreateIterateHandle();
    var every = helperCreateIterateHandle("every", 1, 1, false, true);
    module.exports = every;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/includes.js
var require_includes = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/includes.js"(exports, module) {
    var hasOwnProp = require_hasOwnProp();
    function includes(obj, val) {
      if (obj) {
        if (obj.includes) {
          return obj.includes(val);
        }
        for (var key in obj) {
          if (hasOwnProp(obj, key)) {
            if (val === obj[key]) {
              return true;
            }
          }
        }
      }
      return false;
    }
    module.exports = includes;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/includeArrays.js
var require_includeArrays = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/includeArrays.js"(exports, module) {
    var isArray = require_isArray();
    var includes = require_includes();
    function includeArrays(array1, array2) {
      var len;
      var index = 0;
      if (isArray(array1) && isArray(array2)) {
        for (len = array2.length; index < len; index++) {
          if (!includes(array1, array2[index])) {
            return false;
          }
        }
        return true;
      }
      return includes(array1, array2);
    }
    module.exports = includeArrays;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/uniq.js
var require_uniq = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/uniq.js"(exports, module) {
    var each = require_each();
    var includes = require_includes();
    var isFunction = require_isFunction();
    var property = require_property();
    function uniq(array, iterate, context) {
      var result = [];
      if (iterate) {
        if (!isFunction(iterate)) {
          iterate = property(iterate);
        }
        var val, valMap = {};
        each(array, function(item, key) {
          val = iterate.call(context, item, key, array);
          if (!valMap[val]) {
            valMap[val] = 1;
            result.push(item);
          }
        });
      } else {
        each(array, function(value) {
          if (!includes(result, value)) {
            result.push(value);
          }
        });
      }
      return result;
    }
    module.exports = uniq;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toArray.js
var require_toArray = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toArray.js"(exports, module) {
    var map = require_map();
    function toArray(list) {
      return map(list, function(item) {
        return item;
      });
    }
    module.exports = toArray;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/union.js
var require_union = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/union.js"(exports, module) {
    var uniq = require_uniq();
    var toArray = require_toArray();
    function union() {
      var args = arguments;
      var result = [];
      var index = 0;
      var len = args.length;
      for (; index < len; index++) {
        result = result.concat(toArray(args[index]));
      }
      return uniq(result);
    }
    module.exports = union;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticStrUndefined.js
var require_staticStrUndefined = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticStrUndefined.js"(exports, module) {
    var staticStrUndefined = "undefined";
    module.exports = staticStrUndefined;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isUndefined.js
var require_isUndefined = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isUndefined.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isUndefined = helperCreateInTypeof(staticStrUndefined);
    module.exports = isUndefined;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/eqNull.js
var require_eqNull = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/eqNull.js"(exports, module) {
    var isNull = require_isNull();
    var isUndefined = require_isUndefined();
    function eqNull(obj) {
      return isNull(obj) || isUndefined(obj);
    }
    module.exports = eqNull;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticHGKeyRE.js
var require_staticHGKeyRE = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticHGKeyRE.js"(exports, module) {
    var staticHGKeyRE = /(.+)?\[(\d+)\]$/;
    module.exports = staticHGKeyRE;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetHGSKeys.js
var require_helperGetHGSKeys = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetHGSKeys.js"(exports, module) {
    function helperGetHGSKeys(property) {
      return property ? property.splice && property.join ? property : ("" + property).replace(/(\[\d+\])\.?/g, "$1.").replace(/\.$/, "").split(".") : [];
    }
    module.exports = helperGetHGSKeys;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/get.js
var require_get = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/get.js"(exports, module) {
    var staticHGKeyRE = require_staticHGKeyRE();
    var helperGetHGSKeys = require_helperGetHGSKeys();
    var hasOwnProp = require_hasOwnProp();
    var isUndefined = require_isUndefined();
    var eqNull = require_eqNull();
    function get(obj, property, defaultValue) {
      if (eqNull(obj)) {
        return defaultValue;
      }
      var result = getValueByPath(obj, property);
      return isUndefined(result) ? defaultValue : result;
    }
    function getDeepProps(obj, key) {
      var matchs = key ? key.match(staticHGKeyRE) : "";
      return matchs ? matchs[1] ? obj[matchs[1]] ? obj[matchs[1]][matchs[2]] : void 0 : obj[matchs[2]] : obj[key];
    }
    function getValueByPath(obj, property) {
      if (obj) {
        var rest, props, len;
        var index = 0;
        if (obj[property] || hasOwnProp(obj, property)) {
          return obj[property];
        } else {
          props = helperGetHGSKeys(property);
          len = props.length;
          if (len) {
            for (rest = obj; index < len; index++) {
              rest = getDeepProps(rest, props[index]);
              if (eqNull(rest)) {
                if (index === len - 1) {
                  return rest;
                }
                return;
              }
            }
          }
          return rest;
        }
      }
    }
    module.exports = get;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/orderBy.js
var require_orderBy = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/orderBy.js"(exports, module) {
    var arrayEach = require_arrayEach();
    var toArray = require_toArray();
    var map = require_map();
    var isArray = require_isArray();
    var isFunction = require_isFunction();
    var isPlainObject = require_isPlainObject();
    var isUndefined = require_isUndefined();
    var isNull = require_isNull();
    var eqNull = require_eqNull();
    var get = require_get();
    var property = require_property();
    var ORDER_PROP_ASC = "asc";
    var ORDER_PROP_DESC = "desc";
    function handleSort(v1, v2) {
      if (isUndefined(v1)) {
        return 1;
      }
      if (isNull(v1)) {
        return isUndefined(v2) ? -1 : 1;
      }
      return v1 && v1.localeCompare ? v1.localeCompare(v2) : v1 > v2 ? 1 : -1;
    }
    function buildMultiOrders(name, confs, compares) {
      return function(item1, item2) {
        var v1 = item1[name];
        var v2 = item2[name];
        if (v1 === v2) {
          return compares ? compares(item1, item2) : 0;
        }
        return confs.order === ORDER_PROP_DESC ? handleSort(v2, v1) : handleSort(v1, v2);
      };
    }
    function getSortConfs(arr, list, fieldConfs, context) {
      var sortConfs = [];
      fieldConfs = isArray(fieldConfs) ? fieldConfs : [fieldConfs];
      arrayEach(fieldConfs, function(handle, index) {
        if (handle) {
          var field = handle;
          var order;
          if (isArray(handle)) {
            field = handle[0];
            order = handle[1];
          } else if (isPlainObject(handle)) {
            field = handle.field;
            order = handle.order;
          }
          sortConfs.push({
            field,
            order: order || ORDER_PROP_ASC
          });
          arrayEach(list, isFunction(field) ? function(item, key) {
            item[index] = field.call(context, item.data, key, arr);
          } : function(item) {
            item[index] = field ? get(item.data, field) : item.data;
          });
        }
      });
      return sortConfs;
    }
    function orderBy(arr, fieldConfs, context) {
      if (arr) {
        if (eqNull(fieldConfs)) {
          return toArray(arr).sort(handleSort);
        }
        var compares;
        var list = map(arr, function(item) {
          return { data: item };
        });
        var sortConfs = getSortConfs(arr, list, fieldConfs, context);
        var len = sortConfs.length - 1;
        while (len >= 0) {
          compares = buildMultiOrders(len, sortConfs[len], compares);
          len--;
        }
        if (compares) {
          list = list.sort(compares);
        }
        return map(list, property("data"));
      }
      return [];
    }
    module.exports = orderBy;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/sortBy.js
var require_sortBy = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/sortBy.js"(exports, module) {
    var orderBy = require_orderBy();
    var sortBy = orderBy;
    module.exports = sortBy;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/random.js
var require_random = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/random.js"(exports, module) {
    function random(minVal, maxVal) {
      return minVal >= maxVal ? minVal : (minVal = minVal >> 0) + Math.round(Math.random() * ((maxVal || 9) - minVal));
    }
    module.exports = random;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/values.js
var require_values = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/values.js"(exports, module) {
    var helperCreateGetObjects = require_helperCreateGetObjects();
    var values = helperCreateGetObjects("values", 0);
    module.exports = values;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/shuffle.js
var require_shuffle = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/shuffle.js"(exports, module) {
    var random = require_random();
    var values = require_values();
    function shuffle(array) {
      var index;
      var result = [];
      var list = values(array);
      var len = list.length - 1;
      for (; len >= 0; len--) {
        index = len > 0 ? random(0, len) : 0;
        result.push(list[index]);
        list.splice(index, 1);
      }
      return result;
    }
    module.exports = shuffle;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/sample.js
var require_sample = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/sample.js"(exports, module) {
    var shuffle = require_shuffle();
    function sample(array, number) {
      var result = shuffle(array);
      if (arguments.length <= 1) {
        return result[0];
      }
      if (number < result.length) {
        result.length = number || 0;
      }
      return result;
    }
    module.exports = sample;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateToNumber.js
var require_helperCreateToNumber = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateToNumber.js"(exports, module) {
    function helperCreateToNumber(handle) {
      return function(str) {
        if (str) {
          var num = handle(str && str.replace ? str.replace(/,/g, "") : str);
          if (!isNaN(num)) {
            return num;
          }
        }
        return 0;
      };
    }
    module.exports = helperCreateToNumber;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toNumber.js"(exports, module) {
    var helperCreateToNumber = require_helperCreateToNumber();
    var toNumber = helperCreateToNumber(parseFloat);
    module.exports = toNumber;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/slice.js
var require_slice = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/slice.js"(exports, module) {
    var toNumber = require_toNumber();
    function slice(array, startIndex, endIndex) {
      var result = [];
      var argsSize = arguments.length;
      if (array) {
        startIndex = argsSize >= 2 ? toNumber(startIndex) : 0;
        endIndex = argsSize >= 3 ? toNumber(endIndex) : array.length;
        if (array.slice) {
          return array.slice(startIndex, endIndex);
        }
        for (; startIndex < endIndex; startIndex++) {
          result.push(array[startIndex]);
        }
      }
      return result;
    }
    module.exports = slice;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/filter.js
var require_filter = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/filter.js"(exports, module) {
    var each = require_each();
    function filter(obj, iterate, context) {
      var result = [];
      if (obj && iterate) {
        if (obj.filter) {
          return obj.filter(iterate, context);
        }
        each(obj, function(val, key) {
          if (iterate.call(context, val, key, obj)) {
            result.push(val);
          }
        });
      }
      return result;
    }
    module.exports = filter;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findKey.js
var require_findKey = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findKey.js"(exports, module) {
    var helperCreateIterateHandle = require_helperCreateIterateHandle();
    var findKey = helperCreateIterateHandle("", 0, 2, true);
    module.exports = findKey;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/find.js
var require_find = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/find.js"(exports, module) {
    var helperCreateIterateHandle = require_helperCreateIterateHandle();
    var find = helperCreateIterateHandle("find", 1, 3, true);
    module.exports = find;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findLast.js
var require_findLast = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findLast.js"(exports, module) {
    var isArray = require_isArray();
    var values = require_values();
    function findLast(obj, iterate, context) {
      if (obj) {
        if (!isArray(obj)) {
          obj = values(obj);
        }
        for (var len = obj.length - 1; len >= 0; len--) {
          if (iterate.call(context, obj[len], len, obj)) {
            return obj[len];
          }
        }
      }
    }
    module.exports = findLast;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/reduce.js
var require_reduce = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/reduce.js"(exports, module) {
    var keys = require_keys();
    function reduce(array, callback, initialValue) {
      if (array) {
        var len, reduceMethod;
        var index = 0;
        var context = null;
        var previous = initialValue;
        var isInitialVal = arguments.length > 2;
        var keyList = keys(array);
        if (array.length && array.reduce) {
          reduceMethod = function() {
            return callback.apply(context, arguments);
          };
          if (isInitialVal) {
            return array.reduce(reduceMethod, previous);
          }
          return array.reduce(reduceMethod);
        }
        if (isInitialVal) {
          index = 1;
          previous = array[keyList[0]];
        }
        for (len = keyList.length; index < len; index++) {
          previous = callback.call(context, previous, array[keyList[index]], index, array);
        }
        return previous;
      }
    }
    module.exports = reduce;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/copyWithin.js
var require_copyWithin = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/copyWithin.js"(exports, module) {
    var isArray = require_isArray();
    function copyWithin(array, target, start, end) {
      if (isArray(array) && array.copyWithin) {
        return array.copyWithin(target, start, end);
      }
      var replaceIndex, replaceArray;
      var targetIndex = target >> 0;
      var startIndex = start >> 0;
      var len = array.length;
      var endIndex = arguments.length > 3 ? end >> 0 : len;
      if (targetIndex < len) {
        targetIndex = targetIndex >= 0 ? targetIndex : len + targetIndex;
        if (targetIndex >= 0) {
          startIndex = startIndex >= 0 ? startIndex : len + startIndex;
          endIndex = endIndex >= 0 ? endIndex : len + endIndex;
          if (startIndex < endIndex) {
            for (replaceIndex = 0, replaceArray = array.slice(startIndex, endIndex); targetIndex < len; targetIndex++) {
              if (replaceArray.length <= replaceIndex) {
                break;
              }
              array[targetIndex] = replaceArray[replaceIndex++];
            }
          }
        }
      }
      return array;
    }
    module.exports = copyWithin;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/chunk.js
var require_chunk = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/chunk.js"(exports, module) {
    var isArray = require_isArray();
    function chunk(array, size) {
      var index;
      var result = [];
      var arrLen = size >> 0 || 1;
      if (isArray(array)) {
        if (arrLen >= 0 && array.length > arrLen) {
          index = 0;
          while (index < array.length) {
            result.push(array.slice(index, index + arrLen));
            index += arrLen;
          }
        } else {
          result = array.length ? [array] : array;
        }
      }
      return result;
    }
    module.exports = chunk;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/pluck.js
var require_pluck = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/pluck.js"(exports, module) {
    var map = require_map();
    var property = require_property();
    function pluck(obj, key) {
      return map(obj, property(key));
    }
    module.exports = pluck;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateMinMax.js
var require_helperCreateMinMax = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateMinMax.js"(exports, module) {
    var isFunction = require_isFunction();
    var eqNull = require_eqNull();
    var get = require_get();
    var arrayEach = require_arrayEach();
    function helperCreateMinMax(handle) {
      return function(arr, iterate) {
        if (arr && arr.length) {
          var rest, itemIndex;
          arrayEach(arr, function(itemVal, index) {
            if (iterate) {
              itemVal = isFunction(iterate) ? iterate(itemVal, index, arr) : get(itemVal, iterate);
            }
            if (!eqNull(itemVal) && (eqNull(rest) || handle(rest, itemVal))) {
              itemIndex = index;
              rest = itemVal;
            }
          });
          return arr[itemIndex];
        }
        return rest;
      };
    }
    module.exports = helperCreateMinMax;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/max.js
var require_max = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/max.js"(exports, module) {
    var helperCreateMinMax = require_helperCreateMinMax();
    var max = helperCreateMinMax(function(rest, itemVal) {
      return rest < itemVal;
    });
    module.exports = max;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/unzip.js
var require_unzip = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/unzip.js"(exports, module) {
    var pluck = require_pluck();
    var max = require_max();
    function unzip(arrays) {
      var index, maxItem, len;
      var result = [];
      if (arrays && arrays.length) {
        index = 0;
        maxItem = max(arrays, function(item) {
          return item ? item.length : 0;
        });
        for (len = maxItem ? maxItem.length : 0; index < len; index++) {
          result.push(pluck(arrays, index));
        }
      }
      return result;
    }
    module.exports = unzip;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/zip.js
var require_zip = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/zip.js"(exports, module) {
    var unzip = require_unzip();
    function zip() {
      return unzip(arguments);
    }
    module.exports = zip;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/zipObject.js
var require_zipObject = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/zipObject.js"(exports, module) {
    var values = require_values();
    var each = require_each();
    function zipObject(props, arr) {
      var result = {};
      arr = arr || [];
      each(values(props), function(val, key) {
        result[val] = arr[key];
      });
      return result;
    }
    module.exports = zipObject;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/flatten.js
var require_flatten = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/flatten.js"(exports, module) {
    var isArray = require_isArray();
    var arrayEach = require_arrayEach();
    function flattenDeep(array, deep) {
      var result = [];
      arrayEach(array, function(vals) {
        result = result.concat(isArray(vals) ? deep ? flattenDeep(vals, deep) : vals : [vals]);
      });
      return result;
    }
    function flatten(array, deep) {
      if (isArray(array)) {
        return flattenDeep(array, deep);
      }
      return [];
    }
    module.exports = flatten;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/invoke.js
var require_invoke = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/invoke.js"(exports, module) {
    var map = require_map();
    var isArray = require_isArray();
    function deepGetObj(obj, path) {
      var index = 0;
      var len = path.length;
      while (obj && index < len) {
        obj = obj[path[index++]];
      }
      return len && obj ? obj : 0;
    }
    function invoke(list, path) {
      var func;
      var args = arguments;
      var params = [];
      var paths = [];
      var index = 2;
      var len = args.length;
      for (; index < len; index++) {
        params.push(args[index]);
      }
      if (isArray(path)) {
        len = path.length - 1;
        for (index = 0; index < len; index++) {
          paths.push(path[index]);
        }
        path = path[len];
      }
      return map(list, function(context) {
        if (paths.length) {
          context = deepGetObj(context, paths);
        }
        func = context[path] || path;
        if (func && func.apply) {
          return func.apply(context, params);
        }
      });
    }
    module.exports = invoke;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperDeleteProperty.js
var require_helperDeleteProperty = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperDeleteProperty.js"(exports, module) {
    function helperDeleteProperty(obj, property) {
      try {
        delete obj[property];
      } catch (e) {
        obj[property] = void 0;
      }
    }
    module.exports = helperDeleteProperty;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastEach.js
var require_lastEach = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastEach.js"(exports, module) {
    var isArray = require_isArray();
    var lastArrayEach = require_lastArrayEach();
    var lastObjectEach = require_lastObjectEach();
    function lastEach(obj, iterate, context) {
      if (obj) {
        return (isArray(obj) ? lastArrayEach : lastObjectEach)(obj, iterate, context);
      }
      return obj;
    }
    module.exports = lastEach;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isObject.js
var require_isObject = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isObject.js"(exports, module) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isObject = helperCreateInTypeof("object");
    module.exports = isObject;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/clear.js
var require_clear = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/clear.js"(exports, module) {
    var helperDeleteProperty = require_helperDeleteProperty();
    var isPlainObject = require_isPlainObject();
    var isObject = require_isObject();
    var isArray = require_isArray();
    var isNull = require_isNull();
    var assign = require_assign();
    var objectEach = require_objectEach();
    function clear(obj, defs, assigns) {
      if (obj) {
        var len;
        var isDefs = arguments.length > 1 && (isNull(defs) || !isObject(defs));
        var extds = isDefs ? assigns : defs;
        if (isPlainObject(obj)) {
          objectEach(obj, isDefs ? function(val, key) {
            obj[key] = defs;
          } : function(val, key) {
            helperDeleteProperty(obj, key);
          });
          if (extds) {
            assign(obj, extds);
          }
        } else if (isArray(obj)) {
          if (isDefs) {
            len = obj.length;
            while (len > 0) {
              len--;
              obj[len] = defs;
            }
          } else {
            obj.length = 0;
          }
          if (extds) {
            obj.push.apply(obj, extds);
          }
        }
      }
      return obj;
    }
    module.exports = clear;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/remove.js
var require_remove = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/remove.js"(exports, module) {
    var helperDeleteProperty = require_helperDeleteProperty();
    var isFunction = require_isFunction();
    var isArray = require_isArray();
    var each = require_each();
    var arrayEach = require_arrayEach();
    var lastEach = require_lastEach();
    var clear = require_clear();
    var eqNull = require_eqNull();
    function pluckProperty(name) {
      return function(obj, key) {
        return key === name;
      };
    }
    function remove(obj, iterate, context) {
      if (obj) {
        if (!eqNull(iterate)) {
          var removeKeys = [];
          var rest = [];
          if (!isFunction(iterate)) {
            iterate = pluckProperty(iterate);
          }
          each(obj, function(item, index, rest2) {
            if (iterate.call(context, item, index, rest2)) {
              removeKeys.push(index);
            }
          });
          if (isArray(obj)) {
            lastEach(removeKeys, function(item, key) {
              rest.push(obj[item]);
              obj.splice(item, 1);
            });
          } else {
            rest = {};
            arrayEach(removeKeys, function(key) {
              rest[key] = obj[key];
              helperDeleteProperty(obj, key);
            });
          }
          return rest;
        }
        return clear(obj);
      }
      return obj;
    }
    module.exports = remove;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toArrayTree.js
var require_toArrayTree = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toArrayTree.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var map = require_map();
    var orderBy = require_orderBy();
    var clone = require_clone();
    var eqNull = require_eqNull();
    var each = require_each();
    var remove = require_remove();
    var assign = require_assign();
    function strictTree(array, optChildren) {
      each(array, function(item) {
        if (item[optChildren] && !item[optChildren].length) {
          remove(item, optChildren);
        }
      });
    }
    function toArrayTree(array, options) {
      var opts = assign({}, setupDefaults.treeOptions, options);
      var optStrict = opts.strict;
      var optKey = opts.key;
      var optParentKey = opts.parentKey;
      var optChildren = opts.children;
      var optMapChildren = opts.mapChildren;
      var optSortKey = opts.sortKey;
      var optReverse = opts.reverse;
      var optData = opts.data;
      var result = [];
      var treeMap = {};
      var idsMap = {};
      var id, treeData, parentId;
      if (optSortKey) {
        array = orderBy(clone(array), optSortKey);
        if (optReverse) {
          array = array.reverse();
        }
      }
      each(array, function(item) {
        id = item[optKey];
        idsMap[id] = true;
      });
      each(array, function(item) {
        id = item[optKey];
        if (optData) {
          treeData = {};
          treeData[optData] = item;
        } else {
          treeData = item;
        }
        parentId = item[optParentKey];
        treeMap[id] = treeMap[id] || [];
        treeData[optKey] = id;
        treeData[optParentKey] = parentId;
        if (id === parentId) {
          parentId = null;
          console.log("Fix infinite Loop.", item);
        }
        treeMap[parentId] = treeMap[parentId] || [];
        treeMap[parentId].push(treeData);
        treeData[optChildren] = treeMap[id];
        if (optMapChildren) {
          treeData[optMapChildren] = treeMap[id];
        }
        if (!optStrict || optStrict && eqNull(parentId)) {
          if (!idsMap[parentId]) {
            result.push(treeData);
          }
        }
      });
      if (optStrict) {
        strictTree(array, optChildren);
      }
      return result;
    }
    module.exports = toArrayTree;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toTreeArray.js
var require_toTreeArray = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toTreeArray.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var arrayEach = require_arrayEach();
    var assign = require_assign();
    function unTreeList(result, parentItem, array, opts) {
      var optKey = opts.key;
      var optParentKey = opts.parentKey;
      var optChildren = opts.children;
      var optData = opts.data;
      var optUpdated = opts.updated;
      var optClear = opts.clear;
      arrayEach(array, function(item) {
        var childList = item[optChildren];
        if (optData) {
          item = item[optData];
        }
        if (optUpdated !== false) {
          item[optParentKey] = parentItem ? parentItem[optKey] : null;
        }
        result.push(item);
        if (childList && childList.length) {
          unTreeList(result, item, childList, opts);
        }
        if (optClear) {
          delete item[optChildren];
        }
      });
      return result;
    }
    function toTreeArray(array, options) {
      return unTreeList([], null, array, assign({}, setupDefaults.treeOptions, options));
    }
    module.exports = toTreeArray;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateTreeFunc.js
var require_helperCreateTreeFunc = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateTreeFunc.js"(exports, module) {
    function helperCreateTreeFunc(handle) {
      return function(obj, iterate, options, context) {
        var opts = options || {};
        var optChildren = opts.children || "children";
        return handle(null, obj, iterate, context, [], [], optChildren, opts);
      };
    }
    module.exports = helperCreateTreeFunc;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findTree.js
var require_findTree = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findTree.js"(exports, module) {
    var helperCreateTreeFunc = require_helperCreateTreeFunc();
    function findTreeItem(parent, obj, iterate, context, path, node, parseChildren, opts) {
      if (obj) {
        var item, index, len, paths, nodes, match;
        for (index = 0, len = obj.length; index < len; index++) {
          item = obj[index];
          paths = path.concat(["" + index]);
          nodes = node.concat([item]);
          if (iterate.call(context, item, index, obj, paths, parent, nodes)) {
            return { index, item, path: paths, items: obj, parent, nodes };
          }
          if (parseChildren && item) {
            match = findTreeItem(item, item[parseChildren], iterate, context, paths.concat([parseChildren]), nodes, parseChildren, opts);
            if (match) {
              return match;
            }
          }
        }
      }
    }
    var findTree = helperCreateTreeFunc(findTreeItem);
    module.exports = findTree;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/eachTree.js
var require_eachTree = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/eachTree.js"(exports, module) {
    var helperCreateTreeFunc = require_helperCreateTreeFunc();
    var each = require_each();
    function eachTreeItem(parent, obj, iterate, context, path, node, parseChildren, opts) {
      var paths, nodes;
      each(obj, function(item, index) {
        paths = path.concat(["" + index]);
        nodes = node.concat([item]);
        iterate.call(context, item, index, obj, paths, parent, nodes);
        if (item && parseChildren) {
          paths.push(parseChildren);
          eachTreeItem(item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
        }
      });
    }
    var eachTree = helperCreateTreeFunc(eachTreeItem);
    module.exports = eachTree;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/mapTree.js
var require_mapTree = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/mapTree.js"(exports, module) {
    var helperCreateTreeFunc = require_helperCreateTreeFunc();
    var map = require_map();
    function mapTreeItem(parent, obj, iterate, context, path, node, parseChildren, opts) {
      var paths, nodes, rest;
      var mapChildren = opts.mapChildren || parseChildren;
      return map(obj, function(item, index) {
        paths = path.concat(["" + index]);
        nodes = node.concat([item]);
        rest = iterate.call(context, item, index, obj, paths, parent, nodes);
        if (rest && item && parseChildren && item[parseChildren]) {
          rest[mapChildren] = mapTreeItem(item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
        }
        return rest;
      });
    }
    var mapTree = helperCreateTreeFunc(mapTreeItem);
    module.exports = mapTree;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/filterTree.js
var require_filterTree = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/filterTree.js"(exports, module) {
    var eachTree = require_eachTree();
    function filterTree(obj, iterate, options, context) {
      var result = [];
      if (obj && iterate) {
        eachTree(obj, function(item, index, items, path, parent, nodes) {
          if (iterate.call(context, item, index, items, path, parent, nodes)) {
            result.push(item);
          }
        }, options);
      }
      return result;
    }
    module.exports = filterTree;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/searchTree.js
var require_searchTree = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/searchTree.js"(exports, module) {
    var helperCreateTreeFunc = require_helperCreateTreeFunc();
    var arrayEach = require_arrayEach();
    var assign = require_assign();
    function searchTreeItem(matchParent, parent, obj, iterate, context, path, node, parseChildren, opts) {
      var paths, nodes, rest, isMatch, hasChild;
      var rests = [];
      var hasOriginal = opts.original;
      var sourceData = opts.data;
      var mapChildren = opts.mapChildren || parseChildren;
      var isEvery = opts.isEvery;
      arrayEach(obj, function(item, index) {
        paths = path.concat(["" + index]);
        nodes = node.concat([item]);
        isMatch = matchParent && !isEvery || iterate.call(context, item, index, obj, paths, parent, nodes);
        hasChild = parseChildren && item[parseChildren];
        if (isMatch || hasChild) {
          if (hasOriginal) {
            rest = item;
          } else {
            rest = assign({}, item);
            if (sourceData) {
              rest[sourceData] = item;
            }
          }
          rest[mapChildren] = searchTreeItem(isMatch, item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
          if (isMatch || rest[mapChildren].length) {
            rests.push(rest);
          }
        } else if (isMatch) {
          rests.push(rest);
        }
      });
      return rests;
    }
    var searchTree = helperCreateTreeFunc(function(parent, obj, iterate, context, path, nodes, parseChildren, opts) {
      return searchTreeItem(0, parent, obj, iterate, context, path, nodes, parseChildren, opts);
    });
    module.exports = searchTree;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/arrayIndexOf.js
var require_arrayIndexOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/arrayIndexOf.js"(exports, module) {
    function arrayIndexOf(list, val) {
      if (list.indexOf) {
        return list.indexOf(val);
      }
      for (var index = 0, len = list.length; index < len; index++) {
        if (val === list[index]) {
          return index;
        }
      }
    }
    module.exports = arrayIndexOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/arrayLastIndexOf.js
var require_arrayLastIndexOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/arrayLastIndexOf.js"(exports, module) {
    function arrayLastIndexOf(list, val) {
      if (list.lastIndexOf) {
        return list.lastIndexOf(val);
      }
      for (var len = list.length - 1; len >= 0; len--) {
        if (val === list[len]) {
          return len;
        }
      }
      return -1;
    }
    module.exports = arrayLastIndexOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isNumber.js"(exports, module) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isNumber = helperCreateInTypeof("number");
    module.exports = isNumber;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isNaN.js"(exports, module) {
    var isNumber = require_isNumber();
    function isNumberNaN(obj) {
      return isNumber(obj) && isNaN(obj);
    }
    module.exports = isNumberNaN;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isString.js
var require_isString = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isString.js"(exports, module) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isString = helperCreateInTypeof("string");
    module.exports = isString;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isDate.js
var require_isDate = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isDate.js"(exports, module) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isDate = helperCreateInInObjectString("Date");
    module.exports = isDate;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticParseInt.js
var require_staticParseInt = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticParseInt.js"(exports, module) {
    var staticParseInt = parseInt;
    module.exports = staticParseInt;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetUTCDateTime.js
var require_helperGetUTCDateTime = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetUTCDateTime.js"(exports, module) {
    function helperGetUTCDateTime(resMaps) {
      return Date.UTC(resMaps.y, resMaps.M || 0, resMaps.d || 1, resMaps.H || 0, resMaps.m || 0, resMaps.s || 0, resMaps.S || 0);
    }
    module.exports = helperGetUTCDateTime;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetDateTime.js
var require_helperGetDateTime = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetDateTime.js"(exports, module) {
    function helperGetDateTime(date) {
      return date.getTime();
    }
    module.exports = helperGetDateTime;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toStringDate.js
var require_toStringDate = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toStringDate.js"(exports, module) {
    var staticParseInt = require_staticParseInt();
    var helperGetUTCDateTime = require_helperGetUTCDateTime();
    var helperGetDateTime = require_helperGetDateTime();
    var isString = require_isString();
    var isDate = require_isDate();
    function getParseRule(txt) {
      return "(\\d{" + txt + "})";
    }
    function toParseMs(num) {
      if (num < 10) {
        return num * 100;
      } else if (num < 100) {
        return num * 10;
      }
      return num;
    }
    function toParseNum(num) {
      return isNaN(num) ? num : staticParseInt(num);
    }
    var d2 = getParseRule(2);
    var d1or2 = getParseRule("1,2");
    var d1or7 = getParseRule("1,7");
    var d3or4 = getParseRule("3,4");
    var place = ".{1}";
    var d1Or2RE = place + d1or2;
    var dzZ = "(([zZ])|([-+]\\d{2}:?\\d{2}))";
    var defaulParseStrs = [d3or4, d1Or2RE, d1Or2RE, d1Or2RE, d1Or2RE, d1Or2RE, place + d1or7, dzZ];
    var defaulParseREs = [];
    for (len = defaulParseStrs.length - 1; len >= 0; len--) {
      rule = "";
      for (i = 0; i < len + 1; i++) {
        rule += defaulParseStrs[i];
      }
      defaulParseREs.push(new RegExp("^" + rule + "$"));
    }
    var rule;
    var i;
    var len;
    function parseDefaultRules(str) {
      var matchRest, resMaps = {};
      for (var i2 = 0, dfrLen = defaulParseREs.length; i2 < dfrLen; i2++) {
        matchRest = str.match(defaulParseREs[i2]);
        if (matchRest) {
          resMaps.y = matchRest[1];
          resMaps.M = matchRest[2];
          resMaps.d = matchRest[3];
          resMaps.H = matchRest[4];
          resMaps.m = matchRest[5];
          resMaps.s = matchRest[6];
          resMaps.S = matchRest[7];
          resMaps.Z = matchRest[8];
          break;
        }
      }
      return resMaps;
    }
    var customParseStrs = [
      ["yyyy", d3or4],
      ["yy", d2],
      ["MM", d2],
      ["M", d1or2],
      ["dd", d2],
      ["d", d1or2],
      ["HH", d2],
      ["H", d1or2],
      ["mm", d2],
      ["m", d1or2],
      ["ss", d2],
      ["s", d1or2],
      ["SSS", getParseRule(3)],
      ["S", d1or7],
      ["Z", dzZ]
    ];
    var parseRuleMaps = {};
    var parseRuleKeys = ["\\[([^\\]]+)\\]"];
    for (i = 0; i < customParseStrs.length; i++) {
      itemRule = customParseStrs[i];
      parseRuleMaps[itemRule[0]] = itemRule[1] + "?";
      parseRuleKeys.push(itemRule[0]);
    }
    var itemRule;
    var i;
    var customParseRes = new RegExp(parseRuleKeys.join("|"), "g");
    var cacheFormatMaps = {};
    function parseCustomRules(str, format) {
      var cacheItem = cacheFormatMaps[format];
      if (!cacheItem) {
        var posIndexs = [];
        var re = format.replace(/([$(){}*+.?\\^|])/g, "\\$1").replace(customParseRes, function(text, val) {
          var firstChar = text.charAt(0);
          if (firstChar === "[") {
            return val;
          }
          posIndexs.push(firstChar);
          return parseRuleMaps[text];
        });
        cacheItem = cacheFormatMaps[format] = {
          _i: posIndexs,
          _r: new RegExp(re)
        };
      }
      var resMaps = {};
      var matchRest = str.match(cacheItem._r);
      if (matchRest) {
        var _i = cacheItem._i;
        for (var i2 = 1, len2 = matchRest.length; i2 < len2; i2++) {
          resMaps[_i[i2 - 1]] = matchRest[i2];
        }
        return resMaps;
      }
      return resMaps;
    }
    function parseTimeZone(resMaps) {
      if (/^[zZ]/.test(resMaps.Z)) {
        return new Date(helperGetUTCDateTime(resMaps));
      } else {
        var matchRest = resMaps.Z.match(/([-+])(\d{2}):?(\d{2})/);
        if (matchRest) {
          return new Date(helperGetUTCDateTime(resMaps) - (matchRest[1] === "-" ? -1 : 1) * staticParseInt(matchRest[2]) * 36e5 + staticParseInt(matchRest[3]) * 6e4);
        }
      }
      return /* @__PURE__ */ new Date("");
    }
    function toStringDate(str, format) {
      if (str) {
        var isDType = isDate(str);
        if (isDType || !format && /^[0-9]{11,15}$/.test(str)) {
          return new Date(isDType ? helperGetDateTime(str) : staticParseInt(str));
        }
        if (isString(str)) {
          var resMaps = format ? parseCustomRules(str, format) : parseDefaultRules(str);
          if (resMaps.y) {
            if (resMaps.M) {
              resMaps.M = toParseNum(resMaps.M) - 1;
            }
            if (resMaps.S) {
              resMaps.S = toParseMs(toParseNum(resMaps.S.substring(0, 3)));
            }
            if (resMaps.Z) {
              return parseTimeZone(resMaps);
            } else {
              return new Date(resMaps.y, resMaps.M || 0, resMaps.d || 1, resMaps.H || 0, resMaps.m || 0, resMaps.s || 0, resMaps.S || 0);
            }
          }
        }
      }
      return /* @__PURE__ */ new Date("");
    }
    module.exports = toStringDate;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNewDate.js
var require_helperNewDate = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNewDate.js"(exports, module) {
    function helperNewDate() {
      return /* @__PURE__ */ new Date();
    }
    module.exports = helperNewDate;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isLeapYear.js
var require_isLeapYear = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isLeapYear.js"(exports, module) {
    var isDate = require_isDate();
    var toStringDate = require_toStringDate();
    var helperNewDate = require_helperNewDate();
    function isLeapYear(date) {
      var year;
      var currentDate = date ? toStringDate(date) : helperNewDate();
      if (isDate(currentDate)) {
        year = currentDate.getFullYear();
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      return false;
    }
    module.exports = isLeapYear;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/forOf.js
var require_forOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/forOf.js"(exports, module) {
    var isArray = require_isArray();
    var hasOwnProp = require_hasOwnProp();
    function forOf(obj, iterate, context) {
      if (obj) {
        if (isArray(obj)) {
          for (var index = 0, len = obj.length; index < len; index++) {
            if (iterate.call(context, obj[index], index, obj) === false) {
              break;
            }
          }
        } else {
          for (var key in obj) {
            if (hasOwnProp(obj, key)) {
              if (iterate.call(context, obj[key], key, obj) === false) {
                break;
              }
            }
          }
        }
      }
    }
    module.exports = forOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastForOf.js
var require_lastForOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastForOf.js"(exports, module) {
    var isArray = require_isArray();
    var keys = require_hasOwnProp();
    function lastForOf(obj, iterate, context) {
      if (obj) {
        var len, list;
        if (isArray(obj)) {
          for (len = obj.length - 1; len >= 0; len--) {
            if (iterate.call(context, obj[len], len, obj) === false) {
              break;
            }
          }
        } else {
          list = keys(obj);
          for (len = list.length - 1; len >= 0; len--) {
            if (iterate.call(context, obj[list[len]], list[len], obj) === false) {
              break;
            }
          }
        }
      }
    }
    module.exports = lastForOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateIndexOf.js
var require_helperCreateIndexOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateIndexOf.js"(exports, module) {
    var isArray = require_isArray();
    var isString = require_isString();
    var hasOwnProp = require_hasOwnProp();
    function helperCreateIndexOf(name, callback) {
      return function(obj, val) {
        if (obj) {
          if (obj[name]) {
            return obj[name](val);
          }
          if (isString(obj) || isArray(obj)) {
            return callback(obj, val);
          }
          for (var key in obj) {
            if (hasOwnProp(obj, key)) {
              if (val === obj[key]) {
                return key;
              }
            }
          }
        }
        return -1;
      };
    }
    module.exports = helperCreateIndexOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/indexOf.js
var require_indexOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/indexOf.js"(exports, module) {
    var helperCreateIndexOf = require_helperCreateIndexOf();
    var arrayIndexOf = require_arrayIndexOf();
    var indexOf = helperCreateIndexOf("indexOf", arrayIndexOf);
    module.exports = indexOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastIndexOf.js
var require_lastIndexOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/lastIndexOf.js"(exports, module) {
    var helperCreateIndexOf = require_helperCreateIndexOf();
    var arrayLastIndexOf = require_arrayLastIndexOf();
    var lastIndexOf = helperCreateIndexOf("lastIndexOf", arrayLastIndexOf);
    module.exports = lastIndexOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getSize.js
var require_getSize = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getSize.js"(exports, module) {
    var isArray = require_isArray();
    var isString = require_isString();
    var each = require_each();
    function getSize(obj) {
      var len = 0;
      if (isString(obj) || isArray(obj)) {
        return obj.length;
      }
      each(obj, function() {
        len++;
      });
      return len;
    }
    module.exports = getSize;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isFinite.js
var require_isFinite = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isFinite.js"(exports, module) {
    var isNumber = require_isNumber();
    function isNumberFinite(obj) {
      return isNumber(obj) && isFinite(obj);
    }
    module.exports = isNumberFinite;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isInteger.js
var require_isInteger = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isInteger.js"(exports, module) {
    var isArray = require_isArray();
    var isNull = require_isNull();
    var isInteger = function(obj) {
      return !isNull(obj) && !isNaN(obj) && !isArray(obj) && obj % 1 === 0;
    };
    module.exports = isInteger;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isFloat.js
var require_isFloat = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isFloat.js"(exports, module) {
    var isArray = require_isArray();
    var isInteger = require_isInteger();
    var isNull = require_isNull();
    function isFloat(obj) {
      return !isNull(obj) && !isNaN(obj) && !isArray(obj) && !isInteger(obj);
    }
    module.exports = isFloat;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isBoolean.js
var require_isBoolean = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isBoolean.js"(exports, module) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isBoolean = helperCreateInTypeof("boolean");
    module.exports = isBoolean;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isRegExp.js
var require_isRegExp = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isRegExp.js"(exports, module) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isRegExp = helperCreateInInObjectString("RegExp");
    module.exports = isRegExp;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isError.js
var require_isError = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isError.js"(exports, module) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isError = helperCreateInInObjectString("Error");
    module.exports = isError;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isTypeError.js
var require_isTypeError = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isTypeError.js"(exports, module) {
    function isTypeError(obj) {
      return obj ? obj.constructor === TypeError : false;
    }
    module.exports = isTypeError;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isEmpty.js"(exports, module) {
    function isEmpty(obj) {
      for (var key in obj) {
        return false;
      }
      return true;
    }
    module.exports = isEmpty;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isSymbol.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportSymbol = typeof Symbol !== staticStrUndefined;
    function isSymbol(obj) {
      return supportSymbol && Symbol.isSymbol ? Symbol.isSymbol(obj) : typeof obj === "symbol";
    }
    module.exports = isSymbol;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isArguments.js"(exports, module) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isArguments = helperCreateInInObjectString("Arguments");
    module.exports = isArguments;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isElement.js
var require_isElement = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isElement.js"(exports, module) {
    var isString = require_isString();
    var isNumber = require_isNumber();
    function isElement(obj) {
      return !!(obj && isString(obj.nodeName) && isNumber(obj.nodeType));
    }
    module.exports = isElement;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticDocument.js
var require_staticDocument = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticDocument.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var staticDocument = typeof document === staticStrUndefined ? 0 : document;
    module.exports = staticDocument;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isDocument.js
var require_isDocument = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isDocument.js"(exports, module) {
    var staticDocument = require_staticDocument();
    function isDocument(obj) {
      return !!(obj && staticDocument && obj.nodeType === 9);
    }
    module.exports = isDocument;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticWindow.js
var require_staticWindow = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticWindow.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var staticWindow = typeof window === staticStrUndefined ? 0 : window;
    module.exports = staticWindow;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isWindow.js
var require_isWindow = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isWindow.js"(exports, module) {
    var staticWindow = require_staticWindow();
    function isWindow(obj) {
      return !!(staticWindow && !!(obj && obj === obj.window));
    }
    module.exports = isWindow;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isFormData.js
var require_isFormData = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isFormData.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportFormData = typeof FormData !== staticStrUndefined;
    function isFormData(obj) {
      return supportFormData && obj instanceof FormData;
    }
    module.exports = isFormData;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isMap.js
var require_isMap = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isMap.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportMap = typeof Map !== staticStrUndefined;
    function isMap(obj) {
      return supportMap && obj instanceof Map;
    }
    module.exports = isMap;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isWeakMap.js
var require_isWeakMap = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isWeakMap.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportWeakMap = typeof WeakMap !== staticStrUndefined;
    function isWeakMap(obj) {
      return supportWeakMap && obj instanceof WeakMap;
    }
    module.exports = isWeakMap;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isSet.js
var require_isSet = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isSet.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportSet = typeof Set !== staticStrUndefined;
    function isSet(obj) {
      return supportSet && obj instanceof Set;
    }
    module.exports = isSet;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isWeakSet.js
var require_isWeakSet = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isWeakSet.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportWeakSet = typeof WeakSet !== staticStrUndefined;
    function isWeakSet(obj) {
      return supportWeakSet && obj instanceof WeakSet;
    }
    module.exports = isWeakSet;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateiterateIndexOf.js
var require_helperCreateiterateIndexOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateiterateIndexOf.js"(exports, module) {
    var isFunction = require_isFunction();
    var isString = require_isString();
    var isArray = require_isArray();
    var hasOwnProp = require_hasOwnProp();
    function helperCreateiterateIndexOf(callback) {
      return function(obj, iterate, context) {
        if (obj && isFunction(iterate)) {
          if (isArray(obj) || isString(obj)) {
            return callback(obj, iterate, context);
          }
          for (var key in obj) {
            if (hasOwnProp(obj, key)) {
              if (iterate.call(context, obj[key], key, obj)) {
                return key;
              }
            }
          }
        }
        return -1;
      };
    }
    module.exports = helperCreateiterateIndexOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findIndexOf.js
var require_findIndexOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findIndexOf.js"(exports, module) {
    var helperCreateiterateIndexOf = require_helperCreateiterateIndexOf();
    var findIndexOf = helperCreateiterateIndexOf(function(obj, iterate, context) {
      for (var index = 0, len = obj.length; index < len; index++) {
        if (iterate.call(context, obj[index], index, obj)) {
          return index;
        }
      }
      return -1;
    });
    module.exports = findIndexOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperEqualCompare.js
var require_helperEqualCompare = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperEqualCompare.js"(exports, module) {
    var isNumber = require_isNumber();
    var isArray = require_isArray();
    var isString = require_isString();
    var isRegExp = require_isRegExp();
    var isDate = require_isDate();
    var isBoolean = require_isBoolean();
    var isUndefined = require_isUndefined();
    var keys = require_keys();
    var every = require_every();
    function helperEqualCompare(val1, val2, compare, func, key, obj1, obj2) {
      if (val1 === val2) {
        return true;
      }
      if (val1 && val2 && !isNumber(val1) && !isNumber(val2) && !isString(val1) && !isString(val2)) {
        if (isRegExp(val1)) {
          return compare("" + val1, "" + val2, key, obj1, obj2);
        }
        if (isDate(val1) || isBoolean(val1)) {
          return compare(+val1, +val2, key, obj1, obj2);
        } else {
          var result, val1Keys, val2Keys;
          var isObj1Arr = isArray(val1);
          var isObj2Arr = isArray(val2);
          if (isObj1Arr || isObj2Arr ? isObj1Arr && isObj2Arr : val1.constructor === val2.constructor) {
            val1Keys = keys(val1);
            val2Keys = keys(val2);
            if (func) {
              result = func(val1, val2, key);
            }
            if (val1Keys.length === val2Keys.length) {
              return isUndefined(result) ? every(val1Keys, function(key2, index) {
                return key2 === val2Keys[index] && helperEqualCompare(val1[key2], val2[val2Keys[index]], compare, func, isObj1Arr || isObj2Arr ? index : key2, val1, val2);
              }) : !!result;
            }
            return false;
          }
        }
      }
      return compare(val1, val2, key, obj1, obj2);
    }
    module.exports = helperEqualCompare;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperDefaultCompare.js
var require_helperDefaultCompare = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperDefaultCompare.js"(exports, module) {
    function helperDefaultCompare(v1, v2) {
      return v1 === v2;
    }
    module.exports = helperDefaultCompare;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isEqual.js"(exports, module) {
    var helperEqualCompare = require_helperEqualCompare();
    var helperDefaultCompare = require_helperDefaultCompare();
    function isEqual(obj1, obj2) {
      return helperEqualCompare(obj1, obj2, helperDefaultCompare);
    }
    module.exports = isEqual;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isMatch.js
var require_isMatch = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isMatch.js"(exports, module) {
    var keys = require_keys();
    var findIndexOf = require_findIndexOf();
    var isEqual = require_isEqual();
    var some = require_some();
    var includeArrays = require_includeArrays();
    function isMatch(obj, source) {
      var objKeys = keys(obj);
      var sourceKeys = keys(source);
      if (sourceKeys.length) {
        if (includeArrays(objKeys, sourceKeys)) {
          return some(sourceKeys, function(key2) {
            return findIndexOf(objKeys, function(key1) {
              return key1 === key2 && isEqual(obj[key1], source[key2]);
            }) > -1;
          });
        }
      } else {
        return true;
      }
      return isEqual(obj, source);
    }
    module.exports = isMatch;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isEqualWith.js
var require_isEqualWith = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isEqualWith.js"(exports, module) {
    var helperEqualCompare = require_helperEqualCompare();
    var helperDefaultCompare = require_helperDefaultCompare();
    var isFunction = require_isFunction();
    var isUndefined = require_isUndefined();
    function isEqualWith(obj1, obj2, func) {
      if (isFunction(func)) {
        return helperEqualCompare(obj1, obj2, function(v1, v2, key, obj12, obj22) {
          var result = func(v1, v2, key, obj12, obj22);
          return isUndefined(result) ? helperDefaultCompare(v1, v2) : !!result;
        }, func);
      }
      return helperEqualCompare(obj1, obj2, helperDefaultCompare);
    }
    module.exports = isEqualWith;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getType.js
var require_getType = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getType.js"(exports, module) {
    var isSymbol = require_isSymbol();
    var isDate = require_isDate();
    var isArray = require_isArray();
    var isRegExp = require_isRegExp();
    var isError = require_isError();
    var isNull = require_isNull();
    function getType(obj) {
      if (isNull(obj)) {
        return "null";
      }
      if (isSymbol(obj)) {
        return "symbol";
      }
      if (isDate(obj)) {
        return "date";
      }
      if (isArray(obj)) {
        return "array";
      }
      if (isRegExp(obj)) {
        return "regexp";
      }
      if (isError(obj)) {
        return "error";
      }
      return typeof obj;
    }
    module.exports = getType;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/uniqueId.js
var require_uniqueId = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/uniqueId.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var eqNull = require_eqNull();
    function uniqueId(prefix) {
      return "" + (eqNull(prefix) ? "" : prefix) + setupDefaults.keyId++;
    }
    module.exports = uniqueId;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findLastIndexOf.js
var require_findLastIndexOf = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/findLastIndexOf.js"(exports, module) {
    var helperCreateiterateIndexOf = require_helperCreateiterateIndexOf();
    var findLastIndexOf = helperCreateiterateIndexOf(function(obj, iterate, context) {
      for (var len = obj.length - 1; len >= 0; len--) {
        if (iterate.call(context, obj[len], len, obj)) {
          return len;
        }
      }
      return -1;
    });
    module.exports = findLastIndexOf;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toStringJSON.js
var require_toStringJSON = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toStringJSON.js"(exports, module) {
    var isPlainObject = require_isPlainObject();
    var isString = require_isString();
    function toStringJSON(str) {
      if (isPlainObject(str)) {
        return str;
      } else if (isString(str)) {
        try {
          return JSON.parse(str);
        } catch (e) {
        }
      }
      return {};
    }
    module.exports = toStringJSON;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toJSONString.js
var require_toJSONString = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toJSONString.js"(exports, module) {
    var eqNull = require_eqNull();
    function toJSONString(obj) {
      return eqNull(obj) ? "" : JSON.stringify(obj);
    }
    module.exports = toJSONString;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/entries.js
var require_entries = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/entries.js"(exports, module) {
    var helperCreateGetObjects = require_helperCreateGetObjects();
    var entries = helperCreateGetObjects("entries", 2);
    module.exports = entries;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreatePickOmit.js
var require_helperCreatePickOmit = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreatePickOmit.js"(exports, module) {
    var isFunction = require_isFunction();
    var isArray = require_isArray();
    var each = require_each();
    var findIndexOf = require_findIndexOf();
    function helperCreatePickOmit(case1, case2) {
      return function(obj, callback) {
        var item, index;
        var rest = {};
        var result = [];
        var context = this;
        var args = arguments;
        var len = args.length;
        if (!isFunction(callback)) {
          for (index = 1; index < len; index++) {
            item = args[index];
            result.push.apply(result, isArray(item) ? item : [item]);
          }
          callback = 0;
        }
        each(obj, function(val, key) {
          if ((callback ? callback.call(context, val, key, obj) : findIndexOf(result, function(name) {
            return name === key;
          }) > -1) ? case1 : case2) {
            rest[key] = val;
          }
        });
        return rest;
      };
    }
    module.exports = helperCreatePickOmit;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/pick.js
var require_pick = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/pick.js"(exports, module) {
    var helperCreatePickOmit = require_helperCreatePickOmit();
    var pick = helperCreatePickOmit(1, 0);
    module.exports = pick;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/omit.js
var require_omit = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/omit.js"(exports, module) {
    var helperCreatePickOmit = require_helperCreatePickOmit();
    var omit = helperCreatePickOmit(0, 1);
    module.exports = omit;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/first.js
var require_first = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/first.js"(exports, module) {
    var values = require_values();
    function first(obj) {
      return values(obj)[0];
    }
    module.exports = first;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/last.js
var require_last = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/last.js"(exports, module) {
    var values = require_values();
    function last(obj) {
      var list = values(obj);
      return list[list.length - 1];
    }
    module.exports = last;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/has.js
var require_has = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/has.js"(exports, module) {
    var staticHGKeyRE = require_staticHGKeyRE();
    var helperGetHGSKeys = require_helperGetHGSKeys();
    var hasOwnProp = require_hasOwnProp();
    function has(obj, property) {
      if (obj) {
        if (hasOwnProp(obj, property)) {
          return true;
        } else {
          var prop, arrIndex, objProp, matchs, rest, isHas;
          var props = helperGetHGSKeys(property);
          var index = 0;
          var len = props.length;
          for (rest = obj; index < len; index++) {
            isHas = false;
            prop = props[index];
            matchs = prop ? prop.match(staticHGKeyRE) : "";
            if (matchs) {
              arrIndex = matchs[1];
              objProp = matchs[2];
              if (arrIndex) {
                if (rest[arrIndex]) {
                  if (hasOwnProp(rest[arrIndex], objProp)) {
                    isHas = true;
                    rest = rest[arrIndex][objProp];
                  }
                }
              } else {
                if (hasOwnProp(rest, objProp)) {
                  isHas = true;
                  rest = rest[objProp];
                }
              }
            } else {
              if (hasOwnProp(rest, prop)) {
                isHas = true;
                rest = rest[prop];
              }
            }
            if (isHas) {
              if (index === len - 1) {
                return true;
              }
            } else {
              break;
            }
          }
        }
      }
      return false;
    }
    module.exports = has;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/set.js
var require_set = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/set.js"(exports, module) {
    var staticParseInt = require_staticParseInt();
    var helperGetHGSKeys = require_helperGetHGSKeys();
    var helperCheckCopyKey = require_helperCheckCopyKey();
    var hasOwnProp = require_hasOwnProp();
    var sKeyRE = /(.+)?\[(\d+)\]$/;
    function setDeepProps(obj, key, isEnd, nextKey, value) {
      if (obj[key]) {
        if (isEnd) {
          obj[key] = value;
        }
      } else {
        var index;
        var rest;
        var currMatchs = key ? key.match(sKeyRE) : null;
        if (isEnd) {
          rest = value;
        } else {
          var nextMatchs = nextKey ? nextKey.match(sKeyRE) : null;
          if (nextMatchs && !nextMatchs[1]) {
            rest = new Array(staticParseInt(nextMatchs[2]) + 1);
          } else {
            rest = {};
          }
        }
        if (currMatchs) {
          if (currMatchs[1]) {
            index = staticParseInt(currMatchs[2]);
            if (obj[currMatchs[1]]) {
              if (isEnd) {
                obj[currMatchs[1]][index] = rest;
              } else {
                if (obj[currMatchs[1]][index]) {
                  rest = obj[currMatchs[1]][index];
                } else {
                  obj[currMatchs[1]][index] = rest;
                }
              }
            } else {
              obj[currMatchs[1]] = new Array(index + 1);
              obj[currMatchs[1]][index] = rest;
            }
          } else {
            obj[currMatchs[2]] = rest;
          }
        } else {
          obj[key] = rest;
        }
        return rest;
      }
      return obj[key];
    }
    function set(obj, property, value) {
      if (obj && helperCheckCopyKey(property)) {
        if ((obj[property] || hasOwnProp(obj, property)) && !isPrototypePolluted(property)) {
          obj[property] = value;
        } else {
          var rest = obj;
          var props = helperGetHGSKeys(property);
          var len = props.length;
          for (var index = 0; index < len; index++) {
            if (isPrototypePolluted(props[index])) {
              continue;
            }
            var isEnd = index === len - 1;
            rest = setDeepProps(rest, props[index], isEnd, isEnd ? null : props[index + 1], value);
          }
        }
      }
      return obj;
    }
    function isPrototypePolluted(key) {
      return key === "__proto__" || key === "constructor" || key === "prototype";
    }
    module.exports = set;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/groupBy.js"(exports, module) {
    var isEmpty = require_isEmpty();
    var isObject = require_isObject();
    var isFunction = require_isFunction();
    var property = require_property();
    var each = require_each();
    function createiterateEmpty(iterate) {
      return function() {
        return isEmpty(iterate);
      };
    }
    function groupBy(obj, iterate, context) {
      var groupKey;
      var result = {};
      if (obj) {
        if (iterate && isObject(iterate)) {
          iterate = createiterateEmpty(iterate);
        } else if (!isFunction(iterate)) {
          iterate = property(iterate);
        }
        each(obj, function(val, key) {
          groupKey = iterate ? iterate.call(context, val, key, obj) : val;
          if (result[groupKey]) {
            result[groupKey].push(val);
          } else {
            result[groupKey] = [val];
          }
        });
      }
      return result;
    }
    module.exports = groupBy;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/countBy.js
var require_countBy = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/countBy.js"(exports, module) {
    var groupBy = require_groupBy();
    var objectEach = require_objectEach();
    function countBy(obj, iterate, context) {
      var result = groupBy(obj, iterate, context || this);
      objectEach(result, function(item, key) {
        result[key] = item.length;
      });
      return result;
    }
    module.exports = countBy;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/range.js
var require_range = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/range.js"(exports, module) {
    function range(start, stop, step) {
      var index, len;
      var result = [];
      var args = arguments;
      if (args.length < 2) {
        stop = args[0];
        start = 0;
      }
      index = start >> 0;
      len = stop >> 0;
      if (index < stop) {
        step = step >> 0 || 1;
        for (; index < len; index += step) {
          result.push(index);
        }
      }
      return result;
    }
    module.exports = range;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/destructuring.js
var require_destructuring = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/destructuring.js"(exports, module) {
    var keys = require_keys();
    var slice = require_slice();
    var includes = require_includes();
    var arrayEach = require_arrayEach();
    var assign = require_assign();
    function destructuring(destination, sources) {
      if (destination && sources) {
        var rest = assign.apply(this, [{}].concat(slice(arguments, 1)));
        var restKeys = keys(rest);
        arrayEach(keys(destination), function(key) {
          if (includes(restKeys, key)) {
            destination[key] = rest[key];
          }
        });
      }
      return destination;
    }
    module.exports = destructuring;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/min.js
var require_min = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/min.js"(exports, module) {
    var helperCreateMinMax = require_helperCreateMinMax();
    var min = helperCreateMinMax(function(rest, itemVal) {
      return rest > itemVal;
    });
    module.exports = min;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNumberDecimal.js
var require_helperNumberDecimal = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNumberDecimal.js"(exports, module) {
    function helperNumberDecimal(numStr) {
      return (numStr.split(".")[1] || "").length;
    }
    module.exports = helperNumberDecimal;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperStringRepeat.js
var require_helperStringRepeat = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperStringRepeat.js"(exports, module) {
    var staticParseInt = require_staticParseInt();
    function helperStringRepeat(str, count) {
      if (str.repeat) {
        return str.repeat(count);
      }
      var list = isNaN(count) ? [] : new Array(staticParseInt(count));
      return list.join(str) + (list.length > 0 ? str : "");
    }
    module.exports = helperStringRepeat;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNumberOffsetPoint.js
var require_helperNumberOffsetPoint = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNumberOffsetPoint.js"(exports, module) {
    function helperNumberOffsetPoint(str, offsetIndex) {
      return str.substring(0, offsetIndex) + "." + str.substring(offsetIndex, str.length);
    }
    module.exports = helperNumberOffsetPoint;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toNumberString.js
var require_toNumberString = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toNumberString.js"(exports, module) {
    var helperStringRepeat = require_helperStringRepeat();
    var helperNumberOffsetPoint = require_helperNumberOffsetPoint();
    function toNumberString(num) {
      var rest = "" + num;
      var scienceMatchs = rest.match(/^([-+]?)((\d+)|((\d+)?[.](\d+)?))e([-+]{1})([0-9]+)$/);
      if (scienceMatchs) {
        var isNegative = num < 0;
        var absFlag = isNegative ? "-" : "";
        var intNumStr = scienceMatchs[3] || "";
        var dIntNumStr = scienceMatchs[5] || "";
        var dFloatNumStr = scienceMatchs[6] || "";
        var sciencFlag = scienceMatchs[7];
        var scienceNumStr = scienceMatchs[8];
        var floatOffsetIndex = scienceNumStr - dFloatNumStr.length;
        var intOffsetIndex = scienceNumStr - intNumStr.length;
        var dIntOffsetIndex = scienceNumStr - dIntNumStr.length;
        if (sciencFlag === "+") {
          if (intNumStr) {
            return absFlag + intNumStr + helperStringRepeat("0", scienceNumStr);
          }
          if (floatOffsetIndex > 0) {
            return absFlag + dIntNumStr + dFloatNumStr + helperStringRepeat("0", floatOffsetIndex);
          }
          return absFlag + dIntNumStr + helperNumberOffsetPoint(dFloatNumStr, scienceNumStr);
        }
        if (intNumStr) {
          if (intOffsetIndex > 0) {
            return absFlag + "0." + helperStringRepeat("0", Math.abs(intOffsetIndex)) + intNumStr;
          }
          return absFlag + helperNumberOffsetPoint(intNumStr, intOffsetIndex);
        }
        if (dIntOffsetIndex > 0) {
          return absFlag + "0." + helperStringRepeat("0", Math.abs(dIntOffsetIndex)) + dIntNumStr + dFloatNumStr;
        }
        return absFlag + helperNumberOffsetPoint(dIntNumStr, dIntOffsetIndex) + dFloatNumStr;
      }
      return rest;
    }
    module.exports = toNumberString;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperMultiply.js
var require_helperMultiply = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperMultiply.js"(exports, module) {
    var helperNumberDecimal = require_helperNumberDecimal();
    var toNumberString = require_toNumberString();
    function helperMultiply(multiplier, multiplicand) {
      var str1 = toNumberString(multiplier);
      var str2 = toNumberString(multiplicand);
      return parseInt(str1.replace(".", "")) * parseInt(str2.replace(".", "")) / Math.pow(10, helperNumberDecimal(str1) + helperNumberDecimal(str2));
    }
    module.exports = helperMultiply;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateMathNumber.js
var require_helperCreateMathNumber = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateMathNumber.js"(exports, module) {
    var helperMultiply = require_helperMultiply();
    var toNumber = require_toNumber();
    var toNumberString = require_toNumberString();
    function helperCreateMathNumber(name) {
      return function(num, digits) {
        var numRest = toNumber(num);
        var rest = numRest;
        if (numRest) {
          digits = digits >> 0;
          var numStr = toNumberString(numRest);
          var nums = numStr.split(".");
          var intStr = nums[0];
          var floatStr = nums[1] || "";
          var fStr = floatStr.substring(0, digits + 1);
          var subRest = intStr + (fStr ? "." + fStr : "");
          if (digits >= floatStr.length) {
            return toNumber(subRest);
          }
          subRest = numRest;
          if (digits > 0) {
            var ratio = Math.pow(10, digits);
            rest = Math[name](helperMultiply(subRest, ratio)) / ratio;
          } else {
            rest = Math[name](subRest);
          }
        }
        return rest;
      };
    }
    module.exports = helperCreateMathNumber;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/round.js
var require_round = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/round.js"(exports, module) {
    var helperCreateMathNumber = require_helperCreateMathNumber();
    var round = helperCreateMathNumber("round");
    module.exports = round;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/ceil.js
var require_ceil = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/ceil.js"(exports, module) {
    var helperCreateMathNumber = require_helperCreateMathNumber();
    var ceil = helperCreateMathNumber("ceil");
    module.exports = ceil;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/floor.js
var require_floor = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/floor.js"(exports, module) {
    var helperCreateMathNumber = require_helperCreateMathNumber();
    var floor = helperCreateMathNumber("floor");
    module.exports = floor;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toValueString.js
var require_toValueString = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toValueString.js"(exports, module) {
    var eqNull = require_eqNull();
    var isNumber = require_isNumber();
    var toNumberString = require_toNumberString();
    function toValueString(obj) {
      if (isNumber(obj)) {
        return toNumberString(obj);
      }
      return "" + (eqNull(obj) ? "" : obj);
    }
    module.exports = toValueString;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toFixed.js
var require_toFixed = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toFixed.js"(exports, module) {
    var round = require_round();
    var toValueString = require_toValueString();
    var helperStringRepeat = require_helperStringRepeat();
    var helperNumberOffsetPoint = require_helperNumberOffsetPoint();
    function toFixed(num, digits) {
      digits = digits >> 0;
      var str = toValueString(round(num, digits));
      var nums = str.split(".");
      var intStr = nums[0];
      var floatStr = nums[1] || "";
      var digitOffsetIndex = digits - floatStr.length;
      if (digits) {
        if (digitOffsetIndex > 0) {
          return intStr + "." + floatStr + helperStringRepeat("0", digitOffsetIndex);
        }
        return intStr + helperNumberOffsetPoint(floatStr, Math.abs(digitOffsetIndex));
      }
      return intStr;
    }
    module.exports = toFixed;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/commafy.js
var require_commafy = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/commafy.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var round = require_round();
    var ceil = require_ceil();
    var floor = require_floor();
    var isNumber = require_isNumber();
    var toValueString = require_toValueString();
    var toFixed = require_toFixed();
    var toNumberString = require_toNumberString();
    var assign = require_assign();
    function commafy(num, options) {
      var opts = assign({}, setupDefaults.commafyOptions, options);
      var optDigits = opts.digits;
      var isNum = isNumber(num);
      var rest, result, isNegative, intStr, floatStr;
      if (isNum) {
        rest = (opts.ceil ? ceil : opts.floor ? floor : round)(num, optDigits);
        result = toNumberString(optDigits ? toFixed(rest, optDigits) : rest).split(".");
        intStr = result[0];
        floatStr = result[1];
        isNegative = intStr && rest < 0;
        if (isNegative) {
          intStr = intStr.substring(1, intStr.length);
        }
      } else {
        rest = toValueString(num).replace(/,/g, "");
        result = rest ? [rest] : [];
        intStr = result[0];
      }
      if (result.length) {
        return (isNegative ? "-" : "") + intStr.replace(new RegExp("(?=(?!(\\b))(.{" + (opts.spaceNumber || 3) + "})+$)", "g"), opts.separator || ",") + (floatStr ? "." + floatStr : "");
      }
      return rest;
    }
    module.exports = commafy;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toInteger.js"(exports, module) {
    var staticParseInt = require_staticParseInt();
    var helperCreateToNumber = require_helperCreateToNumber();
    var toInteger = helperCreateToNumber(staticParseInt);
    module.exports = toInteger;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/multiply.js
var require_multiply = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/multiply.js"(exports, module) {
    var helperMultiply = require_helperMultiply();
    var toNumber = require_toNumber();
    function multiply(num1, num2) {
      var multiplier = toNumber(num1);
      var multiplicand = toNumber(num2);
      return helperMultiply(multiplier, multiplicand);
    }
    module.exports = multiply;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNumberAdd.js
var require_helperNumberAdd = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNumberAdd.js"(exports, module) {
    var helperNumberDecimal = require_helperNumberDecimal();
    var toNumberString = require_toNumberString();
    var multiply = require_multiply();
    function helperNumberAdd(addend, augend) {
      var str1 = toNumberString(addend);
      var str2 = toNumberString(augend);
      var ratio = Math.pow(10, Math.max(helperNumberDecimal(str1), helperNumberDecimal(str2)));
      return (multiply(addend, ratio) + multiply(augend, ratio)) / ratio;
    }
    module.exports = helperNumberAdd;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/add.js
var require_add = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/add.js"(exports, module) {
    var helperNumberAdd = require_helperNumberAdd();
    var toNumber = require_toNumber();
    function add(num1, num2) {
      return helperNumberAdd(toNumber(num1), toNumber(num2));
    }
    module.exports = add;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/subtract.js
var require_subtract = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/subtract.js"(exports, module) {
    var helperNumberDecimal = require_helperNumberDecimal();
    var toNumberString = require_toNumberString();
    var toNumber = require_toNumber();
    var toFixed = require_toFixed();
    function subtract(num1, num2) {
      var subtrahend = toNumber(num1);
      var minuend = toNumber(num2);
      var str1 = toNumberString(subtrahend);
      var str2 = toNumberString(minuend);
      var digit1 = helperNumberDecimal(str1);
      var digit2 = helperNumberDecimal(str2);
      var ratio = Math.pow(10, Math.max(digit1, digit2));
      var precision = digit1 >= digit2 ? digit1 : digit2;
      return parseFloat(toFixed((subtrahend * ratio - minuend * ratio) / ratio, precision));
    }
    module.exports = subtract;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNumberDivide.js
var require_helperNumberDivide = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperNumberDivide.js"(exports, module) {
    var helperNumberDecimal = require_helperNumberDecimal();
    var toNumberString = require_toNumberString();
    var multiply = require_multiply();
    function helperNumberDivide(divisor, dividend) {
      var str1 = toNumberString(divisor);
      var str2 = toNumberString(dividend);
      var divisorDecimal = helperNumberDecimal(str1);
      var dividendDecimal = helperNumberDecimal(str2);
      var powY = dividendDecimal - divisorDecimal;
      var isMinus = powY < 0;
      var multiplicand = Math.pow(10, isMinus ? Math.abs(powY) : powY);
      return multiply(str1.replace(".", "") / str2.replace(".", ""), isMinus ? 1 / multiplicand : multiplicand);
    }
    module.exports = helperNumberDivide;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/divide.js
var require_divide = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/divide.js"(exports, module) {
    var helperNumberDivide = require_helperNumberDivide();
    var toNumber = require_toNumber();
    function divide(num1, num2) {
      return helperNumberDivide(toNumber(num1), toNumber(num2));
    }
    module.exports = divide;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/sum.js
var require_sum = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/sum.js"(exports, module) {
    var helperNumberAdd = require_helperNumberAdd();
    var isFunction = require_isFunction();
    var isArray = require_isArray();
    var each = require_each();
    var get = require_get();
    function sum(array, iterate, context) {
      var result = 0;
      each(array && array.length > 2 && isArray(array) ? array.sort() : array, iterate ? isFunction(iterate) ? function() {
        result = helperNumberAdd(result, iterate.apply(context, arguments));
      } : function(val) {
        result = helperNumberAdd(result, get(val, iterate));
      } : function(val) {
        result = helperNumberAdd(result, val);
      });
      return result;
    }
    module.exports = sum;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/mean.js
var require_mean = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/mean.js"(exports, module) {
    var helperNumberDivide = require_helperNumberDivide();
    var getSize = require_getSize();
    var sum = require_sum();
    function mean(array, iterate, context) {
      return helperNumberDivide(sum(array, iterate, context), getSize(array));
    }
    module.exports = mean;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticStrFirst.js
var require_staticStrFirst = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticStrFirst.js"(exports, module) {
    var staticStrFirst = "first";
    module.exports = staticStrFirst;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticStrLast.js
var require_staticStrLast = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticStrLast.js"(exports, module) {
    var staticStrLast = "last";
    module.exports = staticStrLast;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetDateFullYear.js
var require_helperGetDateFullYear = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetDateFullYear.js"(exports, module) {
    function helperGetDateFullYear(date) {
      return date.getFullYear();
    }
    module.exports = helperGetDateFullYear;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticDayTime.js
var require_staticDayTime = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticDayTime.js"(exports, module) {
    var staticDayTime = 864e5;
    module.exports = staticDayTime;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetDateMonth.js
var require_helperGetDateMonth = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetDateMonth.js"(exports, module) {
    function helperGetDateMonth(date) {
      return date.getMonth();
    }
    module.exports = helperGetDateMonth;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isValidDate.js
var require_isValidDate = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isValidDate.js"(exports, module) {
    var isDate = require_isDate();
    var helperGetDateTime = require_helperGetDateTime();
    function isValidDate(val) {
      return isDate(val) && !isNaN(helperGetDateTime(val));
    }
    module.exports = isValidDate;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatMonth.js
var require_getWhatMonth = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatMonth.js"(exports, module) {
    var staticStrFirst = require_staticStrFirst();
    var staticStrLast = require_staticStrLast();
    var staticDayTime = require_staticDayTime();
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var helperGetDateTime = require_helperGetDateTime();
    var helperGetDateMonth = require_helperGetDateMonth();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var isNumber = require_isNumber();
    function getWhatMonth(date, offsetMonth, offsetDay) {
      var monthNum = offsetMonth && !isNaN(offsetMonth) ? offsetMonth : 0;
      date = toStringDate(date);
      if (isValidDate(date)) {
        if (offsetDay === staticStrFirst) {
          return new Date(helperGetDateFullYear(date), helperGetDateMonth(date) + monthNum, 1);
        } else if (offsetDay === staticStrLast) {
          return new Date(helperGetDateTime(getWhatMonth(date, monthNum + 1, staticStrFirst)) - 1);
        } else if (isNumber(offsetDay)) {
          date.setDate(offsetDay);
        }
        if (monthNum) {
          var currDate = date.getDate();
          date.setMonth(helperGetDateMonth(date) + monthNum);
          if (currDate !== date.getDate()) {
            date.setDate(1);
            return new Date(helperGetDateTime(date) - staticDayTime);
          }
        }
      }
      return date;
    }
    module.exports = getWhatMonth;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatYear.js
var require_getWhatYear = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatYear.js"(exports, module) {
    var staticStrFirst = require_staticStrFirst();
    var staticStrLast = require_staticStrLast();
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var getWhatMonth = require_getWhatMonth();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getWhatYear(date, offset, month) {
      var number;
      date = toStringDate(date);
      if (isValidDate(date)) {
        if (offset) {
          number = offset && !isNaN(offset) ? offset : 0;
          date.setFullYear(helperGetDateFullYear(date) + number);
        }
        if (month || !isNaN(month)) {
          if (month === staticStrFirst) {
            return new Date(helperGetDateFullYear(date), 0, 1);
          } else if (month === staticStrLast) {
            date.setMonth(11);
            return getWhatMonth(date, 0, staticStrLast);
          } else {
            date.setMonth(month);
          }
        }
      }
      return date;
    }
    module.exports = getWhatYear;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatQuarter.js
var require_getWhatQuarter = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatQuarter.js"(exports, module) {
    var getWhatMonth = require_getWhatMonth();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getQuarterNumber(date) {
      var month = date.getMonth();
      if (month < 3) {
        return 1;
      } else if (month < 6) {
        return 2;
      } else if (month < 9) {
        return 3;
      }
      return 4;
    }
    function getWhatQuarter(date, offset, day) {
      var currMonth, monthOffset = offset && !isNaN(offset) ? offset * 3 : 0;
      date = toStringDate(date);
      if (isValidDate(date)) {
        currMonth = (getQuarterNumber(date) - 1) * 3;
        date.setMonth(currMonth);
        return getWhatMonth(date, monthOffset, day);
      }
      return date;
    }
    module.exports = getWhatQuarter;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatDay.js
var require_getWhatDay = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatDay.js"(exports, module) {
    var staticStrFirst = require_staticStrFirst();
    var staticStrLast = require_staticStrLast();
    var staticParseInt = require_staticParseInt();
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var helperGetDateMonth = require_helperGetDateMonth();
    var helperGetDateTime = require_helperGetDateTime();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getWhatDay(date, offset, mode) {
      date = toStringDate(date);
      if (isValidDate(date) && !isNaN(offset)) {
        date.setDate(date.getDate() + staticParseInt(offset));
        if (mode === staticStrFirst) {
          return new Date(helperGetDateFullYear(date), helperGetDateMonth(date), date.getDate());
        } else if (mode === staticStrLast) {
          return new Date(helperGetDateTime(getWhatDay(date, 1, staticStrFirst)) - 1);
        }
      }
      return date;
    }
    module.exports = getWhatDay;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperStringUpperCase.js
var require_helperStringUpperCase = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperStringUpperCase.js"(exports, module) {
    function helperStringUpperCase(str) {
      return str.toUpperCase();
    }
    module.exports = helperStringUpperCase;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticWeekTime.js
var require_staticWeekTime = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticWeekTime.js"(exports, module) {
    var staticDayTime = require_staticDayTime();
    var staticWeekTime = staticDayTime * 7;
    module.exports = staticWeekTime;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatWeek.js
var require_getWhatWeek = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getWhatWeek.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var staticDayTime = require_staticDayTime();
    var staticWeekTime = require_staticWeekTime();
    var helperGetDateTime = require_helperGetDateTime();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var isNumber = require_isNumber();
    function getWhatWeek(date, offsetWeek, offsetDay, firstDay) {
      date = toStringDate(date);
      if (isValidDate(date)) {
        var hasCustomDay = isNumber(offsetDay);
        var hasStartDay = isNumber(firstDay);
        var whatDayTime = helperGetDateTime(date);
        if (hasCustomDay || hasStartDay) {
          var viewStartDay = hasStartDay ? firstDay : setupDefaults.firstDayOfWeek;
          var currentDay = date.getDay();
          var customDay = hasCustomDay ? offsetDay : currentDay;
          if (currentDay !== customDay) {
            var offsetNum = 0;
            if (viewStartDay > currentDay) {
              offsetNum = -(7 - viewStartDay + currentDay);
            } else if (viewStartDay < currentDay) {
              offsetNum = viewStartDay - currentDay;
            }
            if (customDay > viewStartDay) {
              whatDayTime += ((customDay === 0 ? 7 : customDay) - viewStartDay + offsetNum) * staticDayTime;
            } else if (customDay < viewStartDay) {
              whatDayTime += (7 - viewStartDay + customDay + offsetNum) * staticDayTime;
            } else {
              whatDayTime += offsetNum * staticDayTime;
            }
          }
        }
        if (offsetWeek && !isNaN(offsetWeek)) {
          whatDayTime += offsetWeek * staticWeekTime;
        }
        return new Date(whatDayTime);
      }
      return date;
    }
    module.exports = getWhatWeek;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateGetDateWeek.js
var require_helperCreateGetDateWeek = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperCreateGetDateWeek.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var staticDayTime = require_staticDayTime();
    var staticWeekTime = require_staticWeekTime();
    var isNumber = require_isNumber();
    var includes = require_includes();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var getWhatWeek = require_getWhatWeek();
    var range = require_range();
    var map = require_map();
    var helperGetDateTime = require_helperGetDateTime();
    var nextStartMaps = map(range(0, 7), function(day) {
      return [(day + 1) % 7, (day + 2) % 7, (day + 3) % 7];
    });
    function matchWeekStartDay(time, viewStartDay) {
      var day = new Date(time).getDay();
      return includes(nextStartMaps[viewStartDay], day);
    }
    function helperCreateGetDateWeek(getStartDate, checkCrossDate) {
      return function(date, firstDay) {
        var viewStartDay = isNumber(firstDay) ? firstDay : setupDefaults.firstDayOfWeek;
        var targetDate = toStringDate(date);
        if (isValidDate(targetDate)) {
          var targetWeekStartDate = getWhatWeek(targetDate, 0, viewStartDay, viewStartDay);
          var firstDate = getStartDate(targetWeekStartDate);
          var firstTime = helperGetDateTime(firstDate);
          var targetWeekStartTime = helperGetDateTime(targetWeekStartDate);
          var targetWeekEndTime = targetWeekStartTime + staticDayTime * 6;
          var targetWeekEndDate = new Date(targetWeekEndTime);
          var firstWeekStartDate = getWhatWeek(firstDate, 0, viewStartDay, viewStartDay);
          var firstWeekStartTime = helperGetDateTime(firstWeekStartDate);
          var tempTime;
          if (targetWeekStartTime === firstWeekStartTime) {
            return 1;
          }
          if (checkCrossDate(targetWeekStartDate, targetWeekEndDate)) {
            tempTime = helperGetDateTime(getStartDate(targetWeekEndDate));
            for (; tempTime < targetWeekEndTime; tempTime += staticDayTime) {
              if (matchWeekStartDay(tempTime, viewStartDay)) {
                return 1;
              }
            }
          }
          var firstWeekEndTime = firstWeekStartTime + staticDayTime * 6;
          var firstWeekEndDate = new Date(targetWeekEndTime);
          var offsetNum = 1;
          if (checkCrossDate(firstWeekStartDate, firstWeekEndDate)) {
            offsetNum = 0;
            tempTime = firstTime;
            for (; tempTime < firstWeekEndTime; tempTime += staticDayTime) {
              if (matchWeekStartDay(tempTime, viewStartDay)) {
                offsetNum++;
                break;
              }
            }
          }
          return Math.floor((targetWeekStartTime - firstWeekStartTime) / staticWeekTime) + offsetNum;
        }
        return NaN;
      };
    }
    module.exports = helperCreateGetDateWeek;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getYearWeek.js
var require_getYearWeek = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getYearWeek.js"(exports, module) {
    var helperCreateGetDateWeek = require_helperCreateGetDateWeek();
    var getYearWeek = helperCreateGetDateWeek(function(targetDate) {
      return new Date(targetDate.getFullYear(), 0, 1);
    }, function(date1, date2) {
      return date1.getFullYear() !== date2.getFullYear();
    });
    module.exports = getYearWeek;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetYMD.js
var require_helperGetYMD = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetYMD.js"(exports, module) {
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var helperGetDateMonth = require_helperGetDateMonth();
    function helperGetYMD(date) {
      return new Date(helperGetDateFullYear(date), helperGetDateMonth(date), date.getDate());
    }
    module.exports = helperGetYMD;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetYMDTime.js
var require_helperGetYMDTime = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetYMDTime.js"(exports, module) {
    var helperGetDateTime = require_helperGetDateTime();
    var helperGetYMD = require_helperGetYMD();
    function helperGetYMDTime(date) {
      return helperGetDateTime(helperGetYMD(date));
    }
    module.exports = helperGetYMDTime;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getYearDay.js
var require_getYearDay = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getYearDay.js"(exports, module) {
    var staticDayTime = require_staticDayTime();
    var staticStrFirst = require_staticStrFirst();
    var helperGetYMDTime = require_helperGetYMDTime();
    var getWhatYear = require_getWhatYear();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getYearDay(date) {
      date = toStringDate(date);
      if (isValidDate(date)) {
        return Math.floor((helperGetYMDTime(date) - helperGetYMDTime(getWhatYear(date, 0, staticStrFirst))) / staticDayTime) + 1;
      }
      return NaN;
    }
    module.exports = getYearDay;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/padStart.js
var require_padStart = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/padStart.js"(exports, module) {
    var toValueString = require_toValueString();
    var isUndefined = require_isUndefined();
    var helperStringRepeat = require_helperStringRepeat();
    function padStart(str, targetLength, padString) {
      var rest = toValueString(str);
      targetLength = targetLength >> 0;
      padString = isUndefined(padString) ? " " : "" + padString;
      if (rest.padStart) {
        return rest.padStart(targetLength, padString);
      }
      if (targetLength > rest.length) {
        targetLength -= rest.length;
        if (targetLength > padString.length) {
          padString += helperStringRepeat(padString, targetLength / padString.length);
        }
        return padString.slice(0, targetLength) + rest;
      }
      return rest;
    }
    module.exports = padStart;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toDateString.js
var require_toDateString = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toDateString.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var helperStringUpperCase = require_helperStringUpperCase();
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var helperGetDateMonth = require_helperGetDateMonth();
    var toStringDate = require_toStringDate();
    var getYearWeek = require_getYearWeek();
    var getYearDay = require_getYearDay();
    var assign = require_assign();
    var isValidDate = require_isValidDate();
    var isFunction = require_isFunction();
    var padStart = require_padStart();
    function handleCustomTemplate(date, formats2, match, value) {
      var format = formats2[match];
      if (format) {
        if (isFunction(format)) {
          return format(value, match, date);
        } else {
          return format[value];
        }
      }
      return value;
    }
    var dateFormatRE = /\[([^\]]+)]|y{2,4}|M{1,2}|d{1,2}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|S{1,3}|Z{1,2}|W{1,2}|D{1,3}|[aAeEq]/g;
    function toDateString(date, format, options) {
      if (date) {
        date = toStringDate(date);
        if (isValidDate(date)) {
          var result = format || setupDefaults.parseDateFormat || setupDefaults.formatString;
          var hours = date.getHours();
          var apm = hours < 12 ? "am" : "pm";
          var formats2 = assign({}, setupDefaults.parseDateRules || setupDefaults.formatStringMatchs, options ? options.formats : null);
          var fy = function(match, length) {
            return ("" + helperGetDateFullYear(date)).substr(4 - length);
          };
          var fM = function(match, length) {
            return padStart(helperGetDateMonth(date) + 1, length, "0");
          };
          var fd = function(match, length) {
            return padStart(date.getDate(), length, "0");
          };
          var fH = function(match, length) {
            return padStart(hours, length, "0");
          };
          var fh = function(match, length) {
            return padStart(hours <= 12 ? hours : hours - 12, length, "0");
          };
          var fm = function(match, length) {
            return padStart(date.getMinutes(), length, "0");
          };
          var fs = function(match, length) {
            return padStart(date.getSeconds(), length, "0");
          };
          var fS = function(match, length) {
            return padStart(date.getMilliseconds(), length, "0");
          };
          var fZ = function(match, length) {
            var zoneHours = date.getTimezoneOffset() / 60 * -1;
            return handleCustomTemplate(date, formats2, match, (zoneHours >= 0 ? "+" : "-") + padStart(zoneHours, 2, "0") + (length === 1 ? ":" : "") + "00");
          };
          var fW = function(match, length) {
            return padStart(handleCustomTemplate(date, formats2, match, getYearWeek(date, (options ? options.firstDay : null) || setupDefaults.firstDayOfWeek)), length, "0");
          };
          var fD = function(match, length) {
            return padStart(handleCustomTemplate(date, formats2, match, getYearDay(date)), length, "0");
          };
          var parseDates = {
            yyyy: fy,
            yy: fy,
            MM: fM,
            M: fM,
            dd: fd,
            d: fd,
            HH: fH,
            H: fH,
            hh: fh,
            h: fh,
            mm: fm,
            m: fm,
            ss: fs,
            s: fs,
            SSS: fS,
            S: fS,
            ZZ: fZ,
            Z: fZ,
            WW: fW,
            W: fW,
            DDD: fD,
            D: fD,
            a: function(match) {
              return handleCustomTemplate(date, formats2, match, apm);
            },
            A: function(match) {
              return handleCustomTemplate(date, formats2, match, helperStringUpperCase(apm));
            },
            e: function(match) {
              return handleCustomTemplate(date, formats2, match, date.getDay());
            },
            E: function(match) {
              return handleCustomTemplate(date, formats2, match, date.getDay());
            },
            q: function(match) {
              return handleCustomTemplate(date, formats2, match, Math.floor((helperGetDateMonth(date) + 3) / 3));
            }
          };
          return result.replace(dateFormatRE, function(match, skip) {
            return skip || (parseDates[match] ? parseDates[match](match, match.length) : match);
          });
        }
        return "Invalid Date";
      }
      return "";
    }
    module.exports = toDateString;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/now.js
var require_now = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/now.js"(exports, module) {
    var helperGetDateTime = require_helperGetDateTime();
    var helperNewDate = require_helperNewDate();
    var now = Date.now || function() {
      return helperGetDateTime(helperNewDate());
    };
    module.exports = now;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/timestamp.js"(exports, module) {
    var helperGetDateTime = require_helperGetDateTime();
    var now = require_now();
    var toStringDate = require_toStringDate();
    var isDate = require_isDate();
    var timestamp = function(str, format) {
      if (str) {
        var date = toStringDate(str, format);
        return isDate(date) ? helperGetDateTime(date) : date;
      }
      return now();
    };
    module.exports = timestamp;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isDateSame.js
var require_isDateSame = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/isDateSame.js"(exports, module) {
    var toDateString = require_toDateString();
    function isDateSame(date1, date2, format) {
      if (date1 && date2) {
        date1 = toDateString(date1, format);
        return date1 !== "Invalid Date" && date1 === toDateString(date2, format);
      }
      return false;
    }
    module.exports = isDateSame;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getMonthWeek.js
var require_getMonthWeek = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getMonthWeek.js"(exports, module) {
    var helperCreateGetDateWeek = require_helperCreateGetDateWeek();
    var getMonthWeek = helperCreateGetDateWeek(function(targetDate) {
      return new Date(targetDate.getFullYear(), targetDate.getMonth(), 1);
    }, function(date1, date2) {
      return date1.getMonth() !== date2.getMonth();
    });
    module.exports = getMonthWeek;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getDayOfYear.js
var require_getDayOfYear = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getDayOfYear.js"(exports, module) {
    var getWhatYear = require_getWhatYear();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var isLeapYear = require_isLeapYear();
    function getDayOfYear(date, year) {
      date = toStringDate(date);
      if (isValidDate(date)) {
        return isLeapYear(getWhatYear(date, year)) ? 366 : 365;
      }
      return NaN;
    }
    module.exports = getDayOfYear;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getDayOfMonth.js
var require_getDayOfMonth = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getDayOfMonth.js"(exports, module) {
    var staticDayTime = require_staticDayTime();
    var staticStrFirst = require_staticStrFirst();
    var staticStrLast = require_staticStrLast();
    var helperGetDateTime = require_helperGetDateTime();
    var getWhatMonth = require_getWhatMonth();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getDayOfMonth(date, month) {
      date = toStringDate(date);
      if (isValidDate(date)) {
        return Math.floor((helperGetDateTime(getWhatMonth(date, month, staticStrLast)) - helperGetDateTime(getWhatMonth(date, month, staticStrFirst))) / staticDayTime) + 1;
      }
      return NaN;
    }
    module.exports = getDayOfMonth;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getDateDiff.js
var require_getDateDiff = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getDateDiff.js"(exports, module) {
    var helperGetDateTime = require_helperGetDateTime();
    var helperNewDate = require_helperNewDate();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var dateDiffRules = [
      ["yyyy", 31536e6],
      ["MM", 2592e6],
      ["dd", 864e5],
      ["HH", 36e5],
      ["mm", 6e4],
      ["ss", 1e3],
      ["S", 0]
    ];
    function getDateDiff(startDate, endDate) {
      var startTime, endTime, item, diffTime, len, index;
      var result = { done: false, time: 0 };
      startDate = toStringDate(startDate);
      endDate = endDate ? toStringDate(endDate) : helperNewDate();
      if (isValidDate(startDate) && isValidDate(endDate)) {
        startTime = helperGetDateTime(startDate);
        endTime = helperGetDateTime(endDate);
        if (startTime < endTime) {
          diffTime = result.time = endTime - startTime;
          result.done = true;
          for (index = 0, len = dateDiffRules.length; index < len; index++) {
            item = dateDiffRules[index];
            if (diffTime >= item[1]) {
              if (index === len - 1) {
                result[item[0]] = diffTime || 0;
              } else {
                result[item[0]] = Math.floor(diffTime / item[1]);
                diffTime -= result[item[0]] * item[1];
              }
            } else {
              result[item[0]] = 0;
            }
          }
        }
      }
      return result;
    }
    module.exports = getDateDiff;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/padEnd.js
var require_padEnd = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/padEnd.js"(exports, module) {
    var toValueString = require_toValueString();
    var isUndefined = require_isUndefined();
    var helperStringRepeat = require_helperStringRepeat();
    function padEnd(str, targetLength, padString) {
      var rest = toValueString(str);
      targetLength = targetLength >> 0;
      padString = isUndefined(padString) ? " " : "" + padString;
      if (rest.padEnd) {
        return rest.padEnd(targetLength, padString);
      }
      if (targetLength > rest.length) {
        targetLength -= rest.length;
        if (targetLength > padString.length) {
          padString += helperStringRepeat(padString, targetLength / padString.length);
        }
        return rest + padString.slice(0, targetLength);
      }
      return rest;
    }
    module.exports = padEnd;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/repeat.js
var require_repeat = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/repeat.js"(exports, module) {
    var toValueString = require_toValueString();
    var helperStringRepeat = require_helperStringRepeat();
    function repeat(str, count) {
      return helperStringRepeat(toValueString(str), count);
    }
    module.exports = repeat;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/trimRight.js
var require_trimRight = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/trimRight.js"(exports, module) {
    var toValueString = require_toValueString();
    function trimRight(str) {
      return str && str.trimRight ? str.trimRight() : toValueString(str).replace(/[\s\uFEFF\xA0]+$/g, "");
    }
    module.exports = trimRight;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/trimLeft.js
var require_trimLeft = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/trimLeft.js"(exports, module) {
    var toValueString = require_toValueString();
    function trimLeft(str) {
      return str && str.trimLeft ? str.trimLeft() : toValueString(str).replace(/^[\s\uFEFF\xA0]+/g, "");
    }
    module.exports = trimLeft;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/trim.js
var require_trim = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/trim.js"(exports, module) {
    var trimRight = require_trimRight();
    var trimLeft = require_trimLeft();
    function trim(str) {
      return str && str.trim ? str.trim() : trimRight(trimLeft(str));
    }
    module.exports = trim;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticEscapeMap.js
var require_staticEscapeMap = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticEscapeMap.js"(exports, module) {
    var staticEscapeMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;"
    };
    module.exports = staticEscapeMap;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperFormatEscaper.js
var require_helperFormatEscaper = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperFormatEscaper.js"(exports, module) {
    var toValueString = require_toValueString();
    var keys = require_keys();
    function helperFormatEscaper(dataMap) {
      var replaceRegexp = new RegExp("(?:" + keys(dataMap).join("|") + ")", "g");
      return function(str) {
        return toValueString(str).replace(replaceRegexp, function(match) {
          return dataMap[match];
        });
      };
    }
    module.exports = helperFormatEscaper;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/escape.js
var require_escape = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/escape.js"(exports, module) {
    var staticEscapeMap = require_staticEscapeMap();
    var helperFormatEscaper = require_helperFormatEscaper();
    var escape = helperFormatEscaper(staticEscapeMap);
    module.exports = escape;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/unescape.js
var require_unescape = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/unescape.js"(exports, module) {
    var staticEscapeMap = require_staticEscapeMap();
    var helperFormatEscaper = require_helperFormatEscaper();
    var each = require_each();
    var unescapeMap = {};
    each(staticEscapeMap, function(item, key) {
      unescapeMap[staticEscapeMap[key]] = key;
    });
    var unescape = helperFormatEscaper(unescapeMap);
    module.exports = unescape;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperStringSubstring.js
var require_helperStringSubstring = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperStringSubstring.js"(exports, module) {
    function helperStringSubstring(str, start, end) {
      return str.substring(start, end);
    }
    module.exports = helperStringSubstring;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperStringLowerCase.js
var require_helperStringLowerCase = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperStringLowerCase.js"(exports, module) {
    function helperStringLowerCase(str) {
      return str.toLowerCase();
    }
    module.exports = helperStringLowerCase;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/camelCase.js
var require_camelCase = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/camelCase.js"(exports, module) {
    var toValueString = require_toValueString();
    var helperStringSubstring = require_helperStringSubstring();
    var helperStringUpperCase = require_helperStringUpperCase();
    var helperStringLowerCase = require_helperStringLowerCase();
    var camelCacheMaps = {};
    function camelCase(str) {
      str = toValueString(str);
      if (camelCacheMaps[str]) {
        return camelCacheMaps[str];
      }
      var strLen = str.length;
      var rest = str.replace(/([-]+)/g, function(text, flag, index) {
        return index && index + flag.length < strLen ? "-" : "";
      });
      strLen = rest.length;
      rest = rest.replace(/([A-Z]+)/g, function(text, upper, index) {
        var upperLen = upper.length;
        upper = helperStringLowerCase(upper);
        if (index) {
          if (upperLen > 2 && index + upperLen < strLen) {
            return helperStringUpperCase(helperStringSubstring(upper, 0, 1)) + helperStringSubstring(upper, 1, upperLen - 1) + helperStringUpperCase(helperStringSubstring(upper, upperLen - 1, upperLen));
          }
          return helperStringUpperCase(helperStringSubstring(upper, 0, 1)) + helperStringSubstring(upper, 1, upperLen);
        } else {
          if (upperLen > 1 && index + upperLen < strLen) {
            return helperStringSubstring(upper, 0, upperLen - 1) + helperStringUpperCase(helperStringSubstring(upper, upperLen - 1, upperLen));
          }
        }
        return upper;
      }).replace(/(-[a-zA-Z])/g, function(text, upper) {
        return helperStringUpperCase(helperStringSubstring(upper, 1, upper.length));
      });
      camelCacheMaps[str] = rest;
      return rest;
    }
    module.exports = camelCase;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/kebabCase.js
var require_kebabCase = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/kebabCase.js"(exports, module) {
    var toValueString = require_toValueString();
    var helperStringSubstring = require_helperStringSubstring();
    var helperStringLowerCase = require_helperStringLowerCase();
    var kebabCacheMaps = {};
    function kebabCase(str) {
      str = toValueString(str);
      if (kebabCacheMaps[str]) {
        return kebabCacheMaps[str];
      }
      if (/^[A-Z]+$/.test(str)) {
        return helperStringLowerCase(str);
      }
      var rest = str.replace(/^([a-z])([A-Z]+)([a-z]+)$/, function(text, prevLower, upper, nextLower) {
        var upperLen = upper.length;
        if (upperLen > 1) {
          return prevLower + "-" + helperStringLowerCase(helperStringSubstring(upper, 0, upperLen - 1)) + "-" + helperStringLowerCase(helperStringSubstring(upper, upperLen - 1, upperLen)) + nextLower;
        }
        return helperStringLowerCase(prevLower + "-" + upper + nextLower);
      }).replace(/^([A-Z]+)([a-z]+)?$/, function(text, upper, nextLower) {
        var upperLen = upper.length;
        return helperStringLowerCase(helperStringSubstring(upper, 0, upperLen - 1) + "-" + helperStringSubstring(upper, upperLen - 1, upperLen) + (nextLower || ""));
      }).replace(/([a-z]?)([A-Z]+)([a-z]?)/g, function(text, prevLower, upper, nextLower, index) {
        var upperLen = upper.length;
        if (upperLen > 1) {
          if (prevLower) {
            prevLower += "-";
          }
          if (nextLower) {
            return (prevLower || "") + helperStringLowerCase(helperStringSubstring(upper, 0, upperLen - 1)) + "-" + helperStringLowerCase(helperStringSubstring(upper, upperLen - 1, upperLen)) + nextLower;
          }
        }
        return (prevLower || "") + (index ? "-" : "") + helperStringLowerCase(upper) + (nextLower || "");
      });
      rest = rest.replace(/([-]+)/g, function(text, flag, index) {
        return index && index + flag.length < rest.length ? "-" : "";
      });
      kebabCacheMaps[str] = rest;
      return rest;
    }
    module.exports = kebabCase;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/startsWith.js
var require_startsWith = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/startsWith.js"(exports, module) {
    var toValueString = require_toValueString();
    function startsWith(str, val, startIndex) {
      var rest = toValueString(str);
      return (arguments.length === 1 ? rest : rest.substring(startIndex)).indexOf(val) === 0;
    }
    module.exports = startsWith;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/endsWith.js
var require_endsWith = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/endsWith.js"(exports, module) {
    var toValueString = require_toValueString();
    function endsWith(str, val, startIndex) {
      var rest = toValueString(str);
      var argsLen = arguments.length;
      return argsLen > 1 && (argsLen > 2 ? rest.substring(0, startIndex).indexOf(val) === startIndex - 1 : rest.indexOf(val) === rest.length - 1);
    }
    module.exports = endsWith;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/template.js
var require_template = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/template.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var toValueString = require_toValueString();
    var trim = require_trim();
    var get = require_get();
    function template(str, args, options) {
      return toValueString(str).replace((options || setupDefaults).tmplRE || /\{{2}([.\w[\]\s]+)\}{2}/g, function(match, key) {
        return get(args, trim(key));
      });
    }
    module.exports = template;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toFormatString.js
var require_toFormatString = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/toFormatString.js"(exports, module) {
    var template = require_template();
    function toFormatString(str, obj) {
      return template(str, obj, { tmplRE: /\{([.\w[\]\s]+)\}/g });
    }
    module.exports = toFormatString;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/noop.js
var require_noop = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/noop.js"(exports, module) {
    function noop() {
    }
    module.exports = noop;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/bind.js
var require_bind = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/bind.js"(exports, module) {
    var slice = require_slice();
    function bind(callback, context) {
      var args = slice(arguments, 2);
      return function() {
        return callback.apply(context, slice(arguments).concat(args));
      };
    }
    module.exports = bind;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/once.js
var require_once = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/once.js"(exports, module) {
    var slice = require_slice();
    function once(callback, context) {
      var done = false;
      var rest = null;
      var args = slice(arguments, 2);
      return function() {
        if (done) {
          return rest;
        }
        rest = callback.apply(context, slice(arguments).concat(args));
        done = true;
        return rest;
      };
    }
    module.exports = once;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/after.js
var require_after = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/after.js"(exports, module) {
    var slice = require_slice();
    function after(count, callback, context) {
      var runCount = 0;
      var rests = [];
      return function() {
        var args = arguments;
        runCount++;
        if (runCount <= count) {
          rests.push(args[0]);
        }
        if (runCount >= count) {
          callback.apply(context, [rests].concat(slice(args)));
        }
      };
    }
    module.exports = after;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/before.js
var require_before = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/before.js"(exports, module) {
    var slice = require_slice();
    function before(count, callback, context) {
      var runCount = 0;
      var rests = [];
      context = context || this;
      return function() {
        var args = arguments;
        runCount++;
        if (runCount < count) {
          rests.push(args[0]);
          callback.apply(context, [rests].concat(slice(args)));
        }
      };
    }
    module.exports = before;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/throttle.js
var require_throttle = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/throttle.js"(exports, module) {
    function throttle(callback, wait, options) {
      var args = null;
      var context = null;
      var opts = options || {};
      var runFlag = false;
      var timeout = null;
      var optLeading = "leading" in opts ? opts.leading : true;
      var optTrailing = "trailing" in opts ? opts.trailing : false;
      var gcFn = function() {
        args = null;
        context = null;
      };
      var runFn = function() {
        runFlag = true;
        callback.apply(context, args);
        timeout = setTimeout(endFn, wait);
        gcFn();
      };
      var endFn = function() {
        timeout = null;
        if (!runFlag && optTrailing === true) {
          runFn();
        }
      };
      var cancelFn = function() {
        var rest = timeout !== null;
        if (rest) {
          clearTimeout(timeout);
        }
        gcFn();
        timeout = null;
        runFlag = false;
        return rest;
      };
      var throttled = function() {
        args = arguments;
        context = this;
        runFlag = false;
        if (timeout === null) {
          if (optLeading === true) {
            runFn();
          } else if (optTrailing === true) {
            timeout = setTimeout(endFn, wait);
          }
        }
      };
      throttled.cancel = cancelFn;
      return throttled;
    }
    module.exports = throttle;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/debounce.js
var require_debounce = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/debounce.js"(exports, module) {
    function debounce(callback, wait, options) {
      var args = null;
      var context = null;
      var opts = options || {};
      var runFlag = false;
      var timeout = null;
      var isLeading = typeof options === "boolean";
      var optLeading = "leading" in opts ? opts.leading : isLeading;
      var optTrailing = "trailing" in opts ? opts.trailing : !isLeading;
      var gcFn = function() {
        args = null;
        context = null;
      };
      var runFn = function() {
        runFlag = true;
        callback.apply(context, args);
        gcFn();
      };
      var endFn = function() {
        if (optLeading === true) {
          timeout = null;
        }
        if (!runFlag && optTrailing === true) {
          runFn();
        }
      };
      var cancelFn = function() {
        var rest = timeout !== null;
        if (rest) {
          clearTimeout(timeout);
        }
        gcFn();
        timeout = null;
        runFlag = false;
        return rest;
      };
      var debounced = function() {
        runFlag = false;
        args = arguments;
        context = this;
        if (timeout === null) {
          if (optLeading === true) {
            runFn();
          }
        } else {
          clearTimeout(timeout);
        }
        timeout = setTimeout(endFn, wait);
      };
      debounced.cancel = cancelFn;
      return debounced;
    }
    module.exports = debounce;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/delay.js
var require_delay = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/delay.js"(exports, module) {
    var slice = require_slice();
    function delay(callback, wait) {
      var args = slice(arguments, 2);
      var context = this;
      return setTimeout(function() {
        callback.apply(context, args);
      }, wait);
    }
    module.exports = delay;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticDecodeURIComponent.js
var require_staticDecodeURIComponent = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticDecodeURIComponent.js"(exports, module) {
    var staticDecodeURIComponent = decodeURIComponent;
    module.exports = staticDecodeURIComponent;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/unserialize.js
var require_unserialize = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/unserialize.js"(exports, module) {
    var staticDecodeURIComponent = require_staticDecodeURIComponent();
    var arrayEach = require_arrayEach();
    var isString = require_isString();
    function unserialize(str) {
      var items;
      var result = {};
      if (str && isString(str)) {
        arrayEach(str.split("&"), function(param) {
          items = param.split("=");
          result[staticDecodeURIComponent(items[0])] = staticDecodeURIComponent(items[1] || "");
        });
      }
      return result;
    }
    module.exports = unserialize;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticEncodeURIComponent.js
var require_staticEncodeURIComponent = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticEncodeURIComponent.js"(exports, module) {
    var staticEncodeURIComponent = encodeURIComponent;
    module.exports = staticEncodeURIComponent;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/serialize.js
var require_serialize = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/serialize.js"(exports, module) {
    var staticEncodeURIComponent = require_staticEncodeURIComponent();
    var each = require_each();
    var isArray = require_isArray();
    var isNull = require_isNull();
    var isUndefined = require_isUndefined();
    var isPlainObject = require_isPlainObject();
    function stringifyParams(resultVal, resultKey, isArr) {
      var _arr;
      var result = [];
      each(resultVal, function(item, key) {
        _arr = isArray(item);
        if (isPlainObject(item) || _arr) {
          result = result.concat(stringifyParams(item, resultKey + "[" + key + "]", _arr));
        } else {
          result.push(staticEncodeURIComponent(resultKey + "[" + (isArr ? "" : key) + "]") + "=" + staticEncodeURIComponent(isNull(item) ? "" : item));
        }
      });
      return result;
    }
    function serialize(query) {
      var _arr;
      var params = [];
      each(query, function(item, key) {
        if (!isUndefined(item)) {
          _arr = isArray(item);
          if (isPlainObject(item) || _arr) {
            params = params.concat(stringifyParams(item, key, _arr));
          } else {
            params.push(staticEncodeURIComponent(key) + "=" + staticEncodeURIComponent(isNull(item) ? "" : item));
          }
        }
      });
      return params.join("&").replace(/%20/g, "+");
    }
    module.exports = serialize;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticLocation.js
var require_staticLocation = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/staticLocation.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var staticLocation = typeof location === staticStrUndefined ? 0 : location;
    module.exports = staticLocation;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetLocatOrigin.js
var require_helperGetLocatOrigin = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/helperGetLocatOrigin.js"(exports, module) {
    var staticLocation = require_staticLocation();
    function helperGetLocatOrigin() {
      return staticLocation ? staticLocation.origin || staticLocation.protocol + "//" + staticLocation.host : "";
    }
    module.exports = helperGetLocatOrigin;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/parseUrl.js
var require_parseUrl = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/parseUrl.js"(exports, module) {
    var staticLocation = require_staticLocation();
    var unserialize = require_unserialize();
    var helperGetLocatOrigin = require_helperGetLocatOrigin();
    function parseURLQuery(uri) {
      return unserialize(uri.split("?")[1] || "");
    }
    function parseUrl(url) {
      var hashs, portText, searchs, parsed;
      var href = "" + url;
      if (href.indexOf("//") === 0) {
        href = (staticLocation ? staticLocation.protocol : "") + href;
      } else if (href.indexOf("/") === 0) {
        href = helperGetLocatOrigin() + href;
      }
      searchs = href.replace(/#.*/, "").match(/(\?.*)/);
      parsed = {
        href,
        hash: "",
        host: "",
        hostname: "",
        protocol: "",
        port: "",
        search: searchs && searchs[1] && searchs[1].length > 1 ? searchs[1] : ""
      };
      parsed.path = href.replace(/^([a-z0-9.+-]*:)\/\//, function(text, protocol) {
        parsed.protocol = protocol;
        return "";
      }).replace(/^([a-z0-9.+-]*)(:\d+)?\/?/, function(text, hostname, port) {
        portText = port || "";
        parsed.port = portText.replace(":", "");
        parsed.hostname = hostname;
        parsed.host = hostname + portText;
        return "/";
      }).replace(/(#.*)/, function(text, hash) {
        parsed.hash = hash.length > 1 ? hash : "";
        return "";
      });
      hashs = parsed.hash.match(/#((.*)\?|(.*))/);
      parsed.pathname = parsed.path.replace(/(\?|#.*).*/, "");
      parsed.origin = parsed.protocol + "//" + parsed.host;
      parsed.hashKey = hashs ? hashs[2] || hashs[1] || "" : "";
      parsed.hashQuery = parseURLQuery(parsed.hash);
      parsed.searchQuery = parseURLQuery(parsed.search);
      return parsed;
    }
    module.exports = parseUrl;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getBaseURL.js
var require_getBaseURL = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/getBaseURL.js"(exports, module) {
    var staticLocation = require_staticLocation();
    var helperGetLocatOrigin = require_helperGetLocatOrigin();
    var lastIndexOf = require_lastIndexOf();
    function getBaseURL() {
      if (staticLocation) {
        var pathname = staticLocation.pathname;
        var lastIndex = lastIndexOf(pathname, "/") + 1;
        return helperGetLocatOrigin() + (lastIndex === pathname.length ? pathname : pathname.substring(0, lastIndex));
      }
      return "";
    }
    module.exports = getBaseURL;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/locat.js
var require_locat = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/locat.js"(exports, module) {
    var staticLocation = require_staticLocation();
    var parseUrl = require_parseUrl();
    function locat() {
      return staticLocation ? parseUrl(staticLocation.href) : {};
    }
    module.exports = locat;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/cookie.js
var require_cookie = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/cookie.js"(exports, module) {
    var setupDefaults = require_setupDefaults();
    var staticDocument = require_staticDocument();
    var staticDecodeURIComponent = require_staticDecodeURIComponent();
    var staticEncodeURIComponent = require_staticEncodeURIComponent();
    var isArray = require_isArray();
    var isObject = require_isObject();
    var isDate = require_isDate();
    var isUndefined = require_isUndefined();
    var includes = require_includes();
    var keys = require_keys();
    var assign = require_assign();
    var arrayEach = require_arrayEach();
    var helperNewDate = require_helperNewDate();
    var helperGetDateTime = require_helperGetDateTime();
    var getWhatYear = require_getWhatYear();
    var getWhatMonth = require_getWhatMonth();
    var getWhatDay = require_getWhatDay();
    function toCookieUnitTime(unit, expires) {
      var num = parseFloat(expires);
      var nowdate = helperNewDate();
      var time = helperGetDateTime(nowdate);
      switch (unit) {
        case "y":
          return helperGetDateTime(getWhatYear(nowdate, num));
        case "M":
          return helperGetDateTime(getWhatMonth(nowdate, num));
        case "d":
          return helperGetDateTime(getWhatDay(nowdate, num));
        case "h":
        case "H":
          return time + num * 60 * 60 * 1e3;
        case "m":
          return time + num * 60 * 1e3;
        case "s":
          return time + num * 1e3;
      }
      return time;
    }
    function toCookieUTCString(date) {
      return (isDate(date) ? date : new Date(date)).toUTCString();
    }
    function cookie(name, value, options) {
      if (staticDocument) {
        var opts, expires, values, result, cookies, keyIndex;
        var inserts = [];
        var args = arguments;
        if (isArray(name)) {
          inserts = name;
        } else if (args.length > 1) {
          inserts = [assign({ name, value }, options)];
        } else if (isObject(name)) {
          inserts = [name];
        }
        if (inserts.length > 0) {
          arrayEach(inserts, function(obj) {
            opts = assign({}, setupDefaults.cookies, obj);
            values = [];
            if (opts.name) {
              expires = opts.expires;
              values.push(staticEncodeURIComponent(opts.name) + "=" + staticEncodeURIComponent(isObject(opts.value) ? JSON.stringify(opts.value) : opts.value));
              if (expires) {
                if (isNaN(expires)) {
                  expires = expires.replace(/^([0-9]+)(y|M|d|H|h|m|s)$/, function(text, num, unit) {
                    return toCookieUTCString(toCookieUnitTime(unit, num));
                  });
                } else if (/^[0-9]{11,13}$/.test(expires) || isDate(expires)) {
                  expires = toCookieUTCString(expires);
                } else {
                  expires = toCookieUTCString(toCookieUnitTime("d", expires));
                }
                opts.expires = expires;
              }
              arrayEach(["expires", "path", "domain", "secure"], function(key) {
                if (!isUndefined(opts[key])) {
                  values.push(opts[key] && key === "secure" ? key : key + "=" + opts[key]);
                }
              });
            }
            staticDocument.cookie = values.join("; ");
          });
          return true;
        } else {
          result = {};
          cookies = staticDocument.cookie;
          if (cookies) {
            arrayEach(cookies.split("; "), function(val) {
              keyIndex = val.indexOf("=");
              result[staticDecodeURIComponent(val.substring(0, keyIndex))] = staticDecodeURIComponent(val.substring(keyIndex + 1) || "");
            });
          }
          return args.length === 1 ? result[name] : result;
        }
      }
      return false;
    }
    function hasCookieItem(value) {
      return includes(cookieKeys(), value);
    }
    function getCookieItem(name) {
      return cookie(name);
    }
    function setCookieItem(name, value, options) {
      cookie(name, value, options);
      return cookie;
    }
    function removeCookieItem(name, options) {
      cookie(name, "", assign({ expires: -1 }, setupDefaults.cookies, options));
    }
    function cookieKeys() {
      return keys(cookie());
    }
    function cookieJson() {
      return cookie();
    }
    assign(cookie, {
      has: hasCookieItem,
      set: setCookieItem,
      setItem: setCookieItem,
      get: getCookieItem,
      getItem: getCookieItem,
      remove: removeCookieItem,
      removeItem: removeCookieItem,
      keys: cookieKeys,
      getJSON: cookieJson
    });
    module.exports = cookie;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/browse.js
var require_browse = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/browse.js"(exports, module) {
    var staticStrUndefined = require_staticStrUndefined();
    var staticDocument = require_staticDocument();
    var staticWindow = require_staticWindow();
    var assign = require_assign();
    var arrayEach = require_arrayEach();
    function isBrowseStorage(storage) {
      try {
        var testKey = "__xe_t";
        storage.setItem(testKey, 1);
        storage.removeItem(testKey);
        return true;
      } catch (e) {
        return false;
      }
    }
    function isBrowseType(type) {
      return navigator.userAgent.indexOf(type) > -1;
    }
    function browse2() {
      var $body, isChrome, isEdge;
      var isMobile = false;
      var isLocalStorage = false;
      var isSessionStorage = false;
      var result = {
        isNode: false,
        isMobile,
        isPC: false,
        isDoc: !!staticDocument
      };
      if (!staticWindow && typeof process !== staticStrUndefined) {
        result.isNode = true;
      } else {
        isEdge = isBrowseType("Edge");
        isChrome = isBrowseType("Chrome");
        isMobile = /(Android|webOS|iPhone|iPad|iPod|SymbianOS|BlackBerry|Windows Phone)/.test(navigator.userAgent);
        if (result.isDoc) {
          $body = staticDocument.body || staticDocument.documentElement;
          arrayEach(["webkit", "khtml", "moz", "ms", "o"], function(core) {
            result["-" + core] = !!$body[core + "MatchesSelector"];
          });
        }
        try {
          isLocalStorage = isBrowseStorage(staticWindow.localStorage);
        } catch (e) {
        }
        try {
          isSessionStorage = isBrowseStorage(staticWindow.sessionStorage);
        } catch (e) {
        }
        assign(result, {
          edge: isEdge,
          firefox: isBrowseType("Firefox"),
          msie: !isEdge && result["-ms"],
          safari: !isChrome && !isEdge && isBrowseType("Safari"),
          isMobile,
          isPC: !isMobile,
          isLocalStorage,
          isSessionStorage
        });
      }
      return result;
    }
    module.exports = browse2;
  }
});

// node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/index.js
var require_xe_utils = __commonJS({
  "node_modules/.pnpm/xe-utils@3.7.5/node_modules/xe-utils/index.js"(exports, module) {
    "use strict";
    var XEUtils63 = require_ctor();
    var assign = require_assign();
    var objectEach = require_objectEach();
    var lastObjectEach = require_lastObjectEach();
    var objectMap = require_objectMap();
    var merge = require_merge();
    var map = require_map();
    var some = require_some();
    var every = require_every();
    var includeArrays = require_includeArrays();
    var arrayEach = require_arrayEach();
    var lastArrayEach = require_lastArrayEach();
    var uniq = require_uniq();
    var union = require_union();
    var toArray = require_toArray();
    var sortBy = require_sortBy();
    var orderBy = require_orderBy();
    var shuffle = require_shuffle();
    var sample = require_sample();
    var slice = require_slice();
    var filter = require_filter();
    var findKey = require_findKey();
    var includes = require_includes();
    var find = require_find();
    var findLast = require_findLast();
    var reduce = require_reduce();
    var copyWithin = require_copyWithin();
    var chunk = require_chunk();
    var zip = require_zip();
    var unzip = require_unzip();
    var zipObject = require_zipObject();
    var flatten = require_flatten();
    var pluck = require_pluck();
    var invoke = require_invoke();
    var toArrayTree = require_toArrayTree();
    var toTreeArray = require_toTreeArray();
    var findTree = require_findTree();
    var eachTree = require_eachTree();
    var mapTree = require_mapTree();
    var filterTree = require_filterTree();
    var searchTree = require_searchTree();
    var arrayIndexOf = require_arrayIndexOf();
    var arrayLastIndexOf = require_arrayLastIndexOf();
    var hasOwnProp = require_hasOwnProp();
    var isArray = require_isArray();
    var isNull = require_isNull();
    var isNumberNaN = require_isNaN();
    var isUndefined = require_isUndefined();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var isString = require_isString();
    var isPlainObject = require_isPlainObject();
    var isLeapYear = require_isLeapYear();
    var isDate = require_isDate();
    var eqNull = require_eqNull();
    var each = require_each();
    var forOf = require_forOf();
    var lastForOf = require_lastForOf();
    var indexOf = require_indexOf();
    var lastIndexOf = require_lastIndexOf();
    var keys = require_keys();
    var values = require_values();
    var clone = require_clone();
    var getSize = require_getSize();
    var lastEach = require_lastEach();
    var remove = require_remove();
    var clear = require_clear();
    var isNumberFinite = require_isFinite();
    var isFloat = require_isFloat();
    var isInteger = require_isInteger();
    var isBoolean = require_isBoolean();
    var isNumber = require_isNumber();
    var isRegExp = require_isRegExp();
    var isError = require_isError();
    var isTypeError = require_isTypeError();
    var isEmpty = require_isEmpty();
    var isSymbol = require_isSymbol();
    var isArguments = require_isArguments();
    var isElement = require_isElement();
    var isDocument = require_isDocument();
    var isWindow = require_isWindow();
    var isFormData = require_isFormData();
    var isMap = require_isMap();
    var isWeakMap = require_isWeakMap();
    var isSet = require_isSet();
    var isWeakSet = require_isWeakSet();
    var isMatch = require_isMatch();
    var isEqual = require_isEqual();
    var isEqualWith = require_isEqualWith();
    var getType = require_getType();
    var uniqueId = require_uniqueId();
    var findIndexOf = require_findIndexOf();
    var findLastIndexOf = require_findLastIndexOf();
    var toStringJSON = require_toStringJSON();
    var toJSONString = require_toJSONString();
    var entries = require_entries();
    var pick = require_pick();
    var omit = require_omit();
    var first = require_first();
    var last = require_last();
    var has = require_has();
    var get = require_get();
    var set = require_set();
    var groupBy = require_groupBy();
    var countBy = require_countBy();
    var range = require_range();
    var destructuring = require_destructuring();
    var random = require_random();
    var max = require_max();
    var min = require_min();
    var commafy = require_commafy();
    var round = require_round();
    var ceil = require_ceil();
    var floor = require_floor();
    var toFixed = require_toFixed();
    var toInteger = require_toInteger();
    var toNumber = require_toNumber();
    var toNumberString = require_toNumberString();
    var add = require_add();
    var subtract = require_subtract();
    var multiply = require_multiply();
    var divide = require_divide();
    var sum = require_sum();
    var mean = require_mean();
    var getWhatYear = require_getWhatYear();
    var getWhatQuarter = require_getWhatQuarter();
    var getWhatMonth = require_getWhatMonth();
    var getWhatDay = require_getWhatDay();
    var toStringDate = require_toStringDate();
    var toDateString = require_toDateString();
    var now = require_now();
    var timestamp = require_timestamp();
    var isValidDate = require_isValidDate();
    var isDateSame = require_isDateSame();
    var getWhatWeek = require_getWhatWeek();
    var getYearDay = require_getYearDay();
    var getYearWeek = require_getYearWeek();
    var getMonthWeek = require_getMonthWeek();
    var getDayOfYear = require_getDayOfYear();
    var getDayOfMonth = require_getDayOfMonth();
    var getDateDiff = require_getDateDiff();
    var padEnd = require_padEnd();
    var padStart = require_padStart();
    var repeat = require_repeat();
    var trim = require_trim();
    var trimRight = require_trimRight();
    var trimLeft = require_trimLeft();
    var escape = require_escape();
    var unescape = require_unescape();
    var camelCase = require_camelCase();
    var kebabCase = require_kebabCase();
    var startsWith = require_startsWith();
    var endsWith = require_endsWith();
    var template = require_template();
    var toFormatString = require_toFormatString();
    var toValueString = require_toValueString();
    var noop = require_noop();
    var property = require_property();
    var bind = require_bind();
    var once = require_once();
    var after = require_after();
    var before = require_before();
    var throttle = require_throttle();
    var debounce = require_debounce();
    var delay = require_delay();
    var unserialize = require_unserialize();
    var serialize = require_serialize();
    var parseUrl = require_parseUrl();
    var getBaseURL = require_getBaseURL();
    var locat = require_locat();
    var cookie = require_cookie();
    var browse2 = require_browse();
    assign(XEUtils63, {
      // object
      assign,
      objectEach,
      lastObjectEach,
      objectMap,
      merge,
      // array
      uniq,
      union,
      sortBy,
      orderBy,
      shuffle,
      sample,
      some,
      every,
      slice,
      filter,
      find,
      findLast,
      findKey,
      includes,
      arrayIndexOf,
      arrayLastIndexOf,
      map,
      reduce,
      copyWithin,
      chunk,
      zip,
      unzip,
      zipObject,
      flatten,
      toArray,
      includeArrays,
      pluck,
      invoke,
      arrayEach,
      lastArrayEach,
      toArrayTree,
      toTreeArray,
      findTree,
      eachTree,
      mapTree,
      filterTree,
      searchTree,
      // base
      hasOwnProp,
      eqNull,
      isNaN: isNumberNaN,
      isFinite: isNumberFinite,
      isUndefined,
      isArray,
      isFloat,
      isInteger,
      isFunction,
      isBoolean,
      isString,
      isNumber,
      isRegExp,
      isObject,
      isPlainObject,
      isDate,
      isError,
      isTypeError,
      isEmpty,
      isNull,
      isSymbol,
      isArguments,
      isElement,
      isDocument,
      isWindow,
      isFormData,
      isMap,
      isWeakMap,
      isSet,
      isWeakSet,
      isLeapYear,
      isMatch,
      isEqual,
      isEqualWith,
      getType,
      uniqueId,
      getSize,
      indexOf,
      lastIndexOf,
      findIndexOf,
      findLastIndexOf,
      toStringJSON,
      toJSONString,
      keys,
      values,
      entries,
      pick,
      omit,
      first,
      last,
      each,
      forOf,
      lastForOf,
      lastEach,
      has,
      get,
      set,
      groupBy,
      countBy,
      clone,
      clear,
      remove,
      range,
      destructuring,
      // number
      random,
      min,
      max,
      commafy,
      round,
      ceil,
      floor,
      toFixed,
      toNumber,
      toNumberString,
      toInteger,
      add,
      subtract,
      multiply,
      divide,
      sum,
      mean,
      // date
      now,
      timestamp,
      isValidDate,
      isDateSame,
      toStringDate,
      toDateString,
      getWhatYear,
      getWhatQuarter,
      getWhatMonth,
      getWhatWeek,
      getWhatDay,
      getYearDay,
      getYearWeek,
      getMonthWeek,
      getDayOfYear,
      getDayOfMonth,
      getDateDiff,
      // string
      trim,
      trimLeft,
      trimRight,
      escape,
      unescape,
      camelCase,
      kebabCase,
      repeat,
      padStart,
      padEnd,
      startsWith,
      endsWith,
      template,
      toFormatString,
      toString: toValueString,
      toValueString,
      // function
      noop,
      property,
      bind,
      once,
      after,
      before,
      throttle,
      debounce,
      delay,
      // url
      unserialize,
      serialize,
      parseUrl,
      // web
      getBaseURL,
      locat,
      browse: browse2,
      cookie
    });
    module.exports = XEUtils63;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/all.js
var all_exports = {};
__export(all_exports, {
  Button: () => Button,
  ButtonGroup: () => ButtonGroup,
  Checkbox: () => Checkbox,
  CheckboxGroup: () => CheckboxGroup,
  Colgroup: () => Colgroup,
  Column: () => Column,
  Custom: () => Custom,
  Drawer: () => Drawer,
  Edit: () => Edit,
  Export: () => Export,
  Filter: () => Filter,
  Form: () => Form,
  FormGather: () => FormGather,
  FormItem: () => FormItem,
  Grid: () => Grid,
  Icon: () => Icon,
  Input: () => Input,
  Keyboard: () => Keyboard,
  List: () => List,
  Menu: () => Menu,
  Modal: () => Modal,
  Optgroup: () => Optgroup,
  Option: () => Option,
  Pager: () => Pager,
  Pulldown: () => Pulldown,
  Radio: () => Radio,
  RadioButton: () => RadioButton,
  RadioGroup: () => RadioGroup,
  Select: () => Select,
  Switch: () => Switch,
  Table: () => Table,
  Textarea: () => Textarea,
  Toolbar: () => Toolbar,
  Tooltip: () => Tooltip,
  VXETable: () => VXETable,
  Validator: () => Validator,
  VxeButton: () => VxeButton,
  VxeButtonGroup: () => VxeButtonGroup,
  VxeCheckbox: () => VxeCheckbox,
  VxeCheckboxGroup: () => VxeCheckboxGroup,
  VxeColgroup: () => VxeColgroup,
  VxeColumn: () => VxeColumn,
  VxeDrawer: () => VxeDrawer,
  VxeForm: () => VxeForm,
  VxeFormGather: () => VxeFormGather,
  VxeFormItem: () => VxeFormItem,
  VxeGrid: () => VxeGrid,
  VxeIcon: () => VxeIcon,
  VxeInput: () => VxeInput,
  VxeList: () => VxeList,
  VxeModal: () => VxeModal,
  VxeOptgroup: () => VxeOptgroup,
  VxeOption: () => VxeOption,
  VxePager: () => VxePager,
  VxePulldown: () => VxePulldown,
  VxeRadio: () => VxeRadio,
  VxeRadioButton: () => VxeRadioButton,
  VxeRadioGroup: () => VxeRadioGroup,
  VxeSelect: () => VxeSelect,
  VxeSwitch: () => VxeSwitch,
  VxeTable: () => VxeTable,
  VxeTableCustomModule: () => VxeTableCustomModule,
  VxeTableEditModule: () => VxeTableEditModule,
  VxeTableExportModule: () => VxeTableExportModule,
  VxeTableFilterModule: () => VxeTableFilterModule,
  VxeTableKeyboardModule: () => VxeTableKeyboardModule,
  VxeTableMenuModule: () => VxeTableMenuModule,
  VxeTableValidatorModule: () => VxeTableValidatorModule,
  VxeTextarea: () => VxeTextarea,
  VxeToolbar: () => VxeToolbar,
  VxeTooltip: () => VxeTooltip,
  VxeUI: () => VxeUI,
  _t: () => _t,
  commands: () => commands,
  component: () => component,
  config: () => config,
  drawer: () => drawer,
  formats: () => formats,
  getComponent: () => getComponent,
  globalConfs: () => globalConfs,
  globalStore: () => globalStore,
  hooks: () => hooks,
  install: () => install,
  interceptor: () => interceptor,
  menus: () => menus,
  modal: () => modal,
  print: () => print,
  readFile: () => readLocalFile,
  renderer: () => renderer,
  saveFile: () => saveLocalFile,
  setConfig: () => setConfig,
  setIcon: () => setIcon,
  setup: () => setup,
  t: () => t,
  tableVersion: () => tableVersion,
  use: () => use,
  v: () => v,
  validators: () => validators,
  version: () => version
});
var import_xe_utils62 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/index.js
var import_xe_utils12 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/conf.js
var iconPrefix = "vxe-icon-";
var GlobalConfig = {
  size: null,
  zIndex: 999,
  version: 0,
  // resizeInterval: 500,
  emptyCell: "　",
  // loadingText: null, // 自定义loading提示内容，如果为null则不显示文本
  table: {
    fit: true,
    showHeader: true,
    animat: true,
    delayHover: 250,
    autoResize: true,
    minHeight: 144,
    // keepSource: false,
    // showOverflow: null,
    // showHeaderOverflow: null,
    // showFooterOverflow: null,
    // resizeInterval: 500,
    // size: null,
    // zIndex: null,
    // stripe: false,
    // border: false,
    // round: false,
    // emptyText: '暂无数据',
    // emptyRender: {
    //   name: ''
    // },
    // rowConfig: {
    //   keyField: '_X_ROW_KEY' // 行数据的唯一主键字段名
    // },
    resizeConfig: {
      refreshDelay: 250
    },
    radioConfig: {
      // trigger: 'default'
      strict: true
    },
    checkboxConfig: {
      // trigger: 'default',
      strict: true
    },
    tooltipConfig: {
      enterable: true
    },
    validConfig: {
      showMessage: true,
      autoClear: true,
      autoPos: true,
      message: "inline",
      msgMode: "single"
    },
    columnConfig: {
      maxFixedSize: 4
    },
    // menuConfig: {
    //   visibleMethod () {}
    // },
    customConfig: {
      allowFixed: true,
      showFooter: true
      //  storage: false,
      //  checkMethod () {}
    },
    sortConfig: {
      // remote: false,
      // trigger: 'default',
      // orders: ['asc', 'desc', null],
      // sortMethod: null,
      showIcon: true,
      iconLayout: "vertical"
    },
    filterConfig: {
      // remote: false,
      // filterMethod: null,
      showIcon: true
    },
    treeConfig: {
      rowField: "id",
      parentField: "parentId",
      childrenField: "children",
      hasChildField: "hasChild",
      mapChildrenField: "_X_ROW_CHILD",
      indent: 20,
      showIcon: true
    },
    expandConfig: {
      // trigger: 'default',
      showIcon: true
    },
    editConfig: {
      // mode: 'cell',
      showIcon: true,
      showAsterisk: true
    },
    importConfig: {
      _typeMaps: {},
      modes: ["insert", "covering"]
    },
    exportConfig: {
      _typeMaps: {
        csv: 1,
        html: 1,
        xml: 1,
        txt: 1
      },
      modes: ["current", "selected"]
    },
    printConfig: {
      modes: ["current", "selected"]
    },
    mouseConfig: {
      extension: true
    },
    keyboardConfig: {
      isEsc: true
    },
    areaConfig: {
      autoClear: true,
      selectCellByHeader: true
    },
    clipConfig: {
      isCopy: true,
      isCut: true,
      isPaste: true
    },
    fnrConfig: {
      isFind: true,
      isReplace: true
    },
    scrollX: {
      // enabled: false,
      gt: 60
      // oSize: 0
    },
    scrollY: {
      // enabled: false,
      gt: 100
      // oSize: 0
    }
  },
  export: {
    types: {}
  },
  grid: {
    // size: null,
    // zoomConfig: {
    //   escRestore: true
    // },
    formConfig: {
      enabled: true
    },
    pagerConfig: {
      enabled: true
      // perfect: false
    },
    toolbarConfig: {
      enabled: true
      // perfect: false
    },
    proxyConfig: {
      enabled: true,
      autoLoad: true,
      message: true,
      props: {
        list: null,
        result: "result",
        total: "page.total",
        message: "message"
      }
      // beforeItem: null,
      // beforeColumn: null,
      // beforeQuery: null,
      // afterQuery: null,
      // beforeDelete: null,
      // afterDelete: null,
      // beforeSave: null,
      // afterSave: null
    }
  },
  toolbar: {
    // size: null,
    // import: {
    //   mode: 'covering'
    // },
    // export: {
    //   types: ['csv', 'html', 'xml', 'txt']
    // },
    // buttons: []
  },
  icon: {
    // loading
    LOADING: iconPrefix + "spinner roll vxe-loading--default-icon",
    // table
    TABLE_SORT_ASC: iconPrefix + "caret-up",
    TABLE_SORT_DESC: iconPrefix + "caret-down",
    TABLE_FILTER_NONE: iconPrefix + "funnel",
    TABLE_FILTER_MATCH: iconPrefix + "funnel",
    TABLE_EDIT: iconPrefix + "edit",
    TABLE_TITLE_PREFIX: iconPrefix + "question-circle-fill",
    TABLE_TITLE_SUFFIX: iconPrefix + "question-circle-fill",
    TABLE_TREE_LOADED: iconPrefix + "spinner roll",
    TABLE_TREE_OPEN: iconPrefix + "caret-right rotate90",
    TABLE_TREE_CLOSE: iconPrefix + "caret-right",
    TABLE_EXPAND_LOADED: iconPrefix + "spinner roll",
    TABLE_EXPAND_OPEN: iconPrefix + "arrow-right rotate90",
    TABLE_EXPAND_CLOSE: iconPrefix + "arrow-right",
    TABLE_CHECKBOX_CHECKED: iconPrefix + "checkbox-checked",
    TABLE_CHECKBOX_UNCHECKED: iconPrefix + "checkbox-unchecked",
    TABLE_CHECKBOX_INDETERMINATE: iconPrefix + "checkbox-indeterminate",
    TABLE_RADIO_CHECKED: iconPrefix + "radio-checked",
    TABLE_RADIO_UNCHECKED: iconPrefix + "radio-unchecked",
    // button
    BUTTON_DROPDOWN: iconPrefix + "arrow-down",
    BUTTON_LOADING: iconPrefix + "spinner roll",
    // select
    SELECT_LOADED: iconPrefix + "spinner roll",
    SELECT_OPEN: iconPrefix + "caret-down rotate180",
    SELECT_CLOSE: iconPrefix + "caret-down",
    // pager
    PAGER_HOME: iconPrefix + "home-page",
    PAGER_END: iconPrefix + "end-page",
    PAGER_JUMP_PREV: iconPrefix + "arrow-double-left",
    PAGER_JUMP_NEXT: iconPrefix + "arrow-double-right",
    PAGER_PREV_PAGE: iconPrefix + "arrow-left",
    PAGER_NEXT_PAGE: iconPrefix + "arrow-right",
    PAGER_JUMP_MORE: iconPrefix + "ellipsis-h",
    // input
    INPUT_CLEAR: iconPrefix + "error-circle-fill",
    INPUT_PWD: iconPrefix + "eye-fill",
    INPUT_SHOW_PWD: iconPrefix + "eye-fill-close",
    INPUT_PREV_NUM: iconPrefix + "caret-up",
    INPUT_NEXT_NUM: iconPrefix + "caret-down",
    INPUT_DATE: iconPrefix + "calendar",
    INPUT_SEARCH: iconPrefix + "search",
    // modal
    MODAL_ZOOM_IN: iconPrefix + "square",
    MODAL_ZOOM_OUT: iconPrefix + "maximize",
    MODAL_CLOSE: iconPrefix + "close",
    MODAL_INFO: iconPrefix + "info-circle-fill",
    MODAL_SUCCESS: iconPrefix + "success-circle-fill",
    MODAL_WARNING: iconPrefix + "warnion-circle-fill",
    MODAL_ERROR: iconPrefix + "error-circle-fill",
    MODAL_QUESTION: iconPrefix + "question-circle-fill",
    MODAL_LOADING: iconPrefix + "spinner roll",
    // toolbar
    TOOLBAR_TOOLS_REFRESH: iconPrefix + "repeat",
    TOOLBAR_TOOLS_REFRESH_LOADING: iconPrefix + "repeat roll",
    TOOLBAR_TOOLS_IMPORT: iconPrefix + "upload",
    TOOLBAR_TOOLS_EXPORT: iconPrefix + "download",
    TOOLBAR_TOOLS_PRINT: iconPrefix + "print",
    TOOLBAR_TOOLS_FULLSCREEN: iconPrefix + "fullscreen",
    TOOLBAR_TOOLS_MINIMIZE: iconPrefix + "minimize",
    TOOLBAR_TOOLS_CUSTOM: iconPrefix + "custom-column",
    TOOLBAR_TOOLS_FIXED_LEFT: iconPrefix + "fixed-left",
    TOOLBAR_TOOLS_FIXED_LEFT_ACTIVED: iconPrefix + "fixed-left-fill",
    TOOLBAR_TOOLS_FIXED_RIGHT: iconPrefix + "fixed-right",
    TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVED: iconPrefix + "fixed-right-fill",
    // form
    FORM_PREFIX: iconPrefix + "question-circle-fill",
    FORM_SUFFIX: iconPrefix + "question-circle-fill",
    FORM_FOLDING: iconPrefix + "arrow-up rotate180",
    FORM_UNFOLDING: iconPrefix + "arrow-up"
  },
  tooltip: {
    // size: null,
    trigger: "hover",
    theme: "dark",
    enterDelay: 500,
    leaveDelay: 300
  },
  pager: {
    // size: null,
    // autoHidden: false,
    // perfect: true,
    // pageSize: 10,
    // pagerCount: 7,
    // pageSizes: [10, 15, 20, 50, 100],
    // layouts: ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total']
  },
  form: {
    // preventSubmit: false,
    // size: null,
    // colon: false,
    validConfig: {
      showMessage: true,
      autoPos: true
    },
    tooltipConfig: {
      enterable: true
    },
    titleAsterisk: true
  },
  input: {
    // size: null,
    // transfer: false
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1,
    digits: 2,
    controls: true
  },
  textarea: {
    // size: null,
    // autosize: {
    //   minRows: 1,
    //   maxRows: 10
    // }
  },
  select: {
    // size: null,
    // transfer: false,
    // optionConfig: {
    //   keyField: '_X_OPTION_KEY'
    // },
    multiCharOverflow: 8
  },
  button: {
    // size: null,
    // transfer: false
  },
  buttonGroup: {
    // size: null
  },
  radio: {
    // size: null,
    strict: true
  },
  radioButton: {
    // size: null,
    strict: true
  },
  radioGroup: {
    // size: null,
    strict: true
  },
  checkbox: {
    // size: null
  },
  checkboxGroup: {
    // size: null
  },
  switch: {
    // size: null
  },
  modal: {
    // size: null,
    top: 15,
    showHeader: true,
    minWidth: 340,
    minHeight: 140,
    lockView: true,
    mask: true,
    duration: 3e3,
    marginSize: 0,
    dblclickZoom: true,
    showTitleOverflow: true,
    animat: true,
    showClose: true,
    draggable: true,
    showConfirmButton: null,
    // storage: false,
    storageKey: "VXE_MODAL_POSITION"
  },
  drawer: {
    // size: null,
    showHeader: true,
    lockView: true,
    mask: true,
    showTitleOverflow: true,
    showClose: true
  },
  list: {
    // size: null,
    scrollY: {
      enabled: true,
      gt: 100
      // oSize: 0
    }
  },
  i18n: (key) => key
};
var conf_default = GlobalConfig;

// node_modules/.pnpm/dom-zindex@1.0.6/node_modules/dom-zindex/es/index.esm.js
var winDom = null;
var bodyEl = null;
var storeEl = null;
var storeId = "z-index-manage";
var styleEl = null;
var styleId = "z-index-style";
var storeMainKey = "m";
var storeSubKey = "s";
var storeData = {
  m: 1e3,
  s: 1e3
};
function getDocument() {
  if (!winDom) {
    if (typeof document !== "undefined") {
      winDom = document;
    }
  }
  return winDom;
}
function getBody() {
  if (winDom && !bodyEl) {
    bodyEl = winDom.body || winDom.getElementsByTagName("body")[0];
  }
  return bodyEl;
}
function getDomMaxZIndex() {
  var max = 0;
  var dom = getDocument();
  if (dom) {
    var body = getBody();
    if (body) {
      var allElem = body.getElementsByTagName("*");
      for (var i = 0; i < allElem.length; i++) {
        var elem = allElem[i];
        if (elem && elem.style && elem.nodeType === 1) {
          var zIndex = elem.style.zIndex;
          if (zIndex && /^\d+$/.test(zIndex)) {
            max = Math.max(max, Number(zIndex));
          }
        }
      }
    }
  }
  return max;
}
function getStyle() {
  if (!styleEl) {
    var dom = getDocument();
    if (dom) {
      styleEl = dom.getElementById(styleId);
      if (!styleEl) {
        styleEl = dom.createElement("style");
        styleEl.id = styleId;
        dom.getElementsByTagName("head")[0].appendChild(styleEl);
      }
    }
  }
  return styleEl;
}
function updateVar() {
  var styEl = getStyle();
  if (styEl) {
    var prefixes = "--dom-";
    var propKey = "-z-index";
    styEl.innerHTML = ":root{" + prefixes + "main" + propKey + ":" + getCurrent() + ";" + prefixes + "sub" + propKey + ":" + getSubCurrent() + "}";
  }
}
function getStoreDom() {
  if (!storeEl) {
    var dom = getDocument();
    if (dom) {
      storeEl = dom.getElementById(storeId);
      if (!storeEl) {
        var body = getBody();
        if (body) {
          storeEl = dom.createElement("div");
          storeEl.id = storeId;
          storeEl.style.display = "none";
          body.appendChild(storeEl);
          setCurrent(storeData.m);
          setSubCurrent(storeData.s);
        }
      }
    }
  }
  return storeEl;
}
function createSetHandle(key) {
  return function(value) {
    if (value) {
      value = Number(value);
      storeData[key] = value;
      var el = getStoreDom();
      if (el) {
        if (el.dataset) {
          el.dataset[key] = value + "";
        } else {
          el.setAttribute("data-" + key, value + "");
        }
      }
    }
    updateVar();
    return storeData[key];
  };
}
var setCurrent = createSetHandle(storeMainKey);
function createGetHandle(key, nextMethod) {
  return function getCurrent2(currZindex) {
    var zIndex;
    var el = getStoreDom();
    if (el) {
      var domVal = el.dataset ? el.dataset[key] : el.getAttribute("data-" + key);
      if (domVal) {
        zIndex = Number(domVal);
      }
    }
    if (!zIndex) {
      zIndex = storeData[key];
    }
    if (currZindex) {
      if (Number(currZindex) < zIndex) {
        return nextMethod();
      }
      return currZindex;
    }
    return zIndex;
  };
}
var getCurrent = createGetHandle(storeMainKey, getNext);
function getNext() {
  return setCurrent(getCurrent() + 1);
}
var setSubCurrent = createSetHandle(storeSubKey);
var _getSubCurrent = createGetHandle(storeSubKey, getSubNext);
function getSubCurrent() {
  return getCurrent() + _getSubCurrent();
}
function getSubNext() {
  setSubCurrent(_getSubCurrent() + 1);
  return getSubCurrent();
}
var DomZIndex = {
  setCurrent,
  getCurrent,
  getNext,
  setSubCurrent,
  getSubCurrent,
  getSubNext,
  getMax: getDomMaxZIndex
};
updateVar();
var index_esm_default = DomZIndex;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/interceptor.js
var import_xe_utils = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/tools/log.js
function getLog(message, params) {
  return `[vxe-table v${"4.6.25"}] ${conf_default.i18n(message, params)}`;
}
function outLog(type) {
  return function(message, params) {
    const msg = getLog(message, params);
    console[type](msg);
    return msg;
  };
}
var warnLog = outLog("warn");
var errLog = outLog("error");

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/interceptor.js
var storeMap = {};
var interceptor = {
  mixin(options) {
    import_xe_utils.default.each(options, (callback, type) => interceptor.add(type, callback));
    return interceptor;
  },
  get(type) {
    return storeMap[type] || [];
  },
  add(type, callback) {
    if (true) {
      const eventTypes = ["created", "mounted", "activated", "beforeUnmount", "unmounted", "event.clearEdit", "event.clearActived", "event.clearFilter", "event.clearAreas", "event.showMenu", "event.keydown", "event.export", "event.import"];
      if (eventTypes.indexOf(type) === -1) {
        warnLog("vxe.error.errProp", [`Interceptor.${type}`, eventTypes.join("|")]);
      }
    }
    if (callback) {
      let eList = storeMap[type];
      if (!eList) {
        eList = storeMap[type] = [];
      }
      if (true) {
        if (eList.indexOf(callback) > -1) {
          warnLog("vxe.error.coverProp", ["Interceptor", type]);
        }
      }
      eList.push(callback);
    }
    return interceptor;
  },
  delete(type, callback) {
    const eList = storeMap[type];
    if (eList) {
      if (callback) {
        import_xe_utils.default.remove(eList, (fn) => fn === callback);
      } else {
        delete storeMap[type];
      }
    }
  }
};

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/renderer.js
var import_xe_utils8 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/util.js
var import_xe_utils6 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/columnInfo.js
var import_xe_utils4 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/formats.js
var import_xe_utils2 = __toESM(require_xe_utils());
var VXEFormatsStore = class {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    import_xe_utils2.default.each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    if (import_xe_utils2.default.isFunction(render)) {
      if (true) {
        warnLog("vxe.error.delProp", ["formats -> callback", "cellFormatMethod"]);
      }
      render = {
        cellFormatMethod: render
      };
    }
    if (true) {
      const confKeys = import_xe_utils2.default.keys(conf);
      import_xe_utils2.default.each(render, (item, key) => {
        if (confKeys.includes(key)) {
          warnLog("vxe.error.coverProp", [name, key]);
        }
      });
    }
    this.store[name] = conf ? import_xe_utils2.default.merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    import_xe_utils2.default.objectEach(this.store, callback);
  }
};
var formats = new VXEFormatsStore();
if (true) {
  Object.assign(formats, { _name: "Formats" });
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/tools/utils.js
var import_xe_utils3 = __toESM(require_xe_utils());
function isEnableConf(conf) {
  return conf && conf.enabled !== false;
}
function isEmptyValue(cellValue) {
  return cellValue === null || cellValue === void 0 || cellValue === "";
}
function parseFile(file) {
  const name = file.name;
  const tIndex = import_xe_utils3.default.lastIndexOf(name, ".");
  const type = name.substring(tIndex + 1, name.length).toLowerCase();
  const filename = name.substring(0, tIndex);
  return { filename, type };
}
function nextZIndex() {
  return index_esm_default.getNext();
}
function getLastZIndex() {
  return index_esm_default.getCurrent();
}
function hasChildrenList(item) {
  return item && item.children && item.children.length > 0;
}
function getFuncText(content) {
  return content ? import_xe_utils3.default.toValueString(conf_default.translate ? conf_default.translate("" + content) : content) : "";
}
function formatText(value, placeholder) {
  return "" + (isEmptyValue(value) ? placeholder ? conf_default.emptyCell : "" : value);
}
function eqEmptyValue(cellValue) {
  return cellValue === "" || import_xe_utils3.default.eqNull(cellValue);
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/columnInfo.js
var ColumnInfo = class {
  /* eslint-disable @typescript-eslint/no-use-before-define */
  constructor($xetable, _vm, { renderHeader, renderCell, renderFooter, renderData } = {}) {
    const $xegrid = $xetable.xegrid;
    const formatter = _vm.formatter;
    const visible = import_xe_utils4.default.isBoolean(_vm.visible) ? _vm.visible : true;
    if (true) {
      const types = ["seq", "checkbox", "radio", "expand", "html"];
      if (_vm.type && types.indexOf(_vm.type) === -1) {
        warnLog("vxe.error.errProp", [`type=${_vm.type}`, types.join(", ")]);
      }
      if (import_xe_utils4.default.isBoolean(_vm.cellRender) || _vm.cellRender && !import_xe_utils4.default.isObject(_vm.cellRender)) {
        warnLog("vxe.error.errProp", [`column.cell-render=${_vm.cellRender}`, "column.cell-render={}"]);
      }
      if (import_xe_utils4.default.isBoolean(_vm.editRender) || _vm.editRender && !import_xe_utils4.default.isObject(_vm.editRender)) {
        warnLog("vxe.error.errProp", [`column.edit-render=${_vm.editRender}`, "column.edit-render={}"]);
      }
      if (_vm.cellRender && _vm.editRender) {
        warnLog("vxe.error.errConflicts", ["column.cell-render", "column.edit-render"]);
      }
      if (_vm.type === "expand") {
        const { props: tableProps } = $xetable;
        const { treeConfig } = tableProps;
        const { computeTreeOpts } = $xetable.getComputeMaps();
        const treeOpts = computeTreeOpts.value;
        if (treeConfig && (treeOpts.showLine || treeOpts.line)) {
          errLog("vxe.error.errConflicts", ["tree-config.showLine", "column.type=expand"]);
        }
      }
      if (formatter) {
        if (import_xe_utils4.default.isString(formatter)) {
          const gFormatOpts = formats.get(formatter) || import_xe_utils4.default[formatter];
          if (!gFormatOpts || !import_xe_utils4.default.isFunction(gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod)) {
            errLog("vxe.error.notFormats", [formatter]);
          }
        } else if (import_xe_utils4.default.isArray(formatter)) {
          const gFormatOpts = formats.get(formatter[0]) || import_xe_utils4.default[formatter[0]];
          if (!gFormatOpts || !import_xe_utils4.default.isFunction(gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod)) {
            errLog("vxe.error.notFormats", [formatter[0]]);
          }
        }
      }
    }
    Object.assign(this, {
      // 基本属性
      type: _vm.type,
      property: _vm.field,
      field: _vm.field,
      title: _vm.title,
      width: _vm.width,
      minWidth: _vm.minWidth,
      maxWidth: _vm.maxWidth,
      resizable: _vm.resizable,
      fixed: _vm.fixed,
      align: _vm.align,
      headerAlign: _vm.headerAlign,
      footerAlign: _vm.footerAlign,
      showOverflow: _vm.showOverflow,
      showHeaderOverflow: _vm.showHeaderOverflow,
      showFooterOverflow: _vm.showFooterOverflow,
      className: _vm.className,
      headerClassName: _vm.headerClassName,
      footerClassName: _vm.footerClassName,
      formatter,
      sortable: _vm.sortable,
      sortBy: _vm.sortBy,
      sortType: _vm.sortType,
      filters: toFilters(_vm.filters),
      filterMultiple: import_xe_utils4.default.isBoolean(_vm.filterMultiple) ? _vm.filterMultiple : true,
      filterMethod: _vm.filterMethod,
      filterResetMethod: _vm.filterResetMethod,
      filterRecoverMethod: _vm.filterRecoverMethod,
      filterRender: _vm.filterRender,
      treeNode: _vm.treeNode,
      cellType: _vm.cellType,
      cellRender: _vm.cellRender,
      editRender: _vm.editRender,
      contentRender: _vm.contentRender,
      headerExportMethod: _vm.headerExportMethod,
      exportMethod: _vm.exportMethod,
      footerExportMethod: _vm.footerExportMethod,
      titleHelp: _vm.titleHelp,
      titlePrefix: _vm.titlePrefix,
      titleSuffix: _vm.titleSuffix,
      // 自定义参数
      params: _vm.params,
      // 渲染属性
      id: _vm.colId || import_xe_utils4.default.uniqueId("col_"),
      parentId: null,
      visible,
      // 内部属性（一旦被使用，将导致不可升级版本）
      halfVisible: false,
      defaultVisible: visible,
      defaultFixed: _vm.fixed,
      checked: false,
      halfChecked: false,
      disabled: false,
      // 分组层级
      level: 1,
      // 跨行
      rowSpan: 1,
      // 跨列
      colSpan: 1,
      // 数据排序
      order: null,
      sortTime: 0,
      // 列排序
      sortNumber: 0,
      renderSortNumber: 0,
      renderWidth: 0,
      renderHeight: 0,
      resizeWidth: 0,
      renderLeft: 0,
      renderArgs: [],
      model: {},
      renderHeader: renderHeader || _vm.renderHeader,
      renderCell: renderCell || _vm.renderCell,
      renderFooter: renderFooter || _vm.renderFooter,
      renderData,
      // 单元格插槽，只对 grid 有效
      slots: _vm.slots
    });
    if ($xegrid) {
      const { computeProxyOpts } = $xegrid.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      if (proxyOpts.beforeColumn) {
        proxyOpts.beforeColumn({ $grid: $xegrid, column: this });
      }
    }
  }
  getTitle() {
    return getFuncText(this.title || (this.type === "seq" ? conf_default.i18n("vxe.table.seqTitle") : ""));
  }
  getKey() {
    return this.field || (this.type ? `type=${this.type}` : null);
  }
  update(name, value) {
    if (name !== "filters") {
      if (name === "field") {
        this.property = value;
      }
      this[name] = value;
    }
  }
};

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/tools/dom.js
var import_xe_utils5 = __toESM(require_xe_utils());
var reClsMap = {};
var browse = import_xe_utils5.default.browse();
function getPropClass(property, params) {
  return property ? import_xe_utils5.default.isFunction(property) ? property(params) : property : "";
}
function getClsRE(cls) {
  if (!reClsMap[cls]) {
    reClsMap[cls] = new RegExp(`(?:^|\\s)${cls}(?!\\S)`, "g");
  }
  return reClsMap[cls];
}
function getNodeOffset(elem, container, rest) {
  if (elem) {
    const parentElem = elem.parentNode;
    rest.top += elem.offsetTop;
    rest.left += elem.offsetLeft;
    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {
      rest.top -= parentElem.scrollTop;
      rest.left -= parentElem.scrollLeft;
    }
    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
      return getNodeOffset(elem.offsetParent, container, rest);
    }
  }
  return rest;
}
function isPx(val) {
  return val && /^\d+(px)?$/.test(val);
}
function isScale(val) {
  return val && /^\d+%$/.test(val);
}
function hasClass(elem, cls) {
  return elem && elem.className && elem.className.match && elem.className.match(getClsRE(cls));
}
function removeClass(elem, cls) {
  if (elem && hasClass(elem, cls)) {
    elem.className = elem.className.replace(getClsRE(cls), "");
  }
}
function addClass(elem, cls) {
  if (elem && !hasClass(elem, cls)) {
    removeClass(elem, cls);
    elem.className = `${elem.className} ${cls}`;
  }
}
function getDomNode() {
  const documentElement = document.documentElement;
  const bodyElem = document.body;
  return {
    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
  };
}
function getOffsetHeight(elem) {
  return elem ? elem.offsetHeight : 0;
}
function getPaddingTopBottomSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingTop = import_xe_utils5.default.toNumber(computedStyle.paddingTop);
    const paddingBottom = import_xe_utils5.default.toNumber(computedStyle.paddingBottom);
    return paddingTop + paddingBottom;
  }
  return 0;
}
function setScrollTop(elem, scrollTop) {
  if (elem) {
    elem.scrollTop = scrollTop;
  }
}
function setScrollLeft(elem, scrollLeft) {
  if (elem) {
    elem.scrollLeft = scrollLeft;
  }
}
function updateCellTitle(overflowElem, column) {
  const content = column.type === "html" ? overflowElem.innerText : overflowElem.textContent;
  if (overflowElem.getAttribute("title") !== content) {
    overflowElem.setAttribute("title", content);
  }
}
function getEventTargetNode(evnt, container, queryCls, queryMethod) {
  let targetElem;
  let target = evnt.target.shadowRoot && evnt.composed ? evnt.composedPath()[0] || evnt.target : evnt.target;
  while (target && target.nodeType && target !== document) {
    if (queryCls && hasClass(target, queryCls) && (!queryMethod || queryMethod(target))) {
      targetElem = target;
    } else if (target === container) {
      return { flag: queryCls ? !!targetElem : true, container, targetElem };
    }
    target = target.parentNode;
  }
  return { flag: false };
}
function getOffsetPos(elem, container) {
  return getNodeOffset(elem, container, { left: 0, top: 0 });
}
function getAbsolutePos(elem) {
  const bounding = elem.getBoundingClientRect();
  const boundingTop = bounding.top;
  const boundingLeft = bounding.left;
  const { scrollTop, scrollLeft, visibleHeight, visibleWidth } = getDomNode();
  return { boundingTop, top: scrollTop + boundingTop, boundingLeft, left: scrollLeft + boundingLeft, visibleHeight, visibleWidth };
}
var scrollIntoViewIfNeeded = "scrollIntoViewIfNeeded";
var scrollIntoView = "scrollIntoView";
function scrollToView(elem) {
  if (elem) {
    if (elem[scrollIntoViewIfNeeded]) {
      elem[scrollIntoViewIfNeeded]();
    } else if (elem[scrollIntoView]) {
      elem[scrollIntoView]();
    }
  }
}
function triggerEvent(targetElem, type) {
  if (targetElem) {
    targetElem.dispatchEvent(new Event(type));
  }
}
function isNodeElement(elem) {
  return elem && elem.nodeType === 1;
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/util.js
var getAllConvertColumns = (columns, parentColumn) => {
  const result = [];
  columns.forEach((column) => {
    column.parentId = parentColumn ? parentColumn.id : null;
    if (column.visible) {
      if (column.children && column.children.length && column.children.some((column2) => column2.visible)) {
        result.push(column);
        result.push(...getAllConvertColumns(column.children, column));
      } else {
        result.push(column);
      }
    }
  });
  return result;
};
var convertHeaderColumnToRows = (originColumns) => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column.level = parent.level + 1;
      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }
    if (column.children && column.children.length && column.children.some((column2) => column2.visible)) {
      let colSpan = 0;
      column.children.forEach((subColumn) => {
        if (subColumn.visible) {
          traverse(subColumn, column);
          colSpan += subColumn.colSpan;
        }
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };
  originColumns.forEach((column) => {
    column.level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getAllConvertColumns(originColumns);
  allColumns.forEach((column) => {
    if (column.children && column.children.length && column.children.some((column2) => column2.visible)) {
      column.rowSpan = 1;
    } else {
      column.rowSpan = maxLevel - column.level + 1;
    }
    rows[column.level - 1].push(column);
  });
  return rows;
};
function restoreScrollLocation($xetable, scrollLeft, scrollTop) {
  const { internalData } = $xetable;
  return $xetable.clearScroll().then(() => {
    if (scrollLeft || scrollTop) {
      internalData.lastScrollLeft = 0;
      internalData.lastScrollTop = 0;
      return $xetable.scrollTo(scrollLeft, scrollTop);
    }
  });
}
function removeScrollListener(scrollElem) {
  if (scrollElem && scrollElem._onscroll) {
    scrollElem.onscroll = null;
  }
}
function restoreScrollListener(scrollElem) {
  if (scrollElem && scrollElem._onscroll) {
    scrollElem.onscroll = scrollElem._onscroll;
  }
}
function getRowUniqueId() {
  return import_xe_utils6.default.uniqueId("row_");
}
function getRowkey($xetable) {
  const { props } = $xetable;
  const { computeRowOpts } = $xetable.getComputeMaps();
  const { rowId } = props;
  const rowOpts = computeRowOpts.value;
  return rowId || rowOpts.keyField || "_X_ROW_KEY";
}
function getRowid($xetable, row) {
  const rowid = import_xe_utils6.default.get(row, getRowkey($xetable));
  return import_xe_utils6.default.eqNull(rowid) ? "" : encodeURIComponent(rowid);
}
var handleFieldOrColumn = ($xetable, fieldOrColumn) => {
  if (fieldOrColumn) {
    return import_xe_utils6.default.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;
  }
  return null;
};
function getPaddingLeftRightSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingLeft = import_xe_utils6.default.toNumber(computedStyle.paddingLeft);
    const paddingRight = import_xe_utils6.default.toNumber(computedStyle.paddingRight);
    return paddingLeft + paddingRight;
  }
  return 0;
}
function getElemenMarginWidth(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const marginLeft = import_xe_utils6.default.toNumber(computedStyle.marginLeft);
    const marginRight = import_xe_utils6.default.toNumber(computedStyle.marginRight);
    return elem.offsetWidth + marginLeft + marginRight;
  }
  return 0;
}
function queryCellElement(cell, selector) {
  return cell.querySelector(".vxe-cell" + selector);
}
function toFilters(filters) {
  if (filters && import_xe_utils6.default.isArray(filters)) {
    return filters.map(({ label, value, data, resetValue, checked }) => {
      return { label, value, data, resetValue, checked: !!checked, _checked: !!checked };
    });
  }
  return filters;
}
function toTreePathSeq(path) {
  return path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("");
}
function getCellValue(row, column) {
  return import_xe_utils6.default.get(row, column.field);
}
function setCellValue(row, column, value) {
  return import_xe_utils6.default.set(row, column.field, value);
}
function getColReMinWidth(params) {
  const { $table, column, cell } = params;
  const { props: tableProps } = $table;
  const { computeResizableOpts } = $table.getComputeMaps();
  const resizableOpts = computeResizableOpts.value;
  const { minWidth: reMinWidth } = resizableOpts;
  if (reMinWidth) {
    const customMinWidth = import_xe_utils6.default.isFunction(reMinWidth) ? reMinWidth(params) : reMinWidth;
    if (customMinWidth !== "auto") {
      return Math.max(1, import_xe_utils6.default.toNumber(customMinWidth));
    }
  }
  const { showHeaderOverflow: allColumnHeaderOverflow } = tableProps;
  const { showHeaderOverflow, minWidth: colMinWidth } = column;
  const headOverflow = import_xe_utils6.default.isUndefined(showHeaderOverflow) || import_xe_utils6.default.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  const showEllipsis = headOverflow === "ellipsis";
  const showTitle = headOverflow === "title";
  const showTooltip = headOverflow === true || headOverflow === "tooltip";
  const hasEllipsis = showTitle || showTooltip || showEllipsis;
  const minTitleWidth = import_xe_utils6.default.floor((import_xe_utils6.default.toNumber(getComputedStyle(cell).fontSize) || 14) * 1.6);
  const paddingLeftRight = getPaddingLeftRightSize(cell) + getPaddingLeftRightSize(queryCellElement(cell, ""));
  let mWidth = minTitleWidth + paddingLeftRight;
  if (hasEllipsis) {
    const checkboxIconWidth = getPaddingLeftRightSize(queryCellElement(cell, "--title>.vxe-cell--checkbox"));
    const requiredIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell--required-icon"));
    const editIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell--edit-icon"));
    const prefixIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell-title-prefix-icon"));
    const suffixIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell-title-suffix-icon"));
    const sortIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell--sort"));
    const filterIconWidth = getElemenMarginWidth(queryCellElement(cell, ">.vxe-cell--filter"));
    mWidth += checkboxIconWidth + requiredIconWidth + editIconWidth + prefixIconWidth + suffixIconWidth + filterIconWidth + sortIconWidth;
  }
  if (colMinWidth) {
    const { refTableBody } = $table.getRefMaps();
    const tableBody = refTableBody.value;
    const bodyElem = tableBody ? tableBody.$el : null;
    if (bodyElem) {
      if (isScale(colMinWidth)) {
        const bodyWidth = bodyElem.clientWidth - 1;
        const meanWidth = bodyWidth / 100;
        return Math.max(mWidth, Math.floor(import_xe_utils6.default.toInteger(colMinWidth) * meanWidth));
      } else if (isPx(colMinWidth)) {
        return Math.max(mWidth, import_xe_utils6.default.toInteger(colMinWidth));
      }
    }
  }
  return mWidth;
}
function isColumnInfo(column) {
  return column && (column.constructor === ColumnInfo || column instanceof ColumnInfo);
}
function createColumn($xetable, options, renderOptions) {
  return isColumnInfo(options) ? options : reactive(new ColumnInfo($xetable, options, renderOptions));
}
function watchColumn($xetable, props, column) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      column.update(name, value);
      if ($xetable) {
        if (name === "filters") {
          $xetable.setFilter(column, value);
          $xetable.handleUpdateDataQueue();
        } else if (["visible", "fixed", "width", "minWidth", "maxWidth"].includes(name)) {
          $xetable.handleRefreshColumnQueue();
        }
      }
    });
  });
}
function assemColumn($xetable, elem, column, colgroup) {
  const { reactData } = $xetable;
  const { staticColumns } = reactData;
  const parentElem = elem.parentNode;
  const parentColumn = colgroup ? colgroup.column : null;
  const parentCols = parentColumn ? parentColumn.children : staticColumns;
  if (parentElem && parentCols) {
    parentCols.splice(import_xe_utils6.default.arrayIndexOf(parentElem.children, elem), 0, column);
    reactData.staticColumns = staticColumns.slice(0);
  }
}
function destroyColumn($xetable, column) {
  const { reactData } = $xetable;
  const { staticColumns } = reactData;
  const matchObj = import_xe_utils6.default.findTree(staticColumns, (item) => item.id === column.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticColumns = staticColumns.slice(0);
}
function getRootColumn($xetable, column) {
  const { internalData } = $xetable;
  const { fullColumnIdData } = internalData;
  if (!column) {
    return null;
  }
  let parentColId = column.parentId;
  while (fullColumnIdData[parentColId]) {
    const column2 = fullColumnIdData[parentColId].column;
    parentColId = column2.parentId;
    if (!parentColId) {
      return column2;
    }
  }
  return column;
}
function mergeBodyMethod(mergeList, _rowIndex, _columnIndex) {
  for (let mIndex = 0; mIndex < mergeList.length; mIndex++) {
    const { row: mergeRowIndex, col: mergeColIndex, rowspan: mergeRowspan, colspan: mergeColspan } = mergeList[mIndex];
    if (mergeColIndex > -1 && mergeRowIndex > -1 && mergeRowspan && mergeColspan) {
      if (mergeRowIndex === _rowIndex && mergeColIndex === _columnIndex) {
        return { rowspan: mergeRowspan, colspan: mergeColspan };
      }
      if (_rowIndex >= mergeRowIndex && _rowIndex < mergeRowIndex + mergeRowspan && _columnIndex >= mergeColIndex && _columnIndex < mergeColIndex + mergeColspan) {
        return { rowspan: 0, colspan: 0 };
      }
    }
  }
}
function clearTableDefaultStatus($xetable) {
  const { props, internalData } = $xetable;
  internalData.initStatus = false;
  $xetable.clearSort();
  $xetable.clearCurrentRow();
  $xetable.clearCurrentColumn();
  $xetable.clearRadioRow();
  $xetable.clearRadioReserve();
  $xetable.clearCheckboxRow();
  $xetable.clearCheckboxReserve();
  $xetable.clearRowExpand();
  $xetable.clearTreeExpand();
  $xetable.clearTreeExpandReserve();
  $xetable.clearPendingRow();
  if ($xetable.clearFilter) {
    $xetable.clearFilter();
  }
  if ($xetable.clearSelected && (props.keyboardConfig || props.mouseConfig)) {
    $xetable.clearSelected();
  }
  if ($xetable.clearCellAreas && props.mouseConfig) {
    $xetable.clearCellAreas();
    $xetable.clearCopyCellArea();
  }
  return $xetable.clearScroll();
}
function clearTableAllStatus($xetable) {
  if ($xetable.clearFilter) {
    $xetable.clearFilter();
  }
  return clearTableDefaultStatus($xetable);
}
function rowToVisible($xetable, row) {
  const { reactData, internalData } = $xetable;
  const { refTableBody } = $xetable.getRefMaps();
  const { scrollYLoad } = reactData;
  const { afterFullData, scrollYStore } = internalData;
  const tableBody = refTableBody.value;
  const bodyElem = tableBody ? tableBody.$el : null;
  if (bodyElem) {
    const trElem = bodyElem.querySelector(`[rowid="${getRowid($xetable, row)}"]`);
    if (trElem) {
      const bodyHeight = bodyElem.clientHeight;
      const bodySrcollTop = bodyElem.scrollTop;
      const trOffsetParent = trElem.offsetParent;
      const trOffsetTop = trElem.offsetTop + (trOffsetParent ? trOffsetParent.offsetTop : 0);
      const trHeight = trElem.clientHeight;
      if (trOffsetTop < bodySrcollTop || trOffsetTop > bodySrcollTop + bodyHeight) {
        return $xetable.scrollTo(null, trOffsetTop);
      } else if (trOffsetTop + trHeight >= bodyHeight + bodySrcollTop) {
        return $xetable.scrollTo(null, bodySrcollTop + trHeight);
      }
    } else {
      if (scrollYLoad) {
        return $xetable.scrollTo(null, (afterFullData.indexOf(row) - 1) * scrollYStore.rowHeight);
      }
    }
  }
  return Promise.resolve();
}
function colToVisible($xetable, column) {
  const { reactData, internalData } = $xetable;
  const { refTableBody } = $xetable.getRefMaps();
  const { scrollXLoad } = reactData;
  const { visibleColumn } = internalData;
  const tableBody = refTableBody.value;
  const bodyElem = tableBody ? tableBody.$el : null;
  if (column && column.fixed) {
    return Promise.resolve();
  }
  if (bodyElem) {
    const tdElem = bodyElem.querySelector(`.${column.id}`);
    if (tdElem) {
      const bodyWidth = bodyElem.clientWidth;
      const bodySrcollLeft = bodyElem.scrollLeft;
      const tdOffsetParent = tdElem.offsetParent;
      const tdOffsetLeft = tdElem.offsetLeft + (tdOffsetParent ? tdOffsetParent.offsetLeft : 0);
      const tdWidth = tdElem.clientWidth;
      if (tdOffsetLeft < bodySrcollLeft || tdOffsetLeft > bodySrcollLeft + bodyWidth) {
        return $xetable.scrollTo(tdOffsetLeft);
      } else if (tdOffsetLeft + tdWidth >= bodyWidth + bodySrcollLeft) {
        return $xetable.scrollTo(bodySrcollLeft + tdWidth);
      }
    } else {
      if (scrollXLoad) {
        let scrollLeft = 0;
        for (let index = 0; index < visibleColumn.length; index++) {
          if (visibleColumn[index] === column) {
            break;
          }
          scrollLeft += visibleColumn[index].renderWidth;
        }
        return $xetable.scrollTo(scrollLeft);
      }
    }
  }
  return Promise.resolve();
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/tools/vn.js
var import_xe_utils7 = __toESM(require_xe_utils());
function getOnName(type) {
  return "on" + type.substring(0, 1).toLocaleUpperCase() + type.substring(1);
}
function getSlotVNs(vns) {
  if (import_xe_utils7.default.isArray(vns)) {
    return vns;
  }
  return [vns];
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/renderer.js
var componentDefaultModelProp = "modelValue";
var defaultCompProps = { transfer: true };
function getModelEvent(renderOpts) {
  switch (renderOpts.name) {
    case "input":
    case "textarea":
      return "input";
  }
  return "update:modelValue";
}
function getChangeEvent(renderOpts) {
  switch (renderOpts.name) {
    case "input":
    case "textarea":
    case "VxeInput":
    case "VxeTextarea":
    case "$input":
    case "$textarea":
      return "input";
  }
  return "change";
}
function parseDate(value, props) {
  return value && props.valueFormat ? import_xe_utils8.default.toStringDate(value, props.valueFormat) : value;
}
function getFormatDate(value, props, defaultFormat) {
  const { dateConfig = {} } = props;
  return import_xe_utils8.default.toDateString(parseDate(value, props), dateConfig.labelFormat || defaultFormat);
}
function getLabelFormatDate(value, props) {
  return getFormatDate(value, props, conf_default.i18n(`vxe.input.date.labelFormat.${props.type}`));
}
function getOldComponentName(name) {
  return `vxe-${name.replace("$", "")}`;
}
function getDefaultComponent({ name }) {
  return resolveComponent(name);
}
function getOldComponent({ name }) {
  return resolveComponent(getOldComponentName(name));
}
function handleConfirmFilter(params, checked, option) {
  const { $panel } = params;
  $panel.changeOption({}, checked, option);
}
function getNativeAttrs(renderOpts) {
  let { name, attrs } = renderOpts;
  if (name === "input") {
    attrs = Object.assign({ type: "text" }, attrs);
  }
  return attrs;
}
function getInputImmediateModel(renderOpts) {
  const { name, immediate, props } = renderOpts;
  if (!immediate) {
    if (name === "VxeInput" || name === "$input") {
      const { type } = props || {};
      return !(!type || type === "text" || type === "number" || type === "integer" || type === "float");
    }
    if (name === "input" || name === "textarea" || name === "$textarea") {
      return false;
    }
    return true;
  }
  return immediate;
}
function getCellEditProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils8.default.assign({ immediate: getInputImmediateModel(renderOpts) }, defaultCompProps, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function getCellEditFilterProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils8.default.assign({}, defaultCompProps, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function getComponentFormItemProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils8.default.assign({}, defaultCompProps, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function isImmediateCell(renderOpts, params) {
  return params.$type === "cell" || getInputImmediateModel(renderOpts);
}
function getCellLabelVNs(renderOpts, params, cellLabel) {
  const { placeholder } = renderOpts;
  return [
    h("span", {
      class: "vxe-cell--label"
    }, placeholder && isEmptyValue(cellLabel) ? [
      h("span", {
        class: "vxe-cell--placeholder"
      }, formatText(getFuncText(placeholder), 1))
    ] : formatText(cellLabel, 1))
  ];
}
function getElementOns(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    import_xe_utils8.default.objectEach(events, (func, key) => {
      ons[getOnName(key)] = function(...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getComponentOns(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const ons = {};
  import_xe_utils8.default.objectEach(events, (func, key) => {
    ons[getOnName(key)] = function(...args) {
      if (true) {
        if (!import_xe_utils8.default.isFunction(func)) {
          errLog("vxe.error.errFunc", [func]);
        }
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getEditOns(renderOpts, params) {
  const { $table, row, column } = params;
  const { name } = renderOpts;
  const { model } = column;
  const isImmediate = isImmediateCell(renderOpts, params);
  return getComponentOns(renderOpts, params, (cellValue) => {
    if (isImmediate) {
      setCellValue(row, column, cellValue);
    } else {
      model.update = true;
      model.value = cellValue;
    }
  }, (eventParams) => {
    if (!isImmediate && ["VxeInput", "VxeTextarea", "$input", "$textarea"].includes(name)) {
      const cellValue = eventParams.value;
      model.update = true;
      model.value = cellValue;
      $table.updateStatus(params, cellValue);
    } else {
      $table.updateStatus(params);
    }
  });
}
function getFilterOns(renderOpts, params, option) {
  return getComponentOns(renderOpts, params, (value) => {
    option.data = value;
  }, () => {
    handleConfirmFilter(params, !import_xe_utils8.default.eqNull(option.data), option);
  });
}
function getItemOns(renderOpts, params) {
  const { $form, data, property } = params;
  return getComponentOns(renderOpts, params, (value) => {
    import_xe_utils8.default.set(data, property, value);
  }, () => {
    $form.updateStatus(params);
  });
}
function getNativeEditOns(renderOpts, params) {
  const { $table, row, column } = params;
  const { model } = column;
  return getElementOns(renderOpts, params, (evnt) => {
    const cellValue = evnt.target.value;
    if (isImmediateCell(renderOpts, params)) {
      setCellValue(row, column, cellValue);
    } else {
      model.update = true;
      model.value = cellValue;
    }
  }, (evnt) => {
    const cellValue = evnt.target.value;
    $table.updateStatus(params, cellValue);
  });
}
function getNativeFilterOns(renderOpts, params, option) {
  return getElementOns(renderOpts, params, (evnt) => {
    option.data = evnt.target.value;
  }, () => {
    handleConfirmFilter(params, !import_xe_utils8.default.eqNull(option.data), option);
  });
}
function getNativeItemOns(renderOpts, params) {
  const { $form, data, property } = params;
  return getElementOns(renderOpts, params, (evnt) => {
    const itemValue = evnt.target.value;
    import_xe_utils8.default.set(data, property, itemValue);
  }, () => {
    $form.updateStatus(params);
  });
}
function nativeEditRender(renderOpts, params) {
  const { row, column } = params;
  const { name } = renderOpts;
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return [
    h(name, Object.assign(Object.assign(Object.assign({ class: `vxe-default-${name}` }, getNativeAttrs(renderOpts)), { value: cellValue }), getNativeEditOns(renderOpts, params)))
  ];
}
function defaultCellRender(renderOpts, params) {
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function defaultEditRender(renderOpts, params) {
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function oldEditRender(renderOpts, params) {
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function oldButtonEditRender(renderOpts, params) {
  return [
    h(resolveComponent("vxe-button"), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function oldButtonsEditRender(renderOpts, params) {
  return renderOpts.children.map((childRenderOpts) => oldButtonEditRender(childRenderOpts, params)[0]);
}
function renderNativeOptgroups(renderOpts, params, renderOptionsMethods) {
  const { optionGroups, optionGroupProps = {} } = renderOpts;
  const groupOptions = optionGroupProps.options || "options";
  const groupLabel = optionGroupProps.label || "label";
  return optionGroups.map((group, gIndex) => {
    return h("optgroup", {
      key: gIndex,
      label: group[groupLabel]
    }, renderOptionsMethods(group[groupOptions], renderOpts, params));
  });
}
function renderNativeOptions(options, renderOpts, params) {
  const { optionProps = {} } = renderOpts;
  const { row, column } = params;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return options.map((option, oIndex) => {
    return h("option", {
      key: oIndex,
      value: option[valueProp],
      disabled: option[disabledProp],
      /* eslint-disable eqeqeq */
      selected: option[valueProp] == cellValue
    }, option[labelProp]);
  });
}
function nativeFilterRender(renderOpts, params) {
  const { column } = params;
  const { name } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  return column.filters.map((option, oIndex) => {
    return h(name, Object.assign(Object.assign(Object.assign({ key: oIndex, class: `vxe-default-${name}` }, attrs), { value: option.data }), getNativeFilterOns(renderOpts, params, option)));
  });
}
function defaultFilterRender(renderOpts, params) {
  const { column } = params;
  return column.filters.map((option, oIndex) => {
    const optionValue = option.data;
    return h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, renderOpts, optionValue)), getFilterOns(renderOpts, params, option)));
  });
}
function oldFilterRender(renderOpts, params) {
  const { column } = params;
  return column.filters.map((option, oIndex) => {
    const optionValue = option.data;
    return h(getOldComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, renderOpts, optionValue)), getFilterOns(renderOpts, params, option)));
  });
}
function handleFilterMethod({ option, row, column }) {
  const { data } = option;
  const cellValue = import_xe_utils8.default.get(row, column.property);
  return cellValue == data;
}
function nativeSelectEditRender(renderOpts, params) {
  return [
    h("select", Object.assign(Object.assign({ class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeEditOns(renderOpts, params)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params))
  ];
}
function defaultSelectEditRender(renderOpts, params) {
  const { row, column } = params;
  const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps, optionGroups, optionGroupProps })), getEditOns(renderOpts, params)))
  ];
}
function oldSelectEditRender(renderOpts, params) {
  const { row, column } = params;
  const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps, optionGroups, optionGroupProps })), getEditOns(renderOpts, params)))
  ];
}
function getSelectCellValue(renderOpts, { row, column }) {
  const { props = {}, options, optionGroups, optionProps = {}, optionGroupProps = {} } = renderOpts;
  const cellValue = import_xe_utils8.default.get(row, column.property);
  let selectItem;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  if (!isEmptyValue(cellValue)) {
    return import_xe_utils8.default.map(props.multiple ? cellValue : [cellValue], optionGroups ? (value) => {
      const groupOptions = optionGroupProps.options || "options";
      for (let index = 0; index < optionGroups.length; index++) {
        selectItem = import_xe_utils8.default.find(optionGroups[index][groupOptions], (item) => item[valueProp] == value);
        if (selectItem) {
          break;
        }
      }
      return selectItem ? selectItem[labelProp] : value;
    } : (value) => {
      selectItem = import_xe_utils8.default.find(options, (item) => item[valueProp] == value);
      return selectItem ? selectItem[labelProp] : value;
    }).join(", ");
  }
  return "";
}
function nativeItemRender(renderOpts, params) {
  const { data, property } = params;
  const { name } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  const itemValue = import_xe_utils8.default.get(data, property);
  return [
    h(name, Object.assign(Object.assign(Object.assign({ class: `vxe-default-${name}` }, attrs), { value: attrs && name === "input" && (attrs.type === "submit" || attrs.type === "reset") ? null : itemValue }), getNativeItemOns(renderOpts, params)))
  ];
}
function defaultItemRender(renderOpts, params) {
  const { data, property } = params;
  const itemValue = import_xe_utils8.default.get(data, property);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldItemRender(renderOpts, params) {
  const { data, property } = params;
  const itemValue = import_xe_utils8.default.get(data, property);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldButtonItemRender(renderOpts, params) {
  return [
    h(resolveComponent("vxe-button"), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function oldButtonsItemRender(renderOpts, params) {
  return renderOpts.children.map((childRenderOpts) => oldButtonItemRender(childRenderOpts, params)[0]);
}
function renderNativeFormOptions(options, renderOpts, params) {
  const { data, property } = params;
  const { optionProps = {} } = renderOpts;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const cellValue = import_xe_utils8.default.get(data, property);
  return options.map((item, oIndex) => {
    return h("option", {
      key: oIndex,
      value: item[valueProp],
      disabled: item[disabledProp],
      /* eslint-disable eqeqeq */
      selected: item[valueProp] == cellValue
    }, item[labelProp]);
  });
}
function handleExportSelectMethod(params) {
  const { row, column, options } = params;
  return options.original ? getCellValue(row, column) : getSelectCellValue(column.editRender || column.cellRender, params);
}
function defaultFormItemRender(renderOpts, params) {
  const { data, property } = params;
  const itemValue = import_xe_utils8.default.get(data, property);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function formItemRadioAndCheckboxRender(renderOpts, params) {
  const { options, optionProps } = renderOpts;
  const { data, property } = params;
  const itemValue = import_xe_utils8.default.get(data, property);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({
      options,
      optionProps
    }, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldFormItemRadioAndCheckboxRender(renderOpts, params) {
  const { name, options, optionProps = {} } = renderOpts;
  const { data, property } = params;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const itemValue = import_xe_utils8.default.get(data, property);
  const compName = getOldComponentName(name);
  if (options) {
    return [
      h(resolveComponent(`${compName}-group`), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)), {
        default: () => {
          return options.map((item, index) => {
            return h(resolveComponent(compName), {
              key: index,
              label: item[valueProp],
              content: item[labelProp],
              disabled: item[disabledProp]
            });
          });
        }
      })
    ];
  }
  return [
    h(resolveComponent(compName), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
var renderMap = {
  input: {
    autofocus: "input",
    renderEdit: nativeEditRender,
    renderDefault: nativeEditRender,
    renderFilter: nativeFilterRender,
    defaultFilterMethod: handleFilterMethod,
    renderItemContent: nativeItemRender
  },
  textarea: {
    autofocus: "textarea",
    renderEdit: nativeEditRender,
    renderItemContent: nativeItemRender
  },
  select: {
    renderEdit: nativeSelectEditRender,
    renderDefault: nativeSelectEditRender,
    renderCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderFilter(renderOpts, params) {
      const { column } = params;
      return column.filters.map((option, oIndex) => {
        return h("select", Object.assign(Object.assign({ key: oIndex, class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeFilterOns(renderOpts, params, option)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params));
      });
    },
    defaultFilterMethod: handleFilterMethod,
    renderItemContent(renderOpts, params) {
      return [
        h("select", Object.assign(Object.assign({ class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeItemOns(renderOpts, params)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeFormOptions) : renderNativeFormOptions(renderOpts.options, renderOpts, params))
      ];
    },
    exportMethod: handleExportSelectMethod
  },
  VxeInput: {
    autofocus: ".vxe-input--inner",
    renderEdit: defaultEditRender,
    renderCell(renderOpts, params) {
      const { props = {} } = renderOpts;
      const { row, column } = params;
      const digits = props.digits || conf_default.input.digits;
      let cellValue = import_xe_utils8.default.get(row, column.property);
      if (cellValue) {
        switch (props.type) {
          case "date":
          case "week":
          case "month":
          case "year":
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case "float":
            cellValue = import_xe_utils8.default.toFixed(import_xe_utils8.default.floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderDefault: defaultEditRender,
    renderFilter: defaultFilterRender,
    defaultFilterMethod: handleFilterMethod,
    renderItemContent: defaultItemRender
  },
  VxeTextarea: {
    autofocus: ".vxe-textarea--inner",
    renderItemContent: defaultItemRender
  },
  VxeButton: {
    renderDefault: defaultCellRender,
    renderItemContent: defaultFormItemRender
  },
  VxeButtonGroup: {
    renderDefault: defaultCellRender,
    renderItemContent(renderOpts, params) {
      const { options } = renderOpts;
      const { data, property } = params;
      const itemValue = import_xe_utils8.default.get(data, property);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ options }, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeSelect: {
    autofocus: ".vxe-input--inner",
    renderEdit: defaultSelectEditRender,
    renderDefault: defaultSelectEditRender,
    renderCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderFilter(renderOpts, params) {
      const { column } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      return column.filters.map((option, oIndex) => {
        const optionValue = option.data;
        return h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, params, optionValue, { options, optionProps, optionGroups, optionGroupProps })), getFilterOns(renderOpts, params, option)));
      });
    },
    defaultFilterMethod: handleFilterMethod,
    renderItemContent(renderOpts, params) {
      const { data, property } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      const itemValue = import_xe_utils8.default.get(data, property);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps, optionGroups, optionGroupProps })), getItemOns(renderOpts, params)))
      ];
    },
    exportMethod: handleExportSelectMethod
  },
  VxeRadio: {
    autofocus: ".vxe-radio--input",
    renderItemContent: defaultFormItemRender
  },
  VxeRadioGroup: {
    autofocus: ".vxe-radio--input",
    renderItemContent: formItemRadioAndCheckboxRender
  },
  VxeCheckbox: {
    autofocus: ".vxe-checkbox--input",
    renderItemContent: defaultFormItemRender
  },
  VxeCheckboxGroup: {
    autofocus: ".vxe-checkbox--input",
    renderItemContent: formItemRadioAndCheckboxRender
  },
  VxeSwitch: {
    autofocus: ".vxe-switch--button",
    renderEdit: defaultEditRender,
    renderDefault: defaultEditRender,
    renderItemContent: defaultItemRender
  },
  // 以下已废弃
  $input: {
    autofocus: ".vxe-input--inner",
    renderEdit: oldEditRender,
    renderCell(renderOpts, params) {
      const { props = {} } = renderOpts;
      const { row, column } = params;
      const digits = props.digits || conf_default.input.digits;
      let cellValue = import_xe_utils8.default.get(row, column.property);
      if (cellValue) {
        switch (props.type) {
          case "date":
          case "week":
          case "month":
          case "year":
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case "float":
            cellValue = import_xe_utils8.default.toFixed(import_xe_utils8.default.floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderDefault: oldEditRender,
    renderFilter: oldFilterRender,
    defaultFilterMethod: handleFilterMethod,
    renderItemContent: oldItemRender
  },
  $textarea: {
    autofocus: ".vxe-textarea--inner",
    renderItemContent: oldItemRender
  },
  $button: {
    renderDefault: oldButtonEditRender,
    renderItemContent: oldButtonItemRender
  },
  $buttons: {
    renderDefault: oldButtonsEditRender,
    renderItemContent: oldButtonsItemRender
  },
  $select: {
    autofocus: ".vxe-input--inner",
    renderEdit: oldSelectEditRender,
    renderDefault: oldSelectEditRender,
    renderCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderFilter(renderOpts, params) {
      const { column } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      return column.filters.map((option, oIndex) => {
        const optionValue = option.data;
        return h(getOldComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, params, optionValue, { options, optionProps, optionGroups, optionGroupProps })), getFilterOns(renderOpts, params, option)));
      });
    },
    defaultFilterMethod: handleFilterMethod,
    renderItemContent(renderOpts, params) {
      const { data, property } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      const itemValue = import_xe_utils8.default.get(data, property);
      return [
        h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps, optionGroups, optionGroupProps })), getItemOns(renderOpts, params)))
      ];
    },
    exportMethod: handleExportSelectMethod
  },
  $radio: {
    autofocus: ".vxe-radio--input",
    renderItemContent: oldFormItemRadioAndCheckboxRender
  },
  $checkbox: {
    autofocus: ".vxe-checkbox--input",
    renderItemContent: oldFormItemRadioAndCheckboxRender
  },
  $switch: {
    autofocus: ".vxe-switch--button",
    renderEdit: oldEditRender,
    renderDefault: oldEditRender,
    renderItemContent: oldItemRender
  }
  // 以上已废弃
};
var renderer = {
  mixin(opts) {
    import_xe_utils8.default.each(opts, (options, name) => renderer.add(name, options));
    return renderer;
  },
  get(name) {
    return renderMap[name] || null;
  },
  add(name, options) {
    if (name && options) {
      const renders = renderMap[name];
      if (renders) {
        if (true) {
          import_xe_utils8.default.each(options, (val, key) => {
            if (!import_xe_utils8.default.eqNull(renders[key]) && renders[key] !== val) {
              warnLog("vxe.error.coverProp", [`Renderer.${name}`, key]);
            }
          });
        }
        Object.assign(renders, options);
      } else {
        renderMap[name] = options;
      }
    }
    return renderer;
  },
  delete(name) {
    delete renderMap[name];
    return renderer;
  }
};

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/commands.js
var import_xe_utils9 = __toESM(require_xe_utils());
var VXECommandsStore = class {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    import_xe_utils9.default.each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    if (import_xe_utils9.default.isFunction(render)) {
      if (true) {
        warnLog("vxe.error.delProp", ["commands -> callback", "commandMethod"]);
      }
      render = {
        commandMethod: render
      };
    }
    if (true) {
      const confKeys = import_xe_utils9.default.keys(conf);
      import_xe_utils9.default.each(render, (item, key) => {
        if (confKeys.includes(key)) {
          warnLog("vxe.error.coverProp", [name, key]);
        }
      });
    }
    this.store[name] = conf ? import_xe_utils9.default.merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    import_xe_utils9.default.objectEach(this.store, callback);
  }
};
var commands = new VXECommandsStore();
if (true) {
  Object.assign(commands, { _name: "Commands" });
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/menus.js
var import_xe_utils10 = __toESM(require_xe_utils());
var VXEMenusStore = class {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    import_xe_utils10.default.each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    if (import_xe_utils10.default.isFunction(render)) {
      if (true) {
        warnLog("vxe.error.delProp", ["menus -> callback", "menuMethod"]);
      }
      render = {
        menuMethod: render
      };
    }
    if (true) {
      const confKeys = import_xe_utils10.default.keys(conf);
      import_xe_utils10.default.each(render, (item, key) => {
        if (confKeys.includes(key)) {
          warnLog("vxe.error.coverProp", [name, key]);
        }
      });
    }
    this.store[name] = conf ? import_xe_utils10.default.merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    import_xe_utils10.default.objectEach(this.store, callback);
  }
};
var menus = new VXEMenusStore();
if (true) {
  Object.assign(menus, { _name: "Menus" });
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/store.js
var import_xe_utils11 = __toESM(require_xe_utils());
var Store = class {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    import_xe_utils11.default.each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, options) {
    const conf = this.store[name];
    if (true) {
      const confKeys = import_xe_utils11.default.keys(conf);
      import_xe_utils11.default.each(options, (item, key) => {
        if (confKeys.includes(key)) {
          warnLog("vxe.error.coverProp", [name, key]);
        }
      });
    }
    this.store[name] = conf ? import_xe_utils11.default.merge(conf, options) : options;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    import_xe_utils11.default.objectEach(this.store, callback);
  }
};
var store_default = Store;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/validators.js
var validators = new store_default();
if (true) {
  Object.assign(validators, { _name: "Validators" });
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/hooks.js
var hooks = new store_default();

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/src/theme.js
function setTheme(name) {
  let theme = name || conf_default.theme;
  if (!theme || theme === "default") {
    theme = "light";
  }
  conf_default.theme = theme;
  if (typeof document !== "undefined") {
    const documentElement = document.documentElement;
    if (documentElement) {
      documentElement.setAttribute("data-vxe-ui-theme", theme);
    }
  }
}
function getTheme() {
  return conf_default.theme;
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/v-x-e-table/index.js
function getExportOrImpotType(types, flag) {
  const rest = [];
  import_xe_utils12.default.objectEach(types, (val, type) => {
    if (val === 0 || val === flag) {
      rest.push(type);
    }
  });
  return rest;
}
var installedPlugins = [];
function use(Plugin, options) {
  if (Plugin && Plugin.install) {
    if (installedPlugins.indexOf(Plugin) === -1) {
      Plugin.install(VXETable, options);
      installedPlugins.push(Plugin);
    }
  }
  return VXETable;
}
function t(key, args) {
  return conf_default.i18n(key, args);
}
function _t(key, args) {
  return key ? import_xe_utils12.default.toValueString(conf_default.translate ? conf_default.translate(key, args) : key) : "";
}
var setConfig = (options) => {
  if (options) {
    if (options.theme) {
      setTheme(options.theme);
    }
    if (options.zIndex) {
      index_esm_default.setCurrent(options.zIndex);
    }
    import_xe_utils12.default.merge(conf_default, options);
  }
  return VXETable;
};
var VXETableConfig = class {
  /**
   * 获取当前的 zIndex
   */
  get zIndex() {
    return getLastZIndex();
  }
  /**
   * 获取下一个 zIndex
   */
  get nextZIndex() {
    return nextZIndex();
  }
  /**
   * 获取所有导出类型
   */
  get exportTypes() {
    return getExportOrImpotType(conf_default.export.types, 1);
  }
  /**
   * 获取所有导入类型
   */
  get importTypes() {
    return getExportOrImpotType(conf_default.export.types, 2);
  }
};
var globalConfs = new VXETableConfig();
var v = "v4";
var setup = (options) => {
  if (true) {
    warnLog("vxe.error.delFunc", ["setup", "setConfig"]);
  }
  setConfig(options);
  return conf_default;
};
var config = (options) => {
  if (true) {
    warnLog("vxe.error.delFunc", ["setup", "setConfig"]);
  }
  setConfig(options);
  return conf_default;
};
function setIcon(options) {
  if (options) {
    Object.assign(conf_default.icon, options);
  }
  return VXETable;
}
var globalStore = {};
var components = {};
function getComponent(name) {
  return components[name] || null;
}
function component(comp) {
  if (comp && comp.name) {
    components[comp.name] = comp;
  }
}
var version = "4.6.25";
var tableVersion = version;
var VXETable = {
  v,
  version,
  tableVersion,
  setConfig,
  setIcon,
  globalStore,
  interceptor,
  renderer,
  commands,
  formats,
  validators,
  menus,
  hooks,
  use,
  t,
  _t,
  setTheme,
  getTheme,
  getComponent,
  // 已废弃
  config,
  setup,
  globalConfs
};
var VxeUI = VXETable;
setTheme("light");

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/filter/src/panel.js
var panel_default = defineComponent({
  name: "VxeTableFilterPanel",
  props: {
    filterStore: Object
  },
  setup(props) {
    const $xetable = inject("$xetable", {});
    const { reactData: tableReactData, internalData: tableInternalData, getComputeMaps } = $xetable;
    const { computeFilterOpts } = getComputeMaps();
    const computeHasCheckOption = computed(() => {
      const { filterStore } = props;
      return filterStore && filterStore.options.some((option) => option.checked);
    });
    const filterCheckAllEvent = (evnt, value) => {
      const { filterStore } = props;
      filterStore.options.forEach((option) => {
        option._checked = value;
        option.checked = value;
      });
      filterStore.isAllSelected = value;
      filterStore.isIndeterminate = false;
    };
    const confirmFilter = (evnt) => {
      const { filterStore } = props;
      filterStore.options.forEach((option) => {
        option.checked = option._checked;
      });
      $xetable.confirmFilterEvent(evnt);
    };
    const changeRadioOption = (evnt, checked, item) => {
      const { filterStore } = props;
      filterStore.options.forEach((option) => {
        option._checked = false;
      });
      item._checked = checked;
      $xetable.checkFilterOptions();
      confirmFilter(evnt);
    };
    const resetFilter = (evnt) => {
      const { filterStore } = props;
      $xetable.handleClearFilter(filterStore.column);
      $xetable.confirmFilterEvent(evnt);
    };
    const changeMultipleOption = (evnt, checked, item) => {
      item._checked = checked;
      $xetable.checkFilterOptions();
    };
    const changeOption = (evnt, checked, item) => {
      const { filterStore } = props;
      if (filterStore.multiple) {
        changeMultipleOption(evnt, checked, item);
      } else {
        changeRadioOption(evnt, checked, item);
      }
    };
    const changeAllOption = (evnt, checked) => {
      const { filterStore } = props;
      if (filterStore.multiple) {
        filterCheckAllEvent(evnt, checked);
      } else {
        resetFilter(evnt);
      }
    };
    const $panel = {
      changeRadioOption,
      changeMultipleOption,
      changeAllOption,
      changeOption,
      confirmFilter,
      resetFilter
    };
    const renderOptions = (filterRender, compConf) => {
      const { filterStore } = props;
      const { column, multiple, maxHeight } = filterStore;
      const { slots } = column;
      const filterSlot = slots ? slots.filter : null;
      const params = Object.assign({}, tableInternalData._currFilterParams, { $panel, $table: $xetable });
      if (filterSlot) {
        return [
          h("div", {
            class: "vxe-table--filter-template"
          }, $xetable.callSlot(filterSlot, params))
        ];
      } else if (compConf && compConf.renderFilter) {
        return [
          h("div", {
            class: "vxe-table--filter-template"
          }, getSlotVNs(compConf.renderFilter(filterRender, params)))
        ];
      }
      const isAllChecked = multiple ? filterStore.isAllSelected : !filterStore.options.some((item) => item._checked);
      const isAllIndeterminate = multiple && filterStore.isIndeterminate;
      return [
        h("ul", {
          class: "vxe-table--filter-header"
        }, [
          h("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": isAllChecked,
              "is--indeterminate": isAllIndeterminate
            }],
            title: conf_default.i18n(multiple ? "vxe.table.allTitle" : "vxe.table.allFilter"),
            onClick: (evnt) => {
              changeAllOption(evnt, !filterStore.isAllSelected);
            }
          }, (multiple ? [
            h("span", {
              class: ["vxe-checkbox--icon", isAllIndeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            h("span", {
              class: "vxe-checkbox--label"
            }, conf_default.i18n("vxe.table.allFilter"))
          ]))
        ]),
        h("ul", {
          class: "vxe-table--filter-body",
          style: maxHeight ? {
            maxHeight: `${maxHeight}px`
          } : {}
        }, filterStore.options.map((item) => {
          const isChecked = item._checked;
          const isIndeterminate = false;
          return h("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": item._checked
            }],
            title: item.label,
            onClick: (evnt) => {
              changeOption(evnt, !item._checked, item);
            }
          }, (multiple ? [
            h("span", {
              class: ["vxe-checkbox--icon", isIndeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            h("span", {
              class: "vxe-checkbox--label"
            }, formatText(item.label, 1))
          ]));
        }))
      ];
    };
    const renderFooters = () => {
      const { filterStore } = props;
      const { column, multiple } = filterStore;
      const filterOpts = computeFilterOpts.value;
      const hasCheckOption = computeHasCheckOption.value;
      const filterRender = column.filterRender;
      const compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
      const isDisabled = !hasCheckOption && !filterStore.isAllSelected && !filterStore.isIndeterminate;
      return multiple && (!compConf || compConf.showFilterFooter !== false) ? [
        h("div", {
          class: "vxe-table--filter-footer"
        }, [
          h("button", {
            class: {
              "is--disabled": isDisabled
            },
            disabled: isDisabled,
            onClick: confirmFilter
          }, filterOpts.confirmButtonText || conf_default.i18n("vxe.table.confirmFilter")),
          h("button", {
            onClick: resetFilter
          }, filterOpts.resetButtonText || conf_default.i18n("vxe.table.resetFilter"))
        ])
      ] : [];
    };
    const renderVN = () => {
      const { filterStore } = props;
      const { initStore } = tableReactData;
      const { column } = filterStore;
      const filterRender = column ? column.filterRender : null;
      const compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
      const filterClassName = compConf ? compConf.filterClassName : "";
      const params = Object.assign({}, tableInternalData._currFilterParams, { $panel, $table: $xetable });
      return h("div", {
        class: [
          "vxe-table--filter-wrapper",
          "filter--prevent-default",
          getPropClass(filterClassName, params),
          {
            "is--animat": $xetable.props.animat,
            "is--multiple": filterStore.multiple,
            "is--active": filterStore.visible
          }
        ],
        style: filterStore.style
      }, initStore.filter && filterStore.visible ? renderOptions(filterRender, compConf).concat(renderFooters()) : []);
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/filter/src/hook.js
var import_xe_utils13 = __toESM(require_xe_utils());
var tableFilterMethodKeys = ["setFilter", "clearFilter", "getCheckedFilters"];
var tableFilterHook = {
  setupTable($xetable) {
    const { props, reactData, internalData } = $xetable;
    const { refTableBody, refTableFilter } = $xetable.getRefMaps();
    const { computeFilterOpts, computeMouseOpts } = $xetable.getComputeMaps();
    const filterPrivateMethods = {
      checkFilterOptions() {
        const { filterStore } = reactData;
        filterStore.isAllSelected = filterStore.options.every((item) => item._checked);
        filterStore.isIndeterminate = !filterStore.isAllSelected && filterStore.options.some((item) => item._checked);
      },
      /**
       * 点击筛选事件
       * 当筛选图标被点击时触发
       * 更新选项是否全部状态
       * 打开筛选面板
       * @param {Event} evnt 事件
       * @param {ColumnInfo} column 列配置
       * @param {Object} params 参数
       */
      triggerFilterEvent(evnt, column, params) {
        const { initStore, filterStore } = reactData;
        if (filterStore.column === column && filterStore.visible) {
          filterStore.visible = false;
        } else {
          const { target: targetElem, pageX } = evnt;
          const { visibleWidth } = getDomNode();
          const { filters, filterMultiple, filterRender } = column;
          const compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
          const filterRecoverMethod = column.filterRecoverMethod || (compConf ? compConf.filterRecoverMethod : null);
          internalData._currFilterParams = params;
          Object.assign(filterStore, {
            multiple: filterMultiple,
            options: filters,
            column,
            style: null
          });
          filterStore.options.forEach((option) => {
            const { _checked, checked } = option;
            option._checked = checked;
            if (!checked && _checked !== checked) {
              if (filterRecoverMethod) {
                filterRecoverMethod({ option, column, $table: $xetable });
              }
            }
          });
          this.checkFilterOptions();
          filterStore.visible = true;
          initStore.filter = true;
          nextTick(() => {
            const tableBody = refTableBody.value;
            const bodyElem = tableBody.$el;
            const tableFilter = refTableFilter.value;
            const filterWrapperElem = tableFilter ? tableFilter.$el : null;
            let filterWidth = 0;
            let filterHeight = 0;
            let filterHeadElem = null;
            let filterFootElem = null;
            if (filterWrapperElem) {
              filterWidth = filterWrapperElem.offsetWidth;
              filterHeight = filterWrapperElem.offsetHeight;
              filterHeadElem = filterWrapperElem.querySelector(".vxe-table--filter-header");
              filterFootElem = filterWrapperElem.querySelector(".vxe-table--filter-footer");
            }
            const centerWidth = filterWidth / 2;
            const minMargin = 10;
            const maxLeft = bodyElem.clientWidth - filterWidth - minMargin;
            let left, right;
            const style = {
              top: `${targetElem.offsetTop + targetElem.offsetParent.offsetTop + targetElem.offsetHeight + 8}px`
            };
            let maxHeight = null;
            if (filterHeight >= bodyElem.clientHeight) {
              maxHeight = Math.max(60, bodyElem.clientHeight - (filterFootElem ? filterFootElem.offsetHeight : 0) - (filterHeadElem ? filterHeadElem.offsetHeight : 0));
            }
            if (column.fixed === "left") {
              left = targetElem.offsetLeft + targetElem.offsetParent.offsetLeft - centerWidth;
            } else if (column.fixed === "right") {
              right = targetElem.offsetParent.offsetWidth - targetElem.offsetLeft + (targetElem.offsetParent.offsetParent.offsetWidth - targetElem.offsetParent.offsetLeft) - column.renderWidth - centerWidth;
            } else {
              left = targetElem.offsetLeft + targetElem.offsetParent.offsetLeft - centerWidth - bodyElem.scrollLeft;
            }
            if (left) {
              const overflowWidth = pageX + filterWidth - centerWidth + minMargin - visibleWidth;
              if (overflowWidth > 0) {
                left -= overflowWidth;
              }
              style.left = `${Math.min(maxLeft, Math.max(minMargin, left))}px`;
            } else if (right) {
              const overflowWidth = pageX + filterWidth - centerWidth + minMargin - visibleWidth;
              if (overflowWidth > 0) {
                right += overflowWidth;
              }
              style.right = `${Math.max(minMargin, right)}px`;
            }
            filterStore.style = style;
            filterStore.maxHeight = maxHeight;
          });
        }
        $xetable.dispatchEvent("filter-visible", { column, field: column.field, property: column.field, filterList: $xetable.getCheckedFilters(), visible: filterStore.visible }, evnt);
      },
      handleClearFilter(column) {
        if (column) {
          const { filters, filterRender } = column;
          if (filters) {
            const compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
            const filterResetMethod = column.filterResetMethod || (compConf ? compConf.filterResetMethod : null);
            filters.forEach((item) => {
              item._checked = false;
              item.checked = false;
              if (!filterResetMethod) {
                item.data = import_xe_utils13.default.clone(item.resetValue, true);
              }
            });
            if (filterResetMethod) {
              filterResetMethod({ options: filters, column, $table: $xetable });
            }
          }
        }
      },
      /**
       * 确认筛选
       * 当筛选面板中的确定按钮被按下时触发
       * @param {Event} evnt 事件
       */
      confirmFilterEvent(evnt) {
        const { mouseConfig } = props;
        const { filterStore, scrollXLoad: oldScrollXLoad, scrollYLoad: oldScrollYLoad } = reactData;
        const filterOpts = computeFilterOpts.value;
        const mouseOpts = computeMouseOpts.value;
        const { column } = filterStore;
        const { field } = column;
        const values = [];
        const datas = [];
        column.filters.forEach((item) => {
          if (item.checked) {
            values.push(item.value);
            datas.push(item.data);
          }
        });
        const filterList = $xetable.getCheckedFilters();
        const params = { $table: $xetable, $event: evnt, column, field, property: field, values, datas, filters: filterList, filterList };
        if (!filterOpts.remote) {
          $xetable.handleTableData(true);
          $xetable.checkSelectionStatus();
        }
        if (mouseConfig && mouseOpts.area && $xetable.handleFilterEvent) {
          $xetable.handleFilterEvent(evnt, params);
        }
        $xetable.dispatchEvent("filter-change", params, evnt);
        $xetable.closeFilter();
        $xetable.updateFooter().then(() => {
          const { scrollXLoad, scrollYLoad } = reactData;
          if (oldScrollXLoad || scrollXLoad || (oldScrollYLoad || scrollYLoad)) {
            if (oldScrollXLoad || scrollXLoad) {
              $xetable.updateScrollXSpace();
            }
            if (oldScrollYLoad || scrollYLoad) {
              $xetable.updateScrollYSpace();
            }
            return $xetable.refreshScroll();
          }
        }).then(() => {
          $xetable.updateCellAreas();
          return $xetable.recalculate(true);
        }).then(() => {
          setTimeout(() => $xetable.recalculate(), 50);
        });
      }
    };
    const filterMethods = {
      /**
       * 手动弹出筛选面板
       * @param column
       */
      openFilter(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column && column.filters) {
          const { elemStore } = internalData;
          const { fixed } = column;
          return $xetable.scrollToColumn(column).then(() => {
            const headerWrapperRef = elemStore[`${fixed || "main"}-header-wrapper`] || elemStore["main-header-wrapper"];
            const headerWrapperElem = headerWrapperRef ? headerWrapperRef.value : null;
            if (headerWrapperElem) {
              const filterBtnElem = headerWrapperElem.querySelector(`.vxe-header--column.${column.id} .vxe-filter--btn`);
              triggerEvent(filterBtnElem, "click");
            }
          });
        }
        return nextTick();
      },
      /**
       * 修改筛选条件列表
       * @param {ColumnInfo} fieldOrColumn 列或字段名
       * @param {Array} options 选项
       */
      setFilter(fieldOrColumn, options) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column && column.filters) {
          column.filters = toFilters(options || []);
        }
        return nextTick();
      },
      /**
       * 清空指定列的筛选条件
       * 如果为空则清空所有列的筛选条件
       * @param {String} fieldOrColumn 列或字段名
       */
      clearFilter(fieldOrColumn) {
        const { filterStore } = reactData;
        const { tableFullColumn } = internalData;
        const filterOpts = computeFilterOpts.value;
        let column;
        if (fieldOrColumn) {
          column = handleFieldOrColumn($xetable, fieldOrColumn);
          if (column) {
            filterPrivateMethods.handleClearFilter(column);
          }
        } else {
          tableFullColumn.forEach(filterPrivateMethods.handleClearFilter);
        }
        if (!fieldOrColumn || column !== filterStore.column) {
          Object.assign(filterStore, {
            isAllSelected: false,
            isIndeterminate: false,
            style: null,
            options: [],
            column: null,
            multiple: false,
            visible: false
          });
        }
        if (!filterOpts.remote) {
          return $xetable.updateData();
        }
        return nextTick();
      },
      getCheckedFilters() {
        const { tableFullColumn } = internalData;
        const filterList = [];
        tableFullColumn.forEach((column) => {
          const { field, filters } = column;
          const valueList = [];
          const dataList = [];
          if (filters && filters.length) {
            filters.forEach((item) => {
              if (item.checked) {
                valueList.push(item.value);
                dataList.push(item.data);
              }
            });
            if (valueList.length) {
              filterList.push({ column, field, property: field, values: valueList, datas: dataList });
            }
          }
        });
        return filterList;
      }
    };
    return Object.assign(Object.assign({}, filterMethods), filterPrivateMethods);
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableFilterMethodKeys);
  }
};
var hook_default = tableFilterHook;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/dynamics/index.js
var dynamicContainerElem;
var dynamicStore = reactive({
  modals: [],
  drawers: []
});
var VxeDynamics = defineComponent({
  setup() {
    return () => {
      const { modals, drawers } = dynamicStore;
      return [
        modals.length ? h("div", {
          class: "vxe-dynamics--modal"
        }, modals.map((item) => h(resolveComponent("vxe-modal"), item))) : createCommentVNode(),
        drawers.length ? h("div", {
          class: "vxe-dynamics--drawer"
        }, drawers.map((item) => h(resolveComponent("vxe-drawer"), item))) : createCommentVNode()
      ];
    };
  }
});
var dynamicApp = createApp(VxeDynamics);
function checkDynamic() {
  if (!dynamicContainerElem) {
    dynamicContainerElem = document.createElement("div");
    dynamicContainerElem.className = "vxe-dynamics";
    document.body.appendChild(dynamicContainerElem);
    dynamicApp.mount(dynamicContainerElem);
  }
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/filter/index.js
var VxeTableFilterModule = {
  Panel: panel_default,
  install(app) {
    VXETable.hooks.add("$tableFilter", hook_default);
    app.component(panel_default.name, panel_default);
  }
};
var Filter = VxeTableFilterModule;
dynamicApp.component(panel_default.name, panel_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/menu/src/panel.js
var import_xe_utils14 = __toESM(require_xe_utils());
var panel_default2 = defineComponent({
  name: "VxeTableMenuPanel",
  setup(props, context) {
    const xID = import_xe_utils14.default.uniqueId();
    const $xetable = inject("$xetable", {});
    const { reactData: tableReactData } = $xetable;
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xemenupanel = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const renderVN = () => {
      const { ctxMenuStore } = tableReactData;
      const { computeMenuOpts } = $xetable.getComputeMaps();
      const menuOpts = computeMenuOpts.value;
      return h(Teleport, {
        to: "body",
        disabled: false
      }, [
        h("div", {
          ref: refElem,
          class: ["vxe-table--context-menu-wrapper", menuOpts.className, {
            "is--visible": ctxMenuStore.visible
          }],
          style: ctxMenuStore.style
        }, ctxMenuStore.list.map((options, gIndex) => {
          return options.every((item) => item.visible === false) ? createCommentVNode() : h("ul", {
            class: "vxe-context-menu--option-wrapper",
            key: gIndex
          }, options.map((item, index) => {
            const hasChildMenus = item.children && item.children.some((child) => child.visible !== false);
            return item.visible === false ? null : h("li", {
              class: [item.className, {
                "link--disabled": item.disabled,
                "link--active": item === ctxMenuStore.selected
              }],
              key: `${gIndex}_${index}`
            }, [
              h("a", {
                class: "vxe-context-menu--link",
                onClick(evnt) {
                  $xetable.ctxMenuLinkEvent(evnt, item);
                },
                onMouseover(evnt) {
                  $xetable.ctxMenuMouseoverEvent(evnt, item);
                },
                onMouseout(evnt) {
                  $xetable.ctxMenuMouseoutEvent(evnt, item);
                }
              }, [
                h("i", {
                  class: ["vxe-context-menu--link-prefix", item.prefixIcon]
                }),
                h("span", {
                  class: "vxe-context-menu--link-content"
                }, getFuncText(item.name)),
                h("i", {
                  class: ["vxe-context-menu--link-suffix", hasChildMenus ? item.suffixIcon || "suffix--haschild" : item.suffixIcon]
                })
              ]),
              hasChildMenus ? h("ul", {
                class: ["vxe-table--context-menu-clild-wrapper", {
                  "is--show": item === ctxMenuStore.selected && ctxMenuStore.showChild
                }]
              }, item.children.map((child, cIndex) => {
                return child.visible === false ? null : h("li", {
                  class: [child.className, {
                    "link--disabled": child.disabled,
                    "link--active": child === ctxMenuStore.selectChild
                  }],
                  key: `${gIndex}_${index}_${cIndex}`
                }, [
                  h("a", {
                    class: "vxe-context-menu--link",
                    onClick(evnt) {
                      $xetable.ctxMenuLinkEvent(evnt, child);
                    },
                    onMouseover(evnt) {
                      $xetable.ctxMenuMouseoverEvent(evnt, item, child);
                    },
                    onMouseout(evnt) {
                      $xetable.ctxMenuMouseoutEvent(evnt, item);
                    }
                  }, [
                    h("i", {
                      class: ["vxe-context-menu--link-prefix", child.prefixIcon]
                    }),
                    h("span", {
                      class: "vxe-context-menu--link-content"
                    }, getFuncText(child.name))
                  ])
                ]);
              })) : null
            ]);
          }));
        }))
      ]);
    };
    $xemenupanel.renderVN = renderVN;
    return $xemenupanel;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/menu/src/hooks.js
var import_xe_utils16 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/tools/event.js
var import_xe_utils15 = __toESM(require_xe_utils());
var EVENT_KEYS = {
  F2: "F2",
  ESCAPE: "Escape",
  ENTER: "Enter",
  TAB: "Tab",
  DELETE: "Delete",
  BACKSPACE: "Backspace",
  SPACEBAR: " ",
  CONTEXT_MENU: "ContextMenu",
  ARROW_UP: "ArrowUp",
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown"
};
var convertEventKeys = {
  " ": "Spacebar",
  Apps: EVENT_KEYS.CONTEXT_MENU,
  Del: EVENT_KEYS.DELETE,
  Up: EVENT_KEYS.ARROW_UP,
  Down: EVENT_KEYS.ARROW_DOWN,
  Left: EVENT_KEYS.ARROW_LEFT,
  Right: EVENT_KEYS.ARROW_RIGHT
};
var wheelName = browse.firefox ? "DOMMouseScroll" : "mousewheel";
var eventStore = [];
var hasEventKey = (evnt, targetKey) => {
  const { key } = evnt;
  targetKey = targetKey.toLowerCase();
  return key ? targetKey === key.toLowerCase() || !!(convertEventKeys[key] && convertEventKeys[key].toLowerCase() === targetKey) : false;
};
function triggerEvent2(evnt) {
  const isWheel = evnt.type === wheelName;
  eventStore.forEach(({ type, cb }) => {
    if (!evnt.cancelBubble) {
      if (type === evnt.type || isWheel && type === "mousewheel") {
        cb(evnt);
      }
    }
  });
}
var GlobalEvent = {
  on(comp, type, cb) {
    eventStore.push({ comp, type, cb });
  },
  off(comp, type) {
    import_xe_utils15.default.remove(eventStore, (item) => item.comp === comp && item.type === type);
  },
  trigger: triggerEvent2,
  eqKeypad(evnt, keyVal) {
    const { key } = evnt;
    if (keyVal.toLowerCase() === key.toLowerCase()) {
      return true;
    }
    return false;
  }
};
if (browse.isDoc) {
  if (!browse.msie) {
    window.addEventListener("copy", triggerEvent2, false);
    window.addEventListener("cut", triggerEvent2, false);
    window.addEventListener("paste", triggerEvent2, false);
  }
  document.addEventListener("keydown", triggerEvent2, false);
  document.addEventListener("contextmenu", triggerEvent2, false);
  window.addEventListener("mousedown", triggerEvent2, false);
  window.addEventListener("blur", triggerEvent2, false);
  window.addEventListener("resize", triggerEvent2, false);
  window.addEventListener(wheelName, import_xe_utils15.default.throttle(triggerEvent2, 100, { leading: true, trailing: false }), { passive: true, capture: false });
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/menu/src/hooks.js
var tableMenuMethodKeys = ["closeMenu"];
var tableMenuHook = {
  setupTable($xetable) {
    const { xID, props, reactData, internalData } = $xetable;
    const { refElem, refTableFilter, refTableMenu } = $xetable.getRefMaps();
    const { computeMouseOpts, computeIsMenu, computeMenuOpts } = $xetable.getComputeMaps();
    let menuMethods = {};
    let menuPrivateMethods = {};
    const handleOpenMenuEvent = (evnt, type, params) => {
      const { ctxMenuStore } = reactData;
      const isMenu = computeIsMenu.value;
      const menuOpts = computeMenuOpts.value;
      const config2 = menuOpts[type];
      const visibleMethod = menuOpts.visibleMethod;
      if (config2) {
        const { options, disabled } = config2;
        if (disabled) {
          evnt.preventDefault();
        } else if (isMenu && options && options.length) {
          params.options = options;
          $xetable.preventEvent(evnt, "event.showMenu", params, () => {
            if (!visibleMethod || visibleMethod(params)) {
              evnt.preventDefault();
              $xetable.updateZindex();
              const { scrollTop, scrollLeft, visibleHeight, visibleWidth } = getDomNode();
              let top = evnt.clientY + scrollTop;
              let left = evnt.clientX + scrollLeft;
              const handleVisible = () => {
                internalData._currMenuParams = params;
                Object.assign(ctxMenuStore, {
                  visible: true,
                  list: options,
                  selected: null,
                  selectChild: null,
                  showChild: false,
                  style: {
                    zIndex: internalData.tZindex,
                    top: `${top}px`,
                    left: `${left}px`
                  }
                });
                nextTick(() => {
                  const tableMenu = refTableMenu.value;
                  const ctxElem = tableMenu.getRefMaps().refElem.value;
                  const clientHeight = ctxElem.clientHeight;
                  const clientWidth = ctxElem.clientWidth;
                  const { boundingTop, boundingLeft } = getAbsolutePos(ctxElem);
                  const offsetTop = boundingTop + clientHeight - visibleHeight;
                  const offsetLeft = boundingLeft + clientWidth - visibleWidth;
                  if (offsetTop > -10) {
                    ctxMenuStore.style.top = `${Math.max(scrollTop + 2, top - clientHeight - 2)}px`;
                  }
                  if (offsetLeft > -10) {
                    ctxMenuStore.style.left = `${Math.max(scrollLeft + 2, left - clientWidth - 2)}px`;
                  }
                });
              };
              const { keyboard, row, column } = params;
              if (keyboard && row && column) {
                $xetable.scrollToRow(row, column).then(() => {
                  const cell = $xetable.getCell(row, column);
                  if (cell) {
                    const { boundingTop, boundingLeft } = getAbsolutePos(cell);
                    top = boundingTop + scrollTop + Math.floor(cell.offsetHeight / 2);
                    left = boundingLeft + scrollLeft + Math.floor(cell.offsetWidth / 2);
                  }
                  handleVisible();
                });
              } else {
                handleVisible();
              }
            } else {
              menuMethods.closeMenu();
            }
          });
        }
      }
      $xetable.closeFilter();
    };
    menuMethods = {
      /**
       * 关闭快捷菜单
       */
      closeMenu() {
        Object.assign(reactData.ctxMenuStore, {
          visible: false,
          selected: null,
          selectChild: null,
          showChild: false
        });
        return nextTick();
      }
    };
    menuPrivateMethods = {
      /**
       * 处理菜单的移动
       */
      moveCtxMenu(evnt, ctxMenuStore, property, hasOper, operRest, menuList) {
        let selectItem;
        const selectIndex = import_xe_utils16.default.findIndexOf(menuList, (item) => ctxMenuStore[property] === item);
        if (hasOper) {
          if (operRest && hasChildrenList(ctxMenuStore.selected)) {
            ctxMenuStore.showChild = true;
          } else {
            ctxMenuStore.showChild = false;
            ctxMenuStore.selectChild = null;
          }
        } else if (hasEventKey(evnt, EVENT_KEYS.ARROW_UP)) {
          for (let len = selectIndex - 1; len >= 0; len--) {
            if (menuList[len].visible !== false) {
              selectItem = menuList[len];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[menuList.length - 1];
        } else if (hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN)) {
          for (let index = selectIndex + 1; index < menuList.length; index++) {
            if (menuList[index].visible !== false) {
              selectItem = menuList[index];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[0];
        } else if (ctxMenuStore[property] && (hasEventKey(evnt, EVENT_KEYS.ENTER) || hasEventKey(evnt, EVENT_KEYS.SPACEBAR))) {
          menuPrivateMethods.ctxMenuLinkEvent(evnt, ctxMenuStore[property]);
        }
      },
      handleOpenMenuEvent,
      /**
       * 快捷菜单事件处理
       */
      handleGlobalContextmenuEvent(evnt) {
        const { mouseConfig, menuConfig } = props;
        const { editStore, ctxMenuStore } = reactData;
        const { visibleColumn } = internalData;
        const tableFilter = refTableFilter.value;
        const tableMenu = refTableMenu.value;
        const mouseOpts = computeMouseOpts.value;
        const menuOpts = computeMenuOpts.value;
        const el = refElem.value;
        const { selected } = editStore;
        const layoutList = ["header", "body", "footer"];
        if (isEnableConf(menuConfig)) {
          if (ctxMenuStore.visible && tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
            evnt.preventDefault();
            return;
          }
          if (internalData._keyCtx) {
            const type = "body";
            const params = { type, $table: $xetable, keyboard: true, columns: visibleColumn.slice(0), $event: evnt };
            if (mouseConfig && mouseOpts.area) {
              const activeArea = $xetable.getActiveCellArea();
              if (activeArea && activeArea.row && activeArea.column) {
                params.row = activeArea.row;
                params.column = activeArea.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            } else if (mouseConfig && mouseOpts.selected) {
              if (selected.row && selected.column) {
                params.row = selected.row;
                params.column = selected.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            }
          }
          for (let index = 0; index < layoutList.length; index++) {
            const layout = layoutList[index];
            const columnTargetNode = getEventTargetNode(evnt, el, `vxe-${layout}--column`, (target) => {
              return target.parentNode.parentNode.parentNode.getAttribute("xid") === xID;
            });
            const params = { type: layout, $table: $xetable, columns: visibleColumn.slice(0), $event: evnt };
            if (columnTargetNode.flag) {
              const cell = columnTargetNode.targetElem;
              const columnNodeRest = $xetable.getColumnNode(cell);
              const column = columnNodeRest ? columnNodeRest.item : null;
              let typePrefix = `${layout}-`;
              if (column) {
                Object.assign(params, { column, columnIndex: $xetable.getColumnIndex(column), cell });
              }
              if (layout === "body") {
                const rowNodeRest = $xetable.getRowNode(cell.parentNode);
                const row = rowNodeRest ? rowNodeRest.item : null;
                typePrefix = "";
                if (row) {
                  params.row = row;
                  params.rowIndex = $xetable.getRowIndex(row);
                }
              }
              const eventType = `${typePrefix}cell-menu`;
              handleOpenMenuEvent(evnt, layout, params);
              $xetable.dispatchEvent(eventType, params, evnt);
              return;
            } else if (getEventTargetNode(evnt, el, `vxe-table--${layout}-wrapper`, (target) => target.getAttribute("xid") === xID).flag) {
              if (menuOpts.trigger === "cell") {
                evnt.preventDefault();
              } else {
                handleOpenMenuEvent(evnt, layout, params);
              }
              return;
            }
          }
        }
        if (tableFilter && !getEventTargetNode(evnt, tableFilter.$el).flag) {
          $xetable.closeFilter();
        }
        menuMethods.closeMenu();
      },
      ctxMenuMouseoverEvent(evnt, item, child) {
        const menuElem = evnt.currentTarget;
        const { ctxMenuStore } = reactData;
        evnt.preventDefault();
        evnt.stopPropagation();
        ctxMenuStore.selected = item;
        ctxMenuStore.selectChild = child;
        if (!child) {
          ctxMenuStore.showChild = hasChildrenList(item);
          if (ctxMenuStore.showChild) {
            nextTick(() => {
              const childWrapperElem = menuElem.nextElementSibling;
              if (childWrapperElem) {
                const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(menuElem);
                const posTop = boundingTop + menuElem.offsetHeight;
                const posLeft = boundingLeft + menuElem.offsetWidth;
                let left = "";
                let right = "";
                if (posLeft + childWrapperElem.offsetWidth > visibleWidth - 10) {
                  left = "auto";
                  right = `${menuElem.offsetWidth}px`;
                }
                let top = "";
                let bottom = "";
                if (posTop + childWrapperElem.offsetHeight > visibleHeight - 10) {
                  top = "auto";
                  bottom = "0";
                }
                childWrapperElem.style.left = left;
                childWrapperElem.style.right = right;
                childWrapperElem.style.top = top;
                childWrapperElem.style.bottom = bottom;
              }
            });
          }
        }
      },
      ctxMenuMouseoutEvent(evnt, item) {
        const { ctxMenuStore } = reactData;
        if (!item.children) {
          ctxMenuStore.selected = null;
        }
        ctxMenuStore.selectChild = null;
      },
      /**
       * 快捷菜单点击事件
       */
      ctxMenuLinkEvent(evnt, menu) {
        if (!menu.disabled && (menu.code || !menu.children || !menu.children.length)) {
          const gMenuOpts = VXETable.menus.get(menu.code);
          const params = Object.assign({}, internalData._currMenuParams, { menu, $table: $xetable, $grid: $xetable.xegrid, $event: evnt });
          const tmMethod = gMenuOpts ? gMenuOpts.tableMenuMethod || gMenuOpts.menuMethod : null;
          if (tmMethod) {
            tmMethod(params, evnt);
          }
          $xetable.dispatchEvent("menu-click", params, evnt);
          menuMethods.closeMenu();
        }
      }
    };
    return Object.assign(Object.assign({}, menuMethods), menuPrivateMethods);
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableMenuMethodKeys);
  }
};
var hooks_default = tableMenuHook;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/menu/index.js
var VxeTableMenuModule = {
  Panel: panel_default2,
  install(app) {
    VXETable.hooks.add("$tableMenu", hooks_default);
    app.component(panel_default2.name, panel_default2);
  }
};
var Menu = VxeTableMenuModule;
dynamicApp.component(panel_default2.name, panel_default2);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/edit/src/hook.js
var import_xe_utils17 = __toESM(require_xe_utils());
var tableEditMethodKeys = ["insert", "insertAt", "insertNextAt", "remove", "removeCheckboxRow", "removeRadioRow", "removeCurrentRow", "getRecordset", "getInsertRecords", "getRemoveRecords", "getUpdateRecords", "getEditRecord", "getActiveRecord", "getSelectedCell", "clearEdit", "clearActived", "clearSelected", "isEditByRow", "isActiveByRow", "setEditRow", "setActiveRow", "setEditCell", "setActiveCell", "setSelectCell"];
var editHook = {
  setupTable($xetable) {
    const { props, reactData, internalData } = $xetable;
    const { refElem } = $xetable.getRefMaps();
    const { computeMouseOpts, computeEditOpts, computeCheckboxOpts, computeTreeOpts } = $xetable.getComputeMaps();
    let editMethods = {};
    let editPrivateMethods = {};
    const getEditColumnModel = (row, column) => {
      const { model, editRender } = column;
      if (editRender) {
        model.value = getCellValue(row, column);
        model.update = false;
      }
    };
    const setEditColumnModel = (row, column) => {
      const { model, editRender } = column;
      if (editRender && model.update) {
        setCellValue(row, column, model.value);
        model.update = false;
        model.value = null;
      }
    };
    const removeCellSelectedClass = () => {
      const el = refElem.value;
      if (el) {
        const cell = el.querySelector(".col--selected");
        if (cell) {
          removeClass(cell, "col--selected");
        }
      }
    };
    function syncActivedCell() {
      const { editStore, tableColumn } = reactData;
      const editOpts = computeEditOpts.value;
      const { actived } = editStore;
      const { row, column } = actived;
      if (row || column) {
        if (editOpts.mode === "row") {
          tableColumn.forEach((column2) => setEditColumnModel(row, column2));
        } else {
          setEditColumnModel(row, column);
        }
      }
    }
    function insertTreeRow(newRecords, isAppend) {
      const { tableFullTreeData, afterFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { rowField, parentField, mapChildrenField } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const funcName = isAppend ? "push" : "unshift";
      newRecords.forEach((item) => {
        const parentRowId = item[parentField];
        const rowid = getRowid($xetable, item);
        const matchObj = parentRowId ? import_xe_utils17.default.findTree(tableFullTreeData, (item2) => parentRowId === item2[rowField], { children: mapChildrenField }) : null;
        if (matchObj) {
          const { item: parentRow } = matchObj;
          const parentRest = fullAllDataRowIdData[getRowid($xetable, parentRow)];
          const parentLevel = parentRest ? parentRest.level : 0;
          let parentChilds = parentRow[childrenField];
          let mapChilds = parentRow[mapChildrenField];
          if (!import_xe_utils17.default.isArray(parentChilds)) {
            parentChilds = parentRow[childrenField] = [];
          }
          if (!import_xe_utils17.default.isArray(mapChilds)) {
            mapChilds = parentRow[childrenField] = [];
          }
          parentChilds[funcName](item);
          mapChilds[funcName](item);
          const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: parentChilds, parent: parentRow, level: parentLevel + 1 };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        } else {
          if (true) {
            if (parentRowId) {
              warnLog("vxe.error.unableInsert");
            }
          }
          afterFullData[funcName](item);
          tableFullTreeData[funcName](item);
          const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: tableFullTreeData, parent: null, level: 0 };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        }
      });
    }
    const handleInsertRowAt = (records, row, isInsertNextRow) => {
      const { treeConfig } = props;
      const { mergeList, editStore } = reactData;
      const { tableFullTreeData, afterFullData, tableFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { transform, rowField, mapChildrenField } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      if (!import_xe_utils17.default.isArray(records)) {
        records = [records];
      }
      const newRecords = reactive($xetable.defineField(records.map((record) => Object.assign(treeConfig && transform ? { [mapChildrenField]: [], [childrenField]: [] } : {}, record))));
      if (import_xe_utils17.default.eqNull(row)) {
        if (treeConfig && transform) {
          insertTreeRow(newRecords, false);
        } else {
          afterFullData.unshift(...newRecords);
          tableFullData.unshift(...newRecords);
          mergeList.forEach((mergeItem) => {
            const { row: mergeRowIndex } = mergeItem;
            if (mergeRowIndex > 0) {
              mergeItem.row = mergeRowIndex + newRecords.length;
            }
          });
        }
      } else {
        if (row === -1) {
          if (treeConfig && transform) {
            insertTreeRow(newRecords, true);
          } else {
            afterFullData.push(...newRecords);
            tableFullData.push(...newRecords);
            mergeList.forEach((mergeItem) => {
              const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
              if (mergeRowIndex + mergeRowspan > afterFullData.length) {
                mergeItem.rowspan = mergeRowspan + newRecords.length;
              }
            });
          }
        } else {
          if (treeConfig && transform) {
            const matchMapObj = import_xe_utils17.default.findTree(tableFullTreeData, (item) => row[rowField] === item[rowField], { children: mapChildrenField });
            if (matchMapObj) {
              const { parent: parentRow } = matchMapObj;
              const parentMapChilds = parentRow ? parentRow[mapChildrenField] : tableFullTreeData;
              const parentRest = fullAllDataRowIdData[getRowid($xetable, parentRow)];
              const parentLevel = parentRest ? parentRest.level : 0;
              newRecords.forEach((item, i) => {
                const rowid = getRowid($xetable, item);
                if (true) {
                  if (item[treeOpts.parentField]) {
                    if (parentRow && item[treeOpts.parentField] !== parentRow[rowField]) {
                      errLog("vxe.error.errProp", [`${treeOpts.parentField}=${item[treeOpts.parentField]}`, `${treeOpts.parentField}=${parentRow[rowField]}`]);
                    }
                  }
                }
                if (parentRow) {
                  item[treeOpts.parentField] = parentRow[rowField];
                }
                let targetIndex = matchMapObj.index + i;
                if (isInsertNextRow) {
                  targetIndex = targetIndex + 1;
                }
                parentMapChilds.splice(targetIndex, 0, item);
                const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: parentMapChilds, parent: parentRow, level: parentLevel + 1 };
                fullDataRowIdData[rowid] = rest;
                fullAllDataRowIdData[rowid] = rest;
              });
              if (parentRow) {
                const matchObj = import_xe_utils17.default.findTree(tableFullTreeData, (item) => row[rowField] === item[rowField], { children: childrenField });
                if (matchObj) {
                  const parentChilds = matchObj.items;
                  let targetIndex = matchObj.index;
                  if (isInsertNextRow) {
                    targetIndex = targetIndex + 1;
                  }
                  parentChilds.splice(targetIndex, 0, ...newRecords);
                }
              }
            } else {
              if (true) {
                warnLog("vxe.error.unableInsert");
              }
              insertTreeRow(newRecords, true);
            }
          } else {
            if (treeConfig) {
              throw new Error(getLog("vxe.error.noTree", ["insert"]));
            }
            let afIndex = -1;
            if (import_xe_utils17.default.isNumber(row)) {
              if (row < afterFullData.length) {
                afIndex = row;
              }
            } else {
              afIndex = $xetable.findRowIndexOf(afterFullData, row);
            }
            if (isInsertNextRow) {
              afIndex = Math.min(afterFullData.length, afIndex + 1);
            }
            if (afIndex === -1) {
              throw new Error(errLog("vxe.error.unableInsert"));
            }
            afterFullData.splice(afIndex, 0, ...newRecords);
            tableFullData.splice($xetable.findRowIndexOf(tableFullData, row), 0, ...newRecords);
            mergeList.forEach((mergeItem) => {
              const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
              if (mergeRowIndex > afIndex) {
                mergeItem.row = mergeRowIndex + newRecords.length;
              } else if (mergeRowIndex + mergeRowspan > afIndex) {
                mergeItem.rowspan = mergeRowspan + newRecords.length;
              }
            });
          }
        }
      }
      const { insertMaps } = editStore;
      newRecords.forEach((newRow) => {
        const rowid = getRowid($xetable, newRow);
        insertMaps[rowid] = newRow;
      });
      $xetable.cacheRowMap();
      $xetable.updateScrollYStatus();
      $xetable.handleTableData(treeConfig && transform);
      if (!(treeConfig && transform)) {
        $xetable.updateAfterDataIndex();
      }
      $xetable.updateFooter();
      $xetable.checkSelectionStatus();
      if (reactData.scrollYLoad) {
        $xetable.updateScrollYSpace();
      }
      return nextTick().then(() => {
        $xetable.updateCellAreas();
        return $xetable.recalculate();
      }).then(() => {
        return {
          row: newRecords.length ? newRecords[newRecords.length - 1] : null,
          rows: newRecords
        };
      });
    };
    editMethods = {
      /**
       * 往表格中插入临时数据
       *
       * @param {*} records
       */
      insert(records) {
        return handleInsertRowAt(records, null);
      },
      /**
       * 往表格指定行中插入临时数据
       * 如果 row 为空则从插入到顶部，如果为树结构，则插入到目标节点顶部
       * 如果 row 为 -1 则从插入到底部，如果为树结构，则插入到目标节点底部
       * 如果 row 为有效行则插入到该行的位置，如果为树结构，则有插入到效的目标节点该行的位置
       * @param {Object/Array} records 新的数据
       * @param {Row} row 指定行
       */
      insertAt(records, row) {
        return handleInsertRowAt(records, row);
      },
      insertNextAt(records, row) {
        return handleInsertRowAt(records, row, true);
      },
      /**
       * 删除指定行数据
       * 如果传 row 则删除一行
       * 如果传 rows 则删除多行
       * 如果为空则删除所有
       */
      remove(rows) {
        const { treeConfig } = props;
        const { mergeList, editStore, selectCheckboxMaps } = reactData;
        const { tableFullTreeData, afterFullData, tableFullData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const { actived, removeMaps, insertMaps } = editStore;
        const { checkField } = checkboxOpts;
        let delList = [];
        if (!rows) {
          rows = tableFullData;
        } else if (!import_xe_utils17.default.isArray(rows)) {
          rows = [rows];
        }
        rows.forEach((row) => {
          if (!$xetable.isInsertByRow(row)) {
            const rowid = getRowid($xetable, row);
            removeMaps[rowid] = row;
          }
        });
        if (!checkField) {
          const selectRowMaps = Object.assign({}, selectCheckboxMaps);
          rows.forEach((row) => {
            const rowid = getRowid($xetable, row);
            if (selectRowMaps[rowid]) {
              delete selectRowMaps[rowid];
            }
          });
          reactData.selectCheckboxMaps = selectRowMaps;
        }
        if (tableFullData === rows) {
          rows = delList = tableFullData.slice(0);
          internalData.tableFullData = [];
          internalData.afterFullData = [];
          $xetable.clearMergeCells();
        } else {
          if (treeConfig && transform) {
            rows.forEach((row) => {
              const rowid = getRowid($xetable, row);
              const matchMapObj = import_xe_utils17.default.findTree(tableFullTreeData, (item) => rowid === getRowid($xetable, item), { children: mapChildrenField });
              if (matchMapObj) {
                const rItems = matchMapObj.items.splice(matchMapObj.index, 1);
                delList.push(rItems[0]);
              }
              const matchObj = import_xe_utils17.default.findTree(tableFullTreeData, (item) => rowid === getRowid($xetable, item), { children: childrenField });
              if (matchObj) {
                matchObj.items.splice(matchObj.index, 1);
              }
              const afIndex = $xetable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                afterFullData.splice(afIndex, 1);
              }
            });
          } else {
            rows.forEach((row) => {
              const tfIndex = $xetable.findRowIndexOf(tableFullData, row);
              if (tfIndex > -1) {
                const rItems = tableFullData.splice(tfIndex, 1);
                delList.push(rItems[0]);
              }
              const afIndex = $xetable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                mergeList.forEach((mergeItem) => {
                  const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
                  if (mergeRowIndex > afIndex) {
                    mergeItem.row = mergeRowIndex - 1;
                  } else if (mergeRowIndex + mergeRowspan > afIndex) {
                    mergeItem.rowspan = mergeRowspan - 1;
                  }
                });
                afterFullData.splice(afIndex, 1);
              }
            });
          }
        }
        if (actived.row && $xetable.findRowIndexOf(rows, actived.row) > -1) {
          editMethods.clearEdit();
        }
        rows.forEach((row) => {
          const rowid = getRowid($xetable, row);
          if (insertMaps[rowid]) {
            delete insertMaps[rowid];
          }
        });
        $xetable.updateFooter();
        $xetable.cacheRowMap();
        $xetable.handleTableData(treeConfig && transform);
        if (!(treeConfig && transform)) {
          $xetable.updateAfterDataIndex();
        }
        $xetable.checkSelectionStatus();
        if (reactData.scrollYLoad) {
          $xetable.updateScrollYSpace();
        }
        return nextTick().then(() => {
          $xetable.updateCellAreas();
          return $xetable.recalculate();
        }).then(() => {
          return { row: delList.length ? delList[delList.length - 1] : null, rows: delList };
        });
      },
      /**
       * 删除复选框选中的数据
       */
      removeCheckboxRow() {
        return editMethods.remove($xetable.getCheckboxRecords()).then((params) => {
          $xetable.clearCheckboxRow();
          return params;
        });
      },
      /**
       * 删除单选框选中的数据
       */
      removeRadioRow() {
        const radioRecord = $xetable.getRadioRecord();
        return editMethods.remove(radioRecord || []).then((params) => {
          $xetable.clearRadioRow();
          return params;
        });
      },
      /**
       * 删除当前行选中的数据
       */
      removeCurrentRow() {
        const currentRecord = $xetable.getCurrentRecord();
        return editMethods.remove(currentRecord || []).then((params) => {
          $xetable.clearCurrentRow();
          return params;
        });
      },
      /**
       * 获取表格数据集，包含新增、删除、修改、标记
       */
      getRecordset() {
        return {
          insertRecords: editMethods.getInsertRecords(),
          removeRecords: editMethods.getRemoveRecords(),
          updateRecords: editMethods.getUpdateRecords(),
          pendingRecords: $xetable.getPendingRecords()
        };
      },
      /**
       * 获取新增的临时数据
       */
      getInsertRecords() {
        const { editStore } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const { insertMaps } = editStore;
        const insertRecords = [];
        import_xe_utils17.default.each(insertMaps, (row, rowid) => {
          if (fullAllDataRowIdData[rowid]) {
            insertRecords.push(row);
          }
        });
        return insertRecords;
      },
      /**
       * 获取已删除的数据
       */
      getRemoveRecords() {
        const { editStore } = reactData;
        const { removeMaps } = editStore;
        const removeRecords = [];
        import_xe_utils17.default.each(removeMaps, (row) => {
          removeRecords.push(row);
        });
        return removeRecords;
      },
      /**
       * 获取更新数据
       * 只精准匹配 row 的更改
       * 如果是树表格，子节点更改状态不会影响父节点的更新状态
       */
      getUpdateRecords() {
        const { keepSource, treeConfig } = props;
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        if (keepSource) {
          syncActivedCell();
          if (treeConfig) {
            return import_xe_utils17.default.filterTree(tableFullData, (row) => $xetable.isUpdateByRow(row), treeOpts);
          }
          return tableFullData.filter((row) => $xetable.isUpdateByRow(row));
        }
        return [];
      },
      getActiveRecord() {
        if (true) {
          warnLog("vxe.error.delFunc", ["getActiveRecord", "getEditRecord"]);
        }
        return this.getEditRecord();
      },
      getEditRecord() {
        const { editStore } = reactData;
        const { afterFullData } = internalData;
        const el = refElem.value;
        const { args, row } = editStore.actived;
        if (args && $xetable.findRowIndexOf(afterFullData, row) > -1 && el.querySelectorAll(".vxe-body--column.col--active").length) {
          return Object.assign({}, args);
        }
        return null;
      },
      /**
       * 获取选中的单元格
       */
      getSelectedCell() {
        const { editStore } = reactData;
        const { args, column } = editStore.selected;
        if (args && column) {
          return Object.assign({}, args);
        }
        return null;
      },
      clearActived(evnt) {
        if (true) {
          warnLog("vxe.error.delFunc", ["clearActived", "clearEdit"]);
        }
        return this.clearEdit(evnt);
      },
      /**
       * 清除激活的编辑
       */
      clearEdit(evnt) {
        const { editStore } = reactData;
        const { actived, focused } = editStore;
        const { row, column } = actived;
        if (row || column) {
          syncActivedCell();
          actived.args = null;
          actived.row = null;
          actived.column = null;
          $xetable.updateFooter();
          $xetable.dispatchEvent("edit-closed", {
            row,
            rowIndex: $xetable.getRowIndex(row),
            $rowIndex: $xetable.getVMRowIndex(row),
            column,
            columnIndex: $xetable.getColumnIndex(column),
            $columnIndex: $xetable.getVMColumnIndex(column)
          }, evnt || null);
        }
        if (conf_default.cellVaildMode === "obsolete") {
          if ($xetable.clearValidate) {
            return $xetable.clearValidate();
          }
        }
        focused.row = null;
        focused.column = null;
        return nextTick();
      },
      /**
       * 清除所选中源状态
       */
      clearSelected() {
        const { editStore } = reactData;
        const { selected } = editStore;
        selected.row = null;
        selected.column = null;
        removeCellSelectedClass();
        return nextTick();
      },
      isActiveByRow(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["isActiveByRow", "isEditByRow"]);
        }
        return this.isEditByRow(row);
      },
      /**
       * 判断行是否为激活编辑状态
       * @param {Row} row 行对象
       */
      isEditByRow(row) {
        const { editStore } = reactData;
        return editStore.actived.row === row;
      },
      setActiveRow(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["setActiveRow", "setEditRow"]);
        }
        return editMethods.setEditRow(row);
      },
      /**
       * 激活行编辑
       */
      setEditRow(row, fieldOrColumn) {
        const { visibleColumn } = internalData;
        let column = import_xe_utils17.default.find(visibleColumn, (column2) => isEnableConf(column2.editRender));
        if (fieldOrColumn) {
          column = import_xe_utils17.default.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        }
        return $xetable.setEditCell(row, column);
      },
      setActiveCell(row, fieldOrColumn) {
        if (true) {
          warnLog("vxe.error.delFunc", ["setActiveCell", "setEditCell"]);
        }
        return editMethods.setEditCell(row, fieldOrColumn);
      },
      /**
       * 激活单元格编辑
       */
      setEditCell(row, fieldOrColumn) {
        const { editConfig } = props;
        const column = import_xe_utils17.default.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        if (row && column && isEnableConf(editConfig) && isEnableConf(column.editRender)) {
          return $xetable.scrollToRow(row, column).then(() => {
            const cell = $xetable.getCell(row, column);
            if (cell) {
              editPrivateMethods.handleActived({
                row,
                rowIndex: $xetable.getRowIndex(row),
                column,
                columnIndex: $xetable.getColumnIndex(column),
                cell,
                $table: $xetable
              });
              internalData._lastCallTime = Date.now();
            }
            return nextTick();
          });
        }
        return nextTick();
      },
      /**
       * 只对 trigger=dblclick 有效，选中单元格
       */
      setSelectCell(row, fieldOrColumn) {
        const { tableData } = reactData;
        const editOpts = computeEditOpts.value;
        const column = import_xe_utils17.default.isString(fieldOrColumn) ? $xetable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        if (row && column && editOpts.trigger !== "manual") {
          const rowIndex = $xetable.findRowIndexOf(tableData, row);
          if (rowIndex > -1 && column) {
            const cell = $xetable.getCell(row, column);
            const params = {
              row,
              rowIndex,
              column,
              columnIndex: $xetable.getColumnIndex(column),
              cell
            };
            $xetable.handleSelected(params, {});
          }
        }
        return nextTick();
      }
    };
    editPrivateMethods = {
      /**
       * 处理激活编辑
       */
      handleActived(params, evnt) {
        const { editConfig, mouseConfig } = props;
        const { editStore, tableColumn } = reactData;
        const editOpts = computeEditOpts.value;
        const { mode } = editOpts;
        const { actived, focused } = editStore;
        const { row, column } = params;
        const { editRender } = column;
        const cell = params.cell || $xetable.getCell(row, column);
        const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
        params.cell = cell;
        if (cell && isEnableConf(editConfig) && isEnableConf(editRender)) {
          if (!$xetable.hasPendingByRow(row)) {
            if (actived.row !== row || (mode === "cell" ? actived.column !== column : false)) {
              let type = "edit-disabled";
              if (!beforeEditMethod || beforeEditMethod(Object.assign(Object.assign({}, params), { $table: $xetable, $grid: $xetable.xegrid }))) {
                if (mouseConfig) {
                  editMethods.clearSelected();
                  if ($xetable.clearCellAreas) {
                    $xetable.clearCellAreas();
                    $xetable.clearCopyCellArea();
                  }
                }
                $xetable.closeTooltip();
                if (actived.column) {
                  editMethods.clearEdit(evnt);
                }
                type = "edit-activated";
                column.renderHeight = cell.offsetHeight;
                actived.args = params;
                actived.row = row;
                actived.column = column;
                if (mode === "row") {
                  tableColumn.forEach((column2) => getEditColumnModel(row, column2));
                } else {
                  getEditColumnModel(row, column);
                }
                const afterEditMethod = editOpts.afterEditMethod;
                nextTick(() => {
                  editPrivateMethods.handleFocus(params, evnt);
                  if (afterEditMethod) {
                    afterEditMethod(Object.assign(Object.assign({}, params), { $table: $xetable, $grid: $xetable.xegrid }));
                  }
                });
              }
              $xetable.dispatchEvent(type, {
                row,
                rowIndex: $xetable.getRowIndex(row),
                $rowIndex: $xetable.getVMRowIndex(row),
                column,
                columnIndex: $xetable.getColumnIndex(column),
                $columnIndex: $xetable.getVMColumnIndex(column)
              }, evnt);
              if (type === "edit-activated") {
                $xetable.dispatchEvent("edit-actived", {
                  row,
                  rowIndex: $xetable.getRowIndex(row),
                  $rowIndex: $xetable.getVMRowIndex(row),
                  column,
                  columnIndex: $xetable.getColumnIndex(column),
                  $columnIndex: $xetable.getVMColumnIndex(column)
                }, evnt);
              }
            } else {
              const { column: oldColumn } = actived;
              if (mouseConfig) {
                editMethods.clearSelected();
                if ($xetable.clearCellAreas) {
                  $xetable.clearCellAreas();
                  $xetable.clearCopyCellArea();
                }
              }
              if (oldColumn !== column) {
                const { model: oldModel } = oldColumn;
                if (oldModel.update) {
                  setCellValue(row, oldColumn, oldModel.value);
                }
                if ($xetable.clearValidate) {
                  $xetable.clearValidate(row, column);
                }
              }
              column.renderHeight = cell.offsetHeight;
              actived.args = params;
              actived.column = column;
              setTimeout(() => {
                editPrivateMethods.handleFocus(params, evnt);
              });
            }
            focused.column = null;
            focused.row = null;
            $xetable.focus();
          }
        }
        return nextTick();
      },
      /**
       * 处理聚焦
       */
      handleFocus(params) {
        const { row, column, cell } = params;
        const { editRender } = column;
        if (isEnableConf(editRender)) {
          const compRender = renderer.get(editRender.name);
          let { autofocus, autoselect } = editRender;
          let inputElem;
          if (!autofocus && compRender) {
            autofocus = compRender.autofocus;
          }
          if (!autoselect && compRender) {
            autoselect = compRender.autoselect;
          }
          if (import_xe_utils17.default.isFunction(autofocus)) {
            inputElem = autofocus.call(this, params);
          } else if (autofocus) {
            if (autofocus === true) {
              inputElem = cell.querySelector("input,textarea");
            } else {
              inputElem = cell.querySelector(autofocus);
            }
            if (inputElem) {
              inputElem.focus();
            }
          }
          if (inputElem) {
            if (autoselect) {
              inputElem.select();
            } else {
              if (browse.msie) {
                const textRange = inputElem.createTextRange();
                textRange.collapse(false);
                textRange.select();
              }
            }
          } else {
            $xetable.scrollToRow(row, column);
          }
        }
      },
      /**
       * 处理选中源
       */
      handleSelected(params, evnt) {
        const { mouseConfig } = props;
        const { editStore } = reactData;
        const mouseOpts = computeMouseOpts.value;
        const editOpts = computeEditOpts.value;
        const { actived, selected } = editStore;
        const { row, column } = params;
        const isMouseSelected = mouseConfig && mouseOpts.selected;
        const selectMethod = () => {
          if (isMouseSelected && (selected.row !== row || selected.column !== column)) {
            if (actived.row !== row || (editOpts.mode === "cell" ? actived.column !== column : false)) {
              editMethods.clearEdit(evnt);
              editMethods.clearSelected();
              if ($xetable.clearCellAreas) {
                $xetable.clearCellAreas();
                $xetable.clearCopyCellArea();
              }
              selected.args = params;
              selected.row = row;
              selected.column = column;
              if (isMouseSelected) {
                editPrivateMethods.addCellSelectedClass();
              }
              $xetable.focus();
              if (evnt) {
                $xetable.dispatchEvent("cell-selected", params, evnt);
              }
            }
          }
          return nextTick();
        };
        return selectMethod();
      },
      addCellSelectedClass() {
        const { editStore } = reactData;
        const { selected } = editStore;
        const { row, column } = selected;
        removeCellSelectedClass();
        if (row && column) {
          const cell = $xetable.getCell(row, column);
          if (cell) {
            addClass(cell, "col--selected");
          }
        }
      }
    };
    return Object.assign(Object.assign({}, editMethods), editPrivateMethods);
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableEditMethodKeys);
  }
};
var hook_default2 = editHook;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/edit/index.js
var VxeTableEditModule = {
  install() {
    VXETable.hooks.add("$tableEdit", hook_default2);
  }
};
var Edit = VxeTableEditModule;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/export/src/export-panel.js
var import_xe_utils25 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/modal/src/modal.js
var import_xe_utils19 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/hooks/size.js
function useSize(props) {
  const xesize = inject("xesize", null);
  const computeSize = computed(() => {
    return props.size || (xesize ? xesize.value : null);
  });
  provide("xesize", computeSize);
  return computeSize;
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/button/src/button.js
var import_xe_utils18 = __toESM(require_xe_utils());
var button_default = defineComponent({
  name: "VxeButton",
  props: {
    /**
     * 按钮类型
     */
    type: String,
    mode: String,
    className: [String, Function],
    popupClassName: [String, Function],
    /**
     * 按钮尺寸
     */
    size: { type: String, default: () => conf_default.button.size || conf_default.size },
    /**
     * 用来标识这一项
     */
    name: [String, Number],
    /**
     * 按钮内容
     */
    content: String,
    /**
     * 固定显示下拉面板的方向
     */
    placement: String,
    /**
     * 按钮状态
     */
    status: String,
    /**
     * 标题
     */
    title: String,
    /**
     * 按钮的图标
     */
    icon: String,
    /**
     * 圆角边框
     */
    round: Boolean,
    /**
     * 圆角按钮
     */
    circle: Boolean,
    /**
     * 是否禁用
     */
    disabled: Boolean,
    /**
     * 是否加载中
     */
    loading: Boolean,
    /**
     * 在下拉面板关闭时销毁内容
     */
    destroyOnClose: Boolean,
    /**
     * 是否将弹框容器插入于 body 内
     */
    transfer: { type: Boolean, default: () => conf_default.button.transfer }
  },
  emits: [
    "click",
    "mouseenter",
    "mouseleave",
    "dropdown-click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils18.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      inited: false,
      showPanel: false,
      animatVisible: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: ""
    });
    const internalData = {
      showTime: null
    };
    const refElem = ref();
    const refButton = ref();
    const refBtnPanel = ref();
    const refMaps = {
      refElem
    };
    const $xebutton = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const $xebuttonggroup = inject("$xebuttongroup", null);
    let buttonMethods = {};
    const computeIsFormBtn = computed(() => {
      const { type } = props;
      if (type) {
        return ["submit", "reset", "button"].indexOf(type) > -1;
      }
      return false;
    });
    const computeBtnMode = computed(() => {
      const { type, mode } = props;
      if (mode === "text" || type === "text" || $xebuttonggroup && $xebuttonggroup.props.mode === "text") {
        return "text";
      }
      return "button";
    });
    const computeBtnStatus = computed(() => {
      const { status } = props;
      if (status) {
        return status;
      }
      if ($xebuttonggroup) {
        return $xebuttonggroup.props.status;
      }
      return "";
    });
    const computeBtnRound = computed(() => {
      const { round } = props;
      if (round) {
        return round;
      }
      if ($xebuttonggroup) {
        return $xebuttonggroup.props.round;
      }
      return false;
    });
    const computeBtnCircle = computed(() => {
      const { circle } = props;
      if (circle) {
        return circle;
      }
      if ($xebuttonggroup) {
        return $xebuttonggroup.props.circle;
      }
      return false;
    });
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { transfer, placement } = props;
        const { panelIndex } = reactData;
        const targetElem = refButton.value;
        const panelElem = refBtnPanel.value;
        if (panelElem && targetElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { top, left, boundingTop, visibleHeight, visibleWidth } = getAbsolutePos(targetElem);
          let panelPlacement = "bottom";
          if (transfer) {
            let btnLeft = left + targetWidth - panelWidth;
            let btnTop = top + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              btnTop = top - panelHeight;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                btnTop = top - panelHeight;
              }
              if (btnTop < marginSize) {
                panelPlacement = "bottom";
                btnTop = top + targetHeight;
              }
            }
            if (btnLeft + panelWidth + marginSize > visibleWidth) {
              btnLeft -= btnLeft + panelWidth + marginSize - visibleWidth;
            }
            if (btnLeft < marginSize) {
              btnLeft = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${btnLeft}px`,
              right: "auto",
              top: `${btnTop}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const clickEvent = (evnt) => {
      if ($xebuttonggroup) {
        $xebuttonggroup.handleClick({ name: props.name }, evnt);
      } else {
        buttonMethods.dispatchEvent("click", { $event: evnt }, evnt);
      }
    };
    const mousedownDropdownEvent = (evnt) => {
      const isLeftBtn = evnt.button === 0;
      if (isLeftBtn) {
        evnt.stopPropagation();
      }
    };
    const clickDropdownEvent = (evnt) => {
      const dropdownElem = evnt.currentTarget;
      const panelElem = refBtnPanel.value;
      const { flag, targetElem } = getEventTargetNode(evnt, dropdownElem, "vxe-button");
      if (flag) {
        if (panelElem) {
          panelElem.dataset.active = "N";
        }
        reactData.showPanel = false;
        setTimeout(() => {
          if (!panelElem || panelElem.dataset.active !== "Y") {
            reactData.animatVisible = false;
          }
        }, 350);
        buttonMethods.dispatchEvent("dropdown-click", { name: targetElem.getAttribute("name"), $event: evnt }, evnt);
      }
    };
    const mouseenterDropdownEvent = () => {
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = "Y";
        reactData.animatVisible = true;
        setTimeout(() => {
          if (panelElem.dataset.active === "Y") {
            reactData.showPanel = true;
            updateZindex();
            updatePlacement();
            setTimeout(() => {
              if (reactData.showPanel) {
                updatePlacement();
              }
            }, 50);
          }
        }, 20);
      }
    };
    const mouseenterTargetEvent = (evnt) => {
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = "Y";
        if (!reactData.inited) {
          reactData.inited = true;
        }
        internalData.showTime = setTimeout(() => {
          if (panelElem.dataset.active === "Y") {
            mouseenterDropdownEvent();
          } else {
            reactData.animatVisible = false;
          }
        }, 250);
      }
      mouseenterEvent(evnt);
    };
    const mouseleaveTargetEvent = (evnt) => {
      closePanel();
      mouseleaveEvent(evnt);
    };
    const mouseenterEvent = (evnt) => {
      emit("mouseenter", { $event: evnt });
    };
    const mouseleaveEvent = (evnt) => {
      emit("mouseleave", { $event: evnt });
    };
    const closePanel = () => {
      const panelElem = refBtnPanel.value;
      clearTimeout(internalData.showTime);
      if (panelElem) {
        panelElem.dataset.active = "N";
        setTimeout(() => {
          if (panelElem.dataset.active !== "Y") {
            reactData.showPanel = false;
            setTimeout(() => {
              if (panelElem.dataset.active !== "Y") {
                reactData.animatVisible = false;
              }
            }, 350);
          }
        }, 100);
      } else {
        reactData.animatVisible = false;
        reactData.showPanel = false;
      }
    };
    const mouseleaveDropdownEvent = () => {
      closePanel();
    };
    const renderContent = () => {
      const { content, icon, loading } = props;
      const contVNs = [];
      if (loading) {
        contVNs.push(h("i", {
          class: ["vxe-button--loading-icon", conf_default.icon.BUTTON_LOADING]
        }));
      } else if (slots.icon) {
        contVNs.push(h("span", {
          class: "vxe-button--custom-icon"
        }, slots.icon({})));
      } else if (icon) {
        contVNs.push(h("i", {
          class: ["vxe-button--icon", icon]
        }));
      }
      if (slots.default) {
        contVNs.push(h("span", {
          class: "vxe-button--content"
        }, slots.default({})));
      } else if (content) {
        contVNs.push(h("span", {
          class: "vxe-button--content"
        }, getFuncText(content)));
      }
      return contVNs;
    };
    buttonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $button: $xebutton, $event: evnt }, params));
      },
      focus() {
        const btnElem = refButton.value;
        btnElem.focus();
        return nextTick();
      },
      blur() {
        const btnElem = refButton.value;
        btnElem.blur();
        return nextTick();
      }
    };
    Object.assign($xebutton, buttonMethods);
    onMounted(() => {
      GlobalEvent.on($xebutton, "mousewheel", (evnt) => {
        const panelElem = refBtnPanel.value;
        if (reactData.showPanel && !getEventTargetNode(evnt, panelElem).flag) {
          closePanel();
        }
      });
    });
    onUnmounted(() => {
      GlobalEvent.off($xebutton, "mousewheel");
    });
    const renderVN = () => {
      const { className, popupClassName, transfer, title, type, destroyOnClose, name, disabled, loading } = props;
      const { inited, showPanel } = reactData;
      const isFormBtn = computeIsFormBtn.value;
      const btnMode = computeBtnMode.value;
      const btnStatus = computeBtnStatus.value;
      const btnRound = computeBtnRound.value;
      const btnCircle = computeBtnCircle.value;
      const vSize = computeSize.value;
      if (slots.dropdowns) {
        return h("div", {
          ref: refElem,
          class: ["vxe-button--dropdown", className ? import_xe_utils18.default.isFunction(className) ? className({ $button: $xebutton }) : className : "", {
            [`size--${vSize}`]: vSize,
            "is--active": showPanel
          }]
        }, [
          h("button", {
            ref: refButton,
            class: ["vxe-button", `type--${btnMode}`, {
              [`size--${vSize}`]: vSize,
              [`theme--${btnStatus}`]: btnStatus,
              "is--round": btnRound,
              "is--circle": btnCircle,
              "is--disabled": disabled || loading,
              "is--loading": loading
            }],
            title,
            name,
            type: isFormBtn ? type : "button",
            disabled: disabled || loading,
            onMouseenter: mouseenterTargetEvent,
            onMouseleave: mouseleaveTargetEvent,
            onClick: clickEvent
          }, renderContent().concat([
            h("i", {
              class: `vxe-button--dropdown-arrow ${conf_default.icon.BUTTON_DROPDOWN}`
            })
          ])),
          h(Teleport, {
            to: "body",
            disabled: transfer ? !inited : true
          }, [
            h("div", {
              ref: refBtnPanel,
              class: ["vxe-button--dropdown-panel", popupClassName ? import_xe_utils18.default.isFunction(popupClassName) ? popupClassName({ $button: $xebutton }) : popupClassName : "", {
                [`size--${vSize}`]: vSize,
                "animat--leave": reactData.animatVisible,
                "animat--enter": showPanel
              }],
              placement: reactData.panelPlacement,
              style: reactData.panelStyle
            }, inited ? [
              h("div", {
                class: "vxe-button--dropdown-wrapper",
                onMousedown: mousedownDropdownEvent,
                onClick: clickDropdownEvent,
                onMouseenter: mouseenterDropdownEvent,
                onMouseleave: mouseleaveDropdownEvent
              }, destroyOnClose && !showPanel ? [] : slots.dropdowns({}))
            ] : [])
          ])
        ]);
      }
      return h("button", {
        ref: refButton,
        class: ["vxe-button", `type--${btnMode}`, className ? import_xe_utils18.default.isFunction(className) ? className({ $button: $xebutton }) : className : "", {
          [`size--${vSize}`]: vSize,
          [`theme--${btnStatus}`]: btnStatus,
          "is--round": btnRound,
          "is--circle": btnCircle,
          "is--disabled": disabled || loading,
          "is--loading": loading
        }],
        title,
        name,
        type: isFormBtn ? type : "button",
        disabled: disabled || loading,
        onClick: clickEvent,
        onMouseenter: mouseenterEvent,
        onMouseleave: mouseleaveEvent
      }, renderContent());
    };
    $xebutton.renderVN = renderVN;
    return $xebutton;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/loading/src/loading.js
var loading_default = defineComponent({
  name: "VxeLoading",
  props: {
    modelValue: Boolean,
    icon: String,
    text: String
  },
  setup(props, { slots }) {
    const computeLoadingIcon = computed(() => {
      return props.icon || conf_default.icon.LOADING;
    });
    const computeLoadingText = computed(() => {
      const loadingText = conf_default.loadingText;
      return props.text || (loadingText === null ? loadingText : conf_default.i18n("vxe.loading.text"));
    });
    return () => {
      const loadingIcon = computeLoadingIcon.value;
      const loadingText = computeLoadingText.value;
      return h("div", {
        class: ["vxe-loading", {
          "is--visible": props.modelValue
        }]
      }, slots.default ? [
        h("div", {
          class: "vxe-loading--wrapper"
        }, slots.default({}))
      ] : [
        h("div", {
          class: "vxe-loading--chunk"
        }, [
          loadingIcon ? h("i", {
            class: loadingIcon
          }) : h("div", {
            class: "vxe-loading--spinner"
          }),
          loadingText ? h("div", {
            class: "vxe-loading--text"
          }, `${loadingText}`) : null
        ])
      ]);
    };
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/loading/index.js
var VxeLoading = Object.assign(loading_default, {
  install(app) {
    app.component(loading_default.name, loading_default);
  }
});
var loading_default2 = VxeLoading;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/modal/src/modal.js
var allActiveModals = [];
var msgQueue = [];
var modal_default = defineComponent({
  name: "VxeModal",
  props: {
    modelValue: Boolean,
    id: String,
    type: { type: String, default: "modal" },
    loading: { type: Boolean, default: null },
    status: String,
    iconStatus: String,
    className: String,
    top: { type: [Number, String], default: () => conf_default.modal.top },
    position: [String, Object],
    title: String,
    duration: { type: [Number, String], default: () => conf_default.modal.duration },
    message: [Number, String],
    content: [Number, String],
    showCancelButton: { type: Boolean, default: null },
    cancelButtonText: { type: String, default: () => conf_default.modal.cancelButtonText },
    showConfirmButton: { type: Boolean, default: () => conf_default.modal.showConfirmButton },
    confirmButtonText: { type: String, default: () => conf_default.modal.confirmButtonText },
    lockView: { type: Boolean, default: () => conf_default.modal.lockView },
    lockScroll: Boolean,
    mask: { type: Boolean, default: () => conf_default.modal.mask },
    maskClosable: { type: Boolean, default: () => conf_default.modal.maskClosable },
    escClosable: { type: Boolean, default: () => conf_default.modal.escClosable },
    resize: Boolean,
    showHeader: { type: Boolean, default: () => conf_default.modal.showHeader },
    showFooter: { type: Boolean, default: () => conf_default.modal.showFooter },
    showZoom: Boolean,
    showClose: { type: Boolean, default: () => conf_default.modal.showClose },
    dblclickZoom: { type: Boolean, default: () => conf_default.modal.dblclickZoom },
    width: [Number, String],
    height: [Number, String],
    minWidth: { type: [Number, String], default: () => conf_default.modal.minWidth },
    minHeight: { type: [Number, String], default: () => conf_default.modal.minHeight },
    zIndex: Number,
    marginSize: { type: [Number, String], default: () => conf_default.modal.marginSize },
    fullscreen: Boolean,
    draggable: { type: Boolean, default: () => conf_default.modal.draggable },
    remember: { type: Boolean, default: () => conf_default.modal.remember },
    destroyOnClose: { type: Boolean, default: () => conf_default.modal.destroyOnClose },
    showTitleOverflow: { type: Boolean, default: () => conf_default.modal.showTitleOverflow },
    transfer: { type: Boolean, default: () => conf_default.modal.transfer },
    storage: { type: Boolean, default: () => conf_default.modal.storage },
    storageKey: { type: String, default: () => conf_default.modal.storageKey },
    animat: { type: Boolean, default: () => conf_default.modal.animat },
    size: { type: String, default: () => conf_default.modal.size || conf_default.size },
    beforeHideMethod: { type: Function, default: () => conf_default.modal.beforeHideMethod },
    slots: Object
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel",
    "zoom",
    "resize",
    "move"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils19.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      inited: false,
      visible: false,
      contentVisible: false,
      modalTop: 0,
      modalZindex: 0,
      zoomLocat: null,
      firstOpen: true
    });
    const refElem = ref();
    const refModalBox = ref();
    const refConfirmBtn = ref();
    const refCancelBtn = ref();
    const refMaps = {
      refElem
    };
    const $xemodal = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let modalMethods = {};
    const computeIsMsg = computed(() => {
      return props.type === "message";
    });
    const getBox = () => {
      const boxElem = refModalBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const { width, height } = props;
      const boxElem = getBox();
      boxElem.style.width = `${width ? isNaN(width) ? width : `${width}px` : ""}`;
      boxElem.style.height = `${height ? isNaN(height) ? height : `${height}px` : ""}`;
      return nextTick();
    };
    const updateZindex = () => {
      const { zIndex } = props;
      const { modalZindex } = reactData;
      if (zIndex) {
        reactData.modalZindex = zIndex;
      } else if (modalZindex < getLastZIndex()) {
        reactData.modalZindex = nextZIndex();
      }
    };
    const updatePosition = () => {
      return nextTick().then(() => {
        const { position } = props;
        const marginSize = import_xe_utils19.default.toNumber(props.marginSize);
        const boxElem = getBox();
        const clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;
        const clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;
        const isPosCenter = position === "center";
        const { top, left } = import_xe_utils19.default.isString(position) ? { top: position, left: position } : Object.assign({}, position);
        const topCenter = isPosCenter || top === "center";
        const leftCenter = isPosCenter || left === "center";
        let posTop = "";
        let posLeft = "";
        if (left && !leftCenter) {
          posLeft = isNaN(left) ? left : `${left}px`;
        } else {
          posLeft = `${Math.max(marginSize, clientVisibleWidth / 2 - boxElem.offsetWidth / 2)}px`;
        }
        if (top && !topCenter) {
          posTop = isNaN(top) ? top : `${top}px`;
        } else {
          posTop = `${Math.max(marginSize, clientVisibleHeight / 2 - boxElem.offsetHeight / 2)}px`;
        }
        boxElem.style.top = posTop;
        boxElem.style.left = posLeft;
      });
    };
    const updateStyle = () => {
      nextTick(() => {
        let offsetTop = 0;
        msgQueue.forEach((comp) => {
          const boxElem = comp.getBox();
          offsetTop += import_xe_utils19.default.toNumber(comp.props.top);
          comp.reactData.modalTop = offsetTop;
          offsetTop += boxElem.clientHeight;
        });
      });
    };
    const removeMsgQueue = () => {
      if (msgQueue.indexOf($xemodal) > -1) {
        import_xe_utils19.default.remove(msgQueue, (comp) => comp === $xemodal);
      }
      updateStyle();
    };
    const closeModal2 = (type) => {
      const { remember, beforeHideMethod } = props;
      const { visible } = reactData;
      const isMsg = computeIsMsg.value;
      const params = { type };
      if (visible) {
        Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then((rest) => {
          if (!import_xe_utils19.default.isError(rest)) {
            if (isMsg) {
              removeMsgQueue();
            }
            reactData.contentVisible = false;
            if (!remember) {
              reactData.zoomLocat = null;
            }
            import_xe_utils19.default.remove(allActiveModals, (item) => item === $xemodal);
            modalMethods.dispatchEvent("before-hide", params);
            setTimeout(() => {
              reactData.visible = false;
              emit("update:modelValue", false);
              modalMethods.dispatchEvent("hide", params);
            }, 200);
          }
        }).catch((e) => e);
      }
      return nextTick();
    };
    const closeEvent = (evnt) => {
      const type = "close";
      modalMethods.dispatchEvent(type, { type }, evnt);
      closeModal2(type);
    };
    const confirmEvent = (evnt) => {
      const type = "confirm";
      modalMethods.dispatchEvent(type, { type }, evnt);
      closeModal2(type);
    };
    const cancelEvent = (evnt) => {
      const type = "cancel";
      modalMethods.dispatchEvent(type, { type }, evnt);
      closeModal2(type);
    };
    const getStorageMap = (key) => {
      const version2 = conf_default.version;
      const rest = import_xe_utils19.default.toStringJSON(localStorage.getItem(key) || "");
      return rest && rest._v === version2 ? rest : { _v: version2 };
    };
    const hasPosStorage = () => {
      const { id, remember, storage, storageKey } = props;
      return !!(id && remember && storage && getStorageMap(storageKey)[id]);
    };
    const restorePosStorage = () => {
      const { id, remember, storage, storageKey } = props;
      if (id && remember && storage) {
        const posStorage = getStorageMap(storageKey)[id];
        if (posStorage) {
          const boxElem = getBox();
          const [left, top, width, height, zoomLeft, zoomTop, zoomWidth, zoomHeight] = posStorage.split(",");
          if (left) {
            boxElem.style.left = `${left}px`;
          }
          if (top) {
            boxElem.style.top = `${top}px`;
          }
          if (width) {
            boxElem.style.width = `${width}px`;
          }
          if (height) {
            boxElem.style.height = `${height}px`;
          }
          if (zoomLeft && zoomTop) {
            reactData.zoomLocat = {
              left: zoomLeft,
              top: zoomTop,
              width: zoomWidth,
              height: zoomHeight
            };
          }
        }
      }
    };
    const addMsgQueue = () => {
      if (msgQueue.indexOf($xemodal) === -1) {
        msgQueue.push($xemodal);
      }
      updateStyle();
    };
    const savePosStorage = () => {
      const { id, remember, storage, storageKey } = props;
      const { zoomLocat } = reactData;
      if (id && remember && storage) {
        const boxElem = getBox();
        const posStorageMap = getStorageMap(storageKey);
        posStorageMap[id] = [
          boxElem.style.left,
          boxElem.style.top,
          boxElem.style.width,
          boxElem.style.height
        ].concat(zoomLocat ? [
          zoomLocat.left,
          zoomLocat.top,
          zoomLocat.width,
          zoomLocat.height
        ] : []).map((val) => val ? import_xe_utils19.default.toNumber(val) : "").join(",");
        localStorage.setItem(storageKey, import_xe_utils19.default.toJSONString(posStorageMap));
      }
    };
    const maximize = () => {
      return nextTick().then(() => {
        if (!reactData.zoomLocat) {
          const marginSize = Math.max(0, import_xe_utils19.default.toNumber(props.marginSize));
          const boxElem = getBox();
          const { visibleHeight, visibleWidth } = getDomNode();
          reactData.zoomLocat = {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft,
            width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
            height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
          };
          Object.assign(boxElem.style, {
            top: `${marginSize}px`,
            left: `${marginSize}px`,
            width: `${visibleWidth - marginSize * 2}px`,
            height: `${visibleHeight - marginSize * 2}px`
          });
          savePosStorage();
        }
      });
    };
    const openModal2 = () => {
      const { duration, remember, showFooter } = props;
      const { inited, visible } = reactData;
      const isMsg = computeIsMsg.value;
      if (!inited) {
        reactData.inited = true;
      }
      if (!visible) {
        if (!remember) {
          recalculate();
        }
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveModals.push($xemodal);
        setTimeout(() => {
          reactData.contentVisible = true;
          nextTick(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = "";
            const params = { type };
            emit("update:modelValue", true);
            modalMethods.dispatchEvent("show", params);
          });
        }, 10);
        if (isMsg) {
          addMsgQueue();
          if (duration !== -1) {
            setTimeout(() => closeModal2("close"), import_xe_utils19.default.toNumber(duration));
          }
        } else {
          nextTick(() => {
            const { fullscreen } = props;
            const { firstOpen } = reactData;
            if (!remember || firstOpen) {
              updatePosition().then(() => {
                setTimeout(() => updatePosition(), 20);
              });
            }
            if (firstOpen) {
              reactData.firstOpen = false;
              if (hasPosStorage()) {
                restorePosStorage();
              } else if (fullscreen) {
                nextTick(() => maximize());
              }
            } else {
              if (fullscreen) {
                nextTick(() => maximize());
              }
            }
          });
        }
      }
      return nextTick();
    };
    const selfClickEvent = (evnt) => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = "mask";
        closeModal2(type);
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastModal = import_xe_utils19.default.max(allActiveModals, (item) => item.reactData.modalZindex);
        if (lastModal) {
          setTimeout(() => {
            if (lastModal === $xemodal && lastModal.props.escClosable) {
              closeModal2("exit");
            }
          }, 10);
        }
      }
    };
    const isMaximized = () => {
      return !!reactData.zoomLocat;
    };
    const revert = () => {
      return nextTick().then(() => {
        const { zoomLocat } = reactData;
        if (zoomLocat) {
          const boxElem = getBox();
          reactData.zoomLocat = null;
          Object.assign(boxElem.style, {
            top: `${zoomLocat.top}px`,
            left: `${zoomLocat.left}px`,
            width: `${zoomLocat.width}px`,
            height: `${zoomLocat.height}px`
          });
          savePosStorage();
        }
      });
    };
    const zoom = () => {
      if (reactData.zoomLocat) {
        return revert().then(() => isMaximized());
      }
      return maximize().then(() => isMaximized());
    };
    const toggleZoomEvent = (evnt) => {
      const { zoomLocat } = reactData;
      const params = { type: zoomLocat ? "revert" : "max" };
      return zoom().then(() => {
        modalMethods.dispatchEvent("zoom", params, evnt);
      });
    };
    const getPosition = () => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          return {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft
          };
        }
      }
      return null;
    };
    const setPosition = (top, left) => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (import_xe_utils19.default.isNumber(top)) {
          boxElem.style.top = `${top}px`;
        }
        if (import_xe_utils19.default.isNumber(left)) {
          boxElem.style.left = `${left}px`;
        }
      }
      return nextTick();
    };
    const boxMousedownEvent = () => {
      const { modalZindex } = reactData;
      if (allActiveModals.some((comp) => comp.reactData.visible && comp.reactData.modalZindex > modalZindex)) {
        updateZindex();
      }
    };
    const mousedownEvent = (evnt) => {
      const { remember, storage } = props;
      const { zoomLocat } = reactData;
      const marginSize = import_xe_utils19.default.toNumber(props.marginSize);
      const boxElem = getBox();
      if (!zoomLocat && evnt.button === 0 && !getEventTargetNode(evnt, boxElem, "trigger--btn").flag) {
        evnt.preventDefault();
        const domMousemove = document.onmousemove;
        const domMouseup = document.onmouseup;
        const disX = evnt.clientX - boxElem.offsetLeft;
        const disY = evnt.clientY - boxElem.offsetTop;
        const { visibleHeight, visibleWidth } = getDomNode();
        document.onmousemove = (evnt2) => {
          evnt2.preventDefault();
          const offsetWidth = boxElem.offsetWidth;
          const offsetHeight = boxElem.offsetHeight;
          const minX = marginSize;
          const maxX = visibleWidth - offsetWidth - marginSize - 1;
          const minY = marginSize;
          const maxY = visibleHeight - offsetHeight - marginSize - 1;
          let left = evnt2.clientX - disX;
          let top = evnt2.clientY - disY;
          if (left > maxX) {
            left = maxX;
          }
          if (left < minX) {
            left = minX;
          }
          if (top > maxY) {
            top = maxY;
          }
          if (top < minY) {
            top = minY;
          }
          boxElem.style.left = `${left}px`;
          boxElem.style.top = `${top}px`;
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
          emit("move", { type: "move", $event: evnt2 });
        };
        document.onmouseup = () => {
          document.onmousemove = domMousemove;
          document.onmouseup = domMouseup;
          if (remember && storage) {
            nextTick(() => {
              savePosStorage();
            });
          }
          setTimeout(() => {
            boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
          }, 50);
        };
      }
    };
    const dragEvent = (evnt) => {
      evnt.preventDefault();
      const { remember, storage } = props;
      const { visibleHeight, visibleWidth } = getDomNode();
      const marginSize = import_xe_utils19.default.toNumber(props.marginSize);
      const targetElem = evnt.target;
      const type = targetElem.getAttribute("type");
      const minWidth = import_xe_utils19.default.toNumber(props.minWidth);
      const minHeight = import_xe_utils19.default.toNumber(props.minHeight);
      const maxWidth = visibleWidth;
      const maxHeight = visibleHeight;
      const boxElem = getBox();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const clientWidth = boxElem.clientWidth;
      const clientHeight = boxElem.clientHeight;
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      const offsetTop = boxElem.offsetTop;
      const offsetLeft = boxElem.offsetLeft;
      const params = { type: "resize" };
      document.onmousemove = (evnt2) => {
        evnt2.preventDefault();
        let dragLeft;
        let dragTop;
        let width;
        let height;
        switch (type) {
          case "wl":
            dragLeft = disX - evnt2.clientX;
            width = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            break;
          case "swst":
            dragLeft = disX - evnt2.clientX;
            dragTop = disY - evnt2.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "swlb":
            dragLeft = disX - evnt2.clientX;
            dragTop = evnt2.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case "st":
            dragTop = disY - evnt2.clientY;
            height = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "wr":
            dragLeft = evnt2.clientX - disX;
            width = dragLeft + clientWidth;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case "sest":
            dragLeft = evnt2.clientX - disX;
            dragTop = disY - evnt2.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "selb":
            dragLeft = evnt2.clientX - disX;
            dragTop = evnt2.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case "sb":
            dragTop = evnt2.clientY - disY;
            height = dragTop + clientHeight;
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
        if (remember && storage) {
          savePosStorage();
        }
        modalMethods.dispatchEvent("resize", params, evnt2);
      };
      document.onmouseup = () => {
        reactData.zoomLocat = null;
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        setTimeout(() => {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
        }, 50);
      };
    };
    modalMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $modal: $xemodal, $event: evnt }, params));
      },
      open: openModal2,
      close() {
        return closeModal2("close");
      },
      getBox,
      getPosition,
      setPosition,
      isMaximized,
      zoom,
      maximize,
      revert
    };
    Object.assign($xemodal, modalMethods);
    const renderTitles = () => {
      const { slots: propSlots = {}, showClose, showZoom, title } = props;
      const { zoomLocat } = reactData;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      const titVNs = [
        h("div", {
          class: "vxe-modal--header-title"
        }, titleSlot ? getSlotVNs(titleSlot({ $modal: $xemodal })) : title ? getFuncText(title) : conf_default.i18n("vxe.alert.title"))
      ];
      const rightVNs = [];
      if (cornerSlot) {
        rightVNs.push(h("span", {
          class: "vxe-modal--corner-wrapper"
        }, getSlotVNs(cornerSlot({ $modal: $xemodal }))));
      }
      if (showZoom) {
        rightVNs.push(h("i", {
          class: ["vxe-modal--zoom-btn", "trigger--btn", zoomLocat ? conf_default.icon.MODAL_ZOOM_OUT : conf_default.icon.MODAL_ZOOM_IN],
          title: conf_default.i18n(`vxe.modal.zoom${zoomLocat ? "Out" : "In"}`),
          onClick: toggleZoomEvent
        }));
      }
      if (showClose) {
        rightVNs.push(h("i", {
          class: ["vxe-modal--close-btn", "trigger--btn", conf_default.icon.MODAL_CLOSE],
          title: conf_default.i18n("vxe.modal.close"),
          onClick: closeEvent
        }));
      }
      titVNs.push(h("div", {
        class: "vxe-modal--header-right"
      }, rightVNs));
      return titVNs;
    };
    const renderHeaders = () => {
      const { slots: propSlots = {}, showZoom, draggable } = props;
      const isMsg = computeIsMsg.value;
      const headerSlot = slots.header || propSlots.header;
      const headVNs = [];
      if (props.showHeader) {
        const headerOns = {};
        if (draggable) {
          headerOns.onMousedown = mousedownEvent;
        }
        if (showZoom && props.dblclickZoom && props.type === "modal") {
          headerOns.onDblclick = toggleZoomEvent;
        }
        headVNs.push(h("div", Object.assign({ class: ["vxe-modal--header", {
          "is--draggable": draggable,
          "is--ellipsis": !isMsg && props.showTitleOverflow
        }] }, headerOns), headerSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(headerSlot({ $modal: $xemodal })) : renderTitles()));
      }
      return headVNs;
    };
    const renderBodys = () => {
      const { slots: propSlots = {}, status, message } = props;
      const content = props.content || message;
      const isMsg = computeIsMsg.value;
      const defaultSlot = slots.default || propSlots.default;
      const contVNs = [];
      if (status) {
        contVNs.push(h("div", {
          class: "vxe-modal--status-wrapper"
        }, [
          h("i", {
            class: ["vxe-modal--status-icon", props.iconStatus || conf_default.icon[`MODAL_${status}`.toLocaleUpperCase()]]
          })
        ]));
      }
      contVNs.push(h("div", {
        class: "vxe-modal--content"
      }, defaultSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(defaultSlot({ $modal: $xemodal })) : getFuncText(content)));
      if (!isMsg) {
        contVNs.push(h(loading_default2, {
          class: "vxe-modal--loading",
          modelValue: props.loading
        }));
      }
      return [
        h("div", {
          class: "vxe-modal--body"
        }, contVNs)
      ];
    };
    const renderBtns = () => {
      const { showCancelButton, showConfirmButton, type } = props;
      const btnVNs = [];
      if (import_xe_utils19.default.isBoolean(showCancelButton) ? showCancelButton : type === "confirm") {
        btnVNs.push(h(button_default, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || conf_default.i18n("vxe.button.cancel"),
          onClick: cancelEvent
        }));
      }
      if (import_xe_utils19.default.isBoolean(showConfirmButton) ? showConfirmButton : type === "confirm" || type === "alert") {
        btnVNs.push(h(button_default, {
          key: 2,
          ref: refConfirmBtn,
          status: "primary",
          content: props.confirmButtonText || conf_default.i18n("vxe.button.confirm"),
          onClick: confirmEvent
        }));
      }
      return btnVNs;
    };
    const renderFooters = () => {
      const { slots: propSlots = {} } = props;
      const isMsg = computeIsMsg.value;
      const footerSlot = slots.footer || propSlots.footer;
      const footVNs = [];
      if (props.showFooter) {
        footVNs.push(h("div", {
          class: "vxe-modal--footer"
        }, footerSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(footerSlot({ $modal: $xemodal })) : renderBtns()));
      }
      if (!isMsg && props.resize) {
        footVNs.push(h("span", {
          class: "vxe-modal--resize"
        }, ["wl", "wr", "swst", "sest", "st", "swlb", "selb", "sb"].map((type) => {
          return h("span", {
            class: `${type}-resize`,
            type,
            onMousedown: dragEvent
          });
        })));
      }
      return footVNs;
    };
    const renderVN = () => {
      const { className, type, animat, loading, status, lockScroll, lockView, mask, resize } = props;
      const { inited, zoomLocat, modalTop, contentVisible, visible } = reactData;
      const vSize = computeSize.value;
      return h(Teleport, {
        to: "body",
        disabled: props.transfer ? !inited : true
      }, [
        h("div", {
          ref: refElem,
          class: ["vxe-modal--wrapper", `type--${type}`, className || "", {
            [`size--${vSize}`]: vSize,
            [`status--${status}`]: status,
            "is--animat": animat,
            "lock--scroll": lockScroll,
            "lock--view": lockView,
            "is--resize": resize,
            "is--mask": mask,
            "is--maximize": zoomLocat,
            "is--visible": contentVisible,
            "is--active": visible,
            "is--loading": loading
          }],
          style: {
            zIndex: reactData.modalZindex,
            top: modalTop ? `${modalTop}px` : null
          },
          onClick: selfClickEvent
        }, [
          h("div", {
            ref: refModalBox,
            class: "vxe-modal--box",
            onMousedown: boxMousedownEvent
          }, renderHeaders().concat(renderBodys(), renderFooters()))
        ])
      ]);
    };
    $xemodal.renderVN = renderVN;
    watch(() => props.width, recalculate);
    watch(() => props.height, recalculate);
    watch(() => props.modelValue, (value) => {
      if (value) {
        openModal2();
      } else {
        closeModal2("model");
      }
    });
    onMounted(() => {
      if (true) {
        if (props.type === "modal" && props.showFooter && !(props.showConfirmButton || props.showCancelButton || slots.footer)) {
          warnLog("vxe.modal.footPropErr");
        }
      }
      nextTick(() => {
        if (props.storage && !props.id) {
          errLog("vxe.error.reqProp", ["modal.id"]);
        }
        if (props.modelValue) {
          openModal2();
        }
        recalculate();
      });
      if (props.escClosable) {
        GlobalEvent.on($xemodal, "keydown", handleGlobalKeydownEvent);
      }
    });
    onUnmounted(() => {
      GlobalEvent.off($xemodal, "keydown");
      removeMsgQueue();
    });
    return $xemodal;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/input/src/input.js
var import_xe_utils22 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/input/src/date.js
var import_xe_utils20 = __toESM(require_xe_utils());
function toStringTimeDate(str) {
  if (str) {
    const rest = /* @__PURE__ */ new Date();
    let h2 = 0;
    let m = 0;
    let s = 0;
    if (import_xe_utils20.default.isDate(str)) {
      h2 = str.getHours();
      m = str.getMinutes();
      s = str.getSeconds();
    } else {
      str = import_xe_utils20.default.toValueString(str);
      const parses = str.match(/^(\d{1,2})(:(\d{1,2}))?(:(\d{1,2}))?/);
      if (parses) {
        h2 = import_xe_utils20.default.toNumber(parses[1]);
        m = import_xe_utils20.default.toNumber(parses[3]);
        s = import_xe_utils20.default.toNumber(parses[5]);
      }
    }
    rest.setHours(h2);
    rest.setMinutes(m);
    rest.setSeconds(s);
    return rest;
  }
  return /* @__PURE__ */ new Date("");
}
function getDateQuarter(date) {
  const month = date.getMonth();
  if (month < 3) {
    return 1;
  } else if (month < 6) {
    return 2;
  } else if (month < 9) {
    return 3;
  }
  return 4;
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/input/src/number.js
var import_xe_utils21 = __toESM(require_xe_utils());
function handleNumber(val) {
  return import_xe_utils21.default.isString(val) ? val.replace(/,/g, "") : val;
}
function toFloatValueFixed(inputValue, digitsValue) {
  if (/^-/.test("" + inputValue)) {
    return import_xe_utils21.default.toFixed(import_xe_utils21.default.ceil(inputValue, digitsValue), digitsValue);
  }
  return import_xe_utils21.default.toFixed(import_xe_utils21.default.floor(inputValue, digitsValue), digitsValue);
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/input/src/input.js
var yearSize = 12;
var monthSize = 20;
var quarterSize = 8;
var input_default = defineComponent({
  name: "VxeInput",
  props: {
    modelValue: [String, Number, Date],
    immediate: { type: Boolean, default: true },
    name: String,
    type: { type: String, default: "text" },
    clearable: { type: Boolean, default: () => conf_default.input.clearable },
    readonly: Boolean,
    disabled: Boolean,
    placeholder: {
      type: String,
      default: () => import_xe_utils22.default.eqNull(conf_default.input.placeholder) ? conf_default.i18n("vxe.base.pleaseInput") : conf_default.input.placeholder
    },
    maxlength: [String, Number],
    autocomplete: { type: String, default: "off" },
    align: String,
    form: String,
    className: String,
    size: { type: String, default: () => conf_default.input.size || conf_default.size },
    multiple: Boolean,
    // text
    showWordCount: Boolean,
    countMethod: Function,
    // number、integer、float
    min: { type: [String, Number], default: null },
    max: { type: [String, Number], default: null },
    step: [String, Number],
    exponential: { type: Boolean, default: () => conf_default.input.exponential },
    // number、integer、float、password
    controls: { type: Boolean, default: () => conf_default.input.controls },
    // float
    digits: { type: [String, Number], default: () => conf_default.input.digits },
    // date、week、month、quarter、year
    startDate: { type: [String, Number, Date], default: () => conf_default.input.startDate },
    endDate: { type: [String, Number, Date], default: () => conf_default.input.endDate },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    // 已废弃 startWeek，被 startDay 替换
    startWeek: Number,
    startDay: { type: [String, Number], default: () => conf_default.input.startDay },
    labelFormat: { type: String, default: () => conf_default.input.labelFormat },
    valueFormat: { type: String, default: () => conf_default.input.valueFormat },
    editable: { type: Boolean, default: true },
    festivalMethod: { type: Function, default: () => conf_default.input.festivalMethod },
    disabledMethod: { type: Function, default: () => conf_default.input.disabledMethod },
    // week
    selectDay: { type: [String, Number], default: () => conf_default.input.selectDay },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: { type: Boolean, default: () => conf_default.input.transfer }
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "search-click",
    "toggle-visible",
    "prev-number",
    "next-number",
    "prefix-click",
    "suffix-click",
    "date-prev",
    "date-today",
    "date-next"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils22.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      inited: false,
      panelIndex: 0,
      showPwd: false,
      visiblePanel: false,
      animatVisible: false,
      panelStyle: null,
      panelPlacement: "",
      isActivated: false,
      inputValue: props.modelValue,
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    });
    const refElem = ref();
    const refInputTarget = ref();
    const refInputPanel = ref();
    const refInputTimeBody = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeinput = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let inputMethods = {};
    const parseDate2 = (value, format) => {
      const { type } = props;
      if (type === "time") {
        return toStringTimeDate(value);
      }
      return import_xe_utils22.default.toStringDate(value, format);
    };
    const computeIsDateTimeType = computed(() => {
      const { type } = props;
      return type === "time" || type === "datetime";
    });
    const computeIsNumType = computed(() => {
      return ["number", "integer", "float"].indexOf(props.type) > -1;
    });
    const computeInputCount = computed(() => {
      return import_xe_utils22.default.getSize(reactData.inputValue);
    });
    const computeIsCountError = computed(() => {
      const inputCount = computeInputCount.value;
      return props.maxlength && inputCount > import_xe_utils22.default.toNumber(props.maxlength);
    });
    const computeIsDatePickerType = computed(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeIsPawdType = computed(() => {
      return props.type === "password";
    });
    const computeIsSearchType = computed(() => {
      return props.type === "search";
    });
    const computeDigitsValue = computed(() => {
      return import_xe_utils22.default.toInteger(props.digits) || 1;
    });
    const computeStepValue = computed(() => {
      const { type } = props;
      const digitsValue = computeDigitsValue.value;
      const step = props.step;
      if (type === "integer") {
        return import_xe_utils22.default.toInteger(step) || 1;
      } else if (type === "float") {
        return import_xe_utils22.default.toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return import_xe_utils22.default.toNumber(step) || 1;
    });
    const computeIsClearable = computed(() => {
      const { type } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      return props.clearable && (isPawdType || isNumType || isDatePickerType || type === "text" || type === "search");
    });
    const computeDateStartTime = computed(() => {
      return props.startDate ? import_xe_utils22.default.toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = computed(() => {
      return props.endDate ? import_xe_utils22.default.toStringDate(props.endDate) : null;
    });
    const computeSupportMultiples = computed(() => {
      return ["date", "week", "month", "quarter", "year"].includes(props.type);
    });
    const computeDateListValue = computed(() => {
      const { modelValue, multiple } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePickerType) {
        return import_xe_utils22.default.toValueString(modelValue).split(",").map((item) => {
          const date = parseDate2(item, dateValueFormat);
          if (import_xe_utils22.default.isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map((date) => import_xe_utils22.default.toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map((date) => import_xe_utils22.default.toDateString(date, dateLabelFormat)).join(", ");
    });
    const computeDateValueFormat = computed(() => {
      const { type } = props;
      return type === "time" ? "HH:mm:ss" : props.valueFormat || (type === "datetime" ? "yyyy-MM-dd HH:mm:ss" : "yyyy-MM-dd");
    });
    const computeDateValue = computed(() => {
      const { modelValue } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePickerType) {
        const date = parseDate2(modelValue, dateValueFormat);
        if (import_xe_utils22.default.isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = computed(() => {
      const dateStartTime = computeDateStartTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = computed(() => {
      const dateEndTime = computeDateEndTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = computed(() => {
      const { datetimePanelValue } = reactData;
      if (datetimePanelValue) {
        return import_xe_utils22.default.toDateString(datetimePanelValue, "HH:mm:ss");
      }
      return "";
    });
    const computeDateHMSTime = computed(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1e3 : 0;
    });
    const computeDateLabelFormat = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        return props.labelFormat || conf_default.i18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return null;
    });
    const computeYearList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index = -4; index < yearSize + 4; index++) {
          const date = import_xe_utils22.default.getWhatYear(startYearDate, index, "first");
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelLabel = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const { datePanelType, selectMonth } = reactData;
        const yearList = computeYearList.value;
        let year = "";
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === "quarter") {
          return conf_default.i18n("vxe.input.date.quarterLabel", [year]);
        } else if (datePanelType === "month") {
          return conf_default.i18n("vxe.input.date.monthLabel", [year]);
        } else if (datePanelType === "year") {
          return yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : "";
        }
        return conf_default.i18n("vxe.input.date.dayLabel", [year, month ? conf_default.i18n(`vxe.input.date.m${month}`) : "-"]);
      }
      return "";
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay, startWeek } = props;
      return import_xe_utils22.default.toNumber(import_xe_utils22.default.isNumber(startDay) || import_xe_utils22.default.isString(startDay) ? startDay : startWeek);
    });
    const computeWeekDatas = computed(() => {
      const weeks = [];
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map((day) => {
          return {
            value: day,
            label: conf_default.i18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const dateHeaders = computeDateHeaders.value;
        return [{ label: conf_default.i18n("vxe.input.date.weeks.w") }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = computed(() => {
      const yearList = computeYearList.value;
      return import_xe_utils22.default.chunk(yearList, 4);
    });
    const computeQuarterList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = import_xe_utils22.default.getWhatYear(selectMonth, 0, "first");
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize - 2; index++) {
          const date = import_xe_utils22.default.getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = computed(() => {
      const quarterList = computeQuarterList.value;
      return import_xe_utils22.default.chunk(quarterList, 2);
    });
    const computeMonthList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = import_xe_utils22.default.getWhatYear(selectMonth, 0, "first").getFullYear();
        for (let index = -4; index < monthSize - 4; index++) {
          const date = import_xe_utils22.default.getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = computed(() => {
      const monthList = computeMonthList.value;
      return import_xe_utils22.default.chunk(monthList, 4);
    });
    const computeDayList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(import_xe_utils22.default.getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = import_xe_utils22.default.getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = computed(() => {
      const dayList = computeDayList.value;
      return import_xe_utils22.default.chunk(dayList, 7);
    });
    const computeWeekDates = computed(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map((list) => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: import_xe_utils22.default.getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 24; index++) {
          list.push({
            value: index,
            label: ("" + index).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeMinuteList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 60; index++) {
          list.push({
            value: index,
            label: ("" + index).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeSecondList = computed(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const computeInpReadonly = computed(() => {
      const { type, readonly, editable, multiple } = props;
      return readonly || multiple || !editable || type === "week" || type === "quarter";
    });
    const computeInputType = computed(() => {
      const { type } = props;
      const { showPwd } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      if (isDatePickerType || isNumType || isPawdType && showPwd || type === "number") {
        return "text";
      }
      return type;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      return "";
    });
    const computeInpMaxlength = computed(() => {
      const { maxlength } = props;
      const isNumType = computeIsNumType.value;
      return isNumType && !import_xe_utils22.default.toNumber(maxlength) ? 16 : maxlength;
    });
    const computeInpImmediate = computed(() => {
      const { type, immediate } = props;
      return immediate || !(type === "text" || type === "number" || type === "integer" || type === "float");
    });
    const computeNumValue = computed(() => {
      const { type } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        return type === "integer" ? import_xe_utils22.default.toInteger(handleNumber(inputValue)) : import_xe_utils22.default.toNumber(handleNumber(inputValue));
      }
      return 0;
    });
    const computeIsDisabledSubtractNumber = computed(() => {
      const { min } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && isNumType && min !== null) {
        return numValue <= import_xe_utils22.default.toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = computed(() => {
      const { max } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && isNumType && max !== null) {
        return numValue >= import_xe_utils22.default.toNumber(max);
      }
      return false;
    });
    const getNumberValue = (val) => {
      const { type, exponential } = props;
      const inpMaxlength = computeInpMaxlength.value;
      const digitsValue = computeDigitsValue.value;
      const restVal = type === "float" ? toFloatValueFixed(val, digitsValue) : import_xe_utils22.default.toValueString(val);
      if (exponential && (val === restVal || import_xe_utils22.default.toValueString(val).toLowerCase() === import_xe_utils22.default.toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxlength);
    };
    const triggerEvent3 = (evnt) => {
      const { inputValue } = reactData;
      inputMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const emitModel = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      inputMethods.dispatchEvent("input", { value }, evnt);
      if (import_xe_utils22.default.toValueString(props.modelValue) !== value) {
        inputMethods.dispatchEvent("change", { value }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, value);
        }
      }
    };
    const emitInputEvent = (value, evnt) => {
      const isDatePickerType = computeIsDatePickerType.value;
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (!isDatePickerType) {
        if (inpImmediate) {
          emitModel(value, evnt);
        } else {
          inputMethods.dispatchEvent("input", { value }, evnt);
        }
      }
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = (evnt) => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent3(evnt);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent3(evnt);
    };
    const clickPrefixEvent = (evnt) => {
      const { disabled } = props;
      if (!disabled) {
        const { inputValue } = reactData;
        inputMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    let hidePanelTimeout;
    const hidePanel = () => {
      return new Promise((resolve) => {
        reactData.visiblePanel = false;
        hidePanelTimeout = window.setTimeout(() => {
          reactData.animatVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const { type } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      if (isNumType || ["text", "search", "password"].indexOf(type) > -1) {
        focus();
      }
      inputMethods.dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const { disabled } = props;
      if (!disabled) {
        if (hasClass(evnt.currentTarget, "is--clear")) {
          emitModel("", evnt);
          clearValueEvent(evnt, "");
        } else {
          const { inputValue } = reactData;
          inputMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
        }
      }
    };
    const dateParseValue = (value) => {
      const { type } = props;
      const { valueFormat } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = "";
      if (value) {
        dValue = parseDate2(value, valueFormat);
      }
      if (import_xe_utils22.default.isValidDate(dValue)) {
        dLabel = import_xe_utils22.default.toDateString(dValue, dateLabelFormat, { firstDay: firstDayOfWeek });
        if (dateLabelFormat && type === "week") {
          const firstWeekDate = import_xe_utils22.default.getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf("yyyy");
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    const changeValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      const { inputValue } = reactData;
      if (isDatePickerType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    const initValue = () => {
      const { type } = props;
      const { inputValue } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const digitsValue = computeDigitsValue.value;
      if (isDatePickerType) {
        changeValue();
      } else if (type === "float") {
        if (inputValue) {
          const validValue = toFloatValueFixed(inputValue, digitsValue);
          if (inputValue !== validValue) {
            emitModel(validValue, { type: "init" });
          }
        }
      }
    };
    const vaildMaxNum = (num) => {
      return props.max === null || import_xe_utils22.default.toNumber(num) <= import_xe_utils22.default.toNumber(props.max);
    };
    const vaildMinNum = (num) => {
      return props.min === null || import_xe_utils22.default.toNumber(num) >= import_xe_utils22.default.toNumber(props.min);
    };
    const dateRevert = () => {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const dateCheckMonth = (date) => {
      const month = import_xe_utils22.default.getWhatMonth(date, 0, "first");
      if (!import_xe_utils22.default.isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date) => {
      const { modelValue, multiple } = props;
      const { datetimePanelValue } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === "week") {
        const sWeek = import_xe_utils22.default.toNumber(props.selectDay);
        date = import_xe_utils22.default.getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        date.setHours(datetimePanelValue.getHours());
        date.setMinutes(datetimePanelValue.getMinutes());
        date.setSeconds(datetimePanelValue.getSeconds());
      }
      const inpVal = import_xe_utils22.default.toDateString(date, dateValueFormat, { firstDay: firstDayOfWeek });
      dateCheckMonth(date);
      if (multiple) {
        const dateMultipleValue = computeDateMultipleValue.value;
        if (isDateTimeType) {
          const dateListValue = [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = import_xe_utils22.default.findIndexOf(dateListValue, (val) => import_xe_utils22.default.isDateSame(date, val, "yyyyMMdd"));
          if (eqIndex === -1) {
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach((item) => {
            if (item) {
              item.setHours(datetimePanelValue.getHours());
              item.setMinutes(datetimePanelValue.getMinutes());
              item.setSeconds(datetimePanelValue.getSeconds());
              datetimeRest.push(item);
            }
          });
          emitModel(datetimeRest.map((date2) => import_xe_utils22.default.toDateString(date2, dateValueFormat)).join(","), { type: "update" });
        } else {
          if (dateMultipleValue.some((val) => import_xe_utils22.default.isEqual(val, inpVal))) {
            emitModel(dateMultipleValue.filter((val) => !import_xe_utils22.default.isEqual(val, inpVal)).join(","), { type: "update" });
          } else {
            emitModel(dateMultipleValue.concat([inpVal]).join(","), { type: "update" });
          }
        }
      } else {
        if (!import_xe_utils22.default.isEqual(modelValue, inpVal)) {
          emitModel(inpVal, { type: "update" });
        }
      }
    };
    const afterCheckValue = () => {
      const { type, min, max, exponential } = props;
      const { inputValue, datetimePanelValue } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      const inpReadonly = computeInpReadonly.value;
      if (!inpReadonly) {
        if (isNumType) {
          if (inputValue) {
            let inpNumVal = type === "integer" ? import_xe_utils22.default.toInteger(handleNumber(inputValue)) : import_xe_utils22.default.toNumber(handleNumber(inputValue));
            if (!vaildMinNum(inpNumVal)) {
              inpNumVal = min;
            } else if (!vaildMaxNum(inpNumVal)) {
              inpNumVal = max;
            }
            if (exponential) {
              const inpStringVal = import_xe_utils22.default.toValueString(inputValue).toLowerCase();
              if (inpStringVal === import_xe_utils22.default.toNumber(inpNumVal).toExponential()) {
                inpNumVal = inpStringVal;
              }
            }
            emitModel(getNumberValue(inpNumVal), { type: "check" });
          }
        } else if (isDatePickerType) {
          if (inputValue) {
            let inpDateVal = parseDate2(inputValue, dateLabelFormat);
            if (import_xe_utils22.default.isValidDate(inpDateVal)) {
              if (type === "time") {
                inpDateVal = import_xe_utils22.default.toDateString(inpDateVal, dateLabelFormat);
                if (inputValue !== inpDateVal) {
                  emitModel(inpDateVal, { type: "check" });
                }
                reactData.inputValue = inpDateVal;
              } else {
                let isChange = false;
                const firstDayOfWeek = computeFirstDayOfWeek.value;
                if (type === "datetime") {
                  const dateValue = computeDateValue.value;
                  if (inputValue !== import_xe_utils22.default.toDateString(dateValue, dateLabelFormat) || inputValue !== import_xe_utils22.default.toDateString(inpDateVal, dateLabelFormat)) {
                    isChange = true;
                    datetimePanelValue.setHours(inpDateVal.getHours());
                    datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                    datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                  }
                } else {
                  isChange = true;
                }
                reactData.inputValue = import_xe_utils22.default.toDateString(inpDateVal, dateLabelFormat, { firstDay: firstDayOfWeek });
                if (isChange) {
                  dateChange(inpDateVal);
                }
              }
            } else {
              dateRevert();
            }
          } else {
            emitModel("", { type: "check" });
          }
        }
      }
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        emitModel(inputValue, evnt);
      }
      afterCheckValue();
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      inputMethods.dispatchEvent("blur", { value: inputValue }, evnt);
    };
    const passwordToggleEvent = (evnt) => {
      const { readonly, disabled } = props;
      const { showPwd } = reactData;
      if (!disabled && !readonly) {
        reactData.showPwd = !showPwd;
      }
      inputMethods.dispatchEvent("toggle-visible", { visible: reactData.showPwd }, evnt);
    };
    const searchEvent = (evnt) => {
      inputMethods.dispatchEvent("search-click", {}, evnt);
    };
    const numberChange = (isPlus, evnt) => {
      const { min, max, type } = props;
      const { inputValue } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === "integer" ? import_xe_utils22.default.toInteger(handleNumber(inputValue)) : import_xe_utils22.default.toNumber(handleNumber(inputValue));
      const newValue = isPlus ? import_xe_utils22.default.add(numValue, stepValue) : import_xe_utils22.default.subtract(numValue, stepValue);
      let restNum;
      if (!vaildMinNum(newValue)) {
        restNum = min;
      } else if (!vaildMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    let downbumTimeout;
    const numberNextEvent = (evnt) => {
      const { readonly, disabled } = props;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      clearTimeout(downbumTimeout);
      if (!disabled && !readonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      inputMethods.dispatchEvent("next-number", { value: reactData.inputValue }, evnt);
    };
    const numberDownNextEvent = (evnt) => {
      downbumTimeout = window.setTimeout(() => {
        numberNextEvent(evnt);
        numberDownNextEvent(evnt);
      }, 60);
    };
    const numberPrevEvent = (evnt) => {
      const { readonly, disabled } = props;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      clearTimeout(downbumTimeout);
      if (!disabled && !readonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      inputMethods.dispatchEvent("prev-number", { value: reactData.inputValue }, evnt);
    };
    const numberKeydownEvent = (evnt) => {
      const isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
      const isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
      }
    };
    const keydownEvent = (evnt) => {
      const { exponential, controls } = props;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        const isCtrlKey = evnt.ctrlKey;
        const isShiftKey = evnt.shiftKey;
        const isAltKey = evnt.altKey;
        const keyCode = evnt.keyCode;
        if (!isCtrlKey && !isShiftKey && !isAltKey && (hasEventKey(evnt, EVENT_KEYS.SPACEBAR) || (!exponential || keyCode !== 69) && (keyCode >= 65 && keyCode <= 90) || keyCode >= 186 && keyCode <= 188 || keyCode >= 191)) {
          evnt.preventDefault();
        }
        if (controls) {
          numberKeydownEvent(evnt);
        }
      }
      triggerEvent3(evnt);
    };
    const keyupEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const numberStopDown = () => {
      clearTimeout(downbumTimeout);
    };
    const numberDownPrevEvent = (evnt) => {
      downbumTimeout = window.setTimeout(() => {
        numberPrevEvent(evnt);
        numberDownPrevEvent(evnt);
      }, 60);
    };
    const numberMousedownEvent = (evnt) => {
      numberStopDown();
      if (evnt.button === 0) {
        const isPrevNumber = hasClass(evnt.currentTarget, "is--prev");
        if (isPrevNumber) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
        downbumTimeout = window.setTimeout(() => {
          if (isPrevNumber) {
            numberDownPrevEvent(evnt);
          } else {
            numberDownNextEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = (evnt) => {
      const isNumType = computeIsNumType.value;
      if (isNumType && props.controls) {
        if (reactData.isActivated) {
          const delta = evnt.deltaY;
          if (delta > 0) {
            numberNextEvent(evnt);
          } else if (delta < 0) {
            numberPrevEvent(evnt);
          }
          evnt.preventDefault();
        }
      }
      triggerEvent3(evnt);
    };
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = import_xe_utils22.default.getWhatMonth(date, offsetMonth, "first");
    };
    const dateNowHandle = () => {
      const currentDate = import_xe_utils22.default.getWhatDay(Date.now(), 0, "first");
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleTypeEvent = () => {
      let { datePanelType } = reactData;
      if (datePanelType === "month" || datePanelType === "quarter") {
        datePanelType = "year";
      } else {
        datePanelType = "month";
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputValue } = reactData;
      const value = inputValue;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        if (type === "year") {
          reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, -yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, -yearSize, "first");
          } else {
            reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, -1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, -yearSize, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, -1, "first");
          } else {
            reactData.selectMonth = import_xe_utils22.default.getWhatMonth(selectMonth, -1, "first");
          }
        }
        inputMethods.dispatchEvent("date-prev", { value, type }, evnt);
      }
    };
    const dateTodayMonthEvent = (evnt) => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
        hidePanel();
      }
      inputMethods.dispatchEvent("date-today", { type: props.type }, evnt);
    };
    const dateNextEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputValue } = reactData;
      const value = inputValue;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        if (type === "year") {
          reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, yearSize, "first");
          } else {
            reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, 1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, yearSize, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = import_xe_utils22.default.getWhatYear(selectMonth, 1, "first");
          } else {
            reactData.selectMonth = import_xe_utils22.default.getWhatMonth(selectMonth, 1, "first");
          }
        }
        inputMethods.dispatchEvent("date-next", { value, type }, evnt);
      }
    };
    const isDateDisabled = (item) => {
      const { disabledMethod } = props;
      const { datePanelType } = reactData;
      return disabledMethod && disabledMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $input: $xeinput });
    };
    const dateSelectItem = (date) => {
      const { type, multiple } = props;
      const { datePanelType } = reactData;
      if (type === "month") {
        if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === "year") {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === "quarter") {
        if (datePanelType === "year") {
          reactData.datePanelType = "quarter";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === "month") {
          reactData.datePanelType = type === "week" ? type : "day";
          dateCheckMonth(date);
        } else if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === "datetime") {
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = (item) => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = (offsetDay) => {
      if (!isDateDisabled({ date: offsetDay })) {
        const dayList = computeDayList.value;
        if (!dayList.some((item) => import_xe_utils22.default.isDateSame(item.date, offsetDay, "yyyyMMdd"))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = (offsetYear) => {
      if (!isDateDisabled({ date: offsetYear })) {
        const yearList = computeYearList.value;
        if (!yearList.some((item) => import_xe_utils22.default.isDateSame(item.date, offsetYear, "yyyy"))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = (offsetQuarter) => {
      if (!isDateDisabled({ date: offsetQuarter })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some((item) => import_xe_utils22.default.isDateSame(item.date, offsetQuarter, "yyyyq"))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = (offsetMonth) => {
      if (!isDateDisabled({ date: offsetMonth })) {
        const monthList = computeMonthList.value;
        if (!monthList.some((item) => import_xe_utils22.default.isDateSame(item.date, offsetMonth, "yyyyMM"))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = (item) => {
      if (!isDateDisabled(item)) {
        const { datePanelType } = reactData;
        if (datePanelType === "month") {
          dateMoveMonth(item.date);
        } else if (datePanelType === "quarter") {
          dateMoveQuarter(item.date);
        } else if (datePanelType === "year") {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const updateTimePos = (liElem) => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = (evnt) => {
      reactData.datetimePanelValue = new Date(reactData.datetimePanelValue.getTime());
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      reactData.datetimePanelValue.setHours(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = () => {
      const { multiple } = props;
      const { datetimePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach((item) => {
              if (item) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
                datetimeRest.push(item);
              }
            });
            emitModel(datetimeRest.map((date) => import_xe_utils22.default.toDateString(date, dateValueFormat)).join(","), { type: "update" });
          } else {
            emitModel(dateMultipleValue.join(","), { type: "update" });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
    };
    const dateMinuteEvent = (evnt, item) => {
      reactData.datetimePanelValue.setMinutes(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      reactData.datetimePanelValue.setSeconds(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateOffsetEvent = (evnt) => {
      const { isActivated, datePanelValue, datePanelType } = reactData;
      if (isActivated) {
        evnt.preventDefault();
        const isLeftArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
        const isRightArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
        if (datePanelType === "year") {
          let offsetYear = import_xe_utils22.default.getWhatYear(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetYear = import_xe_utils22.default.getWhatYear(offsetYear, -1);
          } else if (isUpArrow) {
            offsetYear = import_xe_utils22.default.getWhatYear(offsetYear, -4);
          } else if (isRightArrow) {
            offsetYear = import_xe_utils22.default.getWhatYear(offsetYear, 1);
          } else if (isDwArrow) {
            offsetYear = import_xe_utils22.default.getWhatYear(offsetYear, 4);
          }
          dateMoveYear(offsetYear);
        } else if (datePanelType === "quarter") {
          let offsetQuarter = import_xe_utils22.default.getWhatQuarter(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetQuarter = import_xe_utils22.default.getWhatQuarter(offsetQuarter, -1);
          } else if (isUpArrow) {
            offsetQuarter = import_xe_utils22.default.getWhatQuarter(offsetQuarter, -2);
          } else if (isRightArrow) {
            offsetQuarter = import_xe_utils22.default.getWhatQuarter(offsetQuarter, 1);
          } else if (isDwArrow) {
            offsetQuarter = import_xe_utils22.default.getWhatQuarter(offsetQuarter, 2);
          }
          dateMoveQuarter(offsetQuarter);
        } else if (datePanelType === "month") {
          let offsetMonth = import_xe_utils22.default.getWhatMonth(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetMonth = import_xe_utils22.default.getWhatMonth(offsetMonth, -1);
          } else if (isUpArrow) {
            offsetMonth = import_xe_utils22.default.getWhatMonth(offsetMonth, -4);
          } else if (isRightArrow) {
            offsetMonth = import_xe_utils22.default.getWhatMonth(offsetMonth, 1);
          } else if (isDwArrow) {
            offsetMonth = import_xe_utils22.default.getWhatMonth(offsetMonth, 4);
          }
          dateMoveMonth(offsetMonth);
        } else {
          let offsetDay = datePanelValue || import_xe_utils22.default.getWhatDay(Date.now(), 0, "first");
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          if (isLeftArrow) {
            offsetDay = import_xe_utils22.default.getWhatDay(offsetDay, -1);
          } else if (isUpArrow) {
            offsetDay = import_xe_utils22.default.getWhatWeek(offsetDay, -1, firstDayOfWeek);
          } else if (isRightArrow) {
            offsetDay = import_xe_utils22.default.getWhatDay(offsetDay, 1);
          } else if (isDwArrow) {
            offsetDay = import_xe_utils22.default.getWhatWeek(offsetDay, 1, firstDayOfWeek);
          }
          dateMoveDay(offsetDay);
        }
      }
    };
    const datePgOffsetEvent = (evnt) => {
      const { isActivated } = reactData;
      if (isActivated) {
        const isPgUp = hasEventKey(evnt, EVENT_KEYS.PAGE_UP);
        evnt.preventDefault();
        if (isPgUp) {
          datePrevEvent(evnt);
        } else {
          dateNextEvent(evnt);
        }
      }
    };
    const dateOpenPanel = () => {
      const { type } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (["year", "quarter", "month", "week"].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = "day";
      }
      reactData.currentDate = import_xe_utils22.default.getWhatDay(Date.now(), 0, "first");
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || import_xe_utils22.default.getWhatDay(Date.now(), 0, "first");
        nextTick(() => {
          const timeBodyElem = refInputTimeBody.value;
          import_xe_utils22.default.arrayEach(timeBodyElem.querySelectorAll("li.is--selected"), updateTimePos);
        });
      }
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { transfer, placement } = props;
        const { panelIndex } = reactData;
        const targetElem = refInputTarget.value;
        const panelElem = refInputPanel.value;
        if (targetElem && panelElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(targetElem);
          let panelPlacement = "bottom";
          console.log(getAbsolutePos(targetElem));
          if (transfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showPanel = () => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!disabled && !visiblePanel) {
        if (!reactData.inited) {
          reactData.inited = true;
        }
        clearTimeout(hidePanelTimeout);
        reactData.isActivated = true;
        reactData.animatVisible = true;
        if (isDatePickerType) {
          dateOpenPanel();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return nextTick();
    };
    const datePickerOpenEvent = (evnt) => {
      const { readonly } = props;
      if (!readonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel, isActivated } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const el = refElem.value;
      const panelElem = refInputPanel.value;
      if (!disabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (!reactData.isActivated) {
          if (isDatePickerType) {
            if (visiblePanel) {
              hidePanel();
              afterCheckValue();
            }
          } else {
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable, disabled } = props;
      const { visiblePanel } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!disabled) {
        const isTab = hasEventKey(evnt, EVENT_KEYS.TAB);
        const isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);
        const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
        const isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);
        const isLeftArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
        const isRightArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
        const isPgUp = hasEventKey(evnt, EVENT_KEYS.PAGE_UP);
        const isPgDn = hasEventKey(evnt, EVENT_KEYS.PAGE_DOWN);
        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        } else if (operArrow) {
          if (isDatePickerType) {
            if (isActivated) {
              if (visiblePanel) {
                dateOffsetEvent(evnt);
              } else if (isUpArrow || isDwArrow) {
                datePickerOpenEvent(evnt);
              }
            }
          }
        } else if (isEnter) {
          if (isDatePickerType) {
            if (visiblePanel) {
              if (reactData.datePanelValue) {
                dateSelectItem(reactData.datePanelValue);
              } else {
                hidePanel();
              }
            } else if (isActivated) {
              datePickerOpenEvent(evnt);
            }
          }
        } else if (isPgUp || isPgDn) {
          if (isDatePickerType) {
            if (isActivated) {
              datePgOffsetEvent(evnt);
            }
          }
        }
        if (isTab || isEsc) {
          if (visiblePanel) {
            hidePanel();
          }
        } else if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      if (!disabled) {
        if (visiblePanel) {
          const panelElem = refInputPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { isActivated, visiblePanel } = reactData;
      if (visiblePanel) {
        hidePanel();
        afterCheckValue();
      } else if (isActivated) {
        afterCheckValue();
      }
    };
    const renderDateLabel = (item, label) => {
      const { festivalMethod } = props;
      if (festivalMethod) {
        const { datePanelType } = reactData;
        const festivalRest = festivalMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $input: $xeinput });
        const festivalItem = festivalRest ? import_xe_utils22.default.isString(festivalRest) ? { label: festivalRest } : festivalRest : {};
        const extraItem = festivalItem.extra ? import_xe_utils22.default.isString(festivalItem.extra) ? { label: festivalItem.extra } : festivalItem.extra : null;
        const labels = [
          h("span", {
            class: ["vxe-input--date-label", {
              "is-notice": festivalItem.notice
            }]
          }, extraItem && extraItem.label ? [
            h("span", label),
            h("span", {
              class: ["vxe-input--date-label--extra", extraItem.important ? "is-important" : "", extraItem.className],
              style: extraItem.style
            }, import_xe_utils22.default.toValueString(extraItem.label))
          ] : label)
        ];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          const festivalLabels = import_xe_utils22.default.toValueString(festivalLabel).split(",");
          labels.push(h("span", {
            class: ["vxe-input--date-festival", festivalItem.important ? "is-important" : "", festivalItem.className],
            style: festivalItem.style
          }, [
            festivalLabels.length > 1 ? h("span", {
              class: ["vxe-input--date-festival--overlap", `overlap--${festivalLabels.length}`]
            }, festivalLabels.map((label2) => h("span", label2.substring(0, 3)))) : h("span", {
              class: "vxe-input--date-festival--label"
            }, festivalLabels[0].substring(0, 3))
          ]));
        }
        return labels;
      }
      return label;
    };
    const renderDateDayTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", dateHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", dayDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils22.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils22.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils22.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateWeekTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", weekHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", weekDates.map((rows) => {
            const isSelected = multiple ? rows.some((item) => dateListValue.some((val) => import_xe_utils22.default.isDateSame(val, item.date, matchFormat))) : rows.some((item) => import_xe_utils22.default.isDateSame(dateValue, item.date, matchFormat));
            const isHover = rows.some((item) => import_xe_utils22.default.isDateSame(datePanelValue, item.date, matchFormat));
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--hover": isHover
                },
                // event
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateMonthTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMM";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", monthDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils22.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils22.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils22.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, conf_default.i18n(`vxe.input.date.months.m${item.month}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateQuarterTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyq";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", quarterDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils22.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils22.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils22.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, conf_default.i18n(`vxe.input.date.quarters.q${item.quarter}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateYearTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyy";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", yearDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils22.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils22.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils22.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.year));
            }));
          }))
        ])
      ];
    };
    const renderDateTable = () => {
      const { datePanelType } = reactData;
      switch (datePanelType) {
        case "week":
          return renderDateWeekTable();
        case "month":
          return renderDateMonthTable();
        case "quarter":
          return renderDateQuarterTable();
        case "year":
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const { multiple } = props;
      const { datePanelType } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelLabel = computeSelectDatePanelLabel.value;
      return [
        h("div", {
          class: "vxe-input--date-picker-header"
        }, [
          h("div", {
            class: "vxe-input--date-picker-type-wrapper"
          }, [
            datePanelType === "year" ? h("span", {
              class: "vxe-input--date-picker-label"
            }, selectDatePanelLabel) : h("span", {
              class: "vxe-input--date-picker-btn",
              onClick: dateToggleTypeEvent
            }, selectDatePanelLabel)
          ]),
          h("div", {
            class: "vxe-input--date-picker-btn-wrapper"
          }, [
            h("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-prev-btn", {
                "is--disabled": isDisabledPrevDateBtn
              }],
              onClick: datePrevEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-left"
              })
            ]),
            h("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-current-btn",
              onClick: dateTodayMonthEvent
            }, [
              h("i", {
                class: "vxe-icon-dot"
              })
            ]),
            h("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-next-btn", {
                "is--disabled": isDisabledNextDateBtn
              }],
              onClick: dateNextEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-right"
              })
            ]),
            multiple && computeSupportMultiples.value ? h("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-confirm-btn"
            }, [
              h("button", {
                class: "vxe-input--date-picker-confirm",
                type: "button",
                onClick: dateConfirmEvent
              }, conf_default.i18n("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        h("div", {
          class: "vxe-input--date-picker-body"
        }, renderDateTable())
      ];
    };
    const renderTimePanel = () => {
      const { datetimePanelValue } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const minuteList = computeMinuteList.value;
      const secondList = computeSecondList.value;
      return [
        h("div", {
          class: "vxe-input--time-picker-header"
        }, [
          h("span", {
            class: "vxe-input--time-picker-title"
          }, dateTimeLabel),
          h("button", {
            class: "vxe-input--time-picker-confirm",
            type: "button",
            onClick: dateConfirmEvent
          }, conf_default.i18n("vxe.button.confirm"))
        ]),
        h("div", {
          ref: refInputTimeBody,
          class: "vxe-input--time-picker-body"
        }, [
          h("ul", {
            class: "vxe-input--time-picker-hour-list"
          }, hourList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getHours() === item.value
              },
              onClick: (evnt) => dateHourEvent(evnt, item)
            }, item.label);
          })),
          h("ul", {
            class: "vxe-input--time-picker-minute-list"
          }, minuteList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getMinutes() === item.value
              },
              onClick: (evnt) => dateMinuteEvent(evnt, item)
            }, item.label);
          })),
          h("ul", {
            class: "vxe-input--time-picker-second-list"
          }, secondList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getSeconds() === item.value
              },
              onClick: (evnt) => dateSecondEvent(evnt, item)
            }, item.label);
          }))
        ])
      ];
    };
    const renderPanel = () => {
      const { type, transfer } = props;
      const { inited, animatVisible, visiblePanel, panelPlacement, panelStyle } = reactData;
      const vSize = computeSize.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const renders = [];
      if (isDatePickerType) {
        if (type === "datetime") {
          renders.push(h("div", {
            class: "vxe-input--panel-layout-wrapper"
          }, [
            h("div", {
              class: "vxe-input--panel-left-wrapper"
            }, renderDatePanel()),
            h("div", {
              class: "vxe-input--panel-right-wrapper"
            }, renderTimePanel())
          ]));
        } else if (type === "time") {
          renders.push(h("div", {
            class: "vxe-input--panel-wrapper"
          }, renderTimePanel()));
        } else {
          renders.push(h("div", {
            class: "vxe-input--panel-wrapper"
          }, renderDatePanel()));
        }
        return h(Teleport, {
          to: "body",
          disabled: transfer ? !inited : true
        }, [
          h("div", {
            ref: refInputPanel,
            class: ["vxe-table--ignore-clear vxe-input--panel", `type--${type}`, {
              [`size--${vSize}`]: vSize,
              "is--transfer": transfer,
              "animat--leave": animatVisible,
              "animat--enter": visiblePanel
            }],
            placement: panelPlacement,
            style: panelStyle
          }, renders)
        ]);
      }
      return null;
    };
    const renderNumberIcon = () => {
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return h("span", {
        class: "vxe-input--number-suffix"
      }, [
        h("span", {
          class: ["vxe-input--number-prev is--prev", {
            "is--disabled": isDisabledAddNumber
          }],
          onMousedown: numberMousedownEvent,
          onMouseup: numberStopDown,
          onMouseleave: numberStopDown
        }, [
          h("i", {
            class: ["vxe-input--number-prev-icon", conf_default.icon.INPUT_PREV_NUM]
          })
        ]),
        h("span", {
          class: ["vxe-input--number-next is--next", {
            "is--disabled": isDisabledSubtractNumber
          }],
          onMousedown: numberMousedownEvent,
          onMouseup: numberStopDown,
          onMouseleave: numberStopDown
        }, [
          h("i", {
            class: ["vxe-input--number-next-icon", conf_default.icon.INPUT_NEXT_NUM]
          })
        ])
      ]);
    };
    const renderDatePickerIcon = () => {
      return h("span", {
        class: "vxe-input--date-picker-suffix",
        onClick: datePickerOpenEvent
      }, [
        h("i", {
          class: ["vxe-input--date-picker-icon", conf_default.icon.INPUT_DATE]
        })
      ]);
    };
    const renderSearchIcon = () => {
      return h("span", {
        class: "vxe-input--search-suffix",
        onClick: searchEvent
      }, [
        h("i", {
          class: ["vxe-input--search-icon", conf_default.icon.INPUT_SEARCH]
        })
      ]);
    };
    const renderPasswordIcon = () => {
      const { showPwd } = reactData;
      return h("span", {
        class: "vxe-input--password-suffix",
        onClick: passwordToggleEvent
      }, [
        h("i", {
          class: ["vxe-input--password-icon", showPwd ? conf_default.icon.INPUT_SHOW_PWD : conf_default.icon.INPUT_PWD]
        })
      ]);
    };
    const rendePrefixIcon = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      const icons = [];
      if (prefixSlot) {
        icons.push(h("span", {
          class: "vxe-input--prefix-icon"
        }, prefixSlot({})));
      } else if (prefixIcon) {
        icons.push(h("i", {
          class: ["vxe-input--prefix-icon", prefixIcon]
        }));
      }
      return icons.length ? h("span", {
        class: "vxe-input--prefix",
        onClick: clickPrefixEvent
      }, icons) : null;
    };
    const renderSuffixIcon2 = () => {
      const { disabled, suffixIcon } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isClearable = computeIsClearable.value;
      const icons = [];
      if (suffixSlot) {
        icons.push(h("span", {
          class: "vxe-input--suffix-icon"
        }, suffixSlot({})));
      } else if (suffixIcon) {
        icons.push(h("i", {
          class: ["vxe-input--suffix-icon", suffixIcon]
        }));
      }
      if (isClearable) {
        icons.push(h("i", {
          class: ["vxe-input--clear-icon", conf_default.icon.INPUT_CLEAR]
        }));
      }
      return icons.length ? h("span", {
        class: ["vxe-input--suffix", {
          "is--clear": isClearable && !disabled && !(inputValue === "" || import_xe_utils22.default.eqNull(inputValue))
        }],
        onClick: clickSuffixEvent
      }, icons) : null;
    };
    const renderExtraSuffixIcon = () => {
      const { controls } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      let icons;
      if (isPawdType) {
        icons = renderPasswordIcon();
      } else if (isNumType) {
        if (controls) {
          icons = renderNumberIcon();
        }
      } else if (isDatePickerType) {
        icons = renderDatePickerIcon();
      } else if (isSearchType) {
        icons = renderSearchIcon();
      }
      return icons ? h("span", {
        class: "vxe-input--extra-suffix"
      }, [icons]) : null;
    };
    inputMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $input: $xeinput, $event: evnt }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeinput, inputMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      changeValue();
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        inputValue: props.modelValue,
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    watch(computeDateLabelFormat, () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    nextTick(() => {
      GlobalEvent.on($xeinput, "mousewheel", handleGlobalMousewheelEvent);
      GlobalEvent.on($xeinput, "mousedown", handleGlobalMousedownEvent);
      GlobalEvent.on($xeinput, "keydown", handleGlobalKeydownEvent);
      GlobalEvent.on($xeinput, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      numberStopDown();
      GlobalEvent.off($xeinput, "mousewheel");
      GlobalEvent.off($xeinput, "mousedown");
      GlobalEvent.off($xeinput, "keydown");
      GlobalEvent.off($xeinput, "blur");
    });
    initValue();
    const renderVN = () => {
      const { className, controls, type, align, showWordCount, countMethod, name, disabled, readonly, autocomplete } = props;
      const { inputValue, visiblePanel, isActivated } = reactData;
      const vSize = computeSize.value;
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const inpReadonly = computeInpReadonly.value;
      const inpMaxlength = computeInpMaxlength.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const childs = [];
      const prefix = rendePrefixIcon();
      const suffix = renderSuffixIcon2();
      if (prefix) {
        childs.push(prefix);
      }
      childs.push(h("input", {
        ref: refInputTarget,
        class: "vxe-input--inner",
        value: inputValue,
        name,
        type: inputType,
        placeholder: inpPlaceholder,
        maxlength: inpMaxlength,
        readonly: inpReadonly,
        disabled,
        autocomplete,
        onKeydown: keydownEvent,
        onKeyup: keyupEvent,
        onWheel: wheelEvent,
        onClick: clickEvent,
        onInput: inputEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      }));
      if (suffix) {
        childs.push(suffix);
      }
      childs.push(renderExtraSuffixIcon());
      if (isDatePickerType) {
        childs.push(renderPanel());
      }
      let isWordCount = false;
      if (showWordCount && ["text", "search"].includes(type)) {
        isWordCount = true;
        childs.push(h("span", {
          class: ["vxe-input--count", {
            "is--error": isCountError
          }]
        }, countMethod ? `${countMethod({ value: inputValue })}` : `${inputCount}${inpMaxlength ? `/${inpMaxlength}` : ""}`));
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-input", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          "is--controls": controls,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--readonly": readonly,
          "is--visivle": visiblePanel,
          "is--count": isWordCount,
          "is--disabled": disabled,
          "is--active": isActivated
        }]
      }, childs);
    };
    $xeinput.renderVN = renderVN;
    return $xeinput;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/checkbox/src/checkbox.js
var import_xe_utils23 = __toESM(require_xe_utils());
var checkbox_default = defineComponent({
  name: "VxeCheckbox",
  props: {
    modelValue: [String, Number, Boolean],
    label: { type: [String, Number], default: null },
    indeterminate: Boolean,
    title: [String, Number],
    checkedValue: { type: [String, Number, Boolean], default: true },
    uncheckedValue: { type: [String, Number, Boolean], default: false },
    content: [String, Number],
    disabled: Boolean,
    size: { type: String, default: () => conf_default.checkbox.size || conf_default.size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils23.default.uniqueId();
    const $xecheckbox = {
      xID,
      props,
      context
    };
    let checkboxMethods = {};
    const computeSize = useSize(props);
    const $xecheckboxgroup = inject("$xecheckboxgroup", null);
    const computeIsChecked = computed(() => {
      if ($xecheckboxgroup) {
        return import_xe_utils23.default.includes($xecheckboxgroup.props.modelValue, props.label);
      }
      return props.modelValue === props.checkedValue;
    });
    const computeIsDisabled = computed(() => {
      if (props.disabled) {
        return true;
      }
      if ($xecheckboxgroup) {
        const { props: groupProps } = $xecheckboxgroup;
        const { computeIsMaximize } = $xecheckboxgroup.getComputeMaps();
        const isMaximize = computeIsMaximize.value;
        const isChecked = computeIsChecked.value;
        return groupProps.disabled || isMaximize && !isChecked;
      }
      return false;
    });
    const changeEvent = (evnt) => {
      const { checkedValue, uncheckedValue } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const checked = evnt.target.checked;
        const value = checked ? checkedValue : uncheckedValue;
        const params = { checked, value, label: props.label };
        if ($xecheckboxgroup) {
          $xecheckboxgroup.handleChecked(params, evnt);
        } else {
          emit("update:modelValue", value);
          checkboxMethods.dispatchEvent("change", params, evnt);
          if ($xeform && $xeformiteminfo) {
            $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, value);
          }
        }
      }
    };
    checkboxMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $checkbox: $xecheckbox, $event: evnt }, params));
      }
    };
    Object.assign($xecheckbox, checkboxMethods);
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isChecked = computeIsChecked.value;
      const indeterminate = props.indeterminate;
      return h("label", {
        class: ["vxe-checkbox", {
          [`size--${vSize}`]: vSize,
          "is--indeterminate": indeterminate,
          "is--disabled": isDisabled,
          "is--checked": isChecked
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-checkbox--input",
          type: "checkbox",
          disabled: isDisabled,
          checked: isChecked,
          onChange: changeEvent
        }),
        h("span", {
          class: ["vxe-checkbox--icon", indeterminate ? "vxe-icon-checkbox-indeterminate" : isChecked ? "vxe-icon-checkbox-checked" : "vxe-icon-checkbox-unchecked"]
        }),
        h("span", {
          class: "vxe-checkbox--label"
        }, slots.default ? slots.default({}) : getFuncText(props.content))
      ]);
    };
    $xecheckbox.renderVN = renderVN;
    return $xecheckbox;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/select/src/select.js
var import_xe_utils24 = __toESM(require_xe_utils());
function isOptionVisible(option) {
  return option.visible !== false;
}
function getOptUniqueId() {
  return import_xe_utils24.default.uniqueId("opt_");
}
var select_default = defineComponent({
  name: "VxeSelect",
  props: {
    modelValue: null,
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => import_xe_utils24.default.eqNull(conf_default.select.placeholder) ? conf_default.i18n("vxe.base.pleaseSelect") : conf_default.select.placeholder
    },
    loading: Boolean,
    disabled: Boolean,
    multiple: Boolean,
    multiCharOverflow: { type: [Number, String], default: () => conf_default.select.multiCharOverflow },
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    optionGroups: Array,
    optionGroupProps: Object,
    optionConfig: Object,
    className: [String, Function],
    popupClassName: [String, Function],
    max: { type: [String, Number], default: null },
    size: { type: String, default: () => conf_default.select.size || conf_default.size },
    filterable: Boolean,
    filterMethod: Function,
    remote: Boolean,
    remoteMethod: Function,
    emptyText: String,
    // 已废弃，被 option-config.keyField 替换
    optionId: { type: String, default: () => conf_default.select.optionId },
    // 已废弃，被 option-config.useKey 替换
    optionKey: Boolean,
    transfer: { type: Boolean, default: () => conf_default.select.transfer }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils24.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      inited: false,
      staticOptions: [],
      fullGroupList: [],
      fullOptionList: [],
      visibleGroupList: [],
      visibleOptionList: [],
      remoteValueList: [],
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      currentOption: null,
      currentValue: null,
      visiblePanel: false,
      animatVisible: false,
      isActivated: false,
      searchValue: "",
      searchLoading: false
    });
    const refElem = ref();
    const refInput = ref();
    const refInpSearch = ref();
    const refOptionWrapper = ref();
    const refOptionPanel = ref();
    const refMaps = {
      refElem
    };
    const $xeselect = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let selectMethods = {};
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeGroupPropsOpts = computed(() => {
      return props.optionGroupProps || {};
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeGroupLabelField = computed(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.label || "label";
    });
    const computeGroupOptionsField = computed(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.options || "options";
    });
    const computeIsMaximize = computed(() => {
      const { modelValue, multiple, max } = props;
      if (multiple && max) {
        return (modelValue ? modelValue.length : 0) >= import_xe_utils24.default.toNumber(max);
      }
      return false;
    });
    const computeOptionOpts = computed(() => {
      return Object.assign({}, conf_default.select.optionConfig, props.optionConfig);
    });
    const computeIsGroup = computed(() => {
      return reactData.fullGroupList.some((item) => item.options && item.options.length);
    });
    const computeMultiMaxCharNum = computed(() => {
      return import_xe_utils24.default.toNumber(props.multiCharOverflow);
    });
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils24.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils24.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const findOption = (optionValue) => {
      const { fullOptionList, fullGroupList } = reactData;
      const isGroup = computeIsGroup.value;
      const valueField = computeValueField.value;
      if (isGroup) {
        for (let gIndex = 0; gIndex < fullGroupList.length; gIndex++) {
          const group = fullGroupList[gIndex];
          if (group.options) {
            for (let index = 0; index < group.options.length; index++) {
              const option = group.options[index];
              if (optionValue === option[valueField]) {
                return option;
              }
            }
          }
        }
      }
      return fullOptionList.find((item) => optionValue === item[valueField]);
    };
    const getRemoteSelectLabel = (value) => {
      const { remoteValueList } = reactData;
      const labelField = computeLabelField.value;
      const remoteItem = remoteValueList.find((item2) => value === item2.key);
      const item = remoteItem ? remoteItem.result : null;
      return import_xe_utils24.default.toValueString(item ? item[labelField] : value);
    };
    const getSelectLabel = (value) => {
      const labelField = computeLabelField.value;
      const item = findOption(value);
      return import_xe_utils24.default.toValueString(item ? item[labelField] : value);
    };
    const computeSelectLabel = computed(() => {
      const { modelValue, multiple, remote } = props;
      const multiMaxCharNum = computeMultiMaxCharNum.value;
      if (modelValue && multiple) {
        const vals = import_xe_utils24.default.isArray(modelValue) ? modelValue : [modelValue];
        if (remote) {
          return vals.map((val) => getRemoteSelectLabel(val)).join(", ");
        }
        return vals.map((val) => {
          const label = getSelectLabel(val);
          if (multiMaxCharNum > 0 && label.length > multiMaxCharNum) {
            return `${label.substring(0, multiMaxCharNum)}...`;
          }
          return label;
        }).join(", ");
      }
      if (remote) {
        return getRemoteSelectLabel(modelValue);
      }
      return getSelectLabel(modelValue);
    });
    const getOptkey = () => {
      const optionOpts = computeOptionOpts.value;
      return optionOpts.keyField || props.optionId || "_X_OPTION_KEY";
    };
    const getOptid = (option) => {
      const optid = option[getOptkey()];
      return optid ? encodeURIComponent(optid) : "";
    };
    const refreshOption = () => {
      const { filterable, filterMethod } = props;
      const { fullOptionList, fullGroupList, searchValue } = reactData;
      const isGroup = computeIsGroup.value;
      const groupLabelField = computeGroupLabelField.value;
      const labelField = computeLabelField.value;
      if (isGroup) {
        if (filterable && filterMethod) {
          reactData.visibleGroupList = fullGroupList.filter((group) => isOptionVisible(group) && filterMethod({ group, option: null, searchValue }));
        } else if (filterable) {
          reactData.visibleGroupList = fullGroupList.filter((group) => isOptionVisible(group) && (!searchValue || `${group[groupLabelField]}`.indexOf(searchValue) > -1));
        } else {
          reactData.visibleGroupList = fullGroupList.filter(isOptionVisible);
        }
      } else {
        if (filterable && filterMethod) {
          reactData.visibleOptionList = fullOptionList.filter((option) => isOptionVisible(option) && filterMethod({ group: null, option, searchValue }));
        } else if (filterable) {
          reactData.visibleOptionList = fullOptionList.filter((option) => isOptionVisible(option) && (!searchValue || `${option[labelField]}`.indexOf(searchValue) > -1));
        } else {
          reactData.visibleOptionList = fullOptionList.filter(isOptionVisible);
        }
      }
      return nextTick();
    };
    const cacheItemMap = () => {
      const { fullOptionList, fullGroupList } = reactData;
      const groupOptionsField = computeGroupOptionsField.value;
      const key = getOptkey();
      const handleOptis = (item) => {
        if (!getOptid(item)) {
          item[key] = getOptUniqueId();
        }
      };
      if (fullGroupList.length) {
        fullGroupList.forEach((group) => {
          handleOptis(group);
          if (group[groupOptionsField]) {
            group[groupOptionsField].forEach(handleOptis);
          }
        });
      } else if (fullOptionList.length) {
        fullOptionList.forEach(handleOptis);
      }
      refreshOption();
    };
    const setCurrentOption = (option) => {
      const valueField = computeValueField.value;
      if (option) {
        reactData.currentOption = option;
        reactData.currentValue = option[valueField];
      }
    };
    const scrollToOption = (option, isAlignBottom) => {
      return nextTick().then(() => {
        if (option) {
          const optWrapperElem = refOptionWrapper.value;
          const panelElem = refOptionPanel.value;
          const optElem = panelElem.querySelector(`[optid='${getOptid(option)}']`);
          if (optWrapperElem && optElem) {
            const wrapperHeight = optWrapperElem.offsetHeight;
            const offsetPadding = 5;
            if (isAlignBottom) {
              if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
              }
            } else {
              if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
              }
            }
          }
        }
      });
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { transfer, placement } = props;
        const { panelIndex } = reactData;
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        if (panelElem && el) {
          const targetHeight = el.offsetHeight;
          const targetWidth = el.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(el);
          let panelPlacement = "bottom";
          if (transfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    let hidePanelTimeout;
    const showOptionPanel = () => {
      const { loading, disabled, filterable } = props;
      if (!loading && !disabled) {
        clearTimeout(hidePanelTimeout);
        if (!reactData.inited) {
          reactData.inited = true;
        }
        reactData.isActivated = true;
        reactData.animatVisible = true;
        if (filterable) {
          refreshOption();
        }
        setTimeout(() => {
          const { modelValue, multiple } = props;
          const currOption = findOption(multiple && modelValue ? modelValue[0] : modelValue);
          reactData.visiblePanel = true;
          if (currOption) {
            setCurrentOption(currOption);
            scrollToOption(currOption);
          }
          handleFocusSearch();
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.searchValue = "";
      reactData.searchLoading = false;
      reactData.visiblePanel = false;
      hidePanelTimeout = window.setTimeout(() => {
        reactData.animatVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      if (selectValue !== props.modelValue) {
        emit("update:modelValue", selectValue);
        selectMethods.dispatchEvent("change", { value: selectValue }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      reactData.remoteValueList = [];
      changeEvent(evnt, selectValue);
      selectMethods.dispatchEvent("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const changeOptionEvent = (evnt, selectValue, option) => {
      const { modelValue, multiple } = props;
      const { remoteValueList } = reactData;
      if (multiple) {
        let multipleValue;
        if (modelValue) {
          if (modelValue.indexOf(selectValue) === -1) {
            multipleValue = modelValue.concat([selectValue]);
          } else {
            multipleValue = modelValue.filter((val) => val !== selectValue);
          }
        } else {
          multipleValue = [selectValue];
        }
        const remoteItem = remoteValueList.find((item) => item.key === selectValue);
        if (remoteItem) {
          remoteItem.result = option;
        } else {
          remoteValueList.push({ key: selectValue, result: option });
        }
        changeEvent(evnt, multipleValue);
      } else {
        reactData.remoteValueList = [{ key: selectValue, result: option }];
        changeEvent(evnt, selectValue);
        hideOptionPanel();
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      if (!disabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      if (!disabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const findOffsetOption = (optionValue, isUpArrow) => {
      const { visibleOptionList, visibleGroupList } = reactData;
      const isGroup = computeIsGroup.value;
      const valueField = computeValueField.value;
      const groupOptionsField = computeGroupOptionsField.value;
      let firstOption;
      let prevOption;
      let nextOption;
      let currOption;
      if (isGroup) {
        for (let gIndex = 0; gIndex < visibleGroupList.length; gIndex++) {
          const group = visibleGroupList[gIndex];
          const groupOptionList = group[groupOptionsField];
          const isGroupDisabled = group.disabled;
          if (groupOptionList) {
            for (let index = 0; index < groupOptionList.length; index++) {
              const option = groupOptionList[index];
              const isVisible = isOptionVisible(option);
              const isDisabled = isGroupDisabled || option.disabled;
              if (!firstOption && !isDisabled) {
                firstOption = option;
              }
              if (currOption) {
                if (isVisible && !isDisabled) {
                  nextOption = option;
                  if (!isUpArrow) {
                    return { offsetOption: nextOption };
                  }
                }
              }
              if (optionValue === option[valueField]) {
                currOption = option;
                if (isUpArrow) {
                  return { offsetOption: prevOption };
                }
              } else {
                if (isVisible && !isDisabled) {
                  prevOption = option;
                }
              }
            }
          }
        }
      } else {
        for (let index = 0; index < visibleOptionList.length; index++) {
          const option = visibleOptionList[index];
          const isDisabled = option.disabled;
          if (!firstOption && !isDisabled) {
            firstOption = option;
          }
          if (currOption) {
            if (!isDisabled) {
              nextOption = option;
              if (!isUpArrow) {
                return { offsetOption: nextOption };
              }
            }
          }
          if (optionValue === option[valueField]) {
            currOption = option;
            if (isUpArrow) {
              return { offsetOption: prevOption };
            }
          } else {
            if (!isDisabled) {
              prevOption = option;
            }
          }
        }
      }
      return { firstOption };
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable, disabled } = props;
      const { visiblePanel, currentValue, currentOption } = reactData;
      if (!disabled) {
        const isTab = hasEventKey(evnt, EVENT_KEYS.TAB);
        const isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);
        const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
        const isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
        const isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
        const isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);
        const isSpacebar = hasEventKey(evnt, EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            evnt.preventDefault();
            evnt.stopPropagation();
            changeOptionEvent(evnt, currentValue, currentOption);
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
            let { firstOption, offsetOption } = findOffsetOption(currentValue, isUpArrow);
            if (!offsetOption && !findOption(currentValue)) {
              offsetOption = firstOption;
            }
            setCurrentOption(offsetOption);
            scrollToOption(offsetOption, isDwArrow);
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const handleFocusSearch = () => {
      if (props.filterable) {
        nextTick(() => {
          const inpSearch = refInpSearch.value;
          if (inpSearch) {
            inpSearch.focus();
          }
        });
      }
    };
    const focusEvent = (evnt) => {
      if (!props.disabled) {
        reactData.isActivated = true;
      }
      selectMethods.dispatchEvent("focus", {}, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      selectMethods.dispatchEvent("blur", {}, evnt);
    };
    const modelSearchEvent = (value) => {
      reactData.searchValue = value;
    };
    const focusSearchEvent = () => {
      reactData.isActivated = true;
    };
    const keydownSearchEvent = (params) => {
      const { $event } = params;
      const isEnter = hasEventKey($event, EVENT_KEYS.ENTER);
      if (isEnter) {
        $event.preventDefault();
        $event.stopPropagation();
      }
    };
    const triggerSearchEvent = import_xe_utils24.default.debounce(function() {
      const { remote, remoteMethod } = props;
      const { searchValue } = reactData;
      if (remote && remoteMethod) {
        reactData.searchLoading = true;
        Promise.resolve(remoteMethod({ searchValue })).then(() => nextTick()).catch(() => nextTick()).finally(() => {
          reactData.searchLoading = false;
          refreshOption();
        });
      } else {
        refreshOption();
      }
    }, 350, { trailing: true });
    const togglePanelEvent = (params) => {
      const { $event } = params;
      $event.preventDefault();
      if (reactData.visiblePanel) {
        hideOptionPanel();
      } else {
        showOptionPanel();
      }
    };
    const checkOptionDisabled = (isSelected, option, group) => {
      if (option.disabled) {
        return true;
      }
      if (group && group.disabled) {
        return true;
      }
      const isMaximize = computeIsMaximize.value;
      if (isMaximize && !isSelected) {
        return true;
      }
      return false;
    };
    const renderOption = (list, group) => {
      const { optionKey, modelValue, multiple } = props;
      const { currentValue } = reactData;
      const optionOpts = computeOptionOpts.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const isGroup = computeIsGroup.value;
      const { useKey } = optionOpts;
      const optionSlot = slots.option;
      return list.map((option, cIndex) => {
        const { slots: slots2, className } = option;
        const optionValue = option[valueField];
        const isSelected = multiple ? modelValue && modelValue.indexOf(optionValue) > -1 : modelValue === optionValue;
        const isVisible = !isGroup || isOptionVisible(option);
        const isDisabled = checkOptionDisabled(isSelected, option, group);
        const optid = getOptid(option);
        const defaultSlot = slots2 ? slots2.default : null;
        const optParams = { option, group: null, $select: $xeselect };
        return isVisible ? h("div", {
          key: useKey || optionKey ? optid : cIndex,
          class: ["vxe-select-option", className ? import_xe_utils24.default.isFunction(className) ? className(optParams) : className : "", {
            "is--disabled": isDisabled,
            "is--selected": isSelected,
            "is--hover": currentValue === optionValue
          }],
          // attrs
          optid,
          // event
          onMousedown: (evnt) => {
            const isLeftBtn = evnt.button === 0;
            if (isLeftBtn) {
              evnt.stopPropagation();
            }
          },
          onClick: (evnt) => {
            if (!isDisabled) {
              changeOptionEvent(evnt, optionValue, option);
            }
          },
          onMouseenter: () => {
            if (!isDisabled) {
              setCurrentOption(option);
            }
          }
        }, optionSlot ? callSlot(optionSlot, optParams) : defaultSlot ? callSlot(defaultSlot, optParams) : formatText(getFuncText(option[labelField]))) : null;
      });
    };
    const renderOptgroup = () => {
      const { optionKey } = props;
      const { visibleGroupList } = reactData;
      const optionOpts = computeOptionOpts.value;
      const groupLabelField = computeGroupLabelField.value;
      const groupOptionsField = computeGroupOptionsField.value;
      const { useKey } = optionOpts;
      const optionSlot = slots.option;
      return visibleGroupList.map((group, gIndex) => {
        const { slots: slots2, className } = group;
        const optid = getOptid(group);
        const isGroupDisabled = group.disabled;
        const defaultSlot = slots2 ? slots2.default : null;
        const optParams = { option: group, group, $select: $xeselect };
        return h("div", {
          key: useKey || optionKey ? optid : gIndex,
          class: ["vxe-optgroup", className ? import_xe_utils24.default.isFunction(className) ? className(optParams) : className : "", {
            "is--disabled": isGroupDisabled
          }],
          // attrs
          optid
        }, [
          h("div", {
            class: "vxe-optgroup--title"
          }, optionSlot ? callSlot(optionSlot, optParams) : defaultSlot ? callSlot(defaultSlot, optParams) : getFuncText(group[groupLabelField])),
          h("div", {
            class: "vxe-optgroup--wrapper"
          }, renderOption(group[groupOptionsField] || [], group))
        ]);
      });
    };
    const renderOpts = () => {
      const { visibleGroupList, visibleOptionList, searchLoading } = reactData;
      const isGroup = computeIsGroup.value;
      if (searchLoading) {
        return [
          h("div", {
            class: "vxe-select--search-loading"
          }, [
            h("i", {
              class: ["vxe-select--search-icon", conf_default.icon.SELECT_LOADED]
            }),
            h("span", {
              class: "vxe-select--search-text"
            }, conf_default.i18n("vxe.select.loadingText"))
          ])
        ];
      }
      if (isGroup) {
        if (visibleGroupList.length) {
          return renderOptgroup();
        }
      } else {
        if (visibleOptionList.length) {
          return renderOption(visibleOptionList);
        }
      }
      return [
        h("div", {
          class: "vxe-select--empty-placeholder"
        }, props.emptyText || conf_default.i18n("vxe.select.emptyText"))
      ];
    };
    selectMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $select: $xeselect, $event: evnt }, params));
      },
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return nextTick();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return nextTick();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return nextTick();
      },
      refreshOption,
      focus() {
        const $input = refInput.value;
        reactData.isActivated = true;
        $input.blur();
        return nextTick();
      },
      blur() {
        const $input = refInput.value;
        $input.blur();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xeselect, selectMethods);
    watch(() => reactData.staticOptions, (value) => {
      if (value.some((item) => item.options && item.options.length)) {
        reactData.fullOptionList = [];
        reactData.fullGroupList = value;
      } else {
        reactData.fullGroupList = [];
        reactData.fullOptionList = value || [];
      }
      cacheItemMap();
    });
    watch(() => props.options, (value) => {
      reactData.fullGroupList = [];
      reactData.fullOptionList = value || [];
      cacheItemMap();
    });
    watch(() => props.optionGroups, (value) => {
      reactData.fullOptionList = [];
      reactData.fullGroupList = value || [];
      cacheItemMap();
    });
    onMounted(() => {
      nextTick(() => {
        const { options, optionGroups } = props;
        if (optionGroups) {
          reactData.fullGroupList = optionGroups;
        } else if (options) {
          reactData.fullOptionList = options;
        }
        cacheItemMap();
      });
      GlobalEvent.on($xeselect, "mousewheel", handleGlobalMousewheelEvent);
      GlobalEvent.on($xeselect, "mousedown", handleGlobalMousedownEvent);
      GlobalEvent.on($xeselect, "keydown", handleGlobalKeydownEvent);
      GlobalEvent.on($xeselect, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      GlobalEvent.off($xeselect, "mousewheel");
      GlobalEvent.off($xeselect, "mousedown");
      GlobalEvent.off($xeselect, "keydown");
      GlobalEvent.off($xeselect, "blur");
    });
    const renderVN = () => {
      const { className, popupClassName, transfer, disabled, loading, filterable } = props;
      const { inited, isActivated, visiblePanel } = reactData;
      const vSize = computeSize.value;
      const selectLabel = computeSelectLabel.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      return h("div", {
        ref: refElem,
        class: ["vxe-select", className ? import_xe_utils24.default.isFunction(className) ? className({ $select: $xeselect }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visivle": visiblePanel,
          "is--disabled": disabled,
          "is--filter": filterable,
          "is--loading": loading,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          class: "vxe-select-slots",
          ref: "hideOption"
        }, defaultSlot ? defaultSlot({}) : []),
        h(input_default, {
          ref: refInput,
          clearable: props.clearable,
          placeholder: props.placeholder,
          readonly: true,
          disabled,
          type: "text",
          prefixIcon: props.prefixIcon,
          suffixIcon: loading ? conf_default.icon.SELECT_LOADED : visiblePanel ? conf_default.icon.SELECT_OPEN : conf_default.icon.SELECT_CLOSE,
          modelValue: selectLabel,
          onClear: clearEvent,
          onClick: togglePanelEvent,
          onFocus: focusEvent,
          onBlur: blurEvent,
          onSuffixClick: togglePanelEvent
        }, prefixSlot ? {
          prefix: () => prefixSlot({})
        } : {}),
        h(Teleport, {
          to: "body",
          disabled: transfer ? !inited : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-select--panel", popupClassName ? import_xe_utils24.default.isFunction(popupClassName) ? popupClassName({ $select: $xeselect }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": transfer,
              "animat--leave": !loading && reactData.animatVisible,
              "animat--enter": !loading && visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, inited ? [
            filterable ? h("div", {
              class: "vxe-select--panel-search"
            }, [
              h(input_default, {
                ref: refInpSearch,
                class: "vxe-select-search--input",
                modelValue: reactData.searchValue,
                clearable: true,
                placeholder: conf_default.i18n("vxe.select.search"),
                prefixIcon: conf_default.icon.INPUT_SEARCH,
                "onUpdate:modelValue": modelSearchEvent,
                onFocus: focusSearchEvent,
                onKeydown: keydownSearchEvent,
                onChange: triggerSearchEvent,
                onSearch: triggerSearchEvent
              })
            ]) : createCommentVNode(),
            h("div", {
              class: "vxe-select--panel-wrapper"
            }, [
              headerSlot ? h("div", {
                class: "vxe-select--panel-header"
              }, headerSlot({})) : createCommentVNode(),
              h("div", {
                class: "vxe-select--panel-body"
              }, [
                h("div", {
                  ref: refOptionWrapper,
                  class: "vxe-select-option--wrapper"
                }, renderOpts())
              ]),
              footerSlot ? h("div", {
                class: "vxe-select--panel-footer"
              }, footerSlot({})) : createCommentVNode()
            ])
          ] : [])
        ])
      ]);
    };
    $xeselect.renderVN = renderVN;
    provide("$xeselect", $xeselect);
    return $xeselect;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/export/src/export-panel.js
var export_panel_default = defineComponent({
  name: "VxeTableExportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const $xetable = inject("$xetable", {});
    const { computeExportOpts, computePrintOpts } = $xetable.getComputeMaps();
    const reactData = reactive({
      isAll: false,
      isIndeterminate: false,
      loading: false
    });
    const xButtonConfirm = ref();
    const xInputFilename = ref();
    const xInputSheetname = ref();
    const computeCheckedAll = computed(() => {
      const { storeData: storeData2 } = props;
      return storeData2.columns.every((column) => column.checked);
    });
    const computeShowSheet = computed(() => {
      const { defaultOptions } = props;
      return ["html", "xml", "xlsx", "pdf"].indexOf(defaultOptions.type) > -1;
    });
    const computeSupportMerge = computed(() => {
      const { storeData: storeData2, defaultOptions } = props;
      return !defaultOptions.original && defaultOptions.mode === "current" && (storeData2.isPrint || ["html", "xlsx"].indexOf(defaultOptions.type) > -1);
    });
    const computeSupportStyle = computed(() => {
      const { defaultOptions } = props;
      return !defaultOptions.original && ["xlsx"].indexOf(defaultOptions.type) > -1;
    });
    const handleOptionCheck = (column) => {
      const { storeData: storeData2 } = props;
      const matchObj = import_xe_utils25.default.findTree(storeData2.columns, (item) => item === column);
      if (matchObj && matchObj.parent) {
        const { parent } = matchObj;
        if (parent.children && parent.children.length) {
          parent.checked = parent.children.every((column2) => column2.checked);
          parent.halfChecked = !parent.checked && parent.children.some((column2) => column2.checked || column2.halfChecked);
          handleOptionCheck(parent);
        }
      }
    };
    const checkStatus = () => {
      const { storeData: storeData2 } = props;
      const columns = storeData2.columns;
      reactData.isAll = columns.every((column) => column.disabled || column.checked);
      reactData.isIndeterminate = !reactData.isAll && columns.some((column) => !column.disabled && (column.checked || column.halfChecked));
    };
    const changeOption = (column) => {
      const isChecked = !column.checked;
      import_xe_utils25.default.eachTree([column], (item) => {
        item.checked = isChecked;
        item.halfChecked = false;
      });
      handleOptionCheck(column);
      checkStatus();
    };
    const allColumnEvent = () => {
      const { storeData: storeData2 } = props;
      const isAll = !reactData.isAll;
      import_xe_utils25.default.eachTree(storeData2.columns, (column) => {
        if (!column.disabled) {
          column.checked = isAll;
          column.halfChecked = false;
        }
      });
      reactData.isAll = isAll;
      checkStatus();
    };
    const showEvent = () => {
      nextTick(() => {
        const filenameInp = xInputFilename.value;
        const sheetnameInp = xInputSheetname.value;
        const confirmBtn = xButtonConfirm.value;
        const targetElem = filenameInp || sheetnameInp || confirmBtn;
        if (targetElem) {
          targetElem.focus();
        }
      });
      checkStatus();
    };
    const getExportOption = () => {
      const { storeData: storeData2, defaultOptions } = props;
      const { hasMerge, columns } = storeData2;
      const checkedAll = computeCheckedAll.value;
      const supportMerge = computeSupportMerge.value;
      const expColumns = import_xe_utils25.default.searchTree(columns, (column) => column.checked, { children: "children", mapChildren: "childNodes", original: true });
      return Object.assign({}, defaultOptions, {
        columns: expColumns,
        isMerge: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false
      });
    };
    const printEvent = () => {
      const { storeData: storeData2 } = props;
      const printOpts = computePrintOpts.value;
      storeData2.visible = false;
      $xetable.print(Object.assign({}, printOpts, getExportOption()));
    };
    const exportEvent = () => {
      const { storeData: storeData2 } = props;
      const exportOpts = computeExportOpts.value;
      reactData.loading = true;
      $xetable.exportData(Object.assign({}, exportOpts, getExportOption())).then(() => {
        reactData.loading = false;
        storeData2.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const cancelEvent = () => {
      const { storeData: storeData2 } = props;
      storeData2.visible = false;
    };
    const confirmEvent = () => {
      const { storeData: storeData2 } = props;
      if (storeData2.isPrint) {
        printEvent();
      } else {
        exportEvent();
      }
    };
    const renderVN = () => {
      const { defaultOptions, storeData: storeData2 } = props;
      const { isAll: isAllChecked, isIndeterminate: isAllIndeterminate } = reactData;
      const { hasTree, hasMerge, isPrint, hasColgroup } = storeData2;
      const { isHeader } = defaultOptions;
      const cols = [];
      const checkedAll = computeCheckedAll.value;
      const showSheet = computeShowSheet.value;
      const supportMerge = computeSupportMerge.value;
      const supportStyle = computeSupportStyle.value;
      import_xe_utils25.default.eachTree(storeData2.columns, (column) => {
        const colTitle = formatText(column.getTitle(), 1);
        const isColGroup = column.children && column.children.length;
        const isChecked = column.checked;
        const indeterminate = column.halfChecked;
        cols.push(h("li", {
          class: ["vxe-export--panel-column-option", `level--${column.level}`, {
            "is--group": isColGroup,
            "is--checked": isChecked,
            "is--indeterminate": indeterminate,
            "is--disabled": column.disabled
          }],
          title: colTitle,
          onClick: () => {
            if (!column.disabled) {
              changeOption(column);
            }
          }
        }, [
          h("span", {
            class: ["vxe-checkbox--icon", indeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
          }),
          h("span", {
            class: "vxe-checkbox--label"
          }, colTitle)
        ]));
      });
      return h(modal_default, {
        modelValue: storeData2.visible,
        title: conf_default.i18n(isPrint ? "vxe.export.printTitle" : "vxe.export.expTitle"),
        className: "vxe-table-export-popup-wrapper",
        width: 660,
        mask: true,
        lockView: true,
        showFooter: false,
        escClosable: true,
        maskClosable: true,
        loading: reactData.loading,
        "onUpdate:modelValue"(value) {
          storeData2.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          return h("div", {
            class: "vxe-export--panel"
          }, [
            h("table", {
              cellspacing: 0,
              cellpadding: 0,
              border: 0
            }, [
              h("tbody", [
                [
                  isPrint ? createCommentVNode() : h("tr", [
                    h("td", conf_default.i18n("vxe.export.expName")),
                    h("td", [
                      h(input_default, {
                        ref: xInputFilename,
                        modelValue: defaultOptions.filename,
                        type: "text",
                        clearable: true,
                        placeholder: conf_default.i18n("vxe.export.expNamePlaceholder"),
                        "onUpdate:modelValue"(value) {
                          defaultOptions.filename = value;
                        }
                      })
                    ])
                  ]),
                  isPrint ? createCommentVNode() : h("tr", [
                    h("td", conf_default.i18n("vxe.export.expType")),
                    h("td", [
                      h(select_default, {
                        modelValue: defaultOptions.type,
                        options: storeData2.typeList.map((item) => {
                          return {
                            value: item.value,
                            label: conf_default.i18n(item.label)
                          };
                        }),
                        "onUpdate:modelValue"(value) {
                          defaultOptions.type = value;
                        }
                      })
                    ])
                  ]),
                  isPrint || showSheet ? h("tr", [
                    h("td", conf_default.i18n("vxe.export.expSheetName")),
                    h("td", [
                      h(input_default, {
                        ref: xInputSheetname,
                        modelValue: defaultOptions.sheetName,
                        type: "text",
                        clearable: true,
                        placeholder: conf_default.i18n("vxe.export.expSheetNamePlaceholder"),
                        "onUpdate:modelValue"(value) {
                          defaultOptions.sheetName = value;
                        }
                      })
                    ])
                  ]) : createCommentVNode(),
                  h("tr", [
                    h("td", conf_default.i18n("vxe.export.expMode")),
                    h("td", [
                      h(select_default, {
                        modelValue: defaultOptions.mode,
                        options: storeData2.modeList.map((item) => {
                          return {
                            value: item.value,
                            label: conf_default.i18n(item.label)
                          };
                        }),
                        "onUpdate:modelValue"(value) {
                          defaultOptions.mode = value;
                        }
                      })
                    ])
                  ]),
                  h("tr", [
                    h("td", [conf_default.i18n("vxe.export.expColumn")]),
                    h("td", [
                      h("div", {
                        class: "vxe-export--panel-column"
                      }, [
                        h("ul", {
                          class: "vxe-export--panel-column-header"
                        }, [
                          h("li", {
                            class: ["vxe-export--panel-column-option", {
                              "is--checked": isAllChecked,
                              "is--indeterminate": isAllIndeterminate
                            }],
                            title: conf_default.i18n("vxe.table.allTitle"),
                            onClick: allColumnEvent
                          }, [
                            h("span", {
                              class: ["vxe-checkbox--icon", isAllIndeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
                            }),
                            h("span", {
                              class: "vxe-checkbox--label"
                            }, conf_default.i18n("vxe.export.expCurrentColumn"))
                          ])
                        ]),
                        h("ul", {
                          class: "vxe-export--panel-column-body"
                        }, cols)
                      ])
                    ])
                  ]),
                  h("tr", [
                    h("td", conf_default.i18n("vxe.export.expOpts")),
                    h("td", [
                      h("div", {
                        class: "vxe-export--panel-option-row"
                      }, [
                        h(checkbox_default, {
                          modelValue: defaultOptions.isHeader,
                          title: conf_default.i18n("vxe.export.expHeaderTitle"),
                          content: conf_default.i18n("vxe.export.expOptHeader"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.isHeader = value;
                          }
                        }),
                        h(checkbox_default, {
                          modelValue: defaultOptions.isFooter,
                          disabled: !storeData2.hasFooter,
                          title: conf_default.i18n("vxe.export.expFooterTitle"),
                          content: conf_default.i18n("vxe.export.expOptFooter"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.isFooter = value;
                          }
                        }),
                        h(checkbox_default, {
                          modelValue: defaultOptions.original,
                          title: conf_default.i18n("vxe.export.expOriginalTitle"),
                          content: conf_default.i18n("vxe.export.expOptOriginal"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.original = value;
                          }
                        })
                      ]),
                      h("div", {
                        class: "vxe-export--panel-option-row"
                      }, [
                        h(checkbox_default, {
                          modelValue: isHeader && hasColgroup && supportMerge ? defaultOptions.isColgroup : false,
                          title: conf_default.i18n("vxe.export.expColgroupTitle"),
                          disabled: !isHeader || !hasColgroup || !supportMerge,
                          content: conf_default.i18n("vxe.export.expOptColgroup"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.isColgroup = value;
                          }
                        }),
                        h(checkbox_default, {
                          modelValue: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false,
                          title: conf_default.i18n("vxe.export.expMergeTitle"),
                          disabled: !hasMerge || !supportMerge || !checkedAll,
                          content: conf_default.i18n("vxe.export.expOptMerge"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.isMerge = value;
                          }
                        }),
                        isPrint ? createCommentVNode() : h(checkbox_default, {
                          modelValue: supportStyle ? defaultOptions.useStyle : false,
                          disabled: !supportStyle,
                          title: conf_default.i18n("vxe.export.expUseStyleTitle"),
                          content: conf_default.i18n("vxe.export.expOptUseStyle"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.useStyle = value;
                          }
                        }),
                        h(checkbox_default, {
                          modelValue: hasTree ? defaultOptions.isAllExpand : false,
                          disabled: !hasTree,
                          title: conf_default.i18n("vxe.export.expAllExpandTitle"),
                          content: conf_default.i18n("vxe.export.expOptAllExpand"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.isAllExpand = value;
                          }
                        })
                      ])
                    ])
                  ])
                ]
              ])
            ]),
            h("div", {
              class: "vxe-export--panel-btns"
            }, [
              h(button_default, {
                content: conf_default.i18n("vxe.export.expCancel"),
                onClick: cancelEvent
              }),
              h(button_default, {
                ref: xButtonConfirm,
                status: "primary",
                content: conf_default.i18n(isPrint ? "vxe.export.expPrint" : "vxe.export.expConfirm"),
                onClick: confirmEvent
              })
            ])
          ]);
        }
      });
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/export/src/import-panel.js
var import_xe_utils29 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/radio/src/group.js
var import_xe_utils28 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/radio/src/radio.js
var import_xe_utils26 = __toESM(require_xe_utils());
var radio_default = defineComponent({
  name: "VxeRadio",
  props: {
    modelValue: [String, Number, Boolean],
    label: { type: [String, Number, Boolean], default: null },
    title: [String, Number],
    content: [String, Number],
    disabled: Boolean,
    name: String,
    strict: { type: Boolean, default: () => conf_default.radio.strict },
    size: { type: String, default: () => conf_default.radio.size || conf_default.size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils26.default.uniqueId();
    const $xeradio = {
      xID,
      props,
      context
    };
    const computeSize = useSize(props);
    const $xeradiogroup = inject("$xeradiogroup", null);
    let radioMethods = {};
    const computeDisabled = computed(() => {
      return props.disabled || $xeradiogroup && $xeradiogroup.props.disabled;
    });
    const computeName = computed(() => {
      return $xeradiogroup ? $xeradiogroup.name : props.name;
    });
    const computeStrict = computed(() => {
      return $xeradiogroup ? $xeradiogroup.props.strict : props.strict;
    });
    const computeChecked = computed(() => {
      const { modelValue, label } = props;
      return $xeradiogroup ? $xeradiogroup.props.modelValue === label : modelValue === label;
    });
    const handleValue = (label, evnt) => {
      if ($xeradiogroup) {
        $xeradiogroup.handleChecked({ label }, evnt);
      } else {
        emit("update:modelValue", label);
        radioMethods.dispatchEvent("change", { label }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, label);
        }
      }
    };
    const changeEvent = (evnt) => {
      const isDisabled = computeDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    const clickEvent = (evnt) => {
      const isDisabled = computeDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeradiogroup ? $xeradiogroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    radioMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $radio: $xeradio, $event: evnt }, params));
      }
    };
    Object.assign($xeradio, radioMethods);
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeDisabled.value;
      const name = computeName.value;
      const isChecked = computeChecked.value;
      return h("label", {
        class: ["vxe-radio", {
          [`size--${vSize}`]: vSize,
          "is--checked": isChecked,
          "is--disabled": isDisabled
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-radio--input",
          type: "radio",
          name,
          checked: isChecked,
          disabled: isDisabled,
          onChange: changeEvent,
          onClick: clickEvent
        }),
        h("span", {
          class: ["vxe-radio--icon", isChecked ? "vxe-icon-radio-checked" : "vxe-icon-radio-unchecked"]
        }),
        h("span", {
          class: "vxe-radio--label"
        }, slots.default ? slots.default({}) : getFuncText(props.content))
      ]);
    };
    $xeradio.renderVN = renderVN;
    return $xeradio;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/radio/src/button.js
var import_xe_utils27 = __toESM(require_xe_utils());
var button_default2 = defineComponent({
  name: "VxeRadioButton",
  props: {
    modelValue: [String, Number, Boolean],
    label: { type: [String, Number, Boolean], default: null },
    title: [String, Number],
    content: [String, Number],
    disabled: Boolean,
    strict: { type: Boolean, default: () => conf_default.radioButton.strict },
    size: { type: String, default: () => conf_default.radioButton.size || conf_default.size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils27.default.uniqueId();
    const computeSize = useSize(props);
    const $xeradiobutton = {
      xID,
      props,
      context
    };
    let radioButtonMethods = {};
    const $xeradiogroup = inject("$xeradiogroup", null);
    const computeDisabled = computed(() => {
      return props.disabled || $xeradiogroup && $xeradiogroup.props.disabled;
    });
    const computeName = computed(() => {
      return $xeradiogroup ? $xeradiogroup.name : null;
    });
    const computeStrict = computed(() => {
      return $xeradiogroup ? $xeradiogroup.props.strict : props.strict;
    });
    const computeChecked = computed(() => {
      const { modelValue, label } = props;
      return $xeradiogroup ? $xeradiogroup.props.modelValue === label : modelValue === label;
    });
    radioButtonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $radioButton: $xeradiobutton, $event: evnt }, params));
      }
    };
    Object.assign($xeradiobutton, radioButtonMethods);
    const handleValue = (label, evnt) => {
      if ($xeradiogroup) {
        $xeradiogroup.handleChecked({ label }, evnt);
      } else {
        emit("update:modelValue", label);
        radioButtonMethods.dispatchEvent("change", { label }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, label);
        }
      }
    };
    const changeEvent = (evnt) => {
      const isDisabled = computeDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    const clickEvent = (evnt) => {
      const isDisabled = computeDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeradiogroup ? $xeradiogroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeDisabled.value;
      const name = computeName.value;
      const checked = computeChecked.value;
      return h("label", {
        class: ["vxe-radio", "vxe-radio-button", {
          [`size--${vSize}`]: vSize,
          "is--disabled": isDisabled
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-radio--input",
          type: "radio",
          name,
          checked,
          disabled: isDisabled,
          onChange: changeEvent,
          onClick: clickEvent
        }),
        h("span", {
          class: "vxe-radio--label"
        }, slots.default ? slots.default({}) : getFuncText(props.content))
      ]);
    };
    Object.assign($xeradiobutton, {
      renderVN,
      dispatchEvent
    });
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/radio/src/group.js
var group_default = defineComponent({
  name: "VxeRadioGroup",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: Boolean,
    type: String,
    options: Array,
    optionProps: Object,
    strict: { type: Boolean, default: () => conf_default.radioGroup.strict },
    size: { type: String, default: () => conf_default.radioGroup.size || conf_default.size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils28.default.uniqueId();
    const $xeradiogroup = {
      xID,
      props,
      context,
      name: import_xe_utils28.default.uniqueId("xegroup_")
    };
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeDisabledField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || "disabled";
    });
    let radioGroupMethods = {};
    useSize(props);
    const radioGroupPrivateMethods = {
      handleChecked(params, evnt) {
        emit("update:modelValue", params.label);
        radioGroupMethods.dispatchEvent("change", params);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, params.label);
        }
      }
    };
    radioGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $radioGroup: $xeradiogroup, $event: evnt }, params));
      }
    };
    const renderVN = () => {
      const { options, type } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      const btnComp = type === "button" ? button_default2 : radio_default;
      return h("div", {
        class: "vxe-radio-group"
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item) => {
        return h(btnComp, {
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    Object.assign($xeradiogroup, radioGroupPrivateMethods, {
      renderVN,
      dispatchEvent
    });
    provide("$xeradiogroup", $xeradiogroup);
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/export/src/import-panel.js
var import_panel_default = defineComponent({
  name: "VxeTableImportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const $xetable = inject("$xetable", {});
    const { computeImportOpts } = $xetable.getComputeMaps();
    const reactData = reactive({
      loading: false
    });
    const refFileBtn = ref();
    const computeSelectName = computed(() => {
      const { storeData: storeData2 } = props;
      return `${storeData2.filename}.${storeData2.type}`;
    });
    const computeHasFile = computed(() => {
      const { storeData: storeData2 } = props;
      return storeData2.file && storeData2.type;
    });
    const computeParseTypeLabel = computed(() => {
      const { storeData: storeData2 } = props;
      const { type, typeList } = storeData2;
      if (type) {
        const selectItem = import_xe_utils29.default.find(typeList, (item) => type === item.value);
        return selectItem ? conf_default.i18n(selectItem.label) : "*.*";
      }
      return `*.${typeList.map((item) => item.value).join(", *.")}`;
    });
    const clearFileEvent = () => {
      const { storeData: storeData2 } = props;
      Object.assign(storeData2, {
        filename: "",
        sheetName: "",
        type: ""
      });
    };
    const selectFileEvent = () => {
      const { storeData: storeData2, defaultOptions } = props;
      $xetable.readFile(defaultOptions).then((params) => {
        const { file } = params;
        Object.assign(storeData2, parseFile(file), { file });
      }).catch((e) => e);
    };
    const showEvent = () => {
      nextTick(() => {
        const targetElem = refFileBtn.value;
        if (targetElem) {
          targetElem.focus();
        }
      });
    };
    const cancelEvent = () => {
      const { storeData: storeData2 } = props;
      storeData2.visible = false;
    };
    const importEvent = () => {
      const { storeData: storeData2, defaultOptions } = props;
      const importOpts = computeImportOpts.value;
      reactData.loading = true;
      $xetable.importByFile(storeData2.file, Object.assign({}, importOpts, defaultOptions)).then(() => {
        reactData.loading = false;
        storeData2.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const renderVN = () => {
      const { defaultOptions, storeData: storeData2 } = props;
      const selectName = computeSelectName.value;
      const hasFile = computeHasFile.value;
      const parseTypeLabel = computeParseTypeLabel.value;
      return h(modal_default, {
        modelValue: storeData2.visible,
        title: conf_default.i18n("vxe.import.impTitle"),
        className: "vxe-table-import-popup-wrapper",
        width: 440,
        mask: true,
        lockView: true,
        showFooter: false,
        escClosable: true,
        maskClosable: true,
        loading: reactData.loading,
        "onUpdate:modelValue"(value) {
          storeData2.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          return h("div", {
            class: "vxe-export--panel"
          }, [
            h("table", {
              cellspacing: 0,
              cellpadding: 0,
              border: 0
            }, [
              h("tbody", [
                h("tr", [
                  h("td", conf_default.i18n("vxe.import.impFile")),
                  h("td", [
                    hasFile ? h("div", {
                      class: "vxe-import-selected--file",
                      title: selectName
                    }, [
                      h("span", selectName),
                      h("i", {
                        class: conf_default.icon.INPUT_CLEAR,
                        onClick: clearFileEvent
                      })
                    ]) : h("button", {
                      ref: refFileBtn,
                      class: "vxe-import-select--file",
                      onClick: selectFileEvent
                    }, conf_default.i18n("vxe.import.impSelect"))
                  ])
                ]),
                h("tr", [
                  h("td", conf_default.i18n("vxe.import.impType")),
                  h("td", parseTypeLabel)
                ]),
                h("tr", [
                  h("td", conf_default.i18n("vxe.import.impOpts")),
                  h("td", [
                    h(group_default, {
                      modelValue: defaultOptions.mode,
                      "onUpdate:modelValue"(value) {
                        defaultOptions.mode = value;
                      }
                    }, {
                      default: () => storeData2.modeList.map((item) => h(radio_default, { label: item.value, content: conf_default.i18n(item.label) }))
                    })
                  ])
                ])
              ])
            ]),
            h("div", {
              class: "vxe-export--panel-btns"
            }, [
              h(button_default, {
                content: conf_default.i18n("vxe.import.impCancel"),
                onClick: cancelEvent
              }),
              h(button_default, {
                status: "primary",
                disabled: !hasFile,
                content: conf_default.i18n("vxe.import.impConfirm"),
                onClick: importEvent
              })
            ])
          ]);
        }
      });
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/export/src/hook.js
var import_xe_utils31 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/export/src/util.js
var import_xe_utils30 = __toESM(require_xe_utils());
var fileForm;
var fileInput;
var printFrame;
var defaultHtmlStyle = 'body{margin:0;padding: 0 1px;color:#333333;font-size:14px;font-family:"Microsoft YaHei",微软雅黑,"MicrosoftJhengHei",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function createFrame() {
  const frame = document.createElement("iframe");
  frame.className = "vxe-table--print-frame";
  return frame;
}
function getExportBlobByContent(content, options) {
  return new Blob([content], { type: `text/${options.type};charset=utf-8;` });
}
function createHtmlPage(opts, content) {
  const { style } = opts;
  return [
    "<!DOCTYPE html><html>",
    "<head>",
    '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">',
    `<title>${opts.sheetName}</title>`,
    '<style media="print">.vxe-page-break-before{page-break-before:always;}.vxe-page-break-after{page-break-after:always;}</style>',
    `<style>${defaultHtmlStyle}</style>`,
    style ? `<style>${style}</style>` : "",
    "</head>",
    `<body>${content}</body>`,
    "</html>"
  ].join("");
}
var readLocalFile = (options) => {
  const opts = Object.assign({}, options);
  if (!fileForm) {
    fileForm = document.createElement("form");
    fileInput = document.createElement("input");
    fileForm.className = "vxe-table--file-form";
    fileInput.name = "file";
    fileInput.type = "file";
    fileForm.appendChild(fileInput);
    document.body.appendChild(fileForm);
  }
  return new Promise((resolve, reject) => {
    const types = opts.types || [];
    const isAllType = !types.length || types.some((type) => type === "*");
    fileInput.multiple = !!opts.multiple;
    fileInput.accept = isAllType ? "" : `.${types.join(", .")}`;
    fileInput.onchange = (evnt) => {
      const { files } = evnt.target;
      const file = files[0];
      let errType = "";
      if (!isAllType) {
        for (let fIndex = 0; fIndex < files.length; fIndex++) {
          const { type } = parseFile(files[fIndex]);
          if (!import_xe_utils30.default.includes(types, type)) {
            errType = type;
            break;
          }
        }
      }
      if (!errType) {
        resolve({ status: true, files, file });
      } else {
        if (opts.message !== false) {
          if (true) {
            if (!VXETable.modal) {
              errLog("vxe.error.reqModule", ["Modal"]);
            }
          }
          VXETable.modal.message({ content: conf_default.i18n("vxe.error.notType", [errType]), status: "error" });
        }
        const params = { status: false, files, file };
        reject(params);
      }
    };
    fileForm.reset();
    fileInput.click();
  });
};
function removePrintFrame() {
  if (printFrame) {
    if (printFrame.parentNode) {
      try {
        printFrame.contentDocument.write("");
      } catch (e) {
      }
      printFrame.parentNode.removeChild(printFrame);
    }
    printFrame = null;
  }
}
function appendPrintFrame() {
  if (!printFrame.parentNode) {
    document.body.appendChild(printFrame);
  }
}
function afterPrintEvent() {
  requestAnimationFrame(removePrintFrame);
}
function handlePrint($xetable, opts, content = "") {
  const { beforePrintMethod } = opts;
  if (beforePrintMethod) {
    content = beforePrintMethod({ content, options: opts, $table: $xetable }) || "";
  }
  content = createHtmlPage(opts, content);
  const blob = getExportBlobByContent(content, opts);
  if (browse.msie) {
    removePrintFrame();
    printFrame = createFrame();
    appendPrintFrame();
    printFrame.contentDocument.write(content);
    printFrame.contentDocument.execCommand("print");
  } else {
    if (!printFrame) {
      printFrame = createFrame();
      printFrame.onload = (evnt) => {
        if (evnt.target.src) {
          evnt.target.contentWindow.onafterprint = afterPrintEvent;
          evnt.target.contentWindow.print();
        }
      };
    }
    appendPrintFrame();
    printFrame.src = URL.createObjectURL(blob);
  }
}
var saveLocalFile = (options) => {
  const { filename, type, content } = options;
  const name = `${filename}.${type}`;
  if (window.Blob) {
    const blob = content instanceof Blob ? content : getExportBlobByContent(import_xe_utils30.default.toValueString(content), options);
    if (navigator.msSaveBlob) {
      navigator.msSaveBlob(blob, name);
    } else {
      const url = URL.createObjectURL(blob);
      const linkElem = document.createElement("a");
      linkElem.target = "_blank";
      linkElem.download = name;
      linkElem.href = url;
      document.body.appendChild(linkElem);
      linkElem.click();
      requestAnimationFrame(() => {
        if (linkElem.parentNode) {
          linkElem.parentNode.removeChild(linkElem);
        }
        URL.revokeObjectURL(url);
      });
    }
    return Promise.resolve();
  }
  return Promise.reject(new Error(getLog("vxe.error.notExp")));
};

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/export/src/hook.js
var htmlCellElem;
var csvBOM = "\uFEFF";
var enterSymbol = "\r\n";
function defaultFilterExportColumn(column) {
  return column.property || ["seq", "checkbox", "radio"].indexOf(column.type) > -1;
}
var getConvertColumns = (columns) => {
  const result = [];
  columns.forEach((column) => {
    if (column.childNodes && column.childNodes.length) {
      result.push(column);
      result.push(...getConvertColumns(column.childNodes));
    } else {
      result.push(column);
    }
  });
  return result;
};
var convertToRows = (originColumns) => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column._level = parent._level + 1;
      if (maxLevel < column._level) {
        maxLevel = column._level;
      }
    }
    if (column.childNodes && column.childNodes.length) {
      let colSpan = 0;
      column.childNodes.forEach((subColumn) => {
        traverse(subColumn, column);
        colSpan += subColumn._colSpan;
      });
      column._colSpan = colSpan;
    } else {
      column._colSpan = 1;
    }
  };
  originColumns.forEach((column) => {
    column._level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getConvertColumns(originColumns);
  allColumns.forEach((column) => {
    if (column.childNodes && column.childNodes.length) {
      column._rowSpan = 1;
    } else {
      column._rowSpan = maxLevel - column._level + 1;
    }
    rows[column._level - 1].push(column);
  });
  return rows;
};
function toTableBorder(border) {
  if (border === true) {
    return "full";
  }
  if (border) {
    return border;
  }
  return "default";
}
function getBooleanValue(cellValue) {
  return cellValue === "TRUE" || cellValue === "true" || cellValue === true;
}
function getFooterData(opts, footerTableData) {
  const { footerFilterMethod } = opts;
  return footerFilterMethod ? footerTableData.filter((items, index) => footerFilterMethod({ items, $rowIndex: index })) : footerTableData;
}
function getCsvCellTypeLabel(column, cellValue) {
  if (cellValue) {
    if (column.type === "seq") {
      return `	${cellValue}`;
    }
    switch (column.cellType) {
      case "string":
        if (!isNaN(cellValue)) {
          return `	${cellValue}`;
        }
        break;
      case "number":
        break;
      default:
        if (cellValue.length >= 12 && !isNaN(cellValue)) {
          return `	${cellValue}`;
        }
        break;
    }
  }
  return cellValue;
}
function toTxtCellLabel(val) {
  if (/[",\s\n]/.test(val)) {
    return `"${val.replace(/"/g, '""')}"`;
  }
  return val;
}
function getElementsByTagName(elem, qualifiedName) {
  return elem.getElementsByTagName(qualifiedName);
}
function getTxtCellKey(now) {
  return `#${now}@${import_xe_utils31.default.uniqueId()}`;
}
function replaceTxtCell(cell, vMaps) {
  return cell.replace(/#\d+@\d+/g, (key) => import_xe_utils31.default.hasOwnProp(vMaps, key) ? vMaps[key] : key);
}
function getTxtCellValue(val, vMaps) {
  const rest = replaceTxtCell(val, vMaps);
  return rest.replace(/^"+$/g, (qVal) => '"'.repeat(Math.ceil(qVal.length / 2)));
}
function parseCsvAndTxt(columns, content, cellSeparator) {
  const list = content.split(enterSymbol);
  const rows = [];
  let fields = [];
  if (list.length) {
    const vMaps = {};
    const now = Date.now();
    list.forEach((rVal) => {
      if (rVal) {
        const item = {};
        rVal = rVal.replace(/("")|(\n)/g, (text, dVal) => {
          const key = getTxtCellKey(now);
          vMaps[key] = dVal ? '"' : "\n";
          return key;
        }).replace(/"(.*?)"/g, (text, cVal) => {
          const key = getTxtCellKey(now);
          vMaps[key] = replaceTxtCell(cVal, vMaps);
          return key;
        });
        const cells = rVal.split(cellSeparator);
        if (!fields.length) {
          fields = cells.map((val) => getTxtCellValue(val.trim(), vMaps));
        } else {
          cells.forEach((val, colIndex) => {
            if (colIndex < fields.length) {
              item[fields[colIndex]] = getTxtCellValue(val.trim(), vMaps);
            }
          });
          rows.push(item);
        }
      }
    });
  }
  return { fields, rows };
}
function parseCsv(columns, content) {
  return parseCsvAndTxt(columns, content, ",");
}
function parseTxt(columns, content) {
  return parseCsvAndTxt(columns, content, "	");
}
function parseHTML(columns, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, "text/html");
  const bodyNodes = getElementsByTagName(xmlDoc, "body");
  const rows = [];
  const fields = [];
  if (bodyNodes.length) {
    const tableNodes = getElementsByTagName(bodyNodes[0], "table");
    if (tableNodes.length) {
      const theadNodes = getElementsByTagName(tableNodes[0], "thead");
      if (theadNodes.length) {
        import_xe_utils31.default.arrayEach(getElementsByTagName(theadNodes[0], "tr"), (rowNode) => {
          import_xe_utils31.default.arrayEach(getElementsByTagName(rowNode, "th"), (cellNode) => {
            fields.push(cellNode.textContent);
          });
        });
        const tbodyNodes = getElementsByTagName(tableNodes[0], "tbody");
        if (tbodyNodes.length) {
          import_xe_utils31.default.arrayEach(getElementsByTagName(tbodyNodes[0], "tr"), (rowNode) => {
            const item = {};
            import_xe_utils31.default.arrayEach(getElementsByTagName(rowNode, "td"), (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent || "";
              }
            });
            rows.push(item);
          });
        }
      }
    }
  }
  return { fields, rows };
}
function parseXML(columns, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, "application/xml");
  const sheetNodes = getElementsByTagName(xmlDoc, "Worksheet");
  const rows = [];
  const fields = [];
  if (sheetNodes.length) {
    const tableNodes = getElementsByTagName(sheetNodes[0], "Table");
    if (tableNodes.length) {
      const rowNodes = getElementsByTagName(tableNodes[0], "Row");
      if (rowNodes.length) {
        import_xe_utils31.default.arrayEach(getElementsByTagName(rowNodes[0], "Cell"), (cellNode) => {
          fields.push(cellNode.textContent);
        });
        import_xe_utils31.default.arrayEach(rowNodes, (rowNode, index) => {
          if (index) {
            const item = {};
            const cellNodes = getElementsByTagName(rowNode, "Cell");
            import_xe_utils31.default.arrayEach(cellNodes, (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent;
              }
            });
            rows.push(item);
          }
        });
      }
    }
  }
  return { fields, rows };
}
function clearColumnConvert(columns) {
  import_xe_utils31.default.eachTree(columns, (column) => {
    delete column._level;
    delete column._colSpan;
    delete column._rowSpan;
    delete column._children;
    delete column.childNodes;
  }, { children: "children" });
}
function checkImportData(columns, fields) {
  const tableFields = [];
  columns.forEach((column) => {
    const field = column.property;
    if (field) {
      tableFields.push(field);
    }
  });
  return fields.some((field) => tableFields.indexOf(field) > -1);
}
var tableExportMethodKeys = ["exportData", "importByFile", "importData", "saveFile", "readFile", "print", "openImport", "openExport", "openPrint"];
var tableExportHook = {
  setupTable($xetable) {
    const { props, reactData, internalData } = $xetable;
    const { computeTreeOpts, computePrintOpts, computeExportOpts, computeImportOpts, computeCustomOpts, computeSeqOpts, computeRadioOpts, computeCheckboxOpts, computeColumnOpts } = $xetable.getComputeMaps();
    const $xegrid = inject("$xegrid", null);
    const hasTreeChildren = (row) => {
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      return row[childrenField] && row[childrenField].length;
    };
    const getSeq = (row, $rowIndex, column, $columnIndex) => {
      const seqOpts = computeSeqOpts.value;
      const seqMethod = seqOpts.seqMethod || column.seqMethod;
      if (seqMethod) {
        return seqMethod({
          row,
          rowIndex: $xetable.getRowIndex(row),
          $rowIndex,
          column,
          columnIndex: $xetable.getColumnIndex(column),
          $columnIndex
        });
      }
      return $xetable.getRowSeq(row);
    };
    function getHeaderTitle(opts, column) {
      const columnOpts = computeColumnOpts.value;
      const headExportMethod = column.headerExportMethod || columnOpts.headerExportMethod;
      return headExportMethod ? headExportMethod({ column, options: opts, $table: $xetable }) : (opts.original ? column.property : column.getTitle()) || "";
    }
    const toBooleanValue = (cellValue) => {
      return import_xe_utils31.default.isBoolean(cellValue) ? cellValue ? "TRUE" : "FALSE" : cellValue;
    };
    const getLabelData = (opts, columns, datas) => {
      const { isAllExpand, mode } = opts;
      const { treeConfig } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeOpts = computeTreeOpts.value;
      const columnOpts = computeColumnOpts.value;
      if (!htmlCellElem) {
        htmlCellElem = document.createElement("div");
      }
      if (treeConfig) {
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const rest = [];
        const expandMaps = /* @__PURE__ */ new Map();
        import_xe_utils31.default.eachTree(datas, (item, $rowIndex, items, path, parent, nodes) => {
          const row = item._row || item;
          const parentRow = parent && parent._row ? parent._row : parent;
          if (isAllExpand || !parentRow || expandMaps.has(parentRow) && $xetable.isTreeExpandByRow(parentRow)) {
            const hasRowChild = hasTreeChildren(row);
            const item2 = {
              _row: row,
              _level: nodes.length - 1,
              _hasChild: hasRowChild,
              _expand: hasRowChild && $xetable.isTreeExpandByRow(row)
            };
            columns.forEach((column, $columnIndex) => {
              let cellValue = "";
              const renderOpts = column.editRender || column.cellRender;
              let bodyExportMethod = column.exportMethod;
              if (!bodyExportMethod && renderOpts && renderOpts.name) {
                const compConf = VXETable.renderer.get(renderOpts.name);
                if (compConf) {
                  bodyExportMethod = compConf.exportMethod;
                }
              }
              if (!bodyExportMethod) {
                bodyExportMethod = columnOpts.exportMethod;
              }
              if (bodyExportMethod) {
                cellValue = bodyExportMethod({ $table: $xetable, row, column, options: opts });
              } else {
                switch (column.type) {
                  case "seq":
                    cellValue = mode === "all" ? path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("") : getSeq(row, $rowIndex, column, $columnIndex);
                    break;
                  case "checkbox":
                    cellValue = toBooleanValue($xetable.isCheckedByCheckboxRow(row));
                    item2._checkboxLabel = checkboxOpts.labelField ? import_xe_utils31.default.get(row, checkboxOpts.labelField) : "";
                    item2._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ row });
                    break;
                  case "radio":
                    cellValue = toBooleanValue($xetable.isCheckedByRadioRow(row));
                    item2._radioLabel = radioOpts.labelField ? import_xe_utils31.default.get(row, radioOpts.labelField) : "";
                    item2._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ row });
                    break;
                  default:
                    if (opts.original) {
                      cellValue = getCellValue(row, column);
                    } else {
                      cellValue = $xetable.getCellLabel(row, column);
                      if (column.type === "html") {
                        htmlCellElem.innerHTML = cellValue;
                        cellValue = htmlCellElem.innerText.trim();
                      } else {
                        const cell = $xetable.getCell(row, column);
                        if (cell) {
                          cellValue = cell.innerText.trim();
                        }
                      }
                    }
                }
              }
              item2[column.id] = import_xe_utils31.default.toValueString(cellValue);
            });
            expandMaps.set(row, 1);
            rest.push(Object.assign(item2, row));
          }
        }, { children: childrenField });
        return rest;
      }
      return datas.map((row, $rowIndex) => {
        const item = {
          _row: row
        };
        columns.forEach((column, $columnIndex) => {
          let cellValue = "";
          const renderOpts = column.editRender || column.cellRender;
          let exportLabelMethod = column.exportMethod;
          if (!exportLabelMethod && renderOpts && renderOpts.name) {
            const compConf = VXETable.renderer.get(renderOpts.name);
            if (compConf) {
              exportLabelMethod = compConf.exportMethod;
            }
          }
          if (exportLabelMethod) {
            cellValue = exportLabelMethod({ $table: $xetable, row, column, options: opts });
          } else {
            switch (column.type) {
              case "seq":
                cellValue = mode === "all" ? $rowIndex + 1 : getSeq(row, $rowIndex, column, $columnIndex);
                break;
              case "checkbox":
                cellValue = toBooleanValue($xetable.isCheckedByCheckboxRow(row));
                item._checkboxLabel = checkboxOpts.labelField ? import_xe_utils31.default.get(row, checkboxOpts.labelField) : "";
                item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ row });
                break;
              case "radio":
                cellValue = toBooleanValue($xetable.isCheckedByRadioRow(row));
                item._radioLabel = radioOpts.labelField ? import_xe_utils31.default.get(row, radioOpts.labelField) : "";
                item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ row });
                break;
              default:
                if (opts.original) {
                  cellValue = getCellValue(row, column);
                } else {
                  cellValue = $xetable.getCellLabel(row, column);
                  if (column.type === "html") {
                    htmlCellElem.innerHTML = cellValue;
                    cellValue = htmlCellElem.innerText.trim();
                  } else {
                    const cell = $xetable.getCell(row, column);
                    if (cell) {
                      cellValue = cell.innerText.trim();
                    }
                  }
                }
            }
          }
          item[column.id] = import_xe_utils31.default.toValueString(cellValue);
        });
        return item;
      });
    };
    const getExportData = (opts) => {
      const { columns, dataFilterMethod } = opts;
      let datas = opts.data;
      if (dataFilterMethod) {
        datas = datas.filter((row, index) => dataFilterMethod({ row, $rowIndex: index }));
      }
      return getLabelData(opts, columns, datas);
    };
    const getFooterCellValue = (opts, items, column) => {
      const columnOpts = computeColumnOpts.value;
      const renderOpts = column.editRender || column.cellRender;
      let footLabelMethod = column.footerExportMethod;
      if (!footLabelMethod && renderOpts && renderOpts.name) {
        const compConf = VXETable.renderer.get(renderOpts.name);
        if (compConf) {
          footLabelMethod = compConf.footerExportMethod;
        }
      }
      if (!footLabelMethod) {
        footLabelMethod = columnOpts.footerExportMethod;
      }
      const _columnIndex = $xetable.getVTColumnIndex(column);
      const cellValue = footLabelMethod ? footLabelMethod({ $table: $xetable, items, itemIndex: _columnIndex, row: items, _columnIndex, column, options: opts }) : import_xe_utils31.default.toValueString(items[_columnIndex]);
      return cellValue;
    };
    const toCsv = (opts, columns, datas) => {
      let content = csvBOM;
      if (opts.isHeader) {
        content += columns.map((column) => toTxtCellLabel(getHeaderTitle(opts, column))).join(",") + enterSymbol;
      }
      datas.forEach((row) => {
        content += columns.map((column) => toTxtCellLabel(getCsvCellTypeLabel(column, row[column.id]))).join(",") + enterSymbol;
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach((rows) => {
          content += columns.map((column) => toTxtCellLabel(getFooterCellValue(opts, rows, column))).join(",") + enterSymbol;
        });
      }
      return content;
    };
    const toTxt = (opts, columns, datas) => {
      let content = "";
      if (opts.isHeader) {
        content += columns.map((column) => toTxtCellLabel(getHeaderTitle(opts, column))).join("	") + enterSymbol;
      }
      datas.forEach((row) => {
        content += columns.map((column) => toTxtCellLabel(row[column.id])).join("	") + enterSymbol;
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach((rows) => {
          content += columns.map((column) => toTxtCellLabel(getFooterCellValue(opts, rows, column))).join(",") + enterSymbol;
        });
      }
      return content;
    };
    const hasEllipsis = (column, property, allColumnOverflow) => {
      const columnOverflow = column[property];
      const headOverflow = import_xe_utils31.default.isUndefined(columnOverflow) || import_xe_utils31.default.isNull(columnOverflow) ? allColumnOverflow : columnOverflow;
      const showEllipsis = headOverflow === "ellipsis";
      const showTitle = headOverflow === "title";
      const showTooltip = headOverflow === true || headOverflow === "tooltip";
      let isEllipsis = showTitle || showTooltip || showEllipsis;
      const { scrollXLoad, scrollYLoad } = reactData;
      if ((scrollXLoad || scrollYLoad) && !isEllipsis) {
        isEllipsis = true;
      }
      return isEllipsis;
    };
    const toHtml = (opts, columns, datas) => {
      const { id, border, treeConfig, headerAlign: allHeaderAlign, align: allAlign, footerAlign: allFooterAlign, showOverflow: allColumnOverflow, showHeaderOverflow: allColumnHeaderOverflow } = props;
      const { isAllSelected, isIndeterminate, mergeList } = reactData;
      const treeOpts = computeTreeOpts.value;
      const { print: isPrint, isHeader, isFooter, isColgroup, isMerge, colgroups, original } = opts;
      const allCls = "check-all";
      const clss = [
        "vxe-table",
        `border--${toTableBorder(border)}`,
        isPrint ? "is--print" : "",
        isHeader ? "is--header" : ""
      ].filter((cls) => cls);
      const tables = [
        `<table class="${clss.join(" ")}" border="0" cellspacing="0" cellpadding="0">`,
        `<colgroup>${columns.map((column) => `<col style="width:${column.renderWidth}px">`).join("")}</colgroup>`
      ];
      if (isHeader) {
        tables.push("<thead>");
        if (isColgroup && !original) {
          colgroups.forEach((cols) => {
            tables.push(`<tr>${cols.map((column) => {
              const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
              const classNames = hasEllipsis(column, "showHeaderOverflow", allColumnHeaderOverflow) ? ["col--ellipsis"] : [];
              const cellTitle = getHeaderTitle(opts, column);
              let childWidth = 0;
              let countChild = 0;
              import_xe_utils31.default.eachTree([column], (item) => {
                if (!item.childNodes || !column.childNodes.length) {
                  countChild++;
                }
                childWidth += item.renderWidth;
              }, { children: "childNodes" });
              const cellWidth = childWidth - countChild;
              if (headAlign) {
                classNames.push(`col--${headAlign}`);
              }
              if (column.type === "checkbox") {
                return `<th class="${classNames.join(" ")}" colspan="${column._colSpan}" rowspan="${column._rowSpan}"><div ${isPrint ? "" : `style="width: ${cellWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? "checked" : ""}><span>${cellTitle}</span></div></th>`;
              }
              return `<th class="${classNames.join(" ")}" colspan="${column._colSpan}" rowspan="${column._rowSpan}" title="${cellTitle}"><div ${isPrint ? "" : `style="width: ${cellWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
            }).join("")}</tr>`);
          });
        } else {
          tables.push(`<tr>${columns.map((column) => {
            const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
            const classNames = hasEllipsis(column, "showHeaderOverflow", allColumnHeaderOverflow) ? ["col--ellipsis"] : [];
            const cellTitle = getHeaderTitle(opts, column);
            if (headAlign) {
              classNames.push(`col--${headAlign}`);
            }
            if (column.type === "checkbox") {
              return `<th class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? "checked" : ""}><span>${cellTitle}</span></div></th>`;
            }
            return `<th class="${classNames.join(" ")}" title="${cellTitle}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
          }).join("")}</tr>`);
        }
        tables.push("</thead>");
      }
      if (datas.length) {
        tables.push("<tbody>");
        if (treeConfig) {
          datas.forEach((item) => {
            tables.push("<tr>" + columns.map((column) => {
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = item[column.id];
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.treeNode) {
                let treeIcon = "";
                if (item._hasChild) {
                  treeIcon = `<i class="${item._expand ? "vxe-table--tree-fold-icon" : "vxe-table--tree-unfold-icon"}"></i>`;
                }
                classNames.push("vxe-table--tree-node");
                if (column.type === "radio") {
                  return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="radio" name="radio_${id}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></div></div></td>`;
                } else if (column.type === "checkbox") {
                  return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></div></div></td>`;
                }
                return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell">${cellValue}</div></div></div></td>`;
              }
              if (column.type === "radio") {
                return `<td class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === "checkbox") {
                return `<td class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("") + "</tr>");
          });
        } else {
          datas.forEach((item) => {
            tables.push("<tr>" + columns.map((column) => {
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = item[column.id];
              let rowSpan = 1;
              let colSpan = 1;
              if (isMerge && mergeList.length) {
                const _rowIndex = $xetable.getVTRowIndex(item._row);
                const _columnIndex = $xetable.getVTColumnIndex(column);
                const spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);
                if (spanRest) {
                  const { rowspan, colspan } = spanRest;
                  if (!rowspan || !colspan) {
                    return "";
                  }
                  if (rowspan > 1) {
                    rowSpan = rowspan;
                  }
                  if (colspan > 1) {
                    colSpan = colspan;
                  }
                }
              }
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.type === "radio") {
                return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === "checkbox") {
                return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("") + "</tr>");
          });
        }
        tables.push("</tbody>");
      }
      if (isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        if (footers.length) {
          tables.push("<tfoot>");
          footers.forEach((rows) => {
            tables.push(`<tr>${columns.map((column) => {
              const footAlign = column.footerAlign || column.align || allFooterAlign || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = getFooterCellValue(opts, rows, column);
              if (footAlign) {
                classNames.push(`col--${footAlign}`);
              }
              return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("")}</tr>`);
          });
          tables.push("</tfoot>");
        }
      }
      const script = !isAllSelected && isIndeterminate ? `<script>(function(){var a=document.querySelector(".${allCls}");if(a){a.indeterminate=true}})()<\/script>` : "";
      tables.push("</table>", script);
      return isPrint ? tables.join("") : createHtmlPage(opts, tables.join(""));
    };
    const toXML = (opts, columns, datas) => {
      let xml = [
        '<?xml version="1.0"?>',
        '<?mso-application progid="Excel.Sheet"?>',
        '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">',
        '<DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">',
        "<Version>16.00</Version>",
        "</DocumentProperties>",
        '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel">',
        "<WindowHeight>7920</WindowHeight>",
        "<WindowWidth>21570</WindowWidth>",
        "<WindowTopX>32767</WindowTopX>",
        "<WindowTopY>32767</WindowTopY>",
        "<ProtectStructure>False</ProtectStructure>",
        "<ProtectWindows>False</ProtectWindows>",
        "</ExcelWorkbook>",
        `<Worksheet ss:Name="${opts.sheetName}">`,
        "<Table>",
        columns.map((column) => `<Column ss:Width="${column.renderWidth}"/>`).join("")
      ].join("");
      if (opts.isHeader) {
        xml += `<Row>${columns.map((column) => `<Cell><Data ss:Type="String">${getHeaderTitle(opts, column)}</Data></Cell>`).join("")}</Row>`;
      }
      datas.forEach((row) => {
        xml += "<Row>" + columns.map((column) => `<Cell><Data ss:Type="String">${row[column.id]}</Data></Cell>`).join("") + "</Row>";
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach((rows) => {
          xml += `<Row>${columns.map((column) => `<Cell><Data ss:Type="String">${getFooterCellValue(opts, rows, column)}</Data></Cell>`).join("")}</Row>`;
        });
      }
      return `${xml}</Table></Worksheet></Workbook>`;
    };
    const getContent = (opts, columns, datas) => {
      if (columns.length) {
        switch (opts.type) {
          case "csv":
            return toCsv(opts, columns, datas);
          case "txt":
            return toTxt(opts, columns, datas);
          case "html":
            return toHtml(opts, columns, datas);
          case "xml":
            return toXML(opts, columns, datas);
        }
      }
      return "";
    };
    const downloadFile = (opts, content) => {
      const { filename, type, download } = opts;
      if (!download) {
        const blob = getExportBlobByContent(content, opts);
        return Promise.resolve({ type, content, blob });
      }
      saveLocalFile({ filename, type, content }).then(() => {
        if (opts.message !== false) {
          if (true) {
            if (!VXETable.modal) {
              errLog("vxe.error.reqModule", ["Modal"]);
            }
          }
          VXETable.modal.message({ content: conf_default.i18n("vxe.table.expSuccess"), status: "success" });
        }
      });
    };
    const handleExport = (opts) => {
      const { remote, columns, colgroups, exportMethod, afterExportMethod } = opts;
      return new Promise((resolve) => {
        if (remote) {
          const params = { options: opts, $table: $xetable, $grid: $xegrid };
          resolve(exportMethod ? exportMethod(params) : params);
        } else {
          const datas = getExportData(opts);
          resolve($xetable.preventEvent(null, "event.export", { options: opts, columns, colgroups, datas }, () => {
            return downloadFile(opts, getContent(opts, columns, datas));
          }));
        }
      }).then((params) => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({ status: true, options: opts, $table: $xetable, $grid: $xegrid });
          }
        }
        return Object.assign({ status: true }, params);
      }).catch(() => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({ status: false, options: opts, $table: $xetable, $grid: $xegrid });
          }
        }
        const params = { status: false };
        return Promise.reject(params);
      });
    };
    const handleImport = (content, opts) => {
      const { tableFullColumn, _importResolve, _importReject } = internalData;
      let rest = { fields: [], rows: [] };
      switch (opts.type) {
        case "csv":
          rest = parseCsv(tableFullColumn, content);
          break;
        case "txt":
          rest = parseTxt(tableFullColumn, content);
          break;
        case "html":
          rest = parseHTML(tableFullColumn, content);
          break;
        case "xml":
          rest = parseXML(tableFullColumn, content);
          break;
      }
      const { fields, rows } = rest;
      const status = checkImportData(tableFullColumn, fields);
      if (status) {
        $xetable.createData(rows).then((data) => {
          let loadRest;
          if (opts.mode === "insert") {
            loadRest = $xetable.insert(data);
          } else {
            loadRest = $xetable.reloadData(data);
          }
          if (opts.message !== false) {
            if (true) {
              if (!VXETable.modal) {
                errLog("vxe.error.reqModule", ["Modal"]);
              }
            }
            VXETable.modal.message({ content: conf_default.i18n("vxe.table.impSuccess", [rows.length]), status: "success" });
          }
          return loadRest.then(() => {
            if (_importResolve) {
              _importResolve({ status: true });
            }
          });
        });
      } else if (opts.message !== false) {
        if (true) {
          if (!VXETable.modal) {
            errLog("vxe.error.reqModule", ["Modal"]);
          }
        }
        VXETable.modal.message({ content: conf_default.i18n("vxe.error.impFields"), status: "error" });
        if (_importReject) {
          _importReject({ status: false });
        }
      }
    };
    const handleFileImport = (file, opts) => {
      const { importMethod, afterImportMethod } = opts;
      const { type, filename } = parseFile(file);
      if (!importMethod && !import_xe_utils31.default.includes(VXETable.globalConfs.importTypes, type)) {
        if (opts.message !== false) {
          if (true) {
            if (!VXETable.modal) {
              errLog("vxe.error.reqModule", ["Modal"]);
            }
          }
          VXETable.modal.message({ content: conf_default.i18n("vxe.error.notType", [type]), status: "error" });
        }
        const params = { status: false };
        return Promise.reject(params);
      }
      const rest = new Promise((resolve, reject) => {
        const _importResolve = (params) => {
          resolve(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        const _importReject = (params) => {
          reject(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        internalData._importResolve = _importResolve;
        internalData._importReject = _importReject;
        if (window.FileReader) {
          const options = Object.assign({ mode: "insert" }, opts, { type, filename });
          if (options.remote) {
            if (importMethod) {
              Promise.resolve(importMethod({ file, options, $table: $xetable })).then(() => {
                _importResolve({ status: true });
              }).catch(() => {
                _importResolve({ status: true });
              });
            } else {
              _importResolve({ status: true });
            }
          } else {
            const { tableFullColumn } = internalData;
            $xetable.preventEvent(null, "event.import", { file, options, columns: tableFullColumn }, () => {
              const reader = new FileReader();
              reader.onerror = () => {
                errLog("vxe.error.notType", [type]);
                _importReject({ status: false });
              };
              reader.onload = (e) => {
                handleImport(e.target.result, options);
              };
              reader.readAsText(file, options.encoding || "UTF-8");
            });
          }
        } else {
          if (true) {
            errLog("vxe.error.notExp");
          }
          _importResolve({ status: true });
        }
      });
      return rest.then(() => {
        if (afterImportMethod) {
          afterImportMethod({ status: true, options: opts, $table: $xetable });
        }
      }).catch((e) => {
        if (afterImportMethod) {
          afterImportMethod({ status: false, options: opts, $table: $xetable });
        }
        return Promise.reject(e);
      });
    };
    const handleExportAndPrint = (options, isPrint) => {
      const { treeConfig, showHeader, showFooter } = props;
      const { initStore, mergeList, isGroup, footerTableData, exportStore, exportParams } = reactData;
      const { collectColumn } = internalData;
      const hasTree = treeConfig;
      const customOpts = computeCustomOpts.value;
      const selectRecords = $xetable.getCheckboxRecords();
      const hasFooter = !!footerTableData.length;
      const hasMerge = !hasTree && mergeList.length;
      const defOpts = Object.assign({ message: true, isHeader: showHeader, isFooter: showFooter }, options);
      const types = defOpts.types || VXETable.globalConfs.exportTypes;
      const modes = defOpts.modes;
      const checkMethod = customOpts.checkMethod;
      const exportColumns = collectColumn.slice(0);
      const { columns } = defOpts;
      const typeList = types.map((value) => {
        return {
          value,
          label: `vxe.export.types.${value}`
        };
      });
      const modeList = modes.map((value) => {
        return {
          value,
          label: `vxe.export.modes.${value}`
        };
      });
      import_xe_utils31.default.eachTree(exportColumns, (column, index, items, path, parent) => {
        const isColGroup = column.children && column.children.length;
        if (isColGroup || defaultFilterExportColumn(column)) {
          column.checked = columns ? columns.some((item) => {
            if (isColumnInfo(item)) {
              return column === item;
            } else if (import_xe_utils31.default.isString(item)) {
              return column.field === item;
            } else {
              const colid = item.id || item.colId;
              const type = item.type;
              const field = item.property || item.field;
              if (colid) {
                return column.id === colid;
              } else if (field && type) {
                return column.property === field && column.type === type;
              } else if (field) {
                return column.property === field;
              } else if (type) {
                return column.type === type;
              }
            }
            return false;
          }) : column.visible;
          column.halfChecked = false;
          column.disabled = parent && parent.disabled || (checkMethod ? !checkMethod({ column }) : false);
        }
      });
      Object.assign(exportStore, {
        columns: exportColumns,
        typeList,
        modeList,
        hasFooter,
        hasMerge,
        hasTree,
        isPrint,
        hasColgroup: isGroup,
        visible: true
      });
      Object.assign(exportParams, {
        mode: selectRecords.length ? "selected" : "current"
      }, defOpts);
      if (modes.indexOf(exportParams.mode) === -1) {
        exportParams.mode = modes[0];
      }
      if (types.indexOf(exportParams.type) === -1) {
        exportParams.type = types[0];
      }
      initStore.export = true;
      return nextTick();
    };
    const exportMethods = {
      /**
       * 导出文件，支持 csv/html/xml/txt
       * 如果是树表格，则默认是导出所有节点
       * 如果是启用了虚拟滚动，则只能导出数据源，可以配合 dataFilterMethod 函数自行转换数据
       * @param {Object} options 参数
       */
      exportData(options) {
        const { treeConfig } = props;
        const { isGroup, tableGroupColumn } = reactData;
        const { tableFullColumn, afterFullData } = internalData;
        const exportOpts = computeExportOpts.value;
        const treeOpts = computeTreeOpts.value;
        const opts = Object.assign({
          // filename: '',
          // sheetName: '',
          // original: false,
          // message: false,
          isHeader: true,
          isFooter: true,
          isColgroup: true,
          // isMerge: false,
          // isAllExpand: false,
          download: true,
          type: "csv",
          mode: "current"
          // data: null,
          // remote: false,
          // dataFilterMethod: null,
          // footerFilterMethod: null,
          // exportMethod: null,
          // columnFilterMethod: null,
          // beforeExportMethod: null,
          // afterExportMethod: null
        }, exportOpts, {
          print: false
        }, options);
        const { type, mode, columns, original, beforeExportMethod } = opts;
        let groups = [];
        const customCols = columns && columns.length ? columns : null;
        let columnFilterMethod = opts.columnFilterMethod;
        if (!customCols && !columnFilterMethod) {
          columnFilterMethod = original ? ({ column }) => column.property : ({ column }) => defaultFilterExportColumn(column);
        }
        if (customCols) {
          opts._isCustomColumn = true;
          groups = import_xe_utils31.default.searchTree(import_xe_utils31.default.mapTree(customCols, (item) => {
            let targetColumn;
            if (item) {
              if (isColumnInfo(item)) {
                targetColumn = item;
              } else if (import_xe_utils31.default.isString(item)) {
                targetColumn = $xetable.getColumnByField(item);
              } else {
                const colid = item.id || item.colId;
                const type2 = item.type;
                const field = item.property || item.field;
                if (colid) {
                  targetColumn = $xetable.getColumnById(colid);
                } else if (field && type2) {
                  targetColumn = tableFullColumn.find((column) => column.property === field && column.type === type2);
                } else if (field) {
                  targetColumn = $xetable.getColumnByField(field);
                } else if (type2) {
                  targetColumn = tableFullColumn.find((column) => column.type === type2);
                }
              }
              return targetColumn || {};
            }
          }, {
            children: "childNodes",
            mapChildren: "_children"
          }), (column, index) => isColumnInfo(column) && (!columnFilterMethod || columnFilterMethod({ column, $columnIndex: index })), {
            children: "_children",
            mapChildren: "childNodes",
            original: true
          });
        } else {
          groups = import_xe_utils31.default.searchTree(isGroup ? tableGroupColumn : tableFullColumn, (column, index) => column.visible && (!columnFilterMethod || columnFilterMethod({ column, $columnIndex: index })), { children: "children", mapChildren: "childNodes", original: true });
        }
        const cols = [];
        import_xe_utils31.default.eachTree(groups, (column) => {
          const isColGroup = column.children && column.children.length;
          if (!isColGroup) {
            cols.push(column);
          }
        }, { children: "childNodes" });
        opts.columns = cols;
        opts.colgroups = convertToRows(groups);
        if (!opts.filename) {
          opts.filename = conf_default.i18n(opts.original ? "vxe.table.expOriginFilename" : "vxe.table.expFilename", [import_xe_utils31.default.toDateString(Date.now(), "yyyyMMddHHmmss")]);
        }
        if (!opts.sheetName) {
          opts.sheetName = document.title;
        }
        if (!opts.exportMethod && !import_xe_utils31.default.includes(VXETable.globalConfs.exportTypes, type)) {
          if (true) {
            errLog("vxe.error.notType", [type]);
          }
          const params = { status: false };
          return Promise.reject(params);
        }
        if (!opts.print) {
          if (beforeExportMethod) {
            beforeExportMethod({ options: opts, $table: $xetable, $grid: $xegrid });
          }
        }
        if (!opts.data) {
          opts.data = afterFullData;
          if (mode === "selected") {
            const selectRecords = $xetable.getCheckboxRecords();
            if (["html", "pdf"].indexOf(type) > -1 && treeConfig) {
              opts.data = import_xe_utils31.default.searchTree($xetable.getTableData().fullData, (item) => $xetable.findRowIndexOf(selectRecords, item) > -1, Object.assign({}, treeOpts, { data: "_row" }));
            } else {
              opts.data = selectRecords;
            }
          } else if (mode === "all") {
            if (true) {
              if (!$xegrid) {
                warnLog("vxe.error.errProp", ["all", "mode=current,selected"]);
              }
            }
            if ($xegrid && !opts.remote) {
              const { reactData: gridReactData } = $xegrid;
              const { computeProxyOpts } = $xegrid.getComputeMaps();
              const proxyOpts = computeProxyOpts.value;
              const { beforeQueryAll, afterQueryAll, ajax = {}, props: props2 = {} } = proxyOpts;
              const ajaxMethods = ajax.queryAll;
              if (true) {
                if (!ajaxMethods) {
                  warnLog("vxe.error.notFunc", ["proxy-config.ajax.queryAll"]);
                }
              }
              if (ajaxMethods) {
                const params = {
                  $table: $xetable,
                  $grid: $xegrid,
                  sort: gridReactData.sortData,
                  filters: gridReactData.filterData,
                  form: gridReactData.formData,
                  target: ajaxMethods,
                  options: opts
                };
                return Promise.resolve((beforeQueryAll || ajaxMethods)(params)).catch((e) => e).then((rest) => {
                  opts.data = (props2.list ? import_xe_utils31.default.get(rest, props2.list) : rest) || [];
                  if (afterQueryAll) {
                    afterQueryAll(params);
                  }
                  return handleExport(opts);
                });
              }
            }
          }
        }
        return handleExport(opts);
      },
      importByFile(file, options) {
        const opts = Object.assign({}, options);
        const { beforeImportMethod } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({ options: opts, $table: $xetable });
        }
        return handleFileImport(file, opts);
      },
      importData(options) {
        const importOpts = computeImportOpts.value;
        const opts = Object.assign({
          types: VXETable.globalConfs.importTypes
          // beforeImportMethod: null,
          // afterImportMethod: null
        }, importOpts, options);
        const { beforeImportMethod, afterImportMethod } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({ options: opts, $table: $xetable });
        }
        return readLocalFile(opts).catch((e) => {
          if (afterImportMethod) {
            afterImportMethod({ status: false, options: opts, $table: $xetable });
          }
          return Promise.reject(e);
        }).then((params) => {
          const { file } = params;
          return handleFileImport(file, opts);
        });
      },
      saveFile(options) {
        return saveLocalFile(options);
      },
      readFile(options) {
        return readLocalFile(options);
      },
      print(options) {
        const printOpts = computePrintOpts.value;
        const opts = Object.assign({
          original: false
          // beforePrintMethod
        }, printOpts, options, {
          type: "html",
          download: false,
          remote: false,
          print: true
        });
        if (!opts.sheetName) {
          opts.sheetName = document.title;
        }
        return new Promise((resolve) => {
          if (opts.content) {
            resolve(handlePrint($xetable, opts, opts.content));
          } else {
            resolve(exportMethods.exportData(opts).then(({ content }) => {
              return handlePrint($xetable, opts, content);
            }));
          }
        });
      },
      openImport(options) {
        const { treeConfig, importConfig } = props;
        const { initStore, importStore, importParams } = reactData;
        const importOpts = computeImportOpts.value;
        const defOpts = Object.assign({ mode: "insert", message: true, types: VXETable.globalConfs.importTypes }, options, importOpts);
        const { types } = defOpts;
        const isTree = !!treeConfig;
        if (isTree) {
          if (defOpts.message) {
            VXETable.modal.message({ content: conf_default.i18n("vxe.error.treeNotImp"), status: "error" });
          }
          return;
        }
        if (!importConfig) {
          errLog("vxe.error.reqProp", ["import-config"]);
        }
        const typeList = types.map((value) => {
          return {
            value,
            label: `vxe.export.types.${value}`
          };
        });
        const modeList = defOpts.modes.map((value) => {
          return {
            value,
            label: `vxe.import.modes.${value}`
          };
        });
        Object.assign(importStore, {
          file: null,
          type: "",
          filename: "",
          modeList,
          typeList,
          visible: true
        });
        Object.assign(importParams, defOpts);
        initStore.import = true;
      },
      openExport(options) {
        const exportOpts = computeExportOpts.value;
        if (true) {
          if (!props.exportConfig) {
            errLog("vxe.error.reqProp", ["export-config"]);
          }
        }
        handleExportAndPrint(Object.assign({}, exportOpts, options));
      },
      openPrint(options) {
        const printOpts = computePrintOpts.value;
        if (true) {
          if (!props.printConfig) {
            errLog("vxe.error.reqProp", ["print-config"]);
          }
        }
        handleExportAndPrint(Object.assign({}, printOpts, options), true);
      }
    };
    return exportMethods;
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableExportMethodKeys);
  }
};
var hook_default3 = tableExportHook;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/export/index.js
var print = (options) => {
  const opts = Object.assign({}, options, {
    type: "html"
  });
  handlePrint(null, opts, opts.content);
};
var VxeTableExportModule = {
  ExportPanel: export_panel_default,
  ImportPanel: import_panel_default,
  install(app) {
    VXETable.saveFile = saveLocalFile;
    VXETable.readFile = readLocalFile;
    VXETable.print = print;
    VXETable.setConfig({
      export: {
        types: {
          csv: 0,
          html: 0,
          xml: 0,
          txt: 0
        }
      }
    });
    VXETable.hooks.add("$tableExport", hook_default3);
    app.component(export_panel_default.name, export_panel_default);
    app.component(import_panel_default.name, import_panel_default);
  }
};
var Export = VxeTableExportModule;
dynamicApp.component(export_panel_default.name, export_panel_default);
dynamicApp.component(import_panel_default.name, import_panel_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/keyboard/src/hook.js
var import_xe_utils32 = __toESM(require_xe_utils());
function getTargetOffset(target, container) {
  let offsetTop = 0;
  let offsetLeft = 0;
  const triggerCheckboxLabel = !browse.firefox && hasClass(target, "vxe-checkbox--label");
  if (triggerCheckboxLabel) {
    const checkboxLabelStyle = getComputedStyle(target);
    offsetTop -= import_xe_utils32.default.toNumber(checkboxLabelStyle.paddingTop);
    offsetLeft -= import_xe_utils32.default.toNumber(checkboxLabelStyle.paddingLeft);
  }
  while (target && target !== container) {
    offsetTop += target.offsetTop;
    offsetLeft += target.offsetLeft;
    target = target.offsetParent;
    if (triggerCheckboxLabel) {
      const checkboxStyle = getComputedStyle(target);
      offsetTop -= import_xe_utils32.default.toNumber(checkboxStyle.paddingTop);
      offsetLeft -= import_xe_utils32.default.toNumber(checkboxStyle.paddingLeft);
    }
  }
  return { offsetTop, offsetLeft };
}
var tableKeyboardHook = {
  setupTable($xetable) {
    const { props, reactData, internalData } = $xetable;
    const { refElem } = $xetable.getRefMaps();
    const { computeEditOpts, computeCheckboxOpts, computeMouseOpts, computeTreeOpts } = $xetable.getComputeMaps();
    function getCheckboxRangeRows(params, targetTrElem, moveRange) {
      let countHeight = 0;
      let rangeRows = [];
      const isDown = moveRange > 0;
      const moveSize = moveRange > 0 ? moveRange : Math.abs(moveRange) + targetTrElem.offsetHeight;
      const { scrollYLoad } = reactData;
      const { afterFullData, scrollYStore } = internalData;
      if (scrollYLoad) {
        const _rowIndex = $xetable.getVTRowIndex(params.row);
        if (isDown) {
          rangeRows = afterFullData.slice(_rowIndex, _rowIndex + Math.ceil(moveSize / scrollYStore.rowHeight));
        } else {
          rangeRows = afterFullData.slice(_rowIndex - Math.floor(moveSize / scrollYStore.rowHeight) + 1, _rowIndex + 1);
        }
      } else {
        const siblingProp = isDown ? "next" : "previous";
        while (targetTrElem && countHeight < moveSize) {
          const rowNodeRest = $xetable.getRowNode(targetTrElem);
          if (rowNodeRest) {
            rangeRows.push(rowNodeRest.item);
            countHeight += targetTrElem.offsetHeight;
            targetTrElem = targetTrElem[`${siblingProp}ElementSibling`];
          }
        }
      }
      return rangeRows;
    }
    const handleCheckboxRangeEvent = (evnt, params) => {
      const { column, cell } = params;
      if (column.type === "checkbox") {
        const el = refElem.value;
        const { elemStore } = internalData;
        const disX = evnt.clientX;
        const disY = evnt.clientY;
        const bodyWrapperRef = elemStore[`${column.fixed || "main"}-body-wrapper`] || elemStore["main-body-wrapper"];
        const bodyWrapperElem = bodyWrapperRef ? bodyWrapperRef.value : null;
        if (!bodyWrapperElem) {
          return;
        }
        const checkboxRangeElem = bodyWrapperElem.querySelector(".vxe-table--checkbox-range");
        const domMousemove = document.onmousemove;
        const domMouseup = document.onmouseup;
        const trElem = cell.parentNode;
        const selectRecords = $xetable.getCheckboxRecords();
        let lastRangeRows = [];
        const marginSize = 1;
        const offsetRest = getTargetOffset(evnt.target, bodyWrapperElem);
        const startTop = offsetRest.offsetTop + evnt.offsetY;
        const startLeft = offsetRest.offsetLeft + evnt.offsetX;
        const startScrollTop = bodyWrapperElem.scrollTop;
        const rowHeight = trElem.offsetHeight;
        let mouseScrollTimeout = null;
        let isMouseScrollDown = false;
        let mouseScrollSpaceSize = 1;
        const triggerEvent3 = (type, evnt2) => {
          $xetable.dispatchEvent(`checkbox-range-${type}`, { records: $xetable.getCheckboxRecords(), reserves: $xetable.getCheckboxReserveRecords() }, evnt2);
        };
        const handleChecked = (evnt2) => {
          const { clientX, clientY } = evnt2;
          const offsetLeft = clientX - disX;
          const offsetTop = clientY - disY + (bodyWrapperElem.scrollTop - startScrollTop);
          let rangeHeight = Math.abs(offsetTop);
          let rangeWidth = Math.abs(offsetLeft);
          let rangeTop = startTop;
          let rangeLeft = startLeft;
          if (offsetTop < marginSize) {
            rangeTop += offsetTop;
            if (rangeTop < marginSize) {
              rangeTop = marginSize;
              rangeHeight = startTop;
            }
          } else {
            rangeHeight = Math.min(rangeHeight, bodyWrapperElem.scrollHeight - startTop - marginSize);
          }
          if (offsetLeft < marginSize) {
            rangeLeft += offsetLeft;
            if (rangeWidth > startLeft) {
              rangeLeft = marginSize;
              rangeWidth = startLeft;
            }
          } else {
            rangeWidth = Math.min(rangeWidth, bodyWrapperElem.clientWidth - startLeft - marginSize);
          }
          checkboxRangeElem.style.height = `${rangeHeight}px`;
          checkboxRangeElem.style.width = `${rangeWidth}px`;
          checkboxRangeElem.style.left = `${rangeLeft}px`;
          checkboxRangeElem.style.top = `${rangeTop}px`;
          checkboxRangeElem.style.display = "block";
          const rangeRows = getCheckboxRangeRows(params, trElem, offsetTop < marginSize ? -rangeHeight : rangeHeight);
          if (rangeHeight > 10 && rangeRows.length !== lastRangeRows.length) {
            lastRangeRows = rangeRows;
            if (evnt2.ctrlKey) {
              rangeRows.forEach((row) => {
                $xetable.handleSelectRow({ row }, selectRecords.indexOf(row) === -1);
              });
            } else {
              $xetable.setAllCheckboxRow(false);
              $xetable.handleCheckedCheckboxRow(rangeRows, true, false);
            }
            triggerEvent3("change", evnt2);
          }
        };
        const stopMouseScroll = () => {
          clearTimeout(mouseScrollTimeout);
          mouseScrollTimeout = null;
        };
        const startMouseScroll = (evnt2) => {
          stopMouseScroll();
          mouseScrollTimeout = setTimeout(() => {
            if (mouseScrollTimeout) {
              const { scrollLeft, scrollTop, clientHeight, scrollHeight } = bodyWrapperElem;
              const topSize = Math.ceil(mouseScrollSpaceSize * 50 / rowHeight);
              if (isMouseScrollDown) {
                if (scrollTop + clientHeight < scrollHeight) {
                  $xetable.scrollTo(scrollLeft, scrollTop + topSize);
                  startMouseScroll(evnt2);
                  handleChecked(evnt2);
                } else {
                  stopMouseScroll();
                }
              } else {
                if (scrollTop) {
                  $xetable.scrollTo(scrollLeft, scrollTop - topSize);
                  startMouseScroll(evnt2);
                  handleChecked(evnt2);
                } else {
                  stopMouseScroll();
                }
              }
            }
          }, 50);
        };
        addClass(el, "drag--range");
        document.onmousemove = (evnt2) => {
          evnt2.preventDefault();
          evnt2.stopPropagation();
          const { clientY } = evnt2;
          const { boundingTop } = getAbsolutePos(bodyWrapperElem);
          if (clientY < boundingTop) {
            isMouseScrollDown = false;
            mouseScrollSpaceSize = boundingTop - clientY;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt2);
            }
          } else if (clientY > boundingTop + bodyWrapperElem.clientHeight) {
            isMouseScrollDown = true;
            mouseScrollSpaceSize = clientY - boundingTop - bodyWrapperElem.clientHeight;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt2);
            }
          } else if (mouseScrollTimeout) {
            stopMouseScroll();
          }
          handleChecked(evnt2);
        };
        document.onmouseup = (evnt2) => {
          stopMouseScroll();
          removeClass(el, "drag--range");
          checkboxRangeElem.removeAttribute("style");
          document.onmousemove = domMousemove;
          document.onmouseup = domMouseup;
          triggerEvent3("end", evnt2);
        };
        triggerEvent3("start", evnt);
      }
    };
    const handleCellMousedownEvent = (evnt, params) => {
      const { editConfig, checkboxConfig, mouseConfig } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const editOpts = computeEditOpts.value;
      if (mouseConfig && mouseOpts.area && $xetable.handleCellAreaEvent) {
        return $xetable.handleCellAreaEvent(evnt, params);
      } else {
        if (checkboxConfig && checkboxOpts.range) {
          handleCheckboxRangeEvent(evnt, params);
        }
        if (mouseConfig && mouseOpts.selected) {
          if (!editConfig || editOpts.mode === "cell") {
            $xetable.handleSelected(params, evnt);
          }
        }
      }
    };
    const keyboardMethods = {
      // 处理 Tab 键移动
      moveTabSelected(args, isLeft, evnt) {
        const { editConfig } = props;
        const { afterFullData, visibleColumn } = internalData;
        const editOpts = computeEditOpts.value;
        let targetRow;
        let targetRowIndex;
        let targetColumnIndex;
        const params = Object.assign({}, args);
        const _rowIndex = $xetable.getVTRowIndex(params.row);
        const _columnIndex = $xetable.getVTColumnIndex(params.column);
        evnt.preventDefault();
        if (isLeft) {
          if (_columnIndex <= 0) {
            if (_rowIndex > 0) {
              targetRowIndex = _rowIndex - 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = visibleColumn.length - 1;
            }
          } else {
            targetColumnIndex = _columnIndex - 1;
          }
        } else {
          if (_columnIndex >= visibleColumn.length - 1) {
            if (_rowIndex < afterFullData.length - 1) {
              targetRowIndex = _rowIndex + 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = 0;
            }
          } else {
            targetColumnIndex = _columnIndex + 1;
          }
        }
        const targetColumn = visibleColumn[targetColumnIndex];
        if (targetColumn) {
          if (targetRow) {
            params.rowIndex = targetRowIndex;
            params.row = targetRow;
          } else {
            params.rowIndex = _rowIndex;
          }
          params.columnIndex = targetColumnIndex;
          params.column = targetColumn;
          params.cell = $xetable.getCell(params.row, params.column);
          if (editConfig) {
            if (editOpts.trigger === "click" || editOpts.trigger === "dblclick") {
              if (editOpts.mode === "row") {
                $xetable.handleActived(params, evnt);
              } else {
                $xetable.scrollToRow(params.row, params.column).then(() => $xetable.handleSelected(params, evnt));
              }
            }
          } else {
            $xetable.scrollToRow(params.row, params.column).then(() => $xetable.handleSelected(params, evnt));
          }
        }
      },
      // 处理当前行方向键移动
      moveCurrentRow(isUpArrow, isDwArrow, evnt) {
        const { treeConfig } = props;
        const { currentRow } = reactData;
        const { afterFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let targetRow;
        evnt.preventDefault();
        if (currentRow) {
          if (treeConfig) {
            const { index, items } = import_xe_utils32.default.findTree(afterFullData, (item) => item === currentRow, { children: childrenField });
            if (isUpArrow && index > 0) {
              targetRow = items[index - 1];
            } else if (isDwArrow && index < items.length - 1) {
              targetRow = items[index + 1];
            }
          } else {
            const _rowIndex = $xetable.getVTRowIndex(currentRow);
            if (isUpArrow && _rowIndex > 0) {
              targetRow = afterFullData[_rowIndex - 1];
            } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
              targetRow = afterFullData[_rowIndex + 1];
            }
          }
        } else {
          targetRow = afterFullData[0];
        }
        if (targetRow) {
          const params = {
            $table: $xetable,
            row: targetRow,
            rowIndex: $xetable.getRowIndex(targetRow),
            $rowIndex: $xetable.getVMRowIndex(targetRow)
          };
          $xetable.scrollToRow(targetRow).then(() => $xetable.triggerCurrentRowEvent(evnt, params));
        }
      },
      // 处理可编辑方向键移动
      moveSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        const { afterFullData, visibleColumn } = internalData;
        const params = Object.assign({}, args);
        const _rowIndex = $xetable.getVTRowIndex(params.row);
        const _columnIndex = $xetable.getVTColumnIndex(params.column);
        evnt.preventDefault();
        if (isUpArrow && _rowIndex > 0) {
          params.rowIndex = _rowIndex - 1;
          params.row = afterFullData[params.rowIndex];
        } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
          params.rowIndex = _rowIndex + 1;
          params.row = afterFullData[params.rowIndex];
        } else if (isLeftArrow && _columnIndex) {
          params.columnIndex = _columnIndex - 1;
          params.column = visibleColumn[params.columnIndex];
        } else if (isRightArrow && _columnIndex < visibleColumn.length - 1) {
          params.columnIndex = _columnIndex + 1;
          params.column = visibleColumn[params.columnIndex];
        }
        $xetable.scrollToRow(params.row, params.column).then(() => {
          params.cell = $xetable.getCell(params.row, params.column);
          $xetable.handleSelected(params, evnt);
        });
      },
      /**
       * 表头单元格按下事件
       */
      triggerHeaderCellMousedownEvent(evnt, params) {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        if (mouseConfig && mouseOpts.area && $xetable.handleHeaderCellAreaEvent) {
          const cell = evnt.currentTarget;
          const triggerSort = getEventTargetNode(evnt, cell, "vxe-cell--sort").flag;
          const triggerFilter = getEventTargetNode(evnt, cell, "vxe-cell--filter").flag;
          $xetable.handleHeaderCellAreaEvent(evnt, Object.assign({ cell, triggerSort, triggerFilter }, params));
        }
        $xetable.focus();
        if ($xetable.closeMenu) {
          $xetable.closeMenu();
        }
      },
      /**
       * 单元格按下事件
       */
      triggerCellMousedownEvent(evnt, params) {
        const cell = evnt.currentTarget;
        params.cell = cell;
        handleCellMousedownEvent(evnt, params);
        $xetable.focus();
        $xetable.closeFilter();
        if ($xetable.closeMenu) {
          $xetable.closeMenu();
        }
      }
    };
    return keyboardMethods;
  }
};
var hook_default4 = tableKeyboardHook;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/keyboard/index.js
var VxeTableKeyboardModule = {
  install() {
    VXETable.hooks.add("$tableKeyboard", hook_default4);
  }
};
var Keyboard = VxeTableKeyboardModule;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/validator/src/hook.js
var import_xe_utils33 = __toESM(require_xe_utils());
var Rule = class {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.max,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  /**
   * 获取校验不通过的消息
   * 支持国际化翻译
   */
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
};
var tableValidatorMethodKeys = ["fullValidate", "validate", "clearValidate"];
var validatorHook = {
  setupTable($xetable) {
    const { props, reactData, internalData } = $xetable;
    const { refValidTooltip } = $xetable.getRefMaps();
    const { computeValidOpts, computeTreeOpts, computeEditOpts } = $xetable.getComputeMaps();
    let validatorMethods = {};
    let validatorPrivateMethods = {};
    let validRuleErr;
    const handleValidError = (params) => {
      return new Promise((resolve) => {
        const validOpts = computeValidOpts.value;
        if (validOpts.autoPos === false) {
          $xetable.dispatchEvent("valid-error", params, null);
          resolve();
        } else {
          $xetable.handleActived(params, { type: "valid-error", trigger: "call" }).then(() => {
            resolve(validatorPrivateMethods.showValidTooltip(params));
          });
        }
      });
    };
    const handleErrMsgMode = (validErrMaps) => {
      const validOpts = computeValidOpts.value;
      if (validOpts.msgMode === "single") {
        const keys = Object.keys(validErrMaps);
        const resMaps = validErrMaps;
        if (keys.length) {
          const firstKey = keys[0];
          resMaps[firstKey] = validErrMaps[firstKey];
        }
        return resMaps;
      }
      return validErrMaps;
    };
    const beginValidate = (rows, cb, isFull) => {
      const validRest = {};
      const { editRules, treeConfig } = props;
      const { afterFullData, visibleColumn } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const validOpts = computeValidOpts.value;
      let validList;
      if (rows === true) {
        validList = afterFullData;
      } else if (rows) {
        if (import_xe_utils33.default.isFunction(rows)) {
          cb = rows;
        } else {
          validList = import_xe_utils33.default.isArray(rows) ? rows : [rows];
        }
      }
      if (!validList) {
        if ($xetable.getInsertRecords) {
          validList = $xetable.getInsertRecords().concat($xetable.getUpdateRecords());
        } else {
          validList = [];
        }
      }
      const rowValidErrs = [];
      internalData._lastCallTime = Date.now();
      validRuleErr = false;
      validatorMethods.clearValidate();
      const validErrMaps = {};
      if (editRules) {
        const columns = $xetable.getColumns();
        const handleVaild = (row) => {
          if (isFull || !validRuleErr) {
            const colVailds = [];
            columns.forEach((column) => {
              if ((isFull || !validRuleErr) && import_xe_utils33.default.has(editRules, column.property)) {
                colVailds.push(validatorPrivateMethods.validCellRules("all", row, column).catch(({ rule, rules }) => {
                  const rest = {
                    rule,
                    rules,
                    rowIndex: $xetable.getRowIndex(row),
                    row,
                    columnIndex: $xetable.getColumnIndex(column),
                    column,
                    field: column.property,
                    $table: $xetable
                  };
                  if (!validRest[column.property]) {
                    validRest[column.property] = [];
                  }
                  validErrMaps[`${getRowid($xetable, row)}:${column.id}`] = {
                    column,
                    row,
                    rule,
                    content: rule.content
                  };
                  validRest[column.property].push(rest);
                  if (!isFull) {
                    validRuleErr = true;
                    return Promise.reject(rest);
                  }
                }));
              }
            });
            rowValidErrs.push(Promise.all(colVailds));
          }
        };
        if (treeConfig) {
          import_xe_utils33.default.eachTree(validList, handleVaild, { children: childrenField });
        } else {
          validList.forEach(handleVaild);
        }
        return Promise.all(rowValidErrs).then(() => {
          const ruleProps = Object.keys(validRest);
          reactData.validErrorMaps = handleErrMsgMode(validErrMaps);
          return nextTick().then(() => {
            if (ruleProps.length) {
              return Promise.reject(validRest[ruleProps[0]][0]);
            }
            if (cb) {
              cb();
            }
          });
        }).catch((firstErrParams) => {
          return new Promise((resolve, reject) => {
            const finish = () => {
              nextTick(() => {
                if (cb) {
                  cb(validRest);
                  resolve();
                } else {
                  if (conf_default.validToReject === "obsolete") {
                    reject(validRest);
                  } else {
                    resolve(validRest);
                  }
                }
              });
            };
            const posAndFinish = () => {
              firstErrParams.cell = $xetable.getCell(firstErrParams.row, firstErrParams.column);
              scrollToView(firstErrParams.cell);
              handleValidError(firstErrParams).then(finish);
            };
            if (validOpts.autoPos === false) {
              finish();
            } else {
              const row = firstErrParams.row;
              const column = firstErrParams.column;
              const rowIndex = afterFullData.indexOf(row);
              const columnIndex = visibleColumn.indexOf(column);
              const targetRow = rowIndex > 0 ? afterFullData[rowIndex - 1] : row;
              const targetColumn = columnIndex > 0 ? visibleColumn[columnIndex - 1] : column;
              $xetable.scrollToRow(targetRow, targetColumn).then(posAndFinish);
            }
          });
        });
      } else {
        reactData.validErrorMaps = {};
      }
      return nextTick().then(() => {
        if (cb) {
          cb();
        }
      });
    };
    validatorMethods = {
      /**
       * 完整校验，和 validate 的区别就是会给有效数据中的每一行进行校验
       */
      fullValidate(rows, cb) {
        if (true) {
          if (import_xe_utils33.default.isFunction(cb)) {
            warnLog("vxe.error.notValidators", ["fullValidate(rows, callback)", "fullValidate(rows)"]);
          }
        }
        return beginValidate(rows, cb, true);
      },
      /**
       * 快速校验，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）
       */
      validate(rows, cb) {
        if (true) {
          if (import_xe_utils33.default.isFunction(cb)) {
            warnLog("vxe.error.notValidators", ["validate(rows, callback)", "validate(rows)"]);
          }
        }
        return beginValidate(rows, cb);
      },
      clearValidate(rows, fieldOrColumn) {
        const { validErrorMaps } = reactData;
        const validTip = refValidTooltip.value;
        const validOpts = computeValidOpts.value;
        const rowList = import_xe_utils33.default.isArray(rows) ? rows : rows ? [rows] : [];
        const colList = import_xe_utils33.default.isArray(fieldOrColumn) ? fieldOrColumn : (fieldOrColumn ? [fieldOrColumn] : []).map((column) => handleFieldOrColumn($xetable, column));
        let validErrMaps = {};
        if (validTip && validTip.reactData.visible) {
          validTip.close();
        }
        if (validOpts.msgMode === "single") {
          reactData.validErrorMaps = {};
          return nextTick();
        }
        if (rowList.length && colList.length) {
          validErrMaps = Object.assign({}, validErrorMaps);
          rowList.forEach((row) => {
            colList.forEach((column) => {
              const validKey = `${getRowid($xetable, row)}:${column.id}`;
              if (validErrMaps[validKey]) {
                delete validErrMaps[validKey];
              }
            });
          });
        } else if (rowList.length) {
          const rowIdList = rowList.map((row) => `${getRowid($xetable, row)}`);
          import_xe_utils33.default.each(validErrorMaps, (item, key) => {
            if (rowIdList.indexOf(key.split(":")[0]) > -1) {
              validErrMaps[key] = item;
            }
          });
        } else if (colList.length) {
          const colidList = colList.map((column) => `${column.id}`);
          import_xe_utils33.default.each(validErrorMaps, (item, key) => {
            if (colidList.indexOf(key.split(":")[1]) > -1) {
              validErrMaps[key] = item;
            }
          });
        }
        reactData.validErrorMaps = validErrMaps;
        return nextTick();
      }
    };
    const validErrorRuleValue2 = (rule, val) => {
      const { type, min, max, pattern } = rule;
      const isNumType = type === "number";
      const numVal = isNumType ? import_xe_utils33.default.toNumber(val) : import_xe_utils33.default.getSize(val);
      if (isNumType && isNaN(val)) {
        return true;
      }
      if (!import_xe_utils33.default.eqNull(min) && numVal < import_xe_utils33.default.toNumber(min)) {
        return true;
      }
      if (!import_xe_utils33.default.eqNull(max) && numVal > import_xe_utils33.default.toNumber(max)) {
        return true;
      }
      if (pattern && !(import_xe_utils33.default.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
        return true;
      }
      return false;
    };
    validatorPrivateMethods = {
      /**
       * 校验数据
       * 按表格行、列顺序依次校验（同步或异步）
       * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列
       * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>
       * 如果是传回调方式这返回一个校验不通过列的错误消息
       *
       * rule 配置：
       *  required=Boolean 是否必填
       *  min=Number 最小长度
       *  max=Number 最大长度
       *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise
       *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）
       */
      validCellRules(validType, row, column, val) {
        const { editRules } = props;
        const { field } = column;
        const errorRules = [];
        const syncValidList = [];
        if (field && editRules) {
          const rules = import_xe_utils33.default.get(editRules, field);
          if (rules) {
            const cellValue = import_xe_utils33.default.isUndefined(val) ? import_xe_utils33.default.get(row, field) : val;
            rules.forEach((rule) => {
              const { type, trigger, required, validator } = rule;
              if (validType === "all" || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    cellValue,
                    rule,
                    rules,
                    row,
                    rowIndex: $xetable.getRowIndex(row),
                    column,
                    columnIndex: $xetable.getColumnIndex(column),
                    field: column.field,
                    $table: $xetable,
                    $grid: $xetable.xegrid
                  };
                  let customValid;
                  if (import_xe_utils33.default.isString(validator)) {
                    const gvItem = VXETable.validators.get(validator);
                    if (gvItem) {
                      if (gvItem.cellValidatorMethod) {
                        customValid = gvItem.cellValidatorMethod(validParams);
                      } else {
                        if (true) {
                          warnLog("vxe.error.notValidators", [validator]);
                        }
                      }
                    } else {
                      if (true) {
                        errLog("vxe.error.notValidators", [validator]);
                      }
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (import_xe_utils33.default.isError(customValid)) {
                      validRuleErr = true;
                      errorRules.push(new Rule({ type: "custom", trigger, content: customValid.message, rule: new Rule(rule) }));
                    } else if (customValid.catch) {
                      syncValidList.push(customValid.catch((e) => {
                        validRuleErr = true;
                        errorRules.push(new Rule({ type: "custom", trigger, content: e && e.message ? e.message : rule.content || rule.message, rule: new Rule(rule) }));
                      }));
                    }
                  }
                } else {
                  const isArrType = type === "array";
                  const isArrVal = import_xe_utils33.default.isArray(cellValue);
                  let hasEmpty = true;
                  if (isArrType || isArrVal) {
                    hasEmpty = !isArrVal || !cellValue.length;
                  } else if (import_xe_utils33.default.isString(cellValue)) {
                    hasEmpty = eqEmptyValue(cellValue.trim());
                  } else {
                    hasEmpty = eqEmptyValue(cellValue);
                  }
                  if (required ? hasEmpty || validErrorRuleValue2(rule, cellValue) : !hasEmpty && validErrorRuleValue2(rule, cellValue)) {
                    validRuleErr = true;
                    errorRules.push(new Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncValidList).then(() => {
          if (errorRules.length) {
            const rest = { rules: errorRules, rule: errorRules[0] };
            return Promise.reject(rest);
          }
        });
      },
      hasCellRules(type, row, column) {
        const { editRules } = props;
        const { field } = column;
        if (field && editRules) {
          const rules = import_xe_utils33.default.get(editRules, field);
          return rules && !!import_xe_utils33.default.find(rules, (rule) => type === "all" || !rule.trigger || type === rule.trigger);
        }
        return false;
      },
      /**
       * 触发校验
       */
      triggerValidate(type) {
        const { editConfig, editRules } = props;
        const { editStore } = reactData;
        const { actived } = editStore;
        const editOpts = computeEditOpts.value;
        const validOpts = computeValidOpts.value;
        if (editRules && validOpts.msgMode === "single") {
          reactData.validErrorMaps = {};
        }
        if (editConfig && editRules && actived.row) {
          const { row, column, cell } = actived.args;
          if (validatorPrivateMethods.hasCellRules(type, row, column)) {
            return validatorPrivateMethods.validCellRules(type, row, column).then(() => {
              if (editOpts.mode === "row") {
                validatorMethods.clearValidate(row, column);
              }
            }).catch(({ rule }) => {
              if (!rule.trigger || type === rule.trigger) {
                const rest = { rule, row, column, cell };
                validatorPrivateMethods.showValidTooltip(rest);
                return Promise.reject(rest);
              }
              return Promise.resolve();
            });
          }
        }
        return Promise.resolve();
      },
      /**
       * 弹出校验错误提示
       */
      showValidTooltip(params) {
        const { height } = props;
        const { tableData, validStore, validErrorMaps } = reactData;
        const { rule, row, column, cell } = params;
        const validOpts = computeValidOpts.value;
        const validTip = refValidTooltip.value;
        const content = rule.content;
        validStore.visible = true;
        if (validOpts.msgMode === "single") {
          reactData.validErrorMaps = {
            [`${getRowid($xetable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          };
        } else {
          reactData.validErrorMaps = Object.assign({}, validErrorMaps, {
            [`${getRowid($xetable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          });
        }
        $xetable.dispatchEvent("valid-error", params, null);
        if (validTip) {
          if (validTip && (validOpts.message === "tooltip" || validOpts.message === "default" && !height && tableData.length < 2)) {
            return validTip.open(cell, content);
          }
        }
        return nextTick();
      }
    };
    return Object.assign(Object.assign({}, validatorMethods), validatorPrivateMethods);
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableValidatorMethodKeys);
  }
};
var hook_default5 = validatorHook;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/validator/index.js
var VxeTableValidatorModule = {
  install() {
    VXETable.hooks.add("$tableValidator", hook_default5);
  }
};
var Validator = VxeTableValidatorModule;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/tooltip/src/tooltip.js
var import_xe_utils34 = __toESM(require_xe_utils());
var tooltip_default = defineComponent({
  name: "VxeTooltip",
  props: {
    modelValue: Boolean,
    size: { type: String, default: () => conf_default.tooltip.size || conf_default.size },
    trigger: { type: String, default: () => conf_default.tooltip.trigger || "hover" },
    theme: { type: String, default: () => conf_default.tooltip.theme || "dark" },
    content: { type: [String, Number], default: null },
    useHTML: Boolean,
    zIndex: [String, Number],
    popupClassName: [String, Function],
    isArrow: { type: Boolean, default: true },
    enterable: Boolean,
    enterDelay: { type: Number, default: () => conf_default.tooltip.enterDelay },
    leaveDelay: { type: Number, default: () => conf_default.tooltip.leaveDelay }
  },
  emits: [
    "update:modelValue"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils34.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      target: null,
      isUpdate: false,
      visible: false,
      tipContent: "",
      tipActive: false,
      tipTarget: null,
      tipZindex: 0,
      tipStore: {
        style: {},
        placement: "",
        arrowStyle: {}
      }
    });
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xetooltip = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let tooltipMethods = {};
    const updateTipStyle = () => {
      const { tipTarget, tipStore } = reactData;
      if (tipTarget) {
        const { scrollTop, scrollLeft, visibleWidth } = getDomNode();
        const { top, left } = getAbsolutePos(tipTarget);
        const el = refElem.value;
        const marginSize = 6;
        const offsetHeight = el.offsetHeight;
        const offsetWidth = el.offsetWidth;
        let tipLeft = left;
        let tipTop = top - offsetHeight - marginSize;
        tipLeft = Math.max(marginSize, left + Math.floor((tipTarget.offsetWidth - offsetWidth) / 2));
        if (tipLeft + offsetWidth + marginSize > scrollLeft + visibleWidth) {
          tipLeft = scrollLeft + visibleWidth - offsetWidth - marginSize;
        }
        if (top - offsetHeight < scrollTop + marginSize) {
          tipStore.placement = "bottom";
          tipTop = top + tipTarget.offsetHeight + marginSize;
        }
        tipStore.style.top = `${tipTop}px`;
        tipStore.style.left = `${tipLeft}px`;
        tipStore.arrowStyle.left = `${left - tipLeft + tipTarget.offsetWidth / 2}px`;
      }
    };
    const updateValue = (value) => {
      if (value !== reactData.visible) {
        reactData.visible = value;
        reactData.isUpdate = true;
        emit("update:modelValue", value);
      }
    };
    const updateZindex = () => {
      if (reactData.tipZindex < getLastZIndex()) {
        reactData.tipZindex = nextZIndex();
      }
    };
    const clickEvent = () => {
      if (reactData.visible) {
        tooltipMethods.close();
      } else {
        tooltipMethods.open();
      }
    };
    const targetMouseenterEvent = () => {
      tooltipMethods.open();
    };
    const targetMouseleaveEvent = () => {
      const { trigger, enterable, leaveDelay } = props;
      reactData.tipActive = false;
      if (enterable && trigger === "hover") {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      } else {
        tooltipMethods.close();
      }
    };
    const wrapperMouseenterEvent = () => {
      reactData.tipActive = true;
    };
    const wrapperMouseleaveEvent = () => {
      const { trigger, enterable, leaveDelay } = props;
      reactData.tipActive = false;
      if (enterable && trigger === "hover") {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      }
    };
    const showTip = () => {
      const { tipStore } = reactData;
      const el = refElem.value;
      if (el) {
        const parentNode = el.parentNode;
        if (!parentNode) {
          document.body.appendChild(el);
        }
      }
      updateValue(true);
      updateZindex();
      tipStore.placement = "top";
      tipStore.style = { width: "auto", left: 0, top: 0, zIndex: props.zIndex || reactData.tipZindex };
      tipStore.arrowStyle = { left: "50%" };
      return tooltipMethods.updatePlacement();
    };
    const showDelayTip = import_xe_utils34.default.debounce(() => {
      if (reactData.tipActive) {
        showTip();
      }
    }, props.enterDelay, { leading: false, trailing: true });
    tooltipMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $tooltip: $xetooltip, $event: evnt }, params));
      },
      open(target, content) {
        return tooltipMethods.toVisible(target || reactData.target, content);
      },
      close() {
        reactData.tipTarget = null;
        reactData.tipActive = false;
        Object.assign(reactData.tipStore, {
          style: {},
          placement: "",
          arrowStyle: null
        });
        updateValue(false);
        return nextTick();
      },
      toVisible(target, content) {
        if (target) {
          const { trigger, enterDelay } = props;
          reactData.tipActive = true;
          reactData.tipTarget = target;
          if (content) {
            reactData.tipContent = content;
          }
          if (enterDelay && trigger === "hover") {
            showDelayTip();
          } else {
            return showTip();
          }
        }
        return nextTick();
      },
      updatePlacement() {
        return nextTick().then(() => {
          const { tipTarget } = reactData;
          const el = refElem.value;
          if (tipTarget && el) {
            updateTipStyle();
            return nextTick().then(updateTipStyle);
          }
        });
      },
      isActived() {
        return reactData.tipActive;
      },
      setActived(actived) {
        reactData.tipActive = !!actived;
      }
    };
    Object.assign($xetooltip, tooltipMethods);
    watch(() => props.content, () => {
      reactData.tipContent = props.content;
    });
    watch(() => props.modelValue, () => {
      if (!reactData.isUpdate) {
        if (props.modelValue) {
          tooltipMethods.open();
        } else {
          tooltipMethods.close();
        }
      }
      reactData.isUpdate = false;
    });
    onMounted(() => {
      nextTick(() => {
        const { trigger, content, modelValue } = props;
        const wrapperElem = refElem.value;
        if (wrapperElem) {
          const parentNode = wrapperElem.parentNode;
          if (parentNode) {
            reactData.tipContent = content;
            reactData.tipZindex = nextZIndex();
            import_xe_utils34.default.arrayEach(wrapperElem.children, (elem, index) => {
              if (index > 1) {
                parentNode.insertBefore(elem, wrapperElem);
                if (!reactData.target) {
                  reactData.target = elem;
                }
              }
            });
            parentNode.removeChild(wrapperElem);
            const { target } = reactData;
            if (target) {
              if (trigger === "hover") {
                target.onmouseenter = targetMouseenterEvent;
                target.onmouseleave = targetMouseleaveEvent;
              } else if (trigger === "click") {
                target.onclick = clickEvent;
              }
            }
            if (modelValue) {
              tooltipMethods.open();
            }
          }
        }
      });
    });
    onBeforeUnmount(() => {
      const { trigger } = props;
      const { target } = reactData;
      const wrapperElem = refElem.value;
      if (target) {
        if (trigger === "hover") {
          target.onmouseenter = null;
          target.onmouseleave = null;
        } else if (trigger === "click") {
          target.onclick = null;
        }
      }
      if (wrapperElem) {
        const parentNode = wrapperElem.parentNode;
        if (parentNode) {
          parentNode.removeChild(wrapperElem);
        }
      }
    });
    const renderContent = () => {
      const { useHTML } = props;
      const { tipContent } = reactData;
      const contentSlot = slots.content;
      if (contentSlot) {
        return h("div", {
          key: 1,
          class: "vxe-table--tooltip-content"
        }, getSlotVNs(contentSlot({})));
      }
      if (useHTML) {
        return h("div", {
          key: 2,
          class: "vxe-table--tooltip-content",
          innerHTML: tipContent
        });
      }
      return h("div", {
        key: 3,
        class: "vxe-table--tooltip-content"
      }, formatText(tipContent));
    };
    const renderVN = () => {
      const { popupClassName, theme, isArrow, enterable } = props;
      const { tipActive, visible, tipStore } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      let ons;
      if (enterable) {
        ons = {
          onMouseenter: wrapperMouseenterEvent,
          onMouseleave: wrapperMouseleaveEvent
        };
      }
      return h("div", Object.assign({ ref: refElem, class: ["vxe-table--tooltip-wrapper", `theme--${theme}`, popupClassName ? import_xe_utils34.default.isFunction(popupClassName) ? popupClassName({ $tooltip: $xetooltip }) : popupClassName : "", {
        [`size--${vSize}`]: vSize,
        [`placement--${tipStore.placement}`]: tipStore.placement,
        "is--enterable": enterable,
        "is--visible": visible,
        "is--arrow": isArrow,
        "is--active": tipActive
      }], style: tipStore.style }, ons), [
        renderContent(),
        h("div", {
          class: "vxe-table--tooltip-arrow",
          style: tipStore.arrowStyle
        }),
        ...defaultSlot ? getSlotVNs(defaultSlot({})) : []
      ]);
    };
    $xetooltip.renderVN = renderVN;
    return $xetooltip;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/custom/src/panel.js
var import_xe_utils35 = __toESM(require_xe_utils());
var panel_default3 = defineComponent({
  name: "VxeTableCustomPanel",
  props: {
    customStore: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props) {
    const $xetable = inject("$xetable", {});
    const { reactData } = $xetable;
    const { computeCustomOpts, computeColumnOpts, computeIsMaxFixedColumn } = $xetable.getComputeMaps();
    const refElem = ref();
    const bodyElemRef = ref();
    const dragHintElemRef = ref();
    const dragColumn = ref();
    let prevDropTrEl;
    const handleWrapperMouseenterEvent = (evnt) => {
      const { customStore } = props;
      customStore.activeWrapper = true;
      $xetable.customOpenEvent(evnt);
    };
    const handleWrapperMouseleaveEvent = (evnt) => {
      const { customStore } = props;
      customStore.activeWrapper = false;
      setTimeout(() => {
        if (!customStore.activeBtn && !customStore.activeWrapper) {
          $xetable.customColseEvent(evnt);
        }
      }, 300);
    };
    const confirmCustomEvent = (evnt) => {
      updateColumnSort();
      $xetable.closeCustom();
      $xetable.emitCustomEvent("confirm", evnt);
    };
    const cancelCustomEvent = (evnt) => {
      $xetable.closeCustom();
      $xetable.emitCustomEvent("cancel", evnt);
    };
    const resetCustomEvent = (evnt) => {
      $xetable.resetColumn(true);
      $xetable.closeCustom();
      $xetable.emitCustomEvent("reset", evnt);
    };
    const resetPopupCustomEvent = (evnt) => {
      if (VXETable.modal) {
        VXETable.modal.confirm({
          content: conf_default.i18n("vxe.custom.cstmConfirmRestore"),
          className: "vxe-table--ignore-clear",
          escClosable: true
        }).then((type) => {
          if (type === "confirm") {
            resetCustomEvent(evnt);
          }
        });
      } else {
        resetCustomEvent(evnt);
      }
    };
    const handleOptionCheck = (column) => {
      const { customColumnList } = reactData;
      const matchObj = import_xe_utils35.default.findTree(customColumnList, (item) => item === column);
      if (matchObj && matchObj.parent) {
        const { parent } = matchObj;
        if (parent.children && parent.children.length) {
          parent.visible = parent.children.every((column2) => column2.visible);
          parent.halfVisible = !parent.visible && parent.children.some((column2) => column2.visible || column2.halfVisible);
          handleOptionCheck(parent);
        }
      }
    };
    const changeCheckboxOption = (column) => {
      const isChecked = !column.visible;
      const customOpts = computeCustomOpts.value;
      import_xe_utils35.default.eachTree([column], (item) => {
        item.visible = isChecked;
        item.halfVisible = false;
      });
      handleOptionCheck(column);
      if (customOpts.immediate) {
        $xetable.handleCustom();
      }
      $xetable.checkCustomStatus();
    };
    const changeFixedOption = (column, colFixed) => {
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      if (column.fixed === colFixed) {
        $xetable.clearColumnFixed(column);
      } else {
        if (!isMaxFixedColumn || column.fixed) {
          $xetable.setColumnFixed(column, colFixed);
        }
      }
    };
    const changePopupFixedOption = (column) => {
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      if (!isMaxFixedColumn) {
        $xetable.setColumnFixed(column, column.fixed);
      }
    };
    const allCustomEvent = () => {
      const { customStore } = props;
      const { customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { checkMethod } = customOpts;
      const isAll = !customStore.isAll;
      import_xe_utils35.default.eachTree(customColumnList, (column) => {
        if (!checkMethod || checkMethod({ column })) {
          column.visible = isAll;
          column.halfVisible = false;
        }
      });
      customStore.isAll = isAll;
      $xetable.checkCustomStatus();
    };
    const sortMousedownEvent = (evnt) => {
      const btnEl = evnt.currentTarget;
      const tdEl = btnEl.parentNode;
      const trEl = tdEl.parentNode;
      const colid = trEl.getAttribute("colid");
      const column = $xetable.getColumnById(colid);
      trEl.draggable = true;
      dragColumn.value = column;
      addClass(trEl, "active--drag-origin");
    };
    const sortMouseupEvent = (evnt) => {
      const btnEl = evnt.currentTarget;
      const tdEl = btnEl.parentNode;
      const trEl = tdEl.parentNode;
      const dragHintEl = dragHintElemRef.value;
      trEl.draggable = false;
      dragColumn.value = null;
      removeClass(trEl, "active--drag-origin");
      if (dragHintEl) {
        dragHintEl.style.display = "";
      }
    };
    const sortDragstartEvent = (evnt) => {
      const img = new Image();
      if (evnt.dataTransfer) {
        evnt.dataTransfer.setDragImage(img, 0, 0);
      }
    };
    const updateColumnSort = () => {
      const { customColumnList } = reactData;
      customColumnList.forEach((column, index) => {
        const sortIndex = index + 1;
        column.renderSortNumber = sortIndex;
      });
    };
    const sortDragendEvent = (evnt) => {
      const { customColumnList } = reactData;
      const trEl = evnt.currentTarget;
      const dragHintEl = dragHintElemRef.value;
      if (prevDropTrEl) {
        if (prevDropTrEl !== trEl) {
          const dragOffset = prevDropTrEl.getAttribute("drag-pos");
          const colid = trEl.getAttribute("colid");
          const column = $xetable.getColumnById(colid);
          if (!column) {
            return;
          }
          const cIndex = import_xe_utils35.default.findIndexOf(customColumnList, (item) => item.id === column.id);
          const targetColid = prevDropTrEl.getAttribute("colid");
          const targetColumn = $xetable.getColumnById(targetColid);
          if (!targetColumn) {
            return;
          }
          customColumnList.splice(cIndex, 1);
          const tcIndex = import_xe_utils35.default.findIndexOf(customColumnList, (item) => item.id === targetColumn.id);
          customColumnList.splice(tcIndex + (dragOffset === "bottom" ? 1 : 0), 0, column);
        }
        prevDropTrEl.draggable = false;
        prevDropTrEl.removeAttribute("drag-pos");
        removeClass(prevDropTrEl, "active--drag-target");
      }
      dragColumn.value = null;
      trEl.draggable = false;
      trEl.removeAttribute("drag-pos");
      if (dragHintEl) {
        dragHintEl.style.display = "";
      }
      removeClass(trEl, "active--drag-target");
      removeClass(trEl, "active--drag-origin");
      updateColumnSort();
    };
    const sortDragoverEvent = (evnt) => {
      const trEl = evnt.currentTarget;
      if (prevDropTrEl !== trEl) {
        removeClass(prevDropTrEl, "active--drag-target");
      }
      const colid = trEl.getAttribute("colid");
      const column = $xetable.getColumnById(colid);
      if (column && column.level === 1) {
        evnt.preventDefault();
        const offsetY = evnt.clientY - trEl.getBoundingClientRect().y;
        const dragOffset = offsetY < trEl.clientHeight / 2 ? "top" : "bottom";
        addClass(trEl, "active--drag-target");
        trEl.setAttribute("drag-pos", dragOffset);
        prevDropTrEl = trEl;
      }
      updateDropHint(evnt);
    };
    const updateDropHint = (evnt) => {
      const dragHintEl = dragHintElemRef.value;
      const bodyEl2 = bodyElemRef.value;
      if (!bodyEl2) {
        return;
      }
      if (dragHintEl) {
        const wrapperEl = bodyEl2.parentNode;
        const wrapperRect = wrapperEl.getBoundingClientRect();
        dragHintEl.style.display = "block";
        dragHintEl.style.top = `${Math.min(wrapperEl.clientHeight - wrapperEl.scrollTop - dragHintEl.clientHeight, evnt.clientY - wrapperRect.y)}px`;
        dragHintEl.style.left = `${Math.min(wrapperEl.clientWidth - wrapperEl.scrollLeft - dragHintEl.clientWidth - 16, evnt.clientX - wrapperRect.x)}px`;
      }
    };
    const renderSimplePanel = () => {
      const { customStore } = props;
      const { customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { maxHeight } = customStore;
      const { checkMethod, visibleMethod, trigger } = customOpts;
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const colVNs = [];
      const customWrapperOns = {};
      if (trigger === "hover") {
        customWrapperOns.onMouseenter = handleWrapperMouseenterEvent;
        customWrapperOns.onMouseleave = handleWrapperMouseleaveEvent;
      }
      import_xe_utils35.default.eachTree(customColumnList, (column, index, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({ column }) : true;
        if (isVisible) {
          const isChecked = column.visible;
          const isIndeterminate = column.halfVisible;
          const isColGroup = column.children && column.children.length;
          const colTitle = formatText(column.getTitle(), 1);
          const isDisabled = checkMethod ? !checkMethod({ column }) : false;
          colVNs.push(h("li", {
            key: column.id,
            class: ["vxe-table-custom--option", `level--${column.level}`, {
              "is--group": isColGroup
            }]
          }, [
            h("div", {
              title: colTitle,
              class: ["vxe-table-custom--checkbox-option", {
                "is--checked": isChecked,
                "is--indeterminate": isIndeterminate,
                "is--disabled": isDisabled
              }],
              onClick: () => {
                if (!isDisabled) {
                  changeCheckboxOption(column);
                }
              }
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isIndeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
              }),
              h("span", {
                class: "vxe-checkbox--label"
              }, colTitle)
            ]),
            !parent && customOpts.allowFixed ? h("div", {
              class: "vxe-table-custom--fixed-option"
            }, [
              h("span", {
                class: ["vxe-table-custom--fixed-left-option", column.fixed === "left" ? conf_default.icon.TOOLBAR_TOOLS_FIXED_LEFT_ACTIVED : conf_default.icon.TOOLBAR_TOOLS_FIXED_LEFT, {
                  "is--checked": column.fixed === "left",
                  "is--disabled": isMaxFixedColumn && !column.fixed
                }],
                title: conf_default.i18n(column.fixed === "left" ? "vxe.toolbar.cancelFixed" : "vxe.toolbar.fixedLeft"),
                onClick: () => {
                  changeFixedOption(column, "left");
                }
              }),
              h("span", {
                class: ["vxe-table-custom--fixed-right-option", column.fixed === "right" ? conf_default.icon.TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVED : conf_default.icon.TOOLBAR_TOOLS_FIXED_RIGHT, {
                  "is--checked": column.fixed === "right",
                  "is--disabled": isMaxFixedColumn && !column.fixed
                }],
                title: conf_default.i18n(column.fixed === "right" ? "vxe.toolbar.cancelFixed" : "vxe.toolbar.fixedRight"),
                onClick: () => {
                  changeFixedOption(column, "right");
                }
              })
            ]) : null
          ]));
        }
      });
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      return h("div", {
        ref: refElem,
        key: "simple",
        class: ["vxe-table-custom-wrapper", {
          "is--active": customStore.visible
        }]
      }, [
        h("ul", {
          class: "vxe-table-custom--header"
        }, [
          h("li", {
            class: "vxe-table-custom--option"
          }, [
            h("div", {
              class: ["vxe-table-custom--checkbox-option", {
                "is--checked": isAllChecked,
                "is--indeterminate": isAllIndeterminate
              }],
              title: conf_default.i18n("vxe.table.allTitle"),
              onClick: allCustomEvent
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isAllIndeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
              }),
              h("span", {
                class: "vxe-checkbox--label"
              }, conf_default.i18n("vxe.toolbar.customAll"))
            ])
          ])
        ]),
        h("ul", Object.assign({ class: "vxe-table-custom--body", style: maxHeight ? {
          maxHeight: `${maxHeight}px`
        } : {} }, customWrapperOns), colVNs),
        customOpts.showFooter ? h("div", {
          class: "vxe-table-custom--footer"
        }, [
          h("button", {
            class: "btn--reset",
            onClick: resetCustomEvent
          }, customOpts.resetButtonText || conf_default.i18n("vxe.toolbar.customRestore")),
          h("button", {
            class: "btn--confirm",
            onClick: confirmCustomEvent
          }, customOpts.confirmButtonText || conf_default.i18n("vxe.toolbar.customConfirm"))
        ]) : null
      ]);
    };
    const renderPopupPanel = () => {
      const { customStore } = props;
      const { customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { checkMethod, visibleMethod } = customOpts;
      const columnOpts = computeColumnOpts.value;
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const trVNs = [];
      import_xe_utils35.default.eachTree(customColumnList, (column, index, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({ column }) : true;
        if (isVisible) {
          const isChecked = column.visible;
          const isIndeterminate = column.halfVisible;
          const colTitle = formatText(column.getTitle(), 1);
          const isColGroup = column.children && column.children.length;
          const isDisabled = checkMethod ? !checkMethod({ column }) : false;
          trVNs.push(h("tr", {
            key: column.id,
            colid: column.id,
            class: [`vxe-table-custom-popup--row level--${column.level}`, {
              "is--group": isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [
            h("td", {
              class: "vxe-table-custom-popup--column-item col--sort"
            }, [
              column.level === 1 ? h("span", {
                class: "vxe-table-custom-popup--column-sort-btn",
                onMousedown: sortMousedownEvent,
                onMouseup: sortMouseupEvent
              }, [
                h("i", {
                  class: "vxe-icon-sort"
                })
              ]) : null
            ]),
            h("td", {
              class: "vxe-table-custom-popup--column-item col--name"
            }, [
              h("div", {
                class: "vxe-table-custom-popup--name",
                title: colTitle
              }, colTitle)
            ]),
            h("td", {
              class: "vxe-table-custom-popup--column-item col--visible"
            }, [
              h("div", {
                class: ["vxe-table-custom--checkbox-option", {
                  "is--checked": isChecked,
                  "is--indeterminate": isIndeterminate,
                  "is--disabled": isDisabled
                }],
                onClick: () => {
                  if (!isDisabled) {
                    changeCheckboxOption(column);
                  }
                }
              }, [
                h("span", {
                  class: ["vxe-checkbox--icon", isIndeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
                })
              ])
            ]),
            h("td", {
              class: "vxe-table-custom-popup--column-item col--fixed"
            }, [
              !parent && customOpts.allowFixed ? h(group_default, {
                modelValue: column.fixed || "",
                type: "button",
                size: "mini",
                options: [
                  { label: conf_default.i18n("vxe.custom.setting.fixedLeft"), value: "left", disabled: isMaxFixedColumn },
                  { label: conf_default.i18n("vxe.custom.setting.fixedUnset"), value: "" },
                  { label: conf_default.i18n("vxe.custom.setting.fixedRight"), value: "right", disabled: isMaxFixedColumn }
                ],
                "onUpdate:modelValue"(value) {
                  column.fixed = value;
                },
                onChange() {
                  changePopupFixedOption(column);
                }
              }) : null
            ])
          ]));
        }
      });
      return h(modal_default, {
        key: "popup",
        className: "vxe-table-custom-popup-wrapper vxe-table--ignore-clear",
        modelValue: customStore.visible,
        title: conf_default.i18n("vxe.custom.cstmTitle"),
        width: "40vw",
        minWidth: 520,
        height: "50vh",
        minHeight: 300,
        mask: true,
        lockView: true,
        showFooter: true,
        resize: true,
        escClosable: true,
        destroyOnClose: true,
        "onUpdate:modelValue"(value) {
          customStore.visible = value;
        }
      }, {
        default: () => {
          return h("div", {
            ref: bodyElemRef,
            class: "vxe-table-custom-popup--body"
          }, [
            h("div", {
              class: "vxe-table-custom-popup--table-wrapper"
            }, [
              h("table", {}, [
                h("colgroup", {}, [
                  h("col", {
                    style: {
                      width: "80px"
                    }
                  }),
                  h("col", {}),
                  h("col", {
                    style: {
                      width: "80px"
                    }
                  }),
                  h("col", {
                    style: {
                      width: "200px"
                    }
                  })
                ]),
                h("thead", {}, [
                  h("tr", {}, [
                    h("th", {}, [
                      h("span", {
                        class: "vxe-table-custom-popup--table-sort-help-title"
                      }, conf_default.i18n("vxe.custom.setting.colSort")),
                      h(tooltip_default, {
                        enterable: true,
                        content: conf_default.i18n("vxe.custom.setting.sortHelpTip")
                      }, {
                        default: () => {
                          return h("i", {
                            class: "vxe-table-custom-popup--table-sort-help-icon vxe-icon-question-circle-fill"
                          });
                        }
                      })
                    ]),
                    h("th", {}, conf_default.i18n("vxe.custom.setting.colTitle")),
                    h("th", {}, conf_default.i18n("vxe.custom.setting.colVisible")),
                    h("th", {}, conf_default.i18n("vxe.custom.setting.colFixed", [columnOpts.maxFixedSize || 0]))
                  ])
                ]),
                h(TransitionGroup, {
                  class: "vxe-table-custom--body",
                  tag: "tbody",
                  name: "vxe-table-custom--list"
                }, {
                  default: () => trVNs
                })
              ])
            ]),
            h("div", {
              ref: dragHintElemRef,
              class: "vxe-table-custom-popup--drag-hint"
            }, conf_default.i18n("vxe.custom.cstmDragTarget", [dragColumn.value ? dragColumn.value.getTitle() : ""]))
          ]);
        },
        footer: () => {
          return h("div", {
            class: "vxe-table-custom-popup--footer"
          }, [
            h(button_default, {
              content: customOpts.resetButtonText || conf_default.i18n("vxe.custom.cstmRestore"),
              onClick: resetPopupCustomEvent
            }),
            h(button_default, {
              content: customOpts.resetButtonText || conf_default.i18n("vxe.custom.cstmCancel"),
              onClick: cancelCustomEvent
            }),
            h(button_default, {
              status: "primary",
              content: customOpts.confirmButtonText || conf_default.i18n("vxe.custom.cstmConfirm"),
              onClick: confirmCustomEvent
            })
          ]);
        }
      });
    };
    const renderVN = () => {
      const customOpts = computeCustomOpts.value;
      if (customOpts.mode === "popup") {
        return renderPopupPanel();
      }
      return renderSimplePanel();
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/custom/src/hook.js
var tableCustomMethodKeys = ["openCustom", "closeCustom"];
var customHook = {
  setupTable($xetable) {
    const { reactData, internalData } = $xetable;
    const { computeCustomOpts } = $xetable.getComputeMaps();
    const { refTableHeader, refTableBody, refTableCustom } = $xetable.getRefMaps();
    const $xegrid = $xetable.xegrid;
    const calcMaxHeight = () => {
      const { customStore } = reactData;
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableCustom = refTableCustom.value;
      const customWrapperElem = tableCustom ? tableCustom.$el : null;
      const headElem = tableHeader.$el;
      const bodyElem = tableBody.$el;
      let tableHeight = 0;
      if (headElem) {
        tableHeight += headElem.clientHeight;
      }
      if (bodyElem) {
        tableHeight += bodyElem.clientHeight;
      }
      customStore.maxHeight = Math.max(0, customWrapperElem ? Math.min(customWrapperElem.clientHeight, tableHeight - 80) : 0);
    };
    const openCustom = () => {
      const { initStore, customStore } = reactData;
      customStore.visible = true;
      initStore.custom = true;
      reactData.customColumnList = internalData.collectColumn.slice(0);
      checkCustomStatus();
      calcMaxHeight();
      return nextTick().then(() => calcMaxHeight());
    };
    const closeCustom = () => {
      const { customStore } = reactData;
      const customOpts = computeCustomOpts.value;
      if (customStore.visible) {
        customStore.visible = false;
        if (!customOpts.immediate) {
          $xetable.handleCustom();
        }
      }
      return nextTick();
    };
    const customMethods = {
      openCustom,
      closeCustom
    };
    const checkCustomStatus = () => {
      const { customStore } = reactData;
      const { collectColumn } = internalData;
      const customOpts = computeCustomOpts.value;
      const { checkMethod } = customOpts;
      customStore.isAll = collectColumn.every((column) => (checkMethod ? !checkMethod({ column }) : false) || column.visible);
      customStore.isIndeterminate = !customStore.isAll && collectColumn.some((column) => (!checkMethod || checkMethod({ column })) && (column.visible || column.halfVisible));
    };
    const emitCustomEvent = (type, evnt) => {
      const comp = $xegrid || $xetable;
      comp.dispatchEvent("custom", { type }, evnt);
    };
    const customPrivateMethods = {
      checkCustomStatus,
      emitCustomEvent,
      triggerCustomEvent(evnt) {
        const { customStore } = $xetable.reactData;
        if (customStore.visible) {
          closeCustom();
          emitCustomEvent("close", evnt);
        } else {
          customStore.btnEl = evnt.target;
          openCustom();
          emitCustomEvent("open", evnt);
        }
      },
      customOpenEvent(evnt) {
        const { customStore } = reactData;
        if (!customStore.visible) {
          customStore.activeBtn = true;
          customStore.btnEl = evnt.target;
          $xetable.openCustom();
          $xetable.emitCustomEvent("open", evnt);
        }
      },
      customColseEvent(evnt) {
        const { customStore } = reactData;
        if (customStore.visible) {
          customStore.activeBtn = false;
          $xetable.closeCustom();
          $xetable.emitCustomEvent("close", evnt);
        }
      }
    };
    return Object.assign(Object.assign({}, customMethods), customPrivateMethods);
  },
  setupGrid($xegrid) {
    return $xegrid.extendTableMethods(tableCustomMethodKeys);
  }
};
var hook_default6 = customHook;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/custom/index.js
var VxeTableCustomModule = {
  Panel: panel_default3,
  install(app) {
    VXETable.hooks.add("$tableCustom", hook_default6);
    app.component(panel_default3.name, panel_default3);
  }
};
var Custom = VxeTableCustomModule;
dynamicApp.component(panel_default3.name, panel_default3);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/icon/src/icon.js
var icon_default = defineComponent({
  name: "VxeIcon",
  props: {
    name: String,
    roll: Boolean,
    status: String
  },
  emits: [
    "click"
  ],
  setup(props, { emit }) {
    const clickEvent = (evnt) => {
      emit("click", { $event: evnt });
    };
    return () => {
      const { name, roll, status } = props;
      return h("i", {
        class: [`vxe-icon-${name}`, roll ? "roll" : "", status ? [`theme--${status}`] : ""],
        onClick: clickEvent
      });
    };
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/icon/index.js
var VxeIcon = Object.assign(icon_default, {
  install(app) {
    app.component(icon_default.name, icon_default);
  }
});
var Icon = VxeIcon;
dynamicApp.component(VxeIcon.name, VxeIcon);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/cell.js
var import_xe_utils36 = __toESM(require_xe_utils());
function renderTitlePrefixIcon(params) {
  const { $table, column } = params;
  const titlePrefix = column.titlePrefix || column.titleHelp;
  return titlePrefix ? [
    h("i", {
      class: ["vxe-cell-title-prefix-icon", titlePrefix.icon || conf_default.icon.TABLE_TITLE_PREFIX],
      onMouseenter(evnt) {
        $table.triggerHeaderTitleEvent(evnt, titlePrefix, params);
      },
      onMouseleave(evnt) {
        $table.handleTargetLeaveEvent(evnt);
      }
    })
  ] : [];
}
function renderTitleSuffixIcon(params) {
  const { $table, column } = params;
  const titleSuffix = column.titleSuffix;
  return titleSuffix ? [
    h("i", {
      class: ["vxe-cell-title-suffix-icon", titleSuffix.icon || conf_default.icon.TABLE_TITLE_SUFFIX],
      onMouseenter(evnt) {
        $table.triggerHeaderTitleEvent(evnt, titleSuffix, params);
      },
      onMouseleave(evnt) {
        $table.handleTargetLeaveEvent(evnt);
      }
    })
  ] : [];
}
function renderTitleContent(params, content) {
  const { $table, column } = params;
  const { props, reactData } = $table;
  const { computeTooltipOpts } = $table.getComputeMaps();
  const { showHeaderOverflow: allColumnHeaderOverflow } = props;
  const { type, showHeaderOverflow } = column;
  const tooltipOpts = computeTooltipOpts.value;
  const showAllTip = tooltipOpts.showAll;
  const headOverflow = import_xe_utils36.default.isUndefined(showHeaderOverflow) || import_xe_utils36.default.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  const showTitle = headOverflow === "title";
  const showTooltip = headOverflow === true || headOverflow === "tooltip";
  const ons = {};
  if (showTitle || showTooltip || showAllTip) {
    ons.onMouseenter = (evnt) => {
      if (reactData._isResize) {
        return;
      }
      if (showTitle) {
        updateCellTitle(evnt.currentTarget, column);
      } else if (showTooltip || showAllTip) {
        $table.triggerHeaderTooltipEvent(evnt, params);
      }
    };
  }
  if (showTooltip || showAllTip) {
    ons.onMouseleave = (evnt) => {
      if (reactData._isResize) {
        return;
      }
      if (showTooltip || showAllTip) {
        $table.handleTargetLeaveEvent(evnt);
      }
    };
  }
  return [
    type === "html" && import_xe_utils36.default.isString(content) ? h("span", Object.assign({ class: "vxe-cell--title", innerHTML: content }, ons)) : h("span", Object.assign({ class: "vxe-cell--title" }, ons), getSlotVNs(content))
  ];
}
function getFooterContent(params) {
  const { $table, column, _columnIndex, items, row } = params;
  const { slots, editRender, cellRender } = column;
  const renderOpts = editRender || cellRender;
  const footerSlot = slots ? slots.footer : null;
  if (footerSlot) {
    return $table.callSlot(footerSlot, params);
  }
  if (renderOpts) {
    const compConf = VXETable.renderer.get(renderOpts.name);
    if (compConf && compConf.renderFooter) {
      return getSlotVNs(compConf.renderFooter(renderOpts, params));
    }
  }
  if (import_xe_utils36.default.isArray(items)) {
    return [formatText(items[_columnIndex], 1)];
  }
  return [formatText(import_xe_utils36.default.get(row, column.field), 1)];
}
function getDefaultCellLabel(params) {
  const { $table, row, column } = params;
  return formatText($table.getCellLabel(row, column), 1);
}
var Cell = {
  createColumn($xetable, columnOpts) {
    const { type, sortable, filters, editRender, treeNode } = columnOpts;
    const { props } = $xetable;
    const { editConfig } = props;
    const { computeEditOpts, computeCheckboxOpts } = $xetable.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const editOpts = computeEditOpts.value;
    const renConfs = {
      renderHeader: Cell.renderDefaultHeader,
      renderCell: treeNode ? Cell.renderTreeCell : Cell.renderDefaultCell,
      renderFooter: Cell.renderDefaultFooter
    };
    switch (type) {
      case "seq":
        renConfs.renderHeader = Cell.renderSeqHeader;
        renConfs.renderCell = treeNode ? Cell.renderTreeIndexCell : Cell.renderSeqCell;
        break;
      case "radio":
        renConfs.renderHeader = Cell.renderRadioHeader;
        renConfs.renderCell = treeNode ? Cell.renderTreeRadioCell : Cell.renderRadioCell;
        break;
      case "checkbox":
        renConfs.renderHeader = Cell.renderCheckboxHeader;
        renConfs.renderCell = checkboxOpts.checkField ? treeNode ? Cell.renderTreeSelectionCellByProp : Cell.renderCheckboxCellByProp : treeNode ? Cell.renderTreeSelectionCell : Cell.renderCheckboxCell;
        break;
      case "expand":
        renConfs.renderCell = Cell.renderExpandCell;
        renConfs.renderData = Cell.renderExpandData;
        break;
      case "html":
        renConfs.renderCell = treeNode ? Cell.renderTreeHTMLCell : Cell.renderHTMLCell;
        if (filters && sortable) {
          renConfs.renderHeader = Cell.renderSortAndFilterHeader;
        } else if (sortable) {
          renConfs.renderHeader = Cell.renderSortHeader;
        } else if (filters) {
          renConfs.renderHeader = Cell.renderFilterHeader;
        }
        break;
      default:
        if (editConfig && editRender) {
          renConfs.renderHeader = Cell.renderEditHeader;
          renConfs.renderCell = editOpts.mode === "cell" ? treeNode ? Cell.renderTreeCellEdit : Cell.renderCellEdit : treeNode ? Cell.renderTreeRowEdit : Cell.renderRowEdit;
        } else if (filters && sortable) {
          renConfs.renderHeader = Cell.renderSortAndFilterHeader;
        } else if (sortable) {
          renConfs.renderHeader = Cell.renderSortHeader;
        } else if (filters) {
          renConfs.renderHeader = Cell.renderFilterHeader;
        }
    }
    return createColumn($xetable, columnOpts, renConfs);
  },
  /**
   * 单元格
   */
  renderHeaderTitle(params) {
    const { $table, column } = params;
    const { slots, editRender, cellRender } = column;
    const renderOpts = editRender || cellRender;
    const headerSlot = slots ? slots.header : null;
    if (headerSlot) {
      return renderTitleContent(params, $table.callSlot(headerSlot, params));
    }
    if (renderOpts) {
      const compConf = VXETable.renderer.get(renderOpts.name);
      if (compConf && compConf.renderHeader) {
        return renderTitleContent(params, getSlotVNs(compConf.renderHeader(renderOpts, params)));
      }
    }
    return renderTitleContent(params, formatText(column.getTitle(), 1));
  },
  renderDefaultHeader(params) {
    return renderTitlePrefixIcon(params).concat(Cell.renderHeaderTitle(params)).concat(renderTitleSuffixIcon(params));
  },
  renderDefaultCell(params) {
    const { $table, row, column } = params;
    const { slots, editRender, cellRender } = column;
    const renderOpts = editRender || cellRender;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return $table.callSlot(defaultSlot, params);
    }
    if (renderOpts) {
      const funName = editRender ? "renderCell" : "renderDefault";
      const compConf = VXETable.renderer.get(renderOpts.name);
      const compFn = compConf ? compConf[funName] : null;
      if (compFn) {
        return getSlotVNs(compFn(renderOpts, Object.assign({ $type: editRender ? "edit" : "cell" }, params)));
      }
    }
    const cellValue = $table.getCellLabel(row, column);
    const cellPlaceholder = editRender ? editRender.placeholder : "";
    return [
      h("span", {
        class: "vxe-cell--label"
      }, editRender && eqEmptyValue(cellValue) ? [
        // 如果设置占位符
        h("span", {
          class: "vxe-cell--placeholder"
        }, formatText(getFuncText(cellPlaceholder), 1))
      ] : formatText(cellValue, 1))
    ];
  },
  renderTreeCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderDefaultCell(params));
  },
  renderDefaultFooter(params) {
    return [
      h("span", {
        class: "vxe-cell--item"
      }, getFooterContent(params))
    ];
  },
  /**
   * 树节点
   */
  renderTreeIcon(params, cellVNodes) {
    const { $table, isHidden } = params;
    const { reactData } = $table;
    const { computeTreeOpts } = $table.getComputeMaps();
    const { treeExpandedMaps, treeExpandLazyLoadedMaps } = reactData;
    const treeOpts = computeTreeOpts.value;
    const { row, column, level } = params;
    const { slots } = column;
    const { indent, lazy, trigger, iconLoaded, showIcon, iconOpen, iconClose } = treeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
    const rowChilds = row[childrenField];
    const iconSlot = slots ? slots.icon : null;
    let hasLazyChilds = false;
    let isAceived = false;
    let isLazyLoaded = false;
    const ons = {};
    if (iconSlot) {
      return $table.callSlot(iconSlot, params);
    }
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isAceived = !!treeExpandedMaps[rowid];
      if (lazy) {
        isLazyLoaded = !!treeExpandLazyLoadedMaps[rowid];
        hasLazyChilds = row[hasChildField];
      }
    }
    if (!trigger || trigger === "default") {
      ons.onClick = (evnt) => {
        evnt.stopPropagation();
        $table.triggerTreeExpandEvent(evnt, params);
      };
    }
    return [
      h("div", {
        class: ["vxe-cell--tree-node", {
          "is--active": isAceived
        }],
        style: {
          paddingLeft: `${level * indent}px`
        }
      }, [
        showIcon && (rowChilds && rowChilds.length || hasLazyChilds) ? [
          h("div", Object.assign({ class: "vxe-tree--btn-wrapper" }, ons), [
            h("i", {
              class: ["vxe-tree--node-btn", isLazyLoaded ? iconLoaded || conf_default.icon.TABLE_TREE_LOADED : isAceived ? iconOpen || conf_default.icon.TABLE_TREE_OPEN : iconClose || conf_default.icon.TABLE_TREE_CLOSE]
            })
          ])
        ] : null,
        h("div", {
          class: "vxe-tree-cell"
        }, cellVNodes)
      ])
    ];
  },
  /**
   * 索引
   */
  renderSeqHeader(params) {
    const { $table, column } = params;
    const { slots } = column;
    const headerSlot = slots ? slots.header : null;
    return renderTitleContent(params, headerSlot ? $table.callSlot(headerSlot, params) : formatText(column.getTitle(), 1));
  },
  renderSeqCell(params) {
    const { $table, column } = params;
    const { props } = $table;
    const { treeConfig } = props;
    const { computeSeqOpts } = $table.getComputeMaps();
    const seqOpts = computeSeqOpts.value;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return $table.callSlot(defaultSlot, params);
    }
    const { seq } = params;
    const seqMethod = seqOpts.seqMethod;
    return [formatText(seqMethod ? seqMethod(params) : treeConfig ? seq : (seqOpts.startIndex || 0) + seq, 1)];
  },
  renderTreeIndexCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderSeqCell(params));
  },
  /**
   * 单选
   */
  renderRadioHeader(params) {
    const { $table, column } = params;
    const { slots } = column;
    const headerSlot = slots ? slots.header : null;
    const titleSlot = slots ? slots.title : null;
    return renderTitleContent(params, headerSlot ? $table.callSlot(headerSlot, params) : [
      h("span", {
        class: "vxe-radio--label"
      }, titleSlot ? $table.callSlot(titleSlot, params) : formatText(column.getTitle(), 1))
    ]);
  },
  renderRadioCell(params) {
    const { $table, column, isHidden } = params;
    const { reactData } = $table;
    const { computeRadioOpts } = $table.getComputeMaps();
    const { selectRadioRow } = reactData;
    const radioOpts = computeRadioOpts.value;
    const { slots } = column;
    const { labelField, checkMethod, visibleMethod } = radioOpts;
    const { row } = params;
    const defaultSlot = slots ? slots.default : null;
    const radioSlot = slots ? slots.radio : null;
    const isChecked = $table.eqRow(row, selectRadioRow);
    const isVisible = !visibleMethod || visibleMethod({ row });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            evnt.stopPropagation();
            $table.triggerRadioRowEvent(evnt, params);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({ row });
      }
    }
    const radioParams = Object.assign(Object.assign({}, params), { checked: isChecked, disabled: isDisabled, visible: isVisible });
    if (radioSlot) {
      return $table.callSlot(radioSlot, radioParams);
    }
    const radioVNs = [];
    if (isVisible) {
      radioVNs.push(h("span", {
        class: ["vxe-radio--icon", isChecked ? conf_default.icon.TABLE_RADIO_CHECKED : conf_default.icon.TABLE_RADIO_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      radioVNs.push(h("span", {
        class: "vxe-radio--label"
      }, defaultSlot ? $table.callSlot(defaultSlot, radioParams) : import_xe_utils36.default.get(row, labelField)));
    }
    return [
      h("span", Object.assign({ class: ["vxe-cell--radio", {
        "is--checked": isChecked,
        "is--disabled": isDisabled
      }] }, ons), radioVNs)
    ];
  },
  renderTreeRadioCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderRadioCell(params));
  },
  /**
   * 多选
   */
  renderCheckboxHeader(params) {
    const { $table, column, isHidden } = params;
    const { reactData } = $table;
    const { computeIsAllCheckboxDisabled, computeCheckboxOpts } = $table.getComputeMaps();
    const { isAllSelected: isAllCheckboxSelected, isIndeterminate: isAllCheckboxIndeterminate } = reactData;
    const isAllCheckboxDisabled = computeIsAllCheckboxDisabled.value;
    const { slots } = column;
    const headerSlot = slots ? slots.header : null;
    const titleSlot = slots ? slots.title : null;
    const checkboxOpts = computeCheckboxOpts.value;
    const headerTitle = column.getTitle();
    let ons;
    if (!isHidden) {
      ons = {
        onClick(evnt) {
          if (!isAllCheckboxDisabled) {
            evnt.stopPropagation();
            $table.triggerCheckAllEvent(evnt, !isAllCheckboxSelected);
          }
        }
      };
    }
    const checkboxParams = Object.assign(Object.assign({}, params), { checked: isAllCheckboxSelected, disabled: isAllCheckboxDisabled, indeterminate: isAllCheckboxIndeterminate });
    if (headerSlot) {
      return renderTitleContent(checkboxParams, $table.callSlot(headerSlot, checkboxParams));
    }
    if (checkboxOpts.checkStrictly ? !checkboxOpts.showHeader : checkboxOpts.showHeader === false) {
      return renderTitleContent(checkboxParams, [
        h("span", {
          class: "vxe-checkbox--label"
        }, titleSlot ? $table.callSlot(titleSlot, checkboxParams) : headerTitle)
      ]);
    }
    return renderTitleContent(checkboxParams, [
      h("span", Object.assign({ class: ["vxe-cell--checkbox", {
        "is--checked": isAllCheckboxSelected,
        "is--disabled": isAllCheckboxDisabled,
        "is--indeterminate": isAllCheckboxIndeterminate
      }], title: conf_default.i18n("vxe.table.allTitle") }, ons), [
        h("span", {
          class: ["vxe-checkbox--icon", isAllCheckboxIndeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isAllCheckboxSelected ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
        })
      ].concat(titleSlot || headerTitle ? [
        h("span", {
          class: "vxe-checkbox--label"
        }, titleSlot ? $table.callSlot(titleSlot, checkboxParams) : headerTitle)
      ] : []))
    ]);
  },
  renderCheckboxCell(params) {
    const { $table, row, column, isHidden } = params;
    const { props, reactData } = $table;
    const { treeConfig } = props;
    const { selectCheckboxMaps, treeIndeterminateMaps } = reactData;
    const { computeCheckboxOpts } = $table.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const { labelField, checkMethod, visibleMethod } = checkboxOpts;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    const checkboxSlot = slots ? slots.checkbox : null;
    let indeterminate = false;
    let isChecked = false;
    const isVisible = !visibleMethod || visibleMethod({ row });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isChecked = !!selectCheckboxMaps[rowid];
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            evnt.stopPropagation();
            $table.triggerCheckRowEvent(evnt, params, !isChecked);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({ row });
      }
      if (treeConfig) {
        indeterminate = !!treeIndeterminateMaps[rowid];
      }
    }
    const checkboxParams = Object.assign(Object.assign({}, params), { checked: isChecked, disabled: isDisabled, visible: isVisible, indeterminate });
    if (checkboxSlot) {
      return $table.callSlot(checkboxSlot, checkboxParams);
    }
    const checkVNs = [];
    if (isVisible) {
      checkVNs.push(h("span", {
        class: ["vxe-checkbox--icon", indeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      checkVNs.push(h("span", {
        class: "vxe-checkbox--label"
      }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams) : import_xe_utils36.default.get(row, labelField)));
    }
    return [
      h("span", Object.assign({ class: ["vxe-cell--checkbox", {
        "is--checked": isChecked,
        "is--disabled": isDisabled,
        "is--indeterminate": indeterminate,
        "is--hidden": !isVisible
      }] }, ons), checkVNs)
    ];
  },
  renderTreeSelectionCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderCheckboxCell(params));
  },
  renderCheckboxCellByProp(params) {
    const { $table, row, column, isHidden } = params;
    const { props, reactData } = $table;
    const { treeConfig } = props;
    const { treeIndeterminateMaps } = reactData;
    const { computeCheckboxOpts } = $table.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const { labelField, checkField, checkMethod, visibleMethod } = checkboxOpts;
    const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    const checkboxSlot = slots ? slots.checkbox : null;
    let isIndeterminate = false;
    let isChecked = false;
    const isVisible = !visibleMethod || visibleMethod({ row });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isChecked = import_xe_utils36.default.get(row, checkField);
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            evnt.stopPropagation();
            $table.triggerCheckRowEvent(evnt, params, !isChecked);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({ row });
      }
      if (treeConfig) {
        isIndeterminate = !!treeIndeterminateMaps[rowid];
      }
    }
    const checkboxParams = Object.assign(Object.assign({}, params), { checked: isChecked, disabled: isDisabled, visible: isVisible, indeterminate: isIndeterminate });
    if (checkboxSlot) {
      return $table.callSlot(checkboxSlot, checkboxParams);
    }
    const checkVNs = [];
    if (isVisible) {
      checkVNs.push(h("span", {
        class: ["vxe-checkbox--icon", isIndeterminate ? conf_default.icon.TABLE_CHECKBOX_INDETERMINATE : isChecked ? conf_default.icon.TABLE_CHECKBOX_CHECKED : conf_default.icon.TABLE_CHECKBOX_UNCHECKED]
      }));
      if (defaultSlot || labelField) {
        checkVNs.push(h("span", {
          class: "vxe-checkbox--label"
        }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams) : import_xe_utils36.default.get(row, labelField)));
      }
    }
    return [
      h("span", Object.assign({ class: ["vxe-cell--checkbox", {
        "is--checked": isChecked,
        "is--disabled": isDisabled,
        "is--indeterminate": indeterminateField && !isChecked ? row[indeterminateField] : isIndeterminate,
        "is--hidden": !isVisible
      }] }, ons), checkVNs)
    ];
  },
  renderTreeSelectionCellByProp(params) {
    return Cell.renderTreeIcon(params, Cell.renderCheckboxCellByProp(params));
  },
  /**
   * 展开行
   */
  renderExpandCell(params) {
    const { $table, isHidden, row, column } = params;
    const { reactData } = $table;
    const { rowExpandedMaps, rowExpandLazyLoadedMaps } = reactData;
    const { computeExpandOpts } = $table.getComputeMaps();
    const expandOpts = computeExpandOpts.value;
    const { lazy, labelField, iconLoaded, showIcon, iconOpen, iconClose, visibleMethod } = expandOpts;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    const iconSlot = slots ? slots.icon : null;
    let isAceived = false;
    let isLazyLoaded = false;
    if (iconSlot) {
      return $table.callSlot(iconSlot, params);
    }
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isAceived = !!rowExpandedMaps[rowid];
      if (lazy) {
        isLazyLoaded = !!rowExpandLazyLoadedMaps[rowid];
      }
    }
    return [
      showIcon && (!visibleMethod || visibleMethod(params)) ? h("span", {
        class: ["vxe-table--expanded", {
          "is--active": isAceived
        }],
        onClick(evnt) {
          evnt.stopPropagation();
          $table.triggerRowExpandEvent(evnt, params);
        }
      }, [
        h("i", {
          class: ["vxe-table--expand-btn", isLazyLoaded ? iconLoaded || conf_default.icon.TABLE_EXPAND_LOADED : isAceived ? iconOpen || conf_default.icon.TABLE_EXPAND_OPEN : iconClose || conf_default.icon.TABLE_EXPAND_CLOSE]
        })
      ]) : null,
      defaultSlot || labelField ? h("span", {
        class: "vxe-table--expand-label"
      }, defaultSlot ? $table.callSlot(defaultSlot, params) : import_xe_utils36.default.get(row, labelField)) : null
    ];
  },
  renderExpandData(params) {
    const { $table, column } = params;
    const { slots, contentRender } = column;
    const contentSlot = slots ? slots.content : null;
    if (contentSlot) {
      return $table.callSlot(contentSlot, params);
    }
    if (contentRender) {
      const compConf = VXETable.renderer.get(contentRender.name);
      if (compConf && compConf.renderExpand) {
        return getSlotVNs(compConf.renderExpand(contentRender, params));
      }
    }
    return [];
  },
  /**
   * HTML 标签
   */
  renderHTMLCell(params) {
    const { $table, column } = params;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return $table.callSlot(defaultSlot, params);
    }
    return [
      h("span", {
        class: "vxe-cell--html",
        innerHTML: getDefaultCellLabel(params)
      })
    ];
  },
  renderTreeHTMLCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderHTMLCell(params));
  },
  /**
   * 排序和筛选
   */
  renderSortAndFilterHeader(params) {
    return Cell.renderDefaultHeader(params).concat(Cell.renderSortIcon(params)).concat(Cell.renderFilterIcon(params));
  },
  /**
   * 排序
   */
  renderSortHeader(params) {
    return Cell.renderDefaultHeader(params).concat(Cell.renderSortIcon(params));
  },
  renderSortIcon(params) {
    const { $table, column } = params;
    const { computeSortOpts } = $table.getComputeMaps();
    const sortOpts = computeSortOpts.value;
    const { showIcon, iconLayout, iconAsc, iconDesc } = sortOpts;
    const { order } = column;
    if (showIcon) {
      return [
        h("span", {
          class: ["vxe-cell--sort", `vxe-cell--sort-${iconLayout}-layout`]
        }, [
          h("i", {
            class: ["vxe-sort--asc-btn", iconAsc || conf_default.icon.TABLE_SORT_ASC, {
              "sort--active": order === "asc"
            }],
            title: conf_default.i18n("vxe.table.sortAsc"),
            onClick(evnt) {
              evnt.stopPropagation();
              $table.triggerSortEvent(evnt, column, "asc");
            }
          }),
          h("i", {
            class: ["vxe-sort--desc-btn", iconDesc || conf_default.icon.TABLE_SORT_DESC, {
              "sort--active": order === "desc"
            }],
            title: conf_default.i18n("vxe.table.sortDesc"),
            onClick(evnt) {
              evnt.stopPropagation();
              $table.triggerSortEvent(evnt, column, "desc");
            }
          })
        ])
      ];
    }
    return [];
  },
  /**
   * 筛选
   */
  renderFilterHeader(params) {
    return Cell.renderDefaultHeader(params).concat(Cell.renderFilterIcon(params));
  },
  renderFilterIcon(params) {
    const { $table, column, hasFilter } = params;
    const { reactData } = $table;
    const { filterStore } = reactData;
    const { computeFilterOpts } = $table.getComputeMaps();
    const filterOpts = computeFilterOpts.value;
    const { showIcon, iconNone, iconMatch } = filterOpts;
    return showIcon ? [
      h("span", {
        class: ["vxe-cell--filter", {
          "is--active": filterStore.visible && filterStore.column === column
        }]
      }, [
        h("i", {
          class: ["vxe-filter--btn", hasFilter ? iconMatch || conf_default.icon.TABLE_FILTER_MATCH : iconNone || conf_default.icon.TABLE_FILTER_NONE],
          title: conf_default.i18n("vxe.table.filter"),
          onClick(evnt) {
            if ($table.triggerFilterEvent) {
              $table.triggerFilterEvent(evnt, params.column, params);
            }
          }
        })
      ])
    ] : [];
  },
  /**
   * 可编辑
   */
  renderEditHeader(params) {
    const { $table, column } = params;
    const { props } = $table;
    const { computeEditOpts } = $table.getComputeMaps();
    const { editConfig, editRules } = props;
    const editOpts = computeEditOpts.value;
    const { sortable, filters, editRender } = column;
    let isRequired = false;
    if (editRules) {
      const columnRules = import_xe_utils36.default.get(editRules, column.field);
      if (columnRules) {
        isRequired = columnRules.some((rule) => rule.required);
      }
    }
    return (isEnableConf(editConfig) ? [
      isRequired && editOpts.showAsterisk ? h("i", {
        class: "vxe-cell--required-icon"
      }) : null,
      isEnableConf(editRender) && editOpts.showIcon ? h("i", {
        class: ["vxe-cell--edit-icon", editOpts.icon || conf_default.icon.TABLE_EDIT]
      }) : null
    ] : []).concat(Cell.renderDefaultHeader(params)).concat(sortable ? Cell.renderSortIcon(params) : []).concat(filters ? Cell.renderFilterIcon(params) : []);
  },
  // 行格编辑模式
  renderRowEdit(params) {
    const { $table, column } = params;
    const { reactData } = $table;
    const { editStore } = reactData;
    const { actived } = editStore;
    const { editRender } = column;
    return Cell.runRenderer(params, isEnableConf(editRender) && actived && actived.row === params.row);
  },
  renderTreeRowEdit(params) {
    return Cell.renderTreeIcon(params, Cell.renderRowEdit(params));
  },
  // 单元格编辑模式
  renderCellEdit(params) {
    const { $table, column } = params;
    const { reactData } = $table;
    const { editStore } = reactData;
    const { actived } = editStore;
    const { editRender } = column;
    return Cell.runRenderer(params, isEnableConf(editRender) && actived && actived.row === params.row && actived.column === params.column);
  },
  renderTreeCellEdit(params) {
    return Cell.renderTreeIcon(params, Cell.renderCellEdit(params));
  },
  runRenderer(params, isEdit) {
    const { $table, column } = params;
    const { slots, editRender, formatter } = column;
    const defaultSlot = slots ? slots.default : null;
    const editSlot = slots ? slots.edit : null;
    const compConf = VXETable.renderer.get(editRender.name);
    if (isEdit) {
      if (editSlot) {
        return $table.callSlot(editSlot, params);
      }
      if (compConf && compConf.renderEdit) {
        return getSlotVNs(compConf.renderEdit(editRender, Object.assign({ $type: "edit" }, params)));
      }
      return [];
    }
    if (defaultSlot) {
      return $table.callSlot(defaultSlot, params);
    }
    if (formatter) {
      return [
        h("span", {
          class: "vxe-cell--label"
        }, getDefaultCellLabel(params))
      ];
    }
    return Cell.renderDefaultCell(params);
  }
};
var cell_default = Cell;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/column.js
var columnProps = {
  // 列唯一主键
  colId: [String, Number],
  // 渲染类型 index,radio,checkbox,expand,html
  type: String,
  // 列字段名
  field: String,
  // 列标题
  title: String,
  // 列宽度
  width: [Number, String],
  // 列最小宽度，把剩余宽度按比例分配
  minWidth: [Number, String],
  // 列最大宽度
  maxWidth: [Number, String],
  // 是否允许拖动列宽调整大小
  resizable: { type: Boolean, default: null },
  // 将列固定在左侧或者右侧
  fixed: String,
  // 列对其方式
  align: String,
  // 表头对齐方式
  headerAlign: String,
  // 表尾列的对齐方式
  footerAlign: String,
  // 当内容过长时显示为省略号
  showOverflow: { type: [Boolean, String], default: null },
  // 当表头内容过长时显示为省略号
  showHeaderOverflow: { type: [Boolean, String], default: null },
  // 当表尾内容过长时显示为省略号
  showFooterOverflow: { type: [Boolean, String], default: null },
  // 给单元格附加 className
  className: [String, Function],
  // 给表头单元格附加 className
  headerClassName: [String, Function],
  // 给表尾单元格附加 className
  footerClassName: [String, Function],
  // 格式化显示内容
  formatter: [Function, Array, String],
  // 是否允许排序
  sortable: Boolean,
  // 自定义排序的属性
  sortBy: [String, Function],
  // 排序的字段类型，比如字符串转数值等
  sortType: String,
  // 配置筛选条件数组
  filters: { type: Array, default: null },
  // 筛选是否允许多选
  filterMultiple: { type: Boolean, default: true },
  // 自定义筛选方法
  filterMethod: Function,
  // 筛选重置方法
  filterResetMethod: Function,
  // 筛选复原方法
  filterRecoverMethod: Function,
  // 筛选模板配置项
  filterRender: Object,
  // 指定为树节点
  treeNode: Boolean,
  // 是否可视
  visible: { type: Boolean, default: null },
  // 表头单元格数据导出方法
  headerExportMethod: Function,
  // 单元格数据导出方法
  exportMethod: Function,
  // 表尾单元格数据导出方法
  footerExportMethod: Function,
  // 已废弃，被 titlePrefix 替换
  titleHelp: Object,
  // 标题前缀图标配置项
  titlePrefix: Object,
  // 标题后缀图标配置项
  titleSuffix: Object,
  // 单元格值类型
  cellType: String,
  // 单元格渲染配置项
  cellRender: Object,
  // 单元格编辑渲染配置项
  editRender: Object,
  // 内容渲染配置项
  contentRender: Object,
  // 额外的参数
  params: Object
};
var column_default = defineComponent({
  name: "VxeColumn",
  props: columnProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xetable = inject("$xetable", {});
    const colgroup = inject("xecolgroup", null);
    const column = cell_default.createColumn($xetable, props);
    column.slots = slots;
    provide("$xegrid", null);
    watchColumn($xetable, props, column);
    onMounted(() => {
      assemColumn($xetable, refElem.value, column, colgroup);
    });
    onUnmounted(() => {
      destroyColumn($xetable, column);
    });
    const renderVN = () => {
      return h("div", {
        ref: refElem
      });
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/column/index.js
var VxeColumn = Object.assign(column_default, {
  install(app) {
    app.component(column_default.name, column_default);
    app.component("VxeTableColumn", column_default);
  }
});
var Column = VxeColumn;
dynamicApp.component(column_default.name, column_default);
dynamicApp.component("VxeTableColumn", column_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/group.js
var group_default2 = defineComponent({
  name: "VxeColgroup",
  props: columnProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xetable = inject("$xetable", {});
    const colgroup = inject("xecolgroup", null);
    const column = cell_default.createColumn($xetable, props);
    const columnSlots = {};
    if (slots.header) {
      columnSlots.header = slots.header;
    }
    const xecolumn = { column };
    column.slots = columnSlots;
    column.children = [];
    provide("xecolgroup", xecolumn);
    provide("$xegrid", null);
    watchColumn($xetable, props, column);
    onMounted(() => {
      assemColumn($xetable, refElem.value, column, colgroup);
    });
    onUnmounted(() => {
      destroyColumn($xetable, column);
    });
    const renderVN = () => {
      return h("div", {
        ref: refElem
      }, slots.default ? slots.default() : []);
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/colgroup/index.js
var VxeColgroup = Object.assign(group_default2, {
  install(app) {
    app.component(group_default2.name, group_default2);
    app.component("VxeTableColgroup", group_default2);
  }
});
var Colgroup = VxeColgroup;
dynamicApp.component(group_default2.name, group_default2);
dynamicApp.component("VxeTableColgroup", group_default2);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/grid/src/grid.js
var import_xe_utils48 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/table.js
var import_xe_utils41 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/tools/resize.js
var import_xe_utils37 = __toESM(require_xe_utils());
var resizeTimeout;
var eventStore2 = [];
var defaultInterval = 500;
function eventHandle() {
  if (eventStore2.length) {
    eventStore2.forEach((item) => {
      item.tarList.forEach((observer) => {
        const { target, width, heighe } = observer;
        const clientWidth = target.clientWidth;
        const clientHeight = target.clientHeight;
        const rWidth = clientWidth && width !== clientWidth;
        const rHeight = clientHeight && heighe !== clientHeight;
        if (rWidth || rHeight) {
          observer.width = clientWidth;
          observer.heighe = clientHeight;
          setTimeout(item.callback);
        }
      });
    });
    eventListener();
  }
}
function eventListener() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(eventHandle, conf_default.resizeInterval || defaultInterval);
}
var XEResizeObserver = class {
  constructor(callback) {
    Object.defineProperty(this, "tarList", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "callback", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.callback = callback;
  }
  observe(target) {
    if (target) {
      const { tarList } = this;
      if (!tarList.some((observer) => observer.target === target)) {
        tarList.push({
          target,
          width: target.clientWidth,
          heighe: target.clientHeight
        });
      }
      if (!eventStore2.length) {
        eventListener();
      }
      if (!eventStore2.some((item) => item === this)) {
        eventStore2.push(this);
      }
    }
  }
  unobserve(target) {
    import_xe_utils37.default.remove(eventStore2, (item) => item.tarList.some((observer) => observer.target === target));
  }
  disconnect() {
    import_xe_utils37.default.remove(eventStore2, (item) => item === this);
  }
};
function createResizeEvent(callback) {
  if (window.ResizeObserver) {
    return new window.ResizeObserver(callback);
  }
  return new XEResizeObserver(callback);
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/body.js
var import_xe_utils38 = __toESM(require_xe_utils());
var renderType = "body";
var lineOffsetSizes = {
  mini: 3,
  small: 2,
  medium: 1
};
var body_default = defineComponent({
  name: "VxeTableBody",
  props: {
    tableData: Array,
    tableColumn: Array,
    fixedColumn: Array,
    fixedType: { type: String, default: null }
  },
  setup(props) {
    const $xetable = inject("$xetable", {});
    const xesize = inject("xesize", null);
    const { xID, props: tableProps, context: tableContext, reactData: tableReactData, internalData: tableInternalData } = $xetable;
    const { refTableHeader, refTableBody, refTableFooter, refTableLeftBody, refTableRightBody, refValidTooltip } = $xetable.getRefMaps();
    const { computeEditOpts, computeMouseOpts, computeSYOpts, computeEmptyOpts, computeKeyboardOpts, computeTooltipOpts, computeRadioOpts, computeExpandOpts, computeTreeOpts, computeCheckboxOpts, computeValidOpts, computeRowOpts, computeColumnOpts } = $xetable.getComputeMaps();
    const refElem = ref();
    const refBodyTable = ref();
    const refBodyColgroup = ref();
    const refBodyTBody = ref();
    const refBodyXSpace = ref();
    const refBodyYSpace = ref();
    const refBodyEmptyBlock = ref();
    const getOffsetSize = () => {
      if (xesize) {
        const vSize = xesize.value;
        if (vSize) {
          return lineOffsetSizes[vSize] || 0;
        }
      }
      return 0;
    };
    const isVMScrollProcess = () => {
      const { delayHover } = tableProps;
      const { lastScrollTime, _isResize } = tableReactData;
      return !!(_isResize || lastScrollTime && Date.now() < lastScrollTime + delayHover);
    };
    const countTreeExpand = (prevRow, params) => {
      let count = 1;
      if (!prevRow) {
        return count;
      }
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const rowChildren = prevRow[childrenField];
      if (rowChildren && $xetable.isTreeExpandByRow(prevRow)) {
        for (let index = 0; index < rowChildren.length; index++) {
          count += countTreeExpand(rowChildren[index], params);
        }
      }
      return count;
    };
    const calcTreeLine = (params, items, rIndex) => {
      let expandSize = 1;
      if (rIndex) {
        expandSize = countTreeExpand(items[rIndex - 1], params);
      }
      return tableReactData.rowHeight * expandSize - (rIndex ? 1 : 12 - getOffsetSize());
    };
    const renderLine = (params) => {
      const { row, column } = params;
      const { afterFullData } = tableInternalData;
      const { treeConfig } = tableProps;
      const treeOpts = computeTreeOpts.value;
      const { slots, treeNode } = column;
      const { fullAllDataRowIdData } = tableInternalData;
      const rowid = getRowid($xetable, row);
      const rest = fullAllDataRowIdData[rowid];
      let rLevel = 0;
      let rIndex = 0;
      let items = [];
      if (rest) {
        rLevel = rest.level;
        rIndex = rest._index;
        items = rest.items;
      }
      if (slots && slots.line) {
        return $xetable.callSlot(slots.line, params);
      }
      const isFirstRow = $xetable.eqRow(afterFullData[0], row);
      if (treeConfig && treeNode && (treeOpts.showLine || treeOpts.line)) {
        return [
          h("div", {
            class: "vxe-tree--line-wrapper"
          }, [
            h("div", {
              class: "vxe-tree--line",
              style: {
                height: `${isFirstRow ? 1 : calcTreeLine(params, items, rIndex)}px`,
                left: `${rLevel * treeOpts.indent + (rLevel ? 2 - getOffsetSize() : 0) + 16}px`
              }
            })
          ])
        ];
      }
      return [];
    };
    const renderColumn = (seq, rowid, fixedType, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, columns, items) => {
      const { columnKey, height, showOverflow: allColumnOverflow, cellClassName: allCellClassName, cellStyle, align: allAlign, spanMethod, mouseConfig, editConfig, editRules, tooltipConfig } = tableProps;
      const { tableData, overflowX, scrollYLoad, currentColumn, mergeList, editStore, isAllOverflow, validErrorMaps } = tableReactData;
      const { afterFullData } = tableInternalData;
      const validOpts = computeValidOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const editOpts = computeEditOpts.value;
      const tooltipOpts = computeTooltipOpts.value;
      const rowOpts = computeRowOpts.value;
      const sYOpts = computeSYOpts.value;
      const columnOpts = computeColumnOpts.value;
      const { type, cellRender, editRender, align, showOverflow, className, treeNode, slots } = column;
      const { actived } = editStore;
      const { rHeight: scrollYRHeight } = sYOpts;
      const { height: rowHeight } = rowOpts;
      const renderOpts = editRender || cellRender;
      const compConf = renderOpts ? VXETable.renderer.get(renderOpts.name) : null;
      const compCellClassName = compConf ? compConf.cellClassName : "";
      const compCellStyle = compConf ? compConf.cellStyle : "";
      const showAllTip = tooltipOpts.showAll;
      const columnIndex = $xetable.getColumnIndex(column);
      const _columnIndex = $xetable.getVTColumnIndex(column);
      const isEdit = isEnableConf(editRender);
      let fixedHiddenColumn = fixedType ? column.fixed !== fixedType : column.fixed && overflowX;
      const cellOverflow = import_xe_utils38.default.isUndefined(showOverflow) || import_xe_utils38.default.isNull(showOverflow) ? allColumnOverflow : showOverflow;
      let showEllipsis = cellOverflow === "ellipsis";
      const showTitle = cellOverflow === "title";
      const showTooltip = cellOverflow === true || cellOverflow === "tooltip";
      let hasEllipsis = showTitle || showTooltip || showEllipsis;
      let isDirty;
      const tdOns = {};
      const cellAlign = align || allAlign;
      const errorValidItem = validErrorMaps[`${rowid}:${column.id}`];
      const showValidTip = editRules && validOpts.showMessage && (validOpts.message === "default" ? height || tableData.length > 1 : validOpts.message === "inline");
      const attrs = { colid: column.id };
      const params = { $table: $xetable, $grid: $xetable.xegrid, seq, rowid, row, rowIndex, $rowIndex, _rowIndex, column, columnIndex, $columnIndex, _columnIndex, fixed: fixedType, type: renderType, isHidden: fixedHiddenColumn, level: rowLevel, visibleData: afterFullData, data: tableData, items };
      if (scrollYLoad && !hasEllipsis) {
        showEllipsis = hasEllipsis = true;
      }
      if (showTitle || showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseenter = (evnt) => {
          if (isVMScrollProcess()) {
            return;
          }
          if (showTitle) {
            updateCellTitle(evnt.currentTarget, column);
          } else if (showTooltip || showAllTip) {
            $xetable.triggerBodyTooltipEvent(evnt, params);
          }
          $xetable.dispatchEvent("cell-mouseenter", Object.assign({ cell: evnt.currentTarget }, params), evnt);
        };
      }
      if (showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseleave = (evnt) => {
          if (isVMScrollProcess()) {
            return;
          }
          if (showTooltip || showAllTip) {
            $xetable.handleTargetLeaveEvent(evnt);
          }
          $xetable.dispatchEvent("cell-mouseleave", Object.assign({ cell: evnt.currentTarget }, params), evnt);
        };
      }
      if (checkboxOpts.range || mouseConfig) {
        tdOns.onMousedown = (evnt) => {
          $xetable.triggerCellMousedownEvent(evnt, params);
        };
      }
      tdOns.onClick = (evnt) => {
        $xetable.triggerCellClickEvent(evnt, params);
      };
      tdOns.onDblclick = (evnt) => {
        $xetable.triggerCellDblclickEvent(evnt, params);
      };
      if (mergeList.length) {
        const spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);
        if (spanRest) {
          const { rowspan, colspan } = spanRest;
          if (!rowspan || !colspan) {
            return null;
          }
          if (rowspan > 1) {
            attrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            attrs.colspan = colspan;
          }
        }
      } else if (spanMethod) {
        const { rowspan = 1, colspan = 1 } = spanMethod(params) || {};
        if (!rowspan || !colspan) {
          return null;
        }
        if (rowspan > 1) {
          attrs.rowspan = rowspan;
        }
        if (colspan > 1) {
          attrs.colspan = colspan;
        }
      }
      if (fixedHiddenColumn && mergeList) {
        if (attrs.colspan > 1 || attrs.rowspan > 1) {
          fixedHiddenColumn = false;
        }
      }
      if (!fixedHiddenColumn && editConfig && (editRender || cellRender) && (editOpts.showStatus || editOpts.showUpdateStatus)) {
        isDirty = $xetable.isUpdateByRow(row, column.field);
      }
      const tdVNs = [];
      if (fixedHiddenColumn && (allColumnOverflow ? isAllOverflow : allColumnOverflow)) {
        tdVNs.push(h("div", {
          class: ["vxe-cell", {
            "c--title": showTitle,
            "c--tooltip": showTooltip,
            "c--ellipsis": showEllipsis
          }],
          style: {
            maxHeight: hasEllipsis && (scrollYRHeight || rowHeight) ? `${scrollYRHeight || rowHeight}px` : ""
          }
        }));
      } else {
        tdVNs.push(...renderLine(params), h("div", {
          class: ["vxe-cell", {
            "c--title": showTitle,
            "c--tooltip": showTooltip,
            "c--ellipsis": showEllipsis
          }],
          style: {
            maxHeight: hasEllipsis && (scrollYRHeight || rowHeight) ? `${scrollYRHeight || rowHeight}px` : ""
          },
          title: showTitle ? $xetable.getCellLabel(row, column) : null
        }, column.renderCell(params)));
        if (showValidTip && errorValidItem) {
          const errRule = errorValidItem.rule;
          const validSlot = slots ? slots.valid : null;
          const validParams = Object.assign(Object.assign({}, params), errorValidItem);
          tdVNs.push(h("div", {
            class: ["vxe-cell--valid-error-hint", getPropClass(validOpts.className, validParams)],
            style: errRule && errRule.maxWidth ? {
              width: `${errRule.maxWidth}px`
            } : null
          }, validSlot ? $xetable.callSlot(validSlot, validParams) : [
            h("span", {
              class: "vxe-cell--valid-error-msg"
            }, errorValidItem.content)
          ]));
        }
      }
      return h("td", Object.assign(Object.assign(Object.assign({ class: [
        "vxe-body--column",
        column.id,
        {
          [`col--${cellAlign}`]: cellAlign,
          [`col--${type}`]: type,
          "col--last": $columnIndex === columns.length - 1,
          "col--tree-node": treeNode,
          "col--edit": isEdit,
          "col--ellipsis": hasEllipsis,
          "fixed--hidden": fixedHiddenColumn,
          "col--dirty": isDirty,
          "col--active": editConfig && isEdit && (actived.row === row && (actived.column === column || editOpts.mode === "row")),
          "col--valid-error": !!errorValidItem,
          "col--current": currentColumn === column
        },
        getPropClass(compCellClassName, params),
        getPropClass(className, params),
        getPropClass(allCellClassName, params)
      ], key: columnKey || columnOpts.useKey ? column.id : $columnIndex }, attrs), { style: Object.assign({
        height: hasEllipsis && (scrollYRHeight || rowHeight) ? `${scrollYRHeight || rowHeight}px` : ""
      }, import_xe_utils38.default.isFunction(compCellStyle) ? compCellStyle(params) : compCellStyle, import_xe_utils38.default.isFunction(cellStyle) ? cellStyle(params) : cellStyle) }), tdOns), tdVNs);
    };
    const renderRows = (fixedType, tableData, tableColumn) => {
      const { stripe, rowKey, highlightHoverRow, rowClassName, rowStyle, showOverflow: allColumnOverflow, editConfig, treeConfig } = tableProps;
      const { hasFixedColumn, treeExpandedMaps, scrollYLoad, rowExpandedMaps, expandColumn, selectRadioRow, pendingRowMaps, pendingRowList } = tableReactData;
      const { fullAllDataRowIdData } = tableInternalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const radioOpts = computeRadioOpts.value;
      const treeOpts = computeTreeOpts.value;
      const editOpts = computeEditOpts.value;
      const rowOpts = computeRowOpts.value;
      const { transform } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const rows = [];
      tableData.forEach((row, $rowIndex) => {
        const trOn = {};
        let rowIndex = $rowIndex;
        rowIndex = $xetable.getRowIndex(row);
        if (rowOpts.isHover || highlightHoverRow) {
          trOn.onMouseenter = (evnt) => {
            if (isVMScrollProcess()) {
              return;
            }
            $xetable.triggerHoverEvent(evnt, { row, rowIndex });
          };
          trOn.onMouseleave = () => {
            if (isVMScrollProcess()) {
              return;
            }
            $xetable.clearHoverRow();
          };
        }
        const rowid = getRowid($xetable, row);
        const rest = fullAllDataRowIdData[rowid];
        let rowLevel = 0;
        let seq = -1;
        let _rowIndex = 0;
        if (rest) {
          rowLevel = rest.level;
          seq = rest.seq;
          _rowIndex = rest._index;
        }
        const params = { $table: $xetable, seq, rowid, fixed: fixedType, type: renderType, level: rowLevel, row, rowIndex, $rowIndex, _rowIndex };
        const isExpandRow = expandColumn && !!rowExpandedMaps[rowid];
        let isExpandTree = false;
        let rowChildren = [];
        let isNewRow = false;
        if (editConfig) {
          isNewRow = $xetable.isInsertByRow(row);
        }
        if (treeConfig && !scrollYLoad && !transform) {
          rowChildren = row[childrenField];
          isExpandTree = rowChildren && rowChildren.length && !!treeExpandedMaps[rowid];
        }
        rows.push(h("tr", Object.assign({ class: [
          "vxe-body--row",
          treeConfig ? `row--level-${rowLevel}` : "",
          {
            "row--stripe": stripe && ($xetable.getVTRowIndex(row) + 1) % 2 === 0,
            "is--new": isNewRow,
            "is--expand-row": isExpandRow,
            "is--expand-tree": isExpandTree,
            "row--new": isNewRow && (editOpts.showStatus || editOpts.showInsertStatus),
            "row--radio": radioOpts.highlight && $xetable.eqRow(selectRadioRow, row),
            "row--checked": checkboxOpts.highlight && $xetable.isCheckedByCheckboxRow(row),
            "row--pending": pendingRowList.length && !!pendingRowMaps[rowid]
          },
          getPropClass(rowClassName, params)
        ], rowid, style: rowStyle ? import_xe_utils38.default.isFunction(rowStyle) ? rowStyle(params) : rowStyle : null, key: rowKey || rowOpts.useKey || treeConfig ? rowid : $rowIndex }, trOn), tableColumn.map((column, $columnIndex) => {
          return renderColumn(seq, rowid, fixedType, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, tableColumn, tableData);
        })));
        if (isExpandRow) {
          const expandOpts = computeExpandOpts.value;
          const { height: expandHeight } = expandOpts;
          const cellStyle = {};
          if (expandHeight) {
            cellStyle.height = `${expandHeight}px`;
          }
          if (treeConfig) {
            cellStyle.paddingLeft = `${rowLevel * treeOpts.indent + 30}px`;
          }
          const { showOverflow } = expandColumn;
          const hasEllipsis = import_xe_utils38.default.isUndefined(showOverflow) || import_xe_utils38.default.isNull(showOverflow) ? allColumnOverflow : showOverflow;
          const expandParams = { $table: $xetable, seq, column: expandColumn, fixed: fixedType, type: renderType, level: rowLevel, row, rowIndex, $rowIndex, _rowIndex };
          rows.push(h("tr", Object.assign({ class: "vxe-body--expanded-row", key: `expand_${rowid}`, style: rowStyle ? import_xe_utils38.default.isFunction(rowStyle) ? rowStyle(expandParams) : rowStyle : null }, trOn), [
            h("td", {
              class: {
                "vxe-body--expanded-column": 1,
                "fixed--hidden": fixedType && !hasFixedColumn,
                "col--ellipsis": hasEllipsis
              },
              colspan: tableColumn.length
            }, [
              h("div", {
                class: {
                  "vxe-body--expanded-cell": 1,
                  "is--ellipsis": expandHeight
                },
                style: cellStyle
              }, [
                expandColumn.renderData(expandParams)
              ])
            ])
          ]));
        }
        if (isExpandTree) {
          rows.push(...renderRows(fixedType, rowChildren, tableColumn));
        }
      });
      return rows;
    };
    let scrollProcessTimeout;
    const syncBodyScroll = (fixedType, scrollTop, elem1, elem2) => {
      if (elem1 || elem2) {
        if (elem1) {
          removeScrollListener(elem1);
          elem1.scrollTop = scrollTop;
        }
        if (elem2) {
          removeScrollListener(elem2);
          elem2.scrollTop = scrollTop;
        }
        clearTimeout(scrollProcessTimeout);
        scrollProcessTimeout = setTimeout(() => {
          restoreScrollListener(elem1);
          restoreScrollListener(elem2);
          tableReactData.lastScrollTime = Date.now();
        }, 300);
      }
    };
    const scrollLoadingTime = null;
    const scrollEvent = (evnt) => {
      const { fixedType } = props;
      const { highlightHoverRow } = tableProps;
      const { scrollXLoad, scrollYLoad } = tableReactData;
      const { elemStore, lastScrollTop, lastScrollLeft } = tableInternalData;
      const rowOpts = computeRowOpts.value;
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableFooter = refTableFooter.value;
      const leftBody = refTableLeftBody.value;
      const rightBody = refTableRightBody.value;
      const validTip = refValidTooltip.value;
      const scrollBodyElem = refElem.value;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = tableFooter ? tableFooter.$el : null;
      const bodyElem = tableBody.$el;
      const leftElem = leftBody ? leftBody.$el : null;
      const rightElem = rightBody ? rightBody.$el : null;
      const bodyYRef = elemStore["main-body-ySpace"];
      const bodyYElem = bodyYRef ? bodyYRef.value : null;
      const bodyXRef = elemStore["main-body-xSpace"];
      const bodyXElem = bodyXRef ? bodyXRef.value : null;
      const bodyHeight = scrollYLoad && bodyYElem ? bodyYElem.clientHeight : bodyElem.clientHeight;
      const bodyWidth = scrollXLoad && bodyXElem ? bodyXElem.clientWidth : bodyElem.clientWidth;
      let scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = bodyElem.scrollLeft;
      const isRollX = scrollLeft !== lastScrollLeft;
      const isRollY = scrollTop !== lastScrollTop;
      tableInternalData.lastScrollTop = scrollTop;
      tableInternalData.lastScrollLeft = scrollLeft;
      tableReactData.lastScrollTime = Date.now();
      if (rowOpts.isHover || highlightHoverRow) {
        $xetable.clearHoverRow();
      }
      if (leftElem && fixedType === "left") {
        scrollTop = leftElem.scrollTop;
        syncBodyScroll(fixedType, scrollTop, bodyElem, rightElem);
      } else if (rightElem && fixedType === "right") {
        scrollTop = rightElem.scrollTop;
        syncBodyScroll(fixedType, scrollTop, bodyElem, leftElem);
      } else {
        if (isRollX) {
          if (headerElem) {
            headerElem.scrollLeft = bodyElem.scrollLeft;
          }
          if (footerElem) {
            footerElem.scrollLeft = bodyElem.scrollLeft;
          }
        }
        if (leftElem || rightElem) {
          $xetable.checkScrolling();
          if (isRollY) {
            syncBodyScroll(fixedType, scrollTop, leftElem, rightElem);
          }
        }
      }
      if (scrollXLoad && isRollX) {
        $xetable.triggerScrollXEvent(evnt);
      }
      if (scrollYLoad && isRollY) {
        $xetable.triggerScrollYEvent(evnt);
      }
      if (scrollLoadingTime !== null) {
        clearTimeout(scrollLoadingTime);
      }
      if (isRollX && validTip && validTip.reactData.visible) {
        validTip.updatePlacement();
      }
      $xetable.dispatchEvent("scroll", {
        type: renderType,
        fixed: fixedType,
        scrollTop,
        scrollLeft,
        scrollHeight: bodyElem.scrollHeight,
        scrollWidth: bodyElem.scrollWidth,
        bodyHeight,
        bodyWidth,
        isX: isRollX,
        isY: isRollY
      }, evnt);
    };
    let wheelTime;
    let wheelYSize = 0;
    let wheelYInterval = 0;
    let wheelYTotal = 0;
    let isPrevWheelTop = false;
    const handleWheel = (evnt, isTopWheel, deltaTop, isRollX, isRollY) => {
      const { elemStore } = tableInternalData;
      const { scrollXLoad, scrollYLoad } = tableReactData;
      const tableBody = refTableBody.value;
      const leftBody = refTableLeftBody.value;
      const rightBody = refTableRightBody.value;
      const leftElem = leftBody ? leftBody.$el : null;
      const rightElem = rightBody ? rightBody.$el : null;
      const bodyElem = tableBody.$el;
      const bodyYRef = elemStore["main-body-ySpace"];
      const bodyYElem = bodyYRef ? bodyYRef.value : null;
      const bodyXRef = elemStore["main-body-xSpace"];
      const bodyXElem = bodyXRef ? bodyXRef.value : null;
      const bodyHeight = scrollYLoad && bodyYElem ? bodyYElem.clientHeight : bodyElem.clientHeight;
      const bodyWidth = scrollXLoad && bodyXElem ? bodyXElem.clientWidth : bodyElem.clientWidth;
      const remainSize = isPrevWheelTop === isTopWheel ? Math.max(0, wheelYSize - wheelYTotal) : 0;
      isPrevWheelTop = isTopWheel;
      wheelYSize = Math.abs(isTopWheel ? deltaTop - remainSize : deltaTop + remainSize);
      wheelYInterval = 0;
      wheelYTotal = 0;
      clearTimeout(wheelTime);
      const handleSmooth = () => {
        if (wheelYTotal < wheelYSize) {
          const { fixedType } = props;
          wheelYInterval = Math.max(5, Math.floor(wheelYInterval * 1.5));
          wheelYTotal = wheelYTotal + wheelYInterval;
          if (wheelYTotal > wheelYSize) {
            wheelYInterval = wheelYInterval - (wheelYTotal - wheelYSize);
          }
          const { scrollTop, clientHeight, scrollHeight } = bodyElem;
          const targerTop = scrollTop + wheelYInterval * (isTopWheel ? -1 : 1);
          bodyElem.scrollTop = targerTop;
          if (leftElem) {
            leftElem.scrollTop = targerTop;
          }
          if (rightElem) {
            rightElem.scrollTop = targerTop;
          }
          if (isTopWheel ? targerTop < scrollHeight - clientHeight : targerTop >= 0) {
            wheelTime = setTimeout(handleSmooth, 10);
          }
          $xetable.dispatchEvent("scroll", {
            type: renderType,
            fixed: fixedType,
            scrollTop: bodyElem.scrollTop,
            scrollLeft: bodyElem.scrollLeft,
            scrollHeight: bodyElem.scrollHeight,
            scrollWidth: bodyElem.scrollWidth,
            bodyHeight,
            bodyWidth,
            isX: isRollX,
            isY: isRollY
          }, evnt);
        }
      };
      handleSmooth();
    };
    const wheelEvent = (evnt) => {
      const { deltaY, deltaX } = evnt;
      const { highlightHoverRow } = tableProps;
      const { scrollYLoad } = tableReactData;
      const { lastScrollTop, lastScrollLeft } = tableInternalData;
      const rowOpts = computeRowOpts.value;
      const tableBody = refTableBody.value;
      const scrollBodyElem = refElem.value;
      const bodyElem = tableBody.$el;
      const deltaTop = deltaY;
      const deltaLeft = deltaX;
      const isTopWheel = deltaTop < 0;
      if (isTopWheel ? scrollBodyElem.scrollTop <= 0 : scrollBodyElem.scrollTop >= scrollBodyElem.scrollHeight - scrollBodyElem.clientHeight) {
        return;
      }
      const scrollTop = scrollBodyElem.scrollTop + deltaTop;
      const scrollLeft = bodyElem.scrollLeft + deltaLeft;
      const isRollX = scrollLeft !== lastScrollLeft;
      const isRollY = scrollTop !== lastScrollTop;
      if (isRollY) {
        evnt.preventDefault();
        tableInternalData.lastScrollTop = scrollTop;
        tableInternalData.lastScrollLeft = scrollLeft;
        tableReactData.lastScrollTime = Date.now();
        if (rowOpts.isHover || highlightHoverRow) {
          $xetable.clearHoverRow();
        }
        handleWheel(evnt, isTopWheel, deltaTop, isRollX, isRollY);
        if (scrollYLoad) {
          $xetable.triggerScrollYEvent(evnt);
        }
      }
    };
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { elemStore } = tableInternalData;
        const prefix = `${fixedType || "main"}-body-`;
        const el = refElem.value;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}table`] = refBodyTable;
        elemStore[`${prefix}colgroup`] = refBodyColgroup;
        elemStore[`${prefix}list`] = refBodyTBody;
        elemStore[`${prefix}xSpace`] = refBodyXSpace;
        elemStore[`${prefix}ySpace`] = refBodyYSpace;
        elemStore[`${prefix}emptyBlock`] = refBodyEmptyBlock;
        if (el) {
          el.onscroll = scrollEvent;
          el._onscroll = scrollEvent;
        }
      });
    });
    onBeforeUnmount(() => {
      const el = refElem.value;
      clearTimeout(wheelTime);
      if (el) {
        el._onscroll = null;
        el.onscroll = null;
      }
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { elemStore } = tableInternalData;
      const prefix = `${fixedType || "main"}-body-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}ySpace`] = null;
      elemStore[`${prefix}emptyBlock`] = null;
    });
    const renderVN = () => {
      let { fixedColumn, fixedType, tableColumn } = props;
      const { keyboardConfig, showOverflow: allColumnOverflow, spanMethod, mouseConfig } = tableProps;
      const { tableData, mergeList, scrollYLoad, isAllOverflow } = tableReactData;
      const { visibleColumn } = tableInternalData;
      const { slots } = tableContext;
      const sYOpts = computeSYOpts.value;
      const emptyOpts = computeEmptyOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const mouseOpts = computeMouseOpts.value;
      if (fixedType) {
        if (!tableReactData.expandColumn && (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow))) {
          if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {
            tableColumn = fixedColumn;
          } else {
            tableColumn = visibleColumn;
          }
        } else {
          tableColumn = visibleColumn;
        }
      }
      let emptyContent;
      const emptySlot = slots ? slots.empty : null;
      if (emptySlot) {
        emptyContent = $xetable.callSlot(emptySlot, { $table: $xetable, $grid: $xetable.xegrid });
      } else {
        const compConf = emptyOpts.name ? VXETable.renderer.get(emptyOpts.name) : null;
        const renderTableEmptyView = compConf ? compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (renderTableEmptyView) {
          emptyContent = getSlotVNs(renderTableEmptyView(emptyOpts, { $table: $xetable }));
        } else {
          emptyContent = tableProps.emptyText || conf_default.i18n("vxe.table.emptyText");
        }
      }
      return h("div", Object.assign({ ref: refElem, class: ["vxe-table--body-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"], xid: xID }, sYOpts.mode === "wheel" ? { onWheel: wheelEvent } : {}), [
        fixedType ? createCommentVNode() : h("div", {
          ref: refBodyXSpace,
          class: "vxe-body--x-space"
        }),
        h("div", {
          ref: refBodyYSpace,
          class: "vxe-body--y-space"
        }),
        h("table", {
          ref: refBodyTable,
          class: "vxe-table--body",
          xid: xID,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 列宽
           */
          h("colgroup", {
            ref: refBodyColgroup
          }, tableColumn.map((column, $columnIndex) => {
            return h("col", {
              name: column.id,
              key: $columnIndex
            });
          })),
          /**
           * 内容
           */
          h("tbody", {
            ref: refBodyTBody
          }, renderRows(fixedType, tableData, tableColumn))
        ]),
        h("div", {
          class: "vxe-table--checkbox-range"
        }),
        mouseConfig && mouseOpts.area ? h("div", {
          class: "vxe-table--cell-area"
        }, [
          h("span", {
            class: "vxe-table--cell-main-area"
          }, mouseOpts.extension ? [
            h("span", {
              class: "vxe-table--cell-main-area-btn",
              onMousedown(evnt) {
                $xetable.triggerCellExtendMousedownEvent(evnt, { $table: $xetable, fixed: fixedType, type: renderType });
              }
            })
          ] : []),
          h("span", {
            class: "vxe-table--cell-copy-area"
          }),
          h("span", {
            class: "vxe-table--cell-extend-area"
          }),
          h("span", {
            class: "vxe-table--cell-multi-area"
          }),
          h("span", {
            class: "vxe-table--cell-active-area"
          })
        ]) : null,
        !fixedType ? h("div", {
          class: "vxe-table--empty-block",
          ref: refBodyEmptyBlock
        }, [
          h("div", {
            class: "vxe-table--empty-content"
          }, emptyContent)
        ]) : null
      ]);
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/header.js
var import_xe_utils39 = __toESM(require_xe_utils());
var renderType2 = "header";
var header_default = defineComponent({
  name: "VxeTableHeader",
  props: {
    tableData: Array,
    tableColumn: Array,
    tableGroupColumn: Array,
    fixedColumn: Array,
    fixedType: { type: String, default: null }
  },
  setup(props) {
    const $xetable = inject("$xetable", {});
    const { xID, props: tableProps, reactData: tableReactData, internalData: tableInternalData } = $xetable;
    const { refElem: tableRefElem, refTableBody, refLeftContainer, refRightContainer, refCellResizeBar } = $xetable.getRefMaps();
    const { computeColumnOpts } = $xetable.getComputeMaps();
    const headerColumn = ref([]);
    const refElem = ref();
    const refHeaderTable = ref();
    const refHeaderColgroup = ref();
    const refHeaderTHead = ref();
    const refHeaderXSpace = ref();
    const refHeaderBorderRepair = ref();
    const uploadColumn = () => {
      const { isGroup } = tableReactData;
      headerColumn.value = isGroup ? convertHeaderColumnToRows(props.tableGroupColumn) : [];
    };
    const resizeMousedown = (evnt, params) => {
      const { column } = params;
      const { fixedType } = props;
      const tableBody = refTableBody.value;
      const leftContainerElem = refLeftContainer.value;
      const rightContainerElem = refRightContainer.value;
      const resizeBarElem = refCellResizeBar.value;
      const { clientX: dragClientX } = evnt;
      const wrapperElem = refElem.value;
      const dragBtnElem = evnt.target;
      const cell = params.cell = dragBtnElem.parentNode;
      let dragLeft = 0;
      const tableBodyElem = tableBody.$el;
      const pos = getOffsetPos(dragBtnElem, wrapperElem);
      const dragBtnWidth = dragBtnElem.clientWidth;
      const dragBtnOffsetWidth = Math.floor(dragBtnWidth / 2);
      const minInterval = getColReMinWidth(params) - dragBtnOffsetWidth;
      let dragMinLeft = pos.left - cell.clientWidth + dragBtnWidth + minInterval;
      let dragPosLeft = pos.left + dragBtnOffsetWidth;
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const isLeftFixed = fixedType === "left";
      const isRightFixed = fixedType === "right";
      const tableEl = tableRefElem.value;
      let fixedOffsetWidth = 0;
      if (isLeftFixed || isRightFixed) {
        const siblingProp = isLeftFixed ? "nextElementSibling" : "previousElementSibling";
        let tempCellElem = cell[siblingProp];
        while (tempCellElem) {
          if (hasClass(tempCellElem, "fixed--hidden")) {
            break;
          } else if (!hasClass(tempCellElem, "col--group")) {
            fixedOffsetWidth += tempCellElem.offsetWidth;
          }
          tempCellElem = tempCellElem[siblingProp];
        }
        if (isRightFixed && rightContainerElem) {
          dragPosLeft = rightContainerElem.offsetLeft + fixedOffsetWidth;
        }
      }
      const updateEvent = function(evnt2) {
        evnt2.stopPropagation();
        evnt2.preventDefault();
        const offsetX = evnt2.clientX - dragClientX;
        let left = dragPosLeft + offsetX;
        const scrollLeft = fixedType ? 0 : tableBodyElem.scrollLeft;
        if (isLeftFixed) {
          left = Math.min(left, (rightContainerElem ? rightContainerElem.offsetLeft : tableBodyElem.clientWidth) - fixedOffsetWidth - minInterval);
        } else if (isRightFixed) {
          dragMinLeft = (leftContainerElem ? leftContainerElem.clientWidth : 0) + fixedOffsetWidth + minInterval;
          left = Math.min(left, dragPosLeft + cell.clientWidth - minInterval);
        } else {
          dragMinLeft = Math.max(tableBodyElem.scrollLeft, dragMinLeft);
        }
        dragLeft = Math.max(left, dragMinLeft);
        resizeBarElem.style.left = `${dragLeft - scrollLeft}px`;
      };
      tableReactData._isResize = true;
      addClass(tableEl, "drag--resize");
      resizeBarElem.style.display = "block";
      document.onmousemove = updateEvent;
      document.onmouseup = function(evnt2) {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        const resizeWidth = column.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft);
        column.resizeWidth = resizeWidth;
        resizeBarElem.style.display = "none";
        tableReactData._isResize = false;
        tableInternalData._lastResizeTime = Date.now();
        $xetable.analyColumnWidth();
        $xetable.recalculate(true).then(() => {
          $xetable.saveCustomResizable();
          $xetable.updateCellAreas();
          $xetable.dispatchEvent("resizable-change", Object.assign(Object.assign({}, params), { resizeWidth }), evnt2);
        });
        removeClass(tableEl, "drag--resize");
      };
      updateEvent(evnt);
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
    };
    watch(() => props.tableColumn, uploadColumn);
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { internalData } = $xetable;
        const { elemStore } = internalData;
        const prefix = `${fixedType || "main"}-header-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}table`] = refHeaderTable;
        elemStore[`${prefix}colgroup`] = refHeaderColgroup;
        elemStore[`${prefix}list`] = refHeaderTHead;
        elemStore[`${prefix}xSpace`] = refHeaderXSpace;
        elemStore[`${prefix}repair`] = refHeaderBorderRepair;
        uploadColumn();
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { internalData } = $xetable;
      const { elemStore } = internalData;
      const prefix = `${fixedType || "main"}-header-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}repair`] = null;
    });
    const renderVN = () => {
      const { fixedType, fixedColumn, tableColumn } = props;
      const { resizable, border, columnKey, headerRowClassName, headerCellClassName, headerRowStyle, headerCellStyle, showHeaderOverflow: allColumnHeaderOverflow, headerAlign: allHeaderAlign, align: allAlign, mouseConfig } = tableProps;
      const { isGroup, currentColumn, scrollXLoad, overflowX, scrollbarWidth } = tableReactData;
      const { visibleColumn } = tableInternalData;
      const columnOpts = computeColumnOpts.value;
      let headerGroups = headerColumn.value;
      let renderColumnList = tableColumn;
      if (isGroup) {
        renderColumnList = visibleColumn;
      } else {
        if (fixedType) {
          if (scrollXLoad || allColumnHeaderOverflow) {
            renderColumnList = fixedColumn;
          }
        }
        headerGroups = [renderColumnList];
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table--header-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"],
        xid: xID
      }, [
        fixedType ? createCommentVNode() : h("div", {
          ref: refHeaderXSpace,
          class: "vxe-body--x-space"
        }),
        h("table", {
          ref: refHeaderTable,
          class: "vxe-table--header",
          xid: xID,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 列宽
           */
          h("colgroup", {
            ref: refHeaderColgroup
          }, renderColumnList.map((column, $columnIndex) => {
            return h("col", {
              name: column.id,
              key: $columnIndex
            });
          }).concat(scrollbarWidth ? [
            h("col", {
              name: "col_gutter"
            })
          ] : [])),
          /**
           * 头部
           */
          h("thead", {
            ref: refHeaderTHead
          }, headerGroups.map((cols, $rowIndex) => {
            return h("tr", {
              class: ["vxe-header--row", headerRowClassName ? import_xe_utils39.default.isFunction(headerRowClassName) ? headerRowClassName({ $table: $xetable, $rowIndex, fixed: fixedType, type: renderType2 }) : headerRowClassName : ""],
              style: headerRowStyle ? import_xe_utils39.default.isFunction(headerRowStyle) ? headerRowStyle({ $table: $xetable, $rowIndex, fixed: fixedType, type: renderType2 }) : headerRowStyle : null
            }, cols.map((column, $columnIndex) => {
              const { type, showHeaderOverflow, headerAlign, align, headerClassName } = column;
              const isColGroup = column.children && column.children.length;
              const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : !!column.fixed && overflowX;
              const headOverflow = import_xe_utils39.default.isUndefined(showHeaderOverflow) || import_xe_utils39.default.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
              const headAlign = headerAlign || align || allHeaderAlign || allAlign;
              let showEllipsis = headOverflow === "ellipsis";
              const showTitle = headOverflow === "title";
              const showTooltip = headOverflow === true || headOverflow === "tooltip";
              let hasEllipsis = showTitle || showTooltip || showEllipsis;
              const hasFilter = column.filters && column.filters.some((item) => item.checked);
              const columnIndex = $xetable.getColumnIndex(column);
              const _columnIndex = $xetable.getVTColumnIndex(column);
              const params = { $table: $xetable, $grid: $xetable.xegrid, $rowIndex, column, columnIndex, $columnIndex, _columnIndex, fixed: fixedType, type: renderType2, isHidden: fixedHiddenColumn, hasFilter };
              const thOns = {
                onClick: (evnt) => $xetable.triggerHeaderCellClickEvent(evnt, params),
                onDblclick: (evnt) => $xetable.triggerHeaderCellDblclickEvent(evnt, params)
              };
              if (scrollXLoad && !hasEllipsis) {
                showEllipsis = hasEllipsis = true;
              }
              if (mouseConfig) {
                thOns.onMousedown = (evnt) => $xetable.triggerHeaderCellMousedownEvent(evnt, params);
              }
              return h("th", Object.assign(Object.assign({ class: [
                "vxe-header--column",
                column.id,
                {
                  [`col--${headAlign}`]: headAlign,
                  [`col--${type}`]: type,
                  "col--last": $columnIndex === cols.length - 1,
                  "col--fixed": column.fixed,
                  "col--group": isColGroup,
                  "col--ellipsis": hasEllipsis,
                  "fixed--hidden": fixedHiddenColumn,
                  "is--sortable": column.sortable,
                  "col--filter": !!column.filters,
                  "is--filter-active": hasFilter,
                  "col--current": currentColumn === column
                },
                headerClassName ? import_xe_utils39.default.isFunction(headerClassName) ? headerClassName(params) : headerClassName : "",
                headerCellClassName ? import_xe_utils39.default.isFunction(headerCellClassName) ? headerCellClassName(params) : headerCellClassName : ""
              ], colid: column.id, colspan: column.colSpan > 1 ? column.colSpan : null, rowspan: column.rowSpan > 1 ? column.rowSpan : null, style: headerCellStyle ? import_xe_utils39.default.isFunction(headerCellStyle) ? headerCellStyle(params) : headerCellStyle : null }, thOns), { key: columnKey || columnOpts.useKey || isColGroup ? column.id : $columnIndex }), [
                h("div", {
                  class: ["vxe-cell", {
                    "c--title": showTitle,
                    "c--tooltip": showTooltip,
                    "c--ellipsis": showEllipsis
                  }]
                }, column.renderHeader(params)),
                /**
                 * 列宽拖动
                 */
                !fixedHiddenColumn && !isColGroup && (import_xe_utils39.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || resizable) ? h("div", {
                  class: ["vxe-resizable", {
                    "is--line": !border || border === "none"
                  }],
                  onMousedown: (evnt) => resizeMousedown(evnt, params)
                }) : null
              ]);
            }).concat(scrollbarWidth ? [
              h("th", {
                class: "vxe-header--gutter col--gutter"
              })
            ] : []));
          }))
        ]),
        /**
         * 其他
         */
        h("div", {
          ref: refHeaderBorderRepair,
          class: "vxe-table--header-border-line"
        })
      ]);
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/footer.js
var import_xe_utils40 = __toESM(require_xe_utils());
var renderType3 = "footer";
function mergeFooterMethod(mergeFooterList, _rowIndex, _columnIndex) {
  for (let mIndex = 0; mIndex < mergeFooterList.length; mIndex++) {
    const { row: mergeRowIndex, col: mergeColIndex, rowspan: mergeRowspan, colspan: mergeColspan } = mergeFooterList[mIndex];
    if (mergeColIndex > -1 && mergeRowIndex > -1 && mergeRowspan && mergeColspan) {
      if (mergeRowIndex === _rowIndex && mergeColIndex === _columnIndex) {
        return { rowspan: mergeRowspan, colspan: mergeColspan };
      }
      if (_rowIndex >= mergeRowIndex && _rowIndex < mergeRowIndex + mergeRowspan && _columnIndex >= mergeColIndex && _columnIndex < mergeColIndex + mergeColspan) {
        return { rowspan: 0, colspan: 0 };
      }
    }
  }
}
var footer_default = defineComponent({
  name: "VxeTableFooter",
  props: {
    footerTableData: { type: Array, default: () => [] },
    tableColumn: { type: Array, default: () => [] },
    fixedColumn: { type: Array, default: () => [] },
    fixedType: { type: String, default: null }
  },
  setup(props) {
    const $xetable = inject("$xetable", {});
    const { xID, props: tableProps, reactData: tableReactData, internalData: tableInternalData } = $xetable;
    const { refTableHeader, refTableBody, refValidTooltip } = $xetable.getRefMaps();
    const { computeTooltipOpts, computeColumnOpts } = $xetable.getComputeMaps();
    const refElem = ref();
    const refFooterTable = ref();
    const refFooterColgroup = ref();
    const refFooterTFoot = ref();
    const refFooterXSpace = ref();
    const scrollEvent = (evnt) => {
      const { fixedType } = props;
      const { scrollXLoad } = tableReactData;
      const { lastScrollLeft } = tableInternalData;
      const validTip = refValidTooltip.value;
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = refElem.value;
      const bodyElem = tableBody.$el;
      const scrollLeft = footerElem.scrollLeft;
      const isX = scrollLeft !== lastScrollLeft;
      tableInternalData.lastScrollLeft = scrollLeft;
      tableReactData.lastScrollTime = Date.now();
      if (headerElem) {
        headerElem.scrollLeft = scrollLeft;
      }
      if (bodyElem) {
        bodyElem.scrollLeft = scrollLeft;
      }
      if (scrollXLoad && isX) {
        $xetable.triggerScrollXEvent(evnt);
      }
      if (isX && validTip && validTip.reactData.visible) {
        validTip.updatePlacement();
      }
      $xetable.dispatchEvent("scroll", { type: renderType3, fixed: fixedType, scrollTop: bodyElem.scrollTop, scrollLeft, isX, isY: false }, evnt);
    };
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { elemStore } = tableInternalData;
        const prefix = `${fixedType || "main"}-footer-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}table`] = refFooterTable;
        elemStore[`${prefix}colgroup`] = refFooterColgroup;
        elemStore[`${prefix}list`] = refFooterTFoot;
        elemStore[`${prefix}xSpace`] = refFooterXSpace;
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { elemStore } = tableInternalData;
      const prefix = `${fixedType || "main"}-footer-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
    });
    const renderVN = () => {
      let { fixedType, fixedColumn, tableColumn, footerTableData } = props;
      const { footerRowClassName, footerCellClassName, footerRowStyle, footerCellStyle, footerAlign: allFooterAlign, footerSpanMethod, align: allAlign, columnKey, showFooterOverflow: allColumnFooterOverflow } = tableProps;
      const { visibleColumn } = tableInternalData;
      const { scrollXLoad, overflowX, scrollbarWidth, currentColumn, mergeFooterList } = tableReactData;
      const tooltipOpts = computeTooltipOpts.value;
      const columnOpts = computeColumnOpts.value;
      if (fixedType) {
        if (!tableReactData.expandColumn && (scrollXLoad || allColumnFooterOverflow)) {
          if (!mergeFooterList.length || !footerSpanMethod) {
            tableColumn = fixedColumn;
          } else {
            tableColumn = visibleColumn;
          }
        } else {
          tableColumn = visibleColumn;
        }
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table--footer-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"],
        xid: xID,
        onScroll: scrollEvent
      }, [
        fixedType ? createCommentVNode() : h("div", {
          ref: refFooterXSpace,
          class: "vxe-body--x-space"
        }),
        h("table", {
          ref: refFooterTable,
          class: "vxe-table--footer",
          xid: xID,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 列宽
           */
          h("colgroup", {
            ref: refFooterColgroup
          }, tableColumn.map((column, $columnIndex) => {
            return h("col", {
              name: column.id,
              key: $columnIndex
            });
          }).concat(scrollbarWidth ? [
            h("col", {
              name: "col_gutter"
            })
          ] : [])),
          /**
           * 底部
           */
          h("tfoot", {
            ref: refFooterTFoot
          }, footerTableData.map((list, _rowIndex) => {
            const $rowIndex = _rowIndex;
            const rowParams = { $table: $xetable, row: list, _rowIndex, $rowIndex, fixed: fixedType, type: renderType3 };
            return h("tr", {
              class: ["vxe-footer--row", footerRowClassName ? import_xe_utils40.default.isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ""],
              style: footerRowStyle ? import_xe_utils40.default.isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : null
            }, tableColumn.map((column, $columnIndex) => {
              const { type, showFooterOverflow, footerAlign, align, footerClassName } = column;
              const showAllTip = tooltipOpts.showAll;
              const isColGroup = column.children && column.children.length;
              const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : column.fixed && overflowX;
              const footOverflow = import_xe_utils40.default.isUndefined(showFooterOverflow) || import_xe_utils40.default.isNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
              const footAlign = footerAlign || align || allFooterAlign || allAlign;
              let showEllipsis = footOverflow === "ellipsis";
              const showTitle = footOverflow === "title";
              const showTooltip = footOverflow === true || footOverflow === "tooltip";
              let hasEllipsis = showTitle || showTooltip || showEllipsis;
              const attrs = { colid: column.id };
              const tfOns = {};
              const columnIndex = $xetable.getColumnIndex(column);
              const _columnIndex = $xetable.getVTColumnIndex(column);
              const itemIndex = _columnIndex;
              const cellParams = {
                $table: $xetable,
                $grid: $xetable.xegrid,
                row: list,
                rowIndex: _rowIndex,
                _rowIndex,
                $rowIndex,
                column,
                columnIndex,
                $columnIndex,
                _columnIndex,
                itemIndex,
                items: list,
                fixed: fixedType,
                type: renderType3,
                data: footerTableData
              };
              if (scrollXLoad && !hasEllipsis) {
                showEllipsis = hasEllipsis = true;
              }
              if (showTitle || showTooltip || showAllTip) {
                tfOns.onMouseenter = (evnt) => {
                  if (showTitle) {
                    updateCellTitle(evnt.currentTarget, column);
                  } else if (showTooltip || showAllTip) {
                    $xetable.triggerFooterTooltipEvent(evnt, cellParams);
                  }
                };
              }
              if (showTooltip || showAllTip) {
                tfOns.onMouseleave = (evnt) => {
                  if (showTooltip || showAllTip) {
                    $xetable.handleTargetLeaveEvent(evnt);
                  }
                };
              }
              tfOns.onClick = (evnt) => {
                $xetable.dispatchEvent("footer-cell-click", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
              };
              tfOns.onDblclick = (evnt) => {
                $xetable.dispatchEvent("footer-cell-dblclick", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
              };
              if (mergeFooterList.length) {
                const spanRest = mergeFooterMethod(mergeFooterList, _rowIndex, _columnIndex);
                if (spanRest) {
                  const { rowspan, colspan } = spanRest;
                  if (!rowspan || !colspan) {
                    return null;
                  }
                  if (rowspan > 1) {
                    attrs.rowspan = rowspan;
                  }
                  if (colspan > 1) {
                    attrs.colspan = colspan;
                  }
                }
              } else if (footerSpanMethod) {
                const { rowspan = 1, colspan = 1 } = footerSpanMethod(cellParams) || {};
                if (!rowspan || !colspan) {
                  return null;
                }
                if (rowspan > 1) {
                  attrs.rowspan = rowspan;
                }
                if (colspan > 1) {
                  attrs.colspan = colspan;
                }
              }
              return h("td", Object.assign(Object.assign(Object.assign(Object.assign({ class: ["vxe-footer--column", column.id, {
                [`col--${footAlign}`]: footAlign,
                [`col--${type}`]: type,
                "col--last": $columnIndex === tableColumn.length - 1,
                "fixed--hidden": fixedHiddenColumn,
                "col--ellipsis": hasEllipsis,
                "col--current": currentColumn === column
              }, getPropClass(footerClassName, cellParams), getPropClass(footerCellClassName, cellParams)] }, attrs), { style: footerCellStyle ? import_xe_utils40.default.isFunction(footerCellStyle) ? footerCellStyle(cellParams) : footerCellStyle : null }), tfOns), { key: columnKey || columnOpts.useKey ? column.id : $columnIndex }), [
                h("div", {
                  class: ["vxe-cell", {
                    "c--title": showTitle,
                    "c--tooltip": showTooltip,
                    "c--ellipsis": showEllipsis
                  }]
                }, column.renderFooter(cellParams))
              ]);
            }).concat(scrollbarWidth ? [
              h("td", {
                class: "vxe-footer--gutter col--gutter"
              })
            ] : []));
          }))
        ])
      ]);
    };
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/props.js
var props_default = {
  /** 基本属性 */
  id: String,
  // 数据
  data: Array,
  // 表格的高度
  height: [Number, String],
  // 表格的最小高度
  minHeight: { type: [Number, String], default: () => conf_default.table.minHeight },
  // 表格的最大高度
  maxHeight: [Number, String],
  // 已废弃，被 column-config.resizable 替换
  resizable: { type: Boolean, default: () => conf_default.table.resizable },
  // 是否带有斑马纹
  stripe: { type: Boolean, default: () => conf_default.table.stripe },
  // 是否带有边框
  border: { type: [Boolean, String], default: () => conf_default.table.border },
  // 是否圆角边框
  round: { type: Boolean, default: () => conf_default.table.round },
  // 表格的尺寸
  size: { type: String, default: () => conf_default.table.size || conf_default.size },
  // 列的宽度是否自撑开（可能会被废弃的参数，不要使用）
  fit: { type: Boolean, default: () => conf_default.table.fit },
  // 表格是否加载中
  loading: Boolean,
  // 所有的列对其方式
  align: { type: String, default: () => conf_default.table.align },
  // 所有的表头列的对齐方式
  headerAlign: { type: String, default: () => conf_default.table.headerAlign },
  // 所有的表尾列的对齐方式
  footerAlign: { type: String, default: () => conf_default.table.footerAlign },
  // 是否显示表头
  showHeader: { type: Boolean, default: () => conf_default.table.showHeader },
  // （即将废弃）是否要高亮当前选中行
  highlightCurrentRow: { type: Boolean, default: () => conf_default.table.highlightCurrentRow },
  // （即将废弃）鼠标移到行是否要高亮显示
  highlightHoverRow: { type: Boolean, default: () => conf_default.table.highlightHoverRow },
  // （即将废弃）是否要高亮当前选中列
  highlightCurrentColumn: { type: Boolean, default: () => conf_default.table.highlightCurrentColumn },
  // （即将废弃）鼠标移到列是否要高亮显示
  highlightHoverColumn: { type: Boolean, default: () => conf_default.table.highlightHoverColumn },
  // （即将废弃）激活单元格编辑时是否高亮显示
  highlightCell: Boolean,
  // 是否显示表尾合计
  showFooter: Boolean,
  // 表尾数据
  footerData: Array,
  // 表尾合计的计算方法
  footerMethod: Function,
  // 给行附加 className
  rowClassName: [String, Function],
  // 给单元格附加 className
  cellClassName: [String, Function],
  // 给表头的行附加 className
  headerRowClassName: [String, Function],
  // 给表头的单元格附加 className
  headerCellClassName: [String, Function],
  // 给表尾的行附加 className
  footerRowClassName: [String, Function],
  // 给表尾的单元格附加 className
  footerCellClassName: [String, Function],
  // 给单元格附加样式
  cellStyle: [Object, Function],
  // 给表头单元格附加样式
  headerCellStyle: [Object, Function],
  // 给表尾单元格附加样式
  footerCellStyle: [Object, Function],
  // 给行附加样式
  rowStyle: [Object, Function],
  // 给表头行附加样式
  headerRowStyle: [Object, Function],
  // 给表尾行附加样式
  footerRowStyle: [Object, Function],
  // 合并指定单元格
  mergeCells: Array,
  // 合并指定的表尾
  mergeFooterItems: Array,
  // 自定义合并行或列的方法
  spanMethod: Function,
  // 表尾合并行或列
  footerSpanMethod: Function,
  // 设置所有内容过长时显示为省略号
  showOverflow: { type: [Boolean, String], default: () => conf_default.table.showOverflow },
  // 设置表头所有内容过长时显示为省略号
  showHeaderOverflow: { type: [Boolean, String], default: () => conf_default.table.showHeaderOverflow },
  // 设置表尾所有内容过长时显示为省略号
  showFooterOverflow: { type: [Boolean, String], default: () => conf_default.table.showFooterOverflow },
  /** 高级属性 */
  // （即将废弃）columnKey 已废弃，被 column-config.useKey 替换
  columnKey: Boolean,
  // （即将废弃）rowKey 已废弃，被 row-config.useKey 替换
  rowKey: Boolean,
  // （即将废弃）rowId 已废弃，被 row-config.keyField 替换
  rowId: { type: String, default: () => conf_default.table.rowId },
  zIndex: Number,
  emptyText: { type: String, default: () => conf_default.table.emptyText },
  keepSource: { type: Boolean, default: () => conf_default.table.keepSource },
  // 是否自动监听父容器变化去更新响应式表格宽高
  autoResize: { type: Boolean, default: () => conf_default.table.autoResize },
  // 是否自动根据状态属性去更新响应式表格宽高
  syncResize: [Boolean, String, Number],
  // 响应式布局配置项
  resizeConfig: Object,
  // 列配置信息
  columnConfig: Object,
  // 行配置信息
  rowConfig: Object,
  // 列调整配置项
  resizableConfig: Object,
  // 序号配置项
  seqConfig: Object,
  // 排序配置项
  sortConfig: Object,
  // 筛选配置项
  filterConfig: Object,
  // 单选框配置
  radioConfig: Object,
  // 复选框配置项
  checkboxConfig: Object,
  // tooltip 配置项
  tooltipConfig: Object,
  // 导出配置项
  exportConfig: Object,
  // 导入配置项
  importConfig: Object,
  // 打印配置项
  printConfig: Object,
  // 展开行配置项
  expandConfig: Object,
  // 树形结构配置项
  treeConfig: Object,
  // 快捷菜单配置项
  menuConfig: Object,
  // 鼠标配置项
  mouseConfig: Object,
  // 区域配置项
  areaConfig: Object,
  // 按键配置项
  keyboardConfig: Object,
  // 复制粘/贴配置项
  clipConfig: Object,
  // 查找/替换配置项
  fnrConfig: Object,
  // 编辑配置项
  editConfig: Object,
  // 校验配置项
  validConfig: Object,
  // 校验规则配置项
  editRules: Object,
  // 加载中配置项
  loadingConfig: Object,
  // 空内容渲染配置项
  emptyRender: Object,
  // 自定义列配置项
  customConfig: Object,
  // 横向虚拟滚动配置项
  scrollX: Object,
  // 纵向虚拟滚动配置项
  scrollY: Object,
  // （即将废弃）优化相关
  animat: { type: Boolean, default: () => conf_default.table.animat },
  // （可能会被废弃的参数，不要使用）
  delayHover: { type: Number, default: () => conf_default.table.delayHover },
  // 额外的参数
  params: Object
};

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/emits.js
var emits_default = [
  "update:data",
  "keydown-start",
  "keydown",
  "keydown-end",
  "paste",
  "copy",
  "cut",
  "current-change",
  "radio-change",
  "checkbox-change",
  "checkbox-all",
  "checkbox-range-start",
  "checkbox-range-change",
  "checkbox-range-end",
  "checkbox-range-select",
  "cell-click",
  "cell-dblclick",
  "cell-menu",
  "cell-mouseenter",
  "cell-mouseleave",
  "cell-selected",
  "cell-delete-value",
  "header-cell-click",
  "header-cell-dblclick",
  "header-cell-menu",
  "footer-cell-click",
  "footer-cell-dblclick",
  "footer-cell-menu",
  "clear-merge",
  "sort-change",
  "clear-sort",
  "filter-change",
  "filter-visible",
  "clear-filter",
  "resizable-change",
  "toggle-row-expand",
  "toggle-tree-expand",
  "menu-click",
  "edit-closed",
  "edit-actived",
  "edit-activated",
  "edit-disabled",
  "valid-error",
  "scroll",
  "custom",
  "change-fnr",
  "open-fnr",
  "show-fnr",
  "hide-fnr",
  "fnr-change",
  "fnr-find",
  "fnr-find-all",
  "fnr-replace",
  "fnr-replace-all",
  "cell-area-copy",
  "cell-area-cut",
  "cell-area-paste",
  "cell-area-merge",
  "clear-cell-area-merge",
  "header-cell-area-selection",
  "cell-area-selection-invalid",
  "cell-area-selection-start",
  "cell-area-selection-drag",
  "cell-area-selection-end",
  "cell-area-extension-start",
  "cell-area-extension-drag",
  "cell-area-extension-end",
  "cell-area-selection-all-start",
  "cell-area-selection-all-end",
  "cell-area-arrows-start",
  "cell-area-arrows-end",
  "active-cell-change-start",
  "active-cell-change-end"
];

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/src/table.js
var isWebkit = browse["-webkit"] && !browse.edge;
var resizableStorageKey = "VXE_TABLE_CUSTOM_COLUMN_WIDTH";
var visibleStorageKey = "VXE_TABLE_CUSTOM_COLUMN_VISIBLE";
var fixedStorageKey = "VXE_TABLE_CUSTOM_COLUMN_FIXED";
var sortStorageKey = "VXE_TABLE_CUSTOM_COLUMN_SORT";
var table_default = defineComponent({
  name: "VxeTable",
  props: props_default,
  emits: emits_default,
  setup(props, context) {
    const { slots, emit } = context;
    const hasUseTooltip = VXETable.tooltip;
    const xID = import_xe_utils41.default.uniqueId();
    const computeSize = useSize(props);
    const instance = getCurrentInstance();
    const reactData = reactive({
      // 低性能的静态列
      staticColumns: [],
      // 渲染的列分组
      tableGroupColumn: [],
      // 可视区渲染的列
      tableColumn: [],
      // 渲染中的数据
      tableData: [],
      // 是否启用了横向 X 可视渲染方式加载
      scrollXLoad: false,
      // 是否启用了纵向 Y 可视渲染方式加载
      scrollYLoad: false,
      // 是否存在纵向滚动条
      overflowY: true,
      // 是否存在横向滚动条
      overflowX: false,
      // 纵向滚动条的宽度
      scrollbarWidth: 0,
      // 横向滚动条的高度
      scrollbarHeight: 0,
      // 最后滚动时间戳
      lastScrollTime: 0,
      // 行高
      rowHeight: 0,
      // 表格父容器的高度
      parentHeight: 0,
      // 是否使用分组表头
      isGroup: false,
      isAllOverflow: false,
      // 复选框属性，是否全选
      isAllSelected: false,
      // 复选框属性，有选中且非全选状态
      isIndeterminate: false,
      // 复选框属性，已选中的行集合
      selectCheckboxMaps: {},
      // 当前行
      currentRow: null,
      // 单选框属性，选中列
      currentColumn: null,
      // 单选框属性，选中行
      selectRadioRow: null,
      // 表尾合计数据
      footerTableData: [],
      // 展开列信息
      expandColumn: null,
      // 树节点列信息
      treeNodeColumn: null,
      hasFixedColumn: false,
      // 已展开的行集合
      rowExpandedMaps: {},
      // 懒加载中的展开行的集合
      rowExpandLazyLoadedMaps: {},
      // 已展开树节点集合
      treeExpandedMaps: {},
      // 懒加载中的树节点的集合
      treeExpandLazyLoadedMaps: {},
      // 树节点不确定状态的集合
      treeIndeterminateMaps: {},
      // 合并单元格的对象集
      mergeList: [],
      // 合并表尾数据的对象集
      mergeFooterList: [],
      // 刷新列标识，当列筛选被改变时，触发表格刷新数据
      upDataFlag: 0,
      // 刷新列标识，当列的特定属性被改变时，触发表格刷新列
      reColumnFlag: 0,
      // 已标记的对象集
      pendingRowMaps: {},
      // 已标记的行
      pendingRowList: [],
      // 初始化标识
      initStore: {
        filter: false,
        import: false,
        export: false,
        custom: false
      },
      // 自定义列相关的信息
      customStore: {
        btnEl: null,
        isAll: false,
        isIndeterminate: false,
        activeBtn: false,
        activeWrapper: false,
        visible: false,
        maxHeight: 0
      },
      customColumnList: [],
      // 当前选中的筛选列
      filterStore: {
        isAllSelected: false,
        isIndeterminate: false,
        style: null,
        options: [],
        column: null,
        multiple: false,
        visible: false,
        maxHeight: null
      },
      // 存放列相关的信息
      columnStore: {
        leftList: [],
        centerList: [],
        rightList: [],
        resizeList: [],
        pxList: [],
        pxMinList: [],
        scaleList: [],
        scaleMinList: [],
        autoList: []
      },
      // 存放快捷菜单的信息
      ctxMenuStore: {
        selected: null,
        visible: false,
        showChild: false,
        selectChild: null,
        list: [],
        style: null
      },
      // 存放可编辑相关信息
      editStore: {
        indexs: {
          columns: []
        },
        titles: {
          columns: []
        },
        // 选中源
        selected: {
          row: null,
          column: null
        },
        // 已复制源
        copyed: {
          cut: false,
          rows: [],
          columns: []
        },
        // 激活
        actived: {
          row: null,
          column: null
        },
        // 当前被强制聚焦单元格，只会在鼠标点击后算聚焦
        focused: {
          row: null,
          column: null
        },
        insertMaps: {},
        removeMaps: {}
      },
      // 存放 tooltip 相关信息
      tooltipStore: {
        row: null,
        column: null,
        content: null,
        visible: false
      },
      // 存放数据校验相关信息
      validStore: {
        visible: false
      },
      validErrorMaps: {},
      // 导入相关信息
      importStore: {
        inited: false,
        file: null,
        type: "",
        modeList: [],
        typeList: [],
        filename: "",
        visible: false
      },
      importParams: {
        mode: "",
        types: null,
        message: true
      },
      // 导出相关信息
      exportStore: {
        inited: false,
        name: "",
        modeList: [],
        typeList: [],
        columns: [],
        isPrint: false,
        hasFooter: false,
        hasMerge: false,
        hasTree: false,
        hasColgroup: false,
        visible: false
      },
      exportParams: {
        filename: "",
        sheetName: "",
        mode: "",
        type: "",
        isColgroup: false,
        isMerge: false,
        isAllExpand: false,
        useStyle: false,
        original: false,
        message: true,
        isHeader: false,
        isFooter: false
      },
      scrollVMLoading: false,
      _isResize: false
    });
    const internalData = {
      tZindex: 0,
      elemStore: {},
      // 存放横向 X 虚拟滚动相关的信息
      scrollXStore: {
        offsetSize: 0,
        visibleSize: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 存放纵向 Y 虚拟滚动相关信息
      scrollYStore: {
        rowHeight: 0,
        offsetSize: 0,
        visibleSize: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 表格宽度
      tableWidth: 0,
      // 表格高度
      tableHeight: 0,
      // 表头高度
      headerHeight: 0,
      // 表尾高度
      footerHeight: 0,
      customHeight: 0,
      customMinHeight: 0,
      customMaxHeight: 0,
      // 当前 hover 行
      hoverRow: null,
      // 最后滚动位置
      lastScrollLeft: 0,
      lastScrollTop: 0,
      // 单选框属性，已选中保留的行
      radioReserveRow: null,
      // 复选框属性，已选中保留的行集合
      checkboxReserveRowMap: {},
      // 行数据，已展开保留的行集合
      rowExpandedReserveRowMap: {},
      // 树结构数据，已展开保留的行集合
      treeExpandedReserveRowMap: {},
      // 树结构数据，不确定状态的集合
      treeIndeterminateRowMaps: {},
      // 列表完整数据、条件处理后
      tableFullData: [],
      afterFullData: [],
      afterTreeFullData: [],
      // 列表条件处理后数据集合
      afterFullRowMaps: {},
      // 树结构完整数据、条件处理后
      tableFullTreeData: [],
      tableSynchData: [],
      tableSourceData: [],
      // 收集的列配置（带分组）
      collectColumn: [],
      // 完整所有列（不带分组）
      tableFullColumn: [],
      // 渲染所有列
      visibleColumn: [],
      // 总的缓存数据集
      fullAllDataRowIdData: {},
      // 渲染中缓存数据
      sourceDataRowIdData: {},
      fullDataRowIdData: {},
      fullColumnIdData: {},
      fullColumnFieldData: {},
      // 列选取状态
      columnStatusMaps: {},
      // 行选取状态
      rowStatusMaps: {},
      inited: false,
      tooltipTimeout: null,
      initStatus: false,
      isActivated: false
    };
    let tableMethods = {};
    let tablePrivateMethods = {};
    const refElem = ref();
    const refTooltip = ref();
    const refCommTooltip = ref();
    const refValidTooltip = ref();
    const refTableMenu = ref();
    const refTableFilter = ref();
    const refTableCustom = ref();
    const refTableHeader = ref();
    const refTableBody = ref();
    const refTableFooter = ref();
    const refTableLeftHeader = ref();
    const refTableLeftBody = ref();
    const refTableLeftFooter = ref();
    const refTableRightHeader = ref();
    const refTableRightBody = ref();
    const refTableRightFooter = ref();
    const refLeftContainer = ref();
    const refRightContainer = ref();
    const refCellResizeBar = ref();
    const refEmptyPlaceholder = ref();
    const $xegrid = inject("$xegrid", null);
    let $xetoolbar;
    const computeValidOpts = computed(() => {
      return Object.assign({}, conf_default.table.validConfig, props.validConfig);
    });
    const computeSXOpts = computed(() => {
      return Object.assign({}, conf_default.table.scrollX, props.scrollX);
    });
    const computeSYOpts = computed(() => {
      return Object.assign({}, conf_default.table.scrollY, props.scrollY);
    });
    const computeRowHeightMaps = computed(() => {
      return {
        default: 48,
        medium: 44,
        small: 40,
        mini: 36
      };
    });
    const computeColumnOpts = computed(() => {
      return Object.assign({}, conf_default.table.columnConfig, props.columnConfig);
    });
    const computeRowOpts = computed(() => {
      return Object.assign({}, conf_default.table.rowConfig, props.rowConfig);
    });
    const computeResizeleOpts = computed(() => {
      return Object.assign({}, conf_default.table.resizeConfig, props.resizeConfig);
    });
    const computeResizableOpts = computed(() => {
      return Object.assign({}, conf_default.table.resizableConfig, props.resizableConfig);
    });
    const computeSeqOpts = computed(() => {
      return Object.assign({ startIndex: 0 }, conf_default.table.seqConfig, props.seqConfig);
    });
    const computeRadioOpts = computed(() => {
      return Object.assign({}, conf_default.table.radioConfig, props.radioConfig);
    });
    const computeCheckboxOpts = computed(() => {
      return Object.assign({}, conf_default.table.checkboxConfig, props.checkboxConfig);
    });
    let computeTooltipOpts = ref();
    computeTooltipOpts = computed(() => {
      return Object.assign({}, conf_default.tooltip, conf_default.table.tooltipConfig, props.tooltipConfig);
    });
    const computeTipConfig = computed(() => {
      const tooltipOpts = computeTooltipOpts.value;
      return Object.assign({}, tooltipOpts);
    });
    const computeValidTipOpts = computed(() => {
      const tooltipOpts = computeTooltipOpts.value;
      return Object.assign({ isArrow: false }, tooltipOpts);
    });
    const computeEditOpts = computed(() => {
      return Object.assign({}, conf_default.table.editConfig, props.editConfig);
    });
    const computeSortOpts = computed(() => {
      return Object.assign({ orders: ["asc", "desc", null] }, conf_default.table.sortConfig, props.sortConfig);
    });
    const computeFilterOpts = computed(() => {
      return Object.assign({}, conf_default.table.filterConfig, props.filterConfig);
    });
    const computeMouseOpts = computed(() => {
      return Object.assign({}, conf_default.table.mouseConfig, props.mouseConfig);
    });
    const computeAreaOpts = computed(() => {
      return Object.assign({}, conf_default.table.areaConfig, props.areaConfig);
    });
    const computeKeyboardOpts = computed(() => {
      return Object.assign({}, conf_default.table.keyboardConfig, props.keyboardConfig);
    });
    const computeClipOpts = computed(() => {
      return Object.assign({}, conf_default.table.clipConfig, props.clipConfig);
    });
    const computeFNROpts = computed(() => {
      return Object.assign({}, conf_default.table.fnrConfig, props.fnrConfig);
    });
    const computeMenuOpts = computed(() => {
      return Object.assign({}, conf_default.table.menuConfig, props.menuConfig);
    });
    const computeHeaderMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const headerOpts = menuOpts.header;
      return headerOpts && headerOpts.options ? headerOpts.options : [];
    });
    const computeBodyMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const bodyOpts = menuOpts.body;
      return bodyOpts && bodyOpts.options ? bodyOpts.options : [];
    });
    const computeFooterMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const footerOpts = menuOpts.footer;
      return footerOpts && footerOpts.options ? footerOpts.options : [];
    });
    const computeIsMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const headerMenu = computeHeaderMenu.value;
      const bodyMenu = computeBodyMenu.value;
      const footerMenu = computeFooterMenu.value;
      return !!(props.menuConfig && isEnableConf(menuOpts) && (headerMenu.length || bodyMenu.length || footerMenu.length));
    });
    const computeMenuList = computed(() => {
      const { ctxMenuStore } = reactData;
      const rest = [];
      ctxMenuStore.list.forEach((list) => {
        list.forEach((item) => {
          rest.push(item);
        });
      });
      return rest;
    });
    const computeExportOpts = computed(() => {
      return Object.assign({}, conf_default.table.exportConfig, props.exportConfig);
    });
    const computeImportOpts = computed(() => {
      return Object.assign({}, conf_default.table.importConfig, props.importConfig);
    });
    const computePrintOpts = computed(() => {
      return Object.assign({}, conf_default.table.printConfig, props.printConfig);
    });
    const computeExpandOpts = computed(() => {
      return Object.assign({}, conf_default.table.expandConfig, props.expandConfig);
    });
    const computeTreeOpts = computed(() => {
      return Object.assign({}, conf_default.table.treeConfig, props.treeConfig);
    });
    const computeEmptyOpts = computed(() => {
      return Object.assign({}, conf_default.table.emptyRender, props.emptyRender);
    });
    const computeLoadingOpts = computed(() => {
      return Object.assign({}, conf_default.table.loadingConfig, props.loadingConfig);
    });
    const computeCellOffsetWidth = computed(() => {
      return props.border ? Math.max(2, Math.ceil(reactData.scrollbarWidth / reactData.tableColumn.length)) : 1;
    });
    const computeCustomOpts = computed(() => {
      return Object.assign({}, conf_default.table.customConfig, props.customConfig);
    });
    const computeFixedColumnSize = computed(() => {
      const { collectColumn } = internalData;
      let fixedSize = 0;
      collectColumn.forEach((column) => {
        if (column.fixed) {
          fixedSize++;
        }
      });
      return fixedSize;
    });
    const computeIsMaxFixedColumn = computed(() => {
      const fixedColumnSize = computeFixedColumnSize.value;
      const columnOpts = computeColumnOpts.value;
      const { maxFixedSize } = columnOpts;
      if (maxFixedSize) {
        return fixedColumnSize >= maxFixedSize;
      }
      return false;
    });
    const computeTableBorder = computed(() => {
      const { border } = props;
      if (border === true) {
        return "full";
      }
      if (border) {
        return border;
      }
      return "default";
    });
    const computeIsAllCheckboxDisabled = computed(() => {
      const { treeConfig } = props;
      const { tableData } = reactData;
      const { tableFullData } = internalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const { strict, checkMethod } = checkboxOpts;
      if (strict) {
        if (tableData.length || tableFullData.length) {
          if (checkMethod) {
            if (treeConfig) {
            }
            return tableFullData.every((row) => !checkMethod({ row }));
          }
          return false;
        }
        return true;
      }
      return false;
    });
    const refMaps = {
      refElem,
      refTooltip,
      refValidTooltip,
      refTableFilter,
      refTableCustom,
      refTableMenu,
      refTableHeader,
      refTableBody,
      refTableFooter,
      refTableLeftHeader,
      refTableLeftBody,
      refTableLeftFooter,
      refTableRightHeader,
      refTableRightBody,
      refTableRightFooter,
      refLeftContainer,
      refRightContainer,
      refCellResizeBar
    };
    const computeMaps = {
      computeSize,
      computeValidOpts,
      computeSXOpts,
      computeSYOpts,
      computeColumnOpts,
      computeRowOpts,
      computeResizeleOpts,
      computeResizableOpts,
      computeSeqOpts,
      computeRadioOpts,
      computeCheckboxOpts,
      computeTooltipOpts,
      computeEditOpts,
      computeSortOpts,
      computeFilterOpts,
      computeMouseOpts,
      computeAreaOpts,
      computeKeyboardOpts,
      computeClipOpts,
      computeFNROpts,
      computeHeaderMenu,
      computeBodyMenu,
      computeFooterMenu,
      computeIsMenu,
      computeMenuOpts,
      computeExportOpts,
      computeImportOpts,
      computePrintOpts,
      computeExpandOpts,
      computeTreeOpts,
      computeEmptyOpts,
      computeLoadingOpts,
      computeCustomOpts,
      computeFixedColumnSize,
      computeIsMaxFixedColumn,
      computeIsAllCheckboxDisabled
    };
    const $xetable = {
      xID,
      props,
      context,
      instance,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps,
      xegrid: $xegrid
    };
    const eqCellValue = (row1, row2, field) => {
      const val1 = import_xe_utils41.default.get(row1, field);
      const val2 = import_xe_utils41.default.get(row2, field);
      if (eqEmptyValue(val1) && eqEmptyValue(val2)) {
        return true;
      }
      if (import_xe_utils41.default.isString(val1) || import_xe_utils41.default.isNumber(val1)) {
        return "" + val1 === "" + val2;
      }
      return import_xe_utils41.default.isEqual(val1, val2);
    };
    const getNextSortOrder = (column) => {
      const sortOpts = computeSortOpts.value;
      const { orders } = sortOpts;
      const currOrder = column.order || null;
      const oIndex = orders.indexOf(currOrder) + 1;
      return orders[oIndex < orders.length ? oIndex : 0];
    };
    const getCustomStorageMap = (key) => {
      const version2 = conf_default.version;
      const rest = import_xe_utils41.default.toStringJSON(localStorage.getItem(key) || "");
      return rest && rest._v === version2 ? rest : { _v: version2 };
    };
    const getRecoverRowMaps = (keyMaps) => {
      const { fullAllDataRowIdData } = internalData;
      const restKeys = {};
      import_xe_utils41.default.each(keyMaps, (row, rowid) => {
        if (fullAllDataRowIdData[rowid]) {
          restKeys[rowid] = row;
        }
      });
      return restKeys;
    };
    const handleReserveRow = (reserveRowMap) => {
      const { fullDataRowIdData } = internalData;
      const reserveList = [];
      import_xe_utils41.default.each(reserveRowMap, (item, rowid) => {
        if (fullDataRowIdData[rowid] && $xetable.findRowIndexOf(reserveList, fullDataRowIdData[rowid].row) === -1) {
          reserveList.push(fullDataRowIdData[rowid].row);
        }
      });
      return reserveList;
    };
    const computeVirtualX = () => {
      const { visibleColumn } = internalData;
      const tableBody = refTableBody.value;
      const tableBodyElem = tableBody ? tableBody.$el : null;
      if (tableBodyElem) {
        const { scrollLeft, clientWidth } = tableBodyElem;
        const endWidth = scrollLeft + clientWidth;
        let toVisibleIndex = -1;
        let cWidth = 0;
        let visibleSize = 0;
        for (let colIndex = 0, colLen = visibleColumn.length; colIndex < colLen; colIndex++) {
          cWidth += visibleColumn[colIndex].renderWidth;
          if (toVisibleIndex === -1 && scrollLeft < cWidth) {
            toVisibleIndex = colIndex;
          }
          if (toVisibleIndex >= 0) {
            visibleSize++;
            if (cWidth > endWidth) {
              break;
            }
          }
        }
        return { toVisibleIndex: Math.max(0, toVisibleIndex), visibleSize: Math.max(8, visibleSize) };
      }
      return { toVisibleIndex: 0, visibleSize: 8 };
    };
    const computeVirtualY = () => {
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableBodyElem = tableBody ? tableBody.$el : null;
      const vSize = computeSize.value;
      const rowHeightMaps = computeRowHeightMaps.value;
      if (tableBodyElem) {
        const tableHeaderElem = tableHeader ? tableHeader.$el : null;
        let rowHeight = 0;
        let firstTrElem;
        firstTrElem = tableBodyElem.querySelector("tr");
        if (!firstTrElem && tableHeaderElem) {
          firstTrElem = tableHeaderElem.querySelector("tr");
        }
        if (firstTrElem) {
          rowHeight = firstTrElem.clientHeight;
        }
        if (!rowHeight) {
          rowHeight = rowHeightMaps[vSize || "default"];
        }
        const visibleSize = Math.max(8, Math.ceil(tableBodyElem.clientHeight / rowHeight) + 2);
        return { rowHeight, visibleSize };
      }
      return { rowHeight: 0, visibleSize: 8 };
    };
    const calculateMergerOffserIndex = (list, offsetItem, type) => {
      for (let mcIndex = 0, len = list.length; mcIndex < len; mcIndex++) {
        const mergeItem = list[mcIndex];
        const { startIndex, endIndex } = offsetItem;
        const mergeStartIndex = mergeItem[type];
        const mergeSpanNumber = mergeItem[type + "span"];
        const mergeEndIndex = mergeStartIndex + mergeSpanNumber;
        if (mergeStartIndex < startIndex && startIndex < mergeEndIndex) {
          offsetItem.startIndex = mergeStartIndex;
        }
        if (mergeStartIndex < endIndex && endIndex < mergeEndIndex) {
          offsetItem.endIndex = mergeEndIndex;
        }
        if (offsetItem.startIndex !== startIndex || offsetItem.endIndex !== endIndex) {
          mcIndex = -1;
        }
      }
    };
    const setMerges = (merges, mList, rowList) => {
      if (merges) {
        const { treeConfig } = props;
        const { visibleColumn } = internalData;
        if (!import_xe_utils41.default.isArray(merges)) {
          merges = [merges];
        }
        if (treeConfig && merges.length) {
          errLog("vxe.error.noTree", ["merge-cells | merge-footer-items"]);
        }
        merges.forEach((item) => {
          let { row, col, rowspan, colspan } = item;
          if (rowList && import_xe_utils41.default.isNumber(row)) {
            row = rowList[row];
          }
          if (import_xe_utils41.default.isNumber(col)) {
            col = visibleColumn[col];
          }
          if ((rowList ? row : import_xe_utils41.default.isNumber(row)) && col && (rowspan || colspan)) {
            rowspan = import_xe_utils41.default.toNumber(rowspan) || 1;
            colspan = import_xe_utils41.default.toNumber(colspan) || 1;
            if (rowspan > 1 || colspan > 1) {
              const mcIndex = import_xe_utils41.default.findIndexOf(mList, (item2) => (item2._row === row || getRowid($xetable, item2._row) === getRowid($xetable, row)) && (item2._col.id === col || item2._col.id === col.id));
              const mergeItem = mList[mcIndex];
              if (mergeItem) {
                mergeItem.rowspan = rowspan;
                mergeItem.colspan = colspan;
                mergeItem._rowspan = rowspan;
                mergeItem._colspan = colspan;
              } else {
                const mergeRowIndex = rowList ? $xetable.findRowIndexOf(rowList, row) : row;
                const mergeColIndex = tableMethods.getVTColumnIndex(col);
                mList.push({
                  row: mergeRowIndex,
                  col: mergeColIndex,
                  rowspan,
                  colspan,
                  _row: row,
                  _col: col,
                  _rowspan: rowspan,
                  _colspan: colspan
                });
              }
            }
          }
        });
      }
    };
    const removeMerges = (merges, mList, rowList) => {
      const rest = [];
      if (merges) {
        const { treeConfig } = props;
        const { visibleColumn } = internalData;
        if (!import_xe_utils41.default.isArray(merges)) {
          merges = [merges];
        }
        if (treeConfig && merges.length) {
          errLog("vxe.error.noTree", ["merge-cells | merge-footer-items"]);
        }
        merges.forEach((item) => {
          let { row, col } = item;
          if (rowList && import_xe_utils41.default.isNumber(row)) {
            row = rowList[row];
          }
          if (import_xe_utils41.default.isNumber(col)) {
            col = visibleColumn[col];
          }
          const mcIndex = import_xe_utils41.default.findIndexOf(mList, (item2) => (item2._row === row || getRowid($xetable, item2._row) === getRowid($xetable, row)) && (item2._col.id === col || item2._col.id === col.id));
          if (mcIndex > -1) {
            const rItems = mList.splice(mcIndex, 1);
            rest.push(rItems[0]);
          }
        });
      }
      return rest;
    };
    const clearAllSort = () => {
      const { tableFullColumn } = internalData;
      tableFullColumn.forEach((column) => {
        column.order = null;
      });
    };
    const calcHeight = (key) => {
      const { parentHeight } = reactData;
      const val = props[key];
      let num = 0;
      if (val) {
        if (val === "100%" || val === "auto") {
          num = parentHeight;
        } else {
          const excludeHeight = $xetable.getExcludeHeight();
          if (isScale(val)) {
            num = Math.floor((import_xe_utils41.default.toInteger(val) || 1) / 100 * parentHeight);
          } else {
            num = import_xe_utils41.default.toNumber(val);
          }
          num = Math.max(40, num - excludeHeight);
        }
      }
      return num;
    };
    const restoreCustomStorage = () => {
      const { id, customConfig } = props;
      const customOpts = computeCustomOpts.value;
      const { storage } = customOpts;
      const isAllCustom = storage === true;
      const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
      const isCustomResizable = isAllCustom || storageOpts.resizable;
      const isCustomVisible = isAllCustom || storageOpts.visible;
      const isCustomFixed = isAllCustom || storageOpts.fixed;
      const isCustomSort = isAllCustom || storageOpts.sort;
      if (customConfig && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomSort)) {
        const customMap = {};
        if (!id) {
          errLog("vxe.error.reqProp", ["id"]);
          return;
        }
        if (isCustomResizable) {
          const columnWidthStorage = getCustomStorageMap(resizableStorageKey)[id];
          if (columnWidthStorage) {
            import_xe_utils41.default.each(columnWidthStorage, (resizeWidth, colKey) => {
              customMap[colKey] = { resizeWidth };
            });
          }
        }
        if (isCustomFixed) {
          const columnFixedStorage = getCustomStorageMap(fixedStorageKey)[id];
          if (columnFixedStorage) {
            const colFixeds = columnFixedStorage.split(",");
            colFixeds.forEach((fixConf) => {
              const [colKey, fixed] = fixConf.split("|");
              if (customMap[colKey]) {
                customMap[colKey].fixed = fixed;
              } else {
                customMap[colKey] = { fixed };
              }
            });
          }
        }
        let hasCustomSort = false;
        if (isCustomSort) {
          const columnSortStorage = getCustomStorageMap(sortStorageKey)[id];
          if (columnSortStorage) {
            import_xe_utils41.default.each(columnSortStorage, (renderSortNumber, colKey) => {
              if (customMap[colKey]) {
                customMap[colKey].renderSortNumber = renderSortNumber;
              } else {
                customMap[colKey] = { renderSortNumber };
              }
              if (!hasCustomSort) {
                hasCustomSort = true;
              }
            });
          }
        }
        if (isCustomVisible) {
          const columnVisibleStorage = getCustomStorageMap(visibleStorageKey)[id];
          if (columnVisibleStorage) {
            const colVisibles = columnVisibleStorage.split("|");
            const colHides = colVisibles[0] ? colVisibles[0].split(",") : [];
            const colShows = colVisibles[1] ? colVisibles[1].split(",") : [];
            colHides.forEach((colKey) => {
              if (customMap[colKey]) {
                customMap[colKey].visible = false;
              } else {
                customMap[colKey] = { visible: false };
              }
            });
            colShows.forEach((colKey) => {
              if (customMap[colKey]) {
                customMap[colKey].visible = true;
              } else {
                customMap[colKey] = { visible: true };
              }
            });
          }
        }
        let { collectColumn } = internalData;
        const keyMap = {};
        import_xe_utils41.default.eachTree(collectColumn, (column) => {
          const colKey = column.getKey();
          if (colKey) {
            keyMap[colKey] = column;
          }
        });
        import_xe_utils41.default.each(customMap, ({ visible, resizeWidth, fixed, renderSortNumber }, colKey) => {
          const column = keyMap[colKey];
          if (column) {
            if (import_xe_utils41.default.isNumber(resizeWidth)) {
              column.resizeWidth = resizeWidth;
            }
            if (import_xe_utils41.default.isBoolean(visible)) {
              column.visible = visible;
            }
            if (fixed) {
              column.fixed = fixed;
            }
            if (renderSortNumber) {
              column.renderSortNumber = Number(renderSortNumber);
            }
          }
        });
        if (hasCustomSort) {
          collectColumn = import_xe_utils41.default.orderBy(collectColumn, "renderSortNumber");
          internalData.collectColumn = collectColumn;
          internalData.tableFullColumn = getColumnList(collectColumn);
        }
      }
    };
    const cacheColumnMap = () => {
      const { tableFullColumn, collectColumn } = internalData;
      const fullColumnIdData = internalData.fullColumnIdData = {};
      const fullColumnFieldData = internalData.fullColumnFieldData = {};
      const mouseOpts = computeMouseOpts.value;
      const columnOpts = computeColumnOpts.value;
      const rowOpts = computeRowOpts.value;
      const isGroup = collectColumn.some(hasChildrenList);
      let isAllOverflow = !!props.showOverflow;
      let expandColumn;
      let treeNodeColumn;
      let checkboxColumn;
      let radioColumn;
      let htmlColumn;
      let hasFixed;
      const handleFunc = (column, index, items, path, parent) => {
        const { id: colid, field, fixed, type, treeNode } = column;
        const rest = { column, colid, index, items, parent };
        if (field) {
          if (true) {
            if (fullColumnFieldData[field]) {
              warnLog("vxe.error.colRepet", ["field", field]);
            }
          }
          fullColumnFieldData[field] = rest;
        }
        if (!hasFixed && fixed) {
          hasFixed = fixed;
        }
        if (!htmlColumn && type === "html") {
          htmlColumn = column;
        }
        if (treeNode) {
          if (true) {
            if (treeNodeColumn) {
              warnLog("vxe.error.colRepet", ["tree-node", treeNode]);
            }
          }
          if (!treeNodeColumn) {
            treeNodeColumn = column;
          }
        } else if (type === "expand") {
          if (true) {
            if (expandColumn) {
              warnLog("vxe.error.colRepet", ["type", type]);
            }
          }
          if (!expandColumn) {
            expandColumn = column;
          }
        }
        if (true) {
          if (type === "checkbox") {
            if (checkboxColumn) {
              warnLog("vxe.error.colRepet", ["type", type]);
            }
            if (!checkboxColumn) {
              checkboxColumn = column;
            }
          } else if (type === "radio") {
            if (radioColumn) {
              warnLog("vxe.error.colRepet", ["type", type]);
            }
            if (!radioColumn) {
              radioColumn = column;
            }
          }
        }
        if (isAllOverflow && column.showOverflow === false) {
          isAllOverflow = false;
        }
        if (fullColumnIdData[colid]) {
          errLog("vxe.error.colRepet", ["colId", colid]);
        }
        fullColumnIdData[colid] = rest;
      };
      if (isGroup) {
        import_xe_utils41.default.eachTree(collectColumn, (column, index, items, path, parent, nodes) => {
          column.level = nodes.length;
          handleFunc(column, index, items, path, parent);
        });
      } else {
        tableFullColumn.forEach(handleFunc);
      }
      if (true) {
        if (expandColumn && mouseOpts.area) {
          errLog("vxe.error.errConflicts", ["mouse-config.area", "column.type=expand"]);
        }
      }
      if (true) {
        if (htmlColumn) {
          if (!columnOpts.useKey) {
            errLog("vxe.error.reqProp", ["column-config.useKey", "column.type=html"]);
          }
          if (!rowOpts.useKey) {
            errLog("vxe.error.reqProp", ["row-config.useKey", "column.type=html"]);
          }
        }
      }
      reactData.isGroup = isGroup;
      reactData.treeNodeColumn = treeNodeColumn;
      reactData.expandColumn = expandColumn;
      reactData.isAllOverflow = isAllOverflow;
    };
    const updateHeight = () => {
      internalData.customHeight = calcHeight("height");
      internalData.customMinHeight = calcHeight("minHeight");
      internalData.customMaxHeight = calcHeight("maxHeight");
    };
    const autoCellWidth = () => {
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableFooter = refTableFooter.value;
      const bodyElem = tableBody ? tableBody.$el : null;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = tableFooter ? tableFooter.$el : null;
      if (!bodyElem) {
        return;
      }
      let tableWidth = 0;
      const minCellWidth = 40;
      const bodyWidth = bodyElem.clientWidth - 1;
      let remainWidth = bodyWidth;
      let meanWidth = remainWidth / 100;
      const { fit } = props;
      const { columnStore } = reactData;
      const { resizeList, pxMinList, pxList, scaleList, scaleMinList, autoList } = columnStore;
      pxMinList.forEach((column) => {
        const minWidth = import_xe_utils41.default.toInteger(column.minWidth);
        tableWidth += minWidth;
        column.renderWidth = minWidth;
      });
      scaleMinList.forEach((column) => {
        const scaleWidth = Math.floor(import_xe_utils41.default.toInteger(column.minWidth) * meanWidth);
        tableWidth += scaleWidth;
        column.renderWidth = scaleWidth;
      });
      scaleList.forEach((column) => {
        const scaleWidth = Math.floor(import_xe_utils41.default.toInteger(column.width) * meanWidth);
        tableWidth += scaleWidth;
        column.renderWidth = scaleWidth;
      });
      pxList.forEach((column) => {
        const width = import_xe_utils41.default.toInteger(column.width);
        tableWidth += width;
        column.renderWidth = width;
      });
      resizeList.forEach((column) => {
        const width = import_xe_utils41.default.toInteger(column.resizeWidth);
        tableWidth += width;
        column.renderWidth = width;
      });
      remainWidth -= tableWidth;
      meanWidth = remainWidth > 0 ? Math.floor(remainWidth / (scaleMinList.length + pxMinList.length + autoList.length)) : 0;
      if (fit) {
        if (remainWidth > 0) {
          scaleMinList.concat(pxMinList).forEach((column) => {
            tableWidth += meanWidth;
            column.renderWidth += meanWidth;
          });
        }
      } else {
        meanWidth = minCellWidth;
      }
      autoList.forEach((column) => {
        const width = Math.max(meanWidth, minCellWidth);
        column.renderWidth = width;
        tableWidth += width;
      });
      if (fit) {
        const dynamicList = scaleList.concat(scaleMinList).concat(pxMinList).concat(autoList);
        let dynamicSize = dynamicList.length - 1;
        if (dynamicSize > 0) {
          let odiffer = bodyWidth - tableWidth;
          if (odiffer > 0) {
            while (odiffer > 0 && dynamicSize >= 0) {
              odiffer--;
              dynamicList[dynamicSize--].renderWidth++;
            }
            tableWidth = bodyWidth;
          }
        }
      }
      const tableHeight = bodyElem.offsetHeight;
      const overflowY = bodyElem.scrollHeight > bodyElem.clientHeight;
      let scrollbarWidth = 0;
      if (overflowY) {
        scrollbarWidth = Math.max(bodyElem.offsetWidth - bodyElem.clientWidth, 0);
      }
      reactData.scrollbarWidth = scrollbarWidth;
      reactData.overflowY = overflowY;
      internalData.tableWidth = tableWidth;
      internalData.tableHeight = tableHeight;
      let headerHeight = 0;
      if (headerElem) {
        headerHeight = headerElem.clientHeight;
        nextTick(() => {
          if (headerElem && bodyElem && headerElem.scrollLeft !== bodyElem.scrollLeft) {
            headerElem.scrollLeft = bodyElem.scrollLeft;
          }
        });
      }
      internalData.headerHeight = headerHeight;
      let overflowX = false;
      let footerHeight = 0;
      let scrollbarHeight = 0;
      if (footerElem) {
        footerHeight = footerElem.offsetHeight;
        overflowX = tableWidth > footerElem.clientWidth;
        if (overflowX) {
          scrollbarHeight = Math.max(footerHeight - footerElem.clientHeight, 0);
        }
      } else {
        overflowX = tableWidth > bodyWidth;
        if (overflowX) {
          scrollbarHeight = Math.max(tableHeight - bodyElem.clientHeight, 0);
        }
      }
      internalData.footerHeight = footerHeight;
      reactData.overflowX = overflowX;
      reactData.scrollbarHeight = scrollbarHeight;
      updateHeight();
      reactData.parentHeight = Math.max(internalData.headerHeight + footerHeight + 20, tablePrivateMethods.getParentHeight());
      if (overflowX) {
        tablePrivateMethods.checkScrolling();
      }
    };
    const getOrderField = (column) => {
      const { sortBy, sortType } = column;
      return (row) => {
        let cellValue;
        if (sortBy) {
          cellValue = import_xe_utils41.default.isFunction(sortBy) ? sortBy({ row, column }) : import_xe_utils41.default.get(row, sortBy);
        } else {
          cellValue = tablePrivateMethods.getCellLabel(row, column);
        }
        if (!sortType || sortType === "auto") {
          return isNaN(cellValue) ? cellValue : import_xe_utils41.default.toNumber(cellValue);
        } else if (sortType === "number") {
          return import_xe_utils41.default.toNumber(cellValue);
        } else if (sortType === "string") {
          return import_xe_utils41.default.toValueString(cellValue);
        }
        return cellValue;
      };
    };
    const updateAfterDataIndex = () => {
      const { treeConfig } = props;
      const { afterFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const { afterTreeFullData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const fullMaps = {};
      if (treeConfig) {
        import_xe_utils41.default.eachTree(afterTreeFullData, (row, index, items, path) => {
          const rowid = getRowid($xetable, row);
          const allrest = fullAllDataRowIdData[rowid];
          const seq = path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("");
          if (allrest) {
            allrest.seq = seq;
            allrest._index = index;
          } else {
            const rest = { row, rowid, seq, index: -1, $index: -1, _index: index, items: [], parent: null, level: 0 };
            fullAllDataRowIdData[rowid] = rest;
            fullDataRowIdData[rowid] = rest;
          }
          fullMaps[rowid] = row;
        }, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });
      } else {
        afterFullData.forEach((row, index) => {
          const rowid = getRowid($xetable, row);
          const allrest = fullAllDataRowIdData[rowid];
          const seq = index + 1;
          if (allrest) {
            allrest.seq = seq;
            allrest._index = index;
          } else {
            const rest = { row, rowid, seq, index: -1, $index: -1, _index: index, items: [], parent: null, level: 0 };
            fullAllDataRowIdData[rowid] = rest;
            fullDataRowIdData[rowid] = rest;
          }
          fullMaps[rowid] = row;
        });
      }
      internalData.afterFullRowMaps = fullMaps;
    };
    const handleVirtualTreeToList = () => {
      const { treeConfig } = props;
      const { treeExpandedMaps } = reactData;
      const treeOpts = computeTreeOpts.value;
      if (treeConfig && treeOpts.transform) {
        const fullData = [];
        const expandMaps = {};
        import_xe_utils41.default.eachTree(internalData.afterTreeFullData, (row, index, items, path, parent) => {
          const rowid = getRowid($xetable, row);
          const parentRowid = getRowid($xetable, parent);
          if (!parent || expandMaps[parentRowid] && treeExpandedMaps[parentRowid]) {
            expandMaps[rowid] = 1;
            fullData.push(row);
          }
        }, { children: treeOpts.mapChildrenField });
        internalData.afterFullData = fullData;
        updateScrollYStatus(fullData);
        return fullData;
      }
      return internalData.afterFullData;
    };
    const updateAfterFullData = () => {
      const { treeConfig } = props;
      const { tableFullColumn, tableFullData, tableFullTreeData } = internalData;
      const filterOpts = computeFilterOpts.value;
      const sortOpts = computeSortOpts.value;
      const treeOpts = computeTreeOpts.value;
      const { transform } = treeOpts;
      const { remote: allRemoteFilter, filterMethod: allFilterMethod } = filterOpts;
      const { remote: allRemoteSort, sortMethod: allSortMethod, multiple: sortMultiple, chronological } = sortOpts;
      let tableData = [];
      let tableTree = [];
      if (!allRemoteFilter || !allRemoteSort) {
        const filterColumns = [];
        let orderColumns = [];
        tableFullColumn.forEach((column) => {
          const { field, sortable, order, filters } = column;
          if (!allRemoteFilter && filters && filters.length) {
            const valueList = [];
            const itemList = [];
            filters.forEach((item) => {
              if (item.checked) {
                itemList.push(item);
                valueList.push(item.value);
              }
            });
            if (itemList.length) {
              filterColumns.push({ column, valueList, itemList });
            }
          }
          if (!allRemoteSort && sortable && order) {
            orderColumns.push({ column, field, property: field, order, sortTime: column.sortTime });
          }
        });
        if (sortMultiple && chronological && orderColumns.length > 1) {
          orderColumns = import_xe_utils41.default.orderBy(orderColumns, "sortTime");
        }
        if (!allRemoteFilter && filterColumns.length) {
          const handleFilter = (row) => {
            return filterColumns.every(({ column, valueList, itemList }) => {
              const { filterMethod, filterRender } = column;
              const compConf = filterRender ? VXETable.renderer.get(filterRender.name) : null;
              const compFilterMethod = compConf ? compConf.filterMethod : null;
              const defaultFilterMethod = compConf ? compConf.defaultFilterMethod : null;
              const cellValue = getCellValue(row, column);
              if (filterMethod) {
                return itemList.some((item) => filterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xetable }));
              } else if (compFilterMethod) {
                return itemList.some((item) => compFilterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xetable }));
              } else if (allFilterMethod) {
                return allFilterMethod({ options: itemList, values: valueList, cellValue, row, column });
              } else if (defaultFilterMethod) {
                return itemList.some((item) => defaultFilterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xetable }));
              }
              return valueList.indexOf(import_xe_utils41.default.get(row, column.field)) > -1;
            });
          };
          if (treeConfig && transform) {
            tableTree = import_xe_utils41.default.searchTree(tableFullTreeData, handleFilter, Object.assign(Object.assign({}, treeOpts), { original: true }));
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.filter(handleFilter) : tableFullData.filter(handleFilter);
            tableTree = tableData;
          }
        } else {
          if (treeConfig && transform) {
            tableTree = import_xe_utils41.default.searchTree(tableFullTreeData, () => true, Object.assign(Object.assign({}, treeOpts), { original: true }));
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
            tableTree = tableData;
          }
        }
        if (!allRemoteSort && orderColumns.length) {
          if (treeConfig && transform) {
            if (allSortMethod) {
              const sortRests = allSortMethod({ data: tableTree, sortList: orderColumns, $table: $xetable });
              tableTree = import_xe_utils41.default.isArray(sortRests) ? sortRests : tableTree;
            } else {
              tableTree = import_xe_utils41.default.orderBy(tableTree, orderColumns.map(({ column, order }) => [getOrderField(column), order]));
            }
            tableData = tableTree;
          } else {
            if (allSortMethod) {
              const sortRests = allSortMethod({ data: tableData, sortList: orderColumns, $table: $xetable });
              tableData = import_xe_utils41.default.isArray(sortRests) ? sortRests : tableData;
            } else {
              tableData = import_xe_utils41.default.orderBy(tableData, orderColumns.map(({ column, order }) => [getOrderField(column), order]));
            }
            tableTree = tableData;
          }
        }
      } else {
        if (treeConfig && transform) {
          tableTree = import_xe_utils41.default.searchTree(tableFullTreeData, () => true, Object.assign(Object.assign({}, treeOpts), { original: true }));
          tableData = tableTree;
        } else {
          tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
          tableTree = tableData;
        }
      }
      internalData.afterFullData = tableData;
      internalData.afterTreeFullData = tableTree;
      updateAfterDataIndex();
    };
    const updateStyle = () => {
      const { border, showFooter, showOverflow: allColumnOverflow, showHeaderOverflow: allColumnHeaderOverflow, showFooterOverflow: allColumnFooterOverflow, mouseConfig, spanMethod, footerSpanMethod, keyboardConfig } = props;
      const { isGroup, currentRow, tableColumn, scrollXLoad, scrollYLoad, scrollbarWidth, scrollbarHeight, columnStore, editStore, mergeList, mergeFooterList, isAllOverflow } = reactData;
      let { visibleColumn, fullColumnIdData, tableHeight, tableWidth, headerHeight, footerHeight, elemStore, customHeight, customMinHeight, customMaxHeight } = internalData;
      const containerList = ["main", "left", "right"];
      const emptyPlaceholderElem = refEmptyPlaceholder.value;
      const cellOffsetWidth = computeCellOffsetWidth.value;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const bodyWrapperRef = elemStore["main-body-wrapper"];
      const bodyWrapperElem = bodyWrapperRef ? bodyWrapperRef.value : null;
      if (emptyPlaceholderElem) {
        emptyPlaceholderElem.style.top = `${headerHeight}px`;
        emptyPlaceholderElem.style.height = bodyWrapperElem ? `${bodyWrapperElem.offsetHeight - scrollbarHeight}px` : "";
      }
      if (customHeight > 0) {
        if (showFooter) {
          customHeight += scrollbarHeight;
        }
      }
      containerList.forEach((name, index) => {
        const fixedType = index > 0 ? name : "";
        const layoutList = ["header", "body", "footer"];
        const isFixedLeft = fixedType === "left";
        let fixedColumn = [];
        let fixedWrapperElem;
        if (fixedType) {
          fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
          fixedWrapperElem = isFixedLeft ? refLeftContainer.value : refRightContainer.value;
        }
        layoutList.forEach((layout) => {
          const wrapperRef = elemStore[`${name}-${layout}-wrapper`];
          const wrapperElem = wrapperRef ? wrapperRef.value : null;
          const tableRef = elemStore[`${name}-${layout}-table`];
          const tableElem = tableRef ? tableRef.value : null;
          if (layout === "header") {
            let tWidth = tableWidth;
            let renderColumnList = tableColumn;
            if (isGroup) {
              renderColumnList = visibleColumn;
            } else {
              if (fixedType) {
                if (scrollXLoad || allColumnHeaderOverflow) {
                  renderColumnList = fixedColumn;
                }
              }
            }
            tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth + scrollbarWidth}px` : "";
            }
            const repairRef = elemStore[`${name}-${layout}-repair`];
            const repairElem = repairRef ? repairRef.value : null;
            if (repairElem) {
              repairElem.style.width = `${tableWidth}px`;
            }
            const listRef = elemStore[`${name}-${layout}-list`];
            const listElem = listRef ? listRef.value : null;
            if (isGroup && listElem) {
              import_xe_utils41.default.arrayEach(listElem.querySelectorAll(".col--group"), (thElem) => {
                const colNode = tableMethods.getColumnNode(thElem);
                if (colNode) {
                  const column = colNode.item;
                  const { showHeaderOverflow } = column;
                  const cellOverflow = import_xe_utils41.default.isBoolean(showHeaderOverflow) ? showHeaderOverflow : allColumnHeaderOverflow;
                  const showEllipsis = cellOverflow === "ellipsis";
                  const showTitle = cellOverflow === "title";
                  const showTooltip = cellOverflow === true || cellOverflow === "tooltip";
                  const hasEllipsis = showTitle || showTooltip || showEllipsis;
                  let childWidth = 0;
                  let countChild = 0;
                  if (hasEllipsis) {
                    import_xe_utils41.default.eachTree(column.children, (item) => {
                      if (!item.children || !column.children.length) {
                        countChild++;
                      }
                      childWidth += item.renderWidth;
                    }, { children: "children" });
                  }
                  thElem.style.width = hasEllipsis ? `${childWidth - countChild - (border ? 2 : 0)}px` : "";
                }
              });
            }
          } else if (layout === "body") {
            const emptyBlockRef = elemStore[`${name}-${layout}-emptyBlock`];
            const emptyBlockElem = emptyBlockRef ? emptyBlockRef.value : null;
            if (isNodeElement(wrapperElem)) {
              let bodyMaxHeight = 0;
              const bodyMinHeight = customMinHeight - headerHeight - footerHeight;
              if (customMaxHeight) {
                bodyMaxHeight = customMaxHeight - headerHeight - footerHeight;
                if (fixedType) {
                  bodyMaxHeight -= showFooter ? 0 : scrollbarHeight;
                }
                bodyMaxHeight = Math.max(bodyMinHeight, bodyMaxHeight);
                wrapperElem.style.maxHeight = `${bodyMaxHeight}px`;
              }
              if (customHeight) {
                let bodyHeight = customHeight - headerHeight - footerHeight;
                if (fixedType) {
                  bodyHeight -= showFooter ? 0 : scrollbarHeight;
                }
                if (bodyMaxHeight) {
                  bodyHeight = Math.min(bodyMaxHeight, bodyHeight);
                }
                wrapperElem.style.height = `${Math.max(bodyMinHeight, bodyHeight)}px`;
              } else {
                wrapperElem.style.height = "";
              }
              wrapperElem.style.minHeight = `${bodyMinHeight}px`;
            }
            if (fixedWrapperElem) {
              if (isNodeElement(wrapperElem)) {
                wrapperElem.style.top = `${headerHeight}px`;
              }
              fixedWrapperElem.style.height = `${(customHeight > 0 ? customHeight - headerHeight - footerHeight : tableHeight) + headerHeight + footerHeight - scrollbarHeight * (showFooter ? 2 : 1)}px`;
              fixedWrapperElem.style.width = `${fixedColumn.reduce((previous, column) => previous + column.renderWidth, isFixedLeft ? 0 : scrollbarWidth)}px`;
            }
            let tWidth = tableWidth;
            let renderColumnList = tableColumn;
            if (fixedType) {
              if (!reactData.expandColumn && (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow))) {
                if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {
                  renderColumnList = fixedColumn;
                } else {
                  renderColumnList = visibleColumn;
                }
              } else {
                renderColumnList = visibleColumn;
              }
            }
            tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth}px` : "";
              tableElem.style.paddingRight = scrollbarWidth && fixedType && (browse["-moz"] || browse.safari) ? `${scrollbarWidth}px` : "";
            }
            if (emptyBlockElem) {
              emptyBlockElem.style.width = tWidth ? `${tWidth}px` : "";
            }
          } else if (layout === "footer") {
            let tWidth = tableWidth;
            let renderColumnList = tableColumn;
            if (fixedType) {
              if (!reactData.expandColumn && (scrollXLoad || allColumnFooterOverflow)) {
                if (!mergeFooterList.length || !footerSpanMethod) {
                  renderColumnList = fixedColumn;
                } else {
                  renderColumnList = visibleColumn;
                }
              } else {
                renderColumnList = visibleColumn;
              }
            }
            tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (isNodeElement(wrapperElem)) {
              if (fixedWrapperElem) {
                wrapperElem.style.top = `${customHeight > 0 ? customHeight - footerHeight : tableHeight + headerHeight}px`;
              }
              wrapperElem.style.marginTop = `${-Math.max(1, scrollbarHeight)}px`;
            }
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth + scrollbarWidth}px` : "";
            }
          }
          const colgroupRef = elemStore[`${name}-${layout}-colgroup`];
          const colgroupElem = colgroupRef ? colgroupRef.value : null;
          if (colgroupElem) {
            import_xe_utils41.default.arrayEach(colgroupElem.children, (colElem) => {
              const colid = colElem.getAttribute("name");
              if (colid === "col_gutter") {
                colElem.style.width = `${scrollbarWidth}px`;
              }
              if (fullColumnIdData[colid]) {
                const column = fullColumnIdData[colid].column;
                const { showHeaderOverflow, showFooterOverflow, showOverflow } = column;
                let cellOverflow;
                colElem.style.width = `${column.renderWidth}px`;
                if (layout === "header") {
                  cellOverflow = import_xe_utils41.default.isUndefined(showHeaderOverflow) || import_xe_utils41.default.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
                } else if (layout === "footer") {
                  cellOverflow = import_xe_utils41.default.isUndefined(showFooterOverflow) || import_xe_utils41.default.isNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
                } else {
                  cellOverflow = import_xe_utils41.default.isUndefined(showOverflow) || import_xe_utils41.default.isNull(showOverflow) ? allColumnOverflow : showOverflow;
                }
                const showEllipsis = cellOverflow === "ellipsis";
                const showTitle = cellOverflow === "title";
                const showTooltip = cellOverflow === true || cellOverflow === "tooltip";
                let hasEllipsis = showTitle || showTooltip || showEllipsis;
                const listRef = elemStore[`${name}-${layout}-list`];
                const listElem = listRef ? listRef.value : null;
                if (scrollYLoad && !hasEllipsis) {
                  hasEllipsis = true;
                }
                if (listElem) {
                  import_xe_utils41.default.arrayEach(listElem.querySelectorAll(`.${column.id}`), (elem) => {
                    const colspan = parseInt(elem.getAttribute("colspan") || 1);
                    const cellElem = elem.querySelector(".vxe-cell");
                    let colWidth = column.renderWidth;
                    if (cellElem) {
                      if (colspan > 1) {
                        const columnIndex = tableMethods.getColumnIndex(column);
                        for (let index2 = 1; index2 < colspan; index2++) {
                          const nextColumn = tableMethods.getColumns(columnIndex + index2);
                          if (nextColumn) {
                            colWidth += nextColumn.renderWidth;
                          }
                        }
                      }
                      cellElem.style.width = hasEllipsis ? `${colWidth - cellOffsetWidth * colspan}px` : "";
                    }
                  });
                }
              }
            });
          }
        });
      });
      if (currentRow) {
        tableMethods.setCurrentRow(currentRow);
      }
      if (mouseConfig && mouseOpts.selected && editStore.selected.row && editStore.selected.column) {
        $xetable.addCellSelectedClass();
      }
      return nextTick();
    };
    const checkValidate = (type) => {
      if ($xetable.triggerValidate) {
        return $xetable.triggerValidate(type);
      }
      return nextTick();
    };
    const handleChangeCell = (evnt, params) => {
      checkValidate("blur").catch((e) => e).then(() => {
        $xetable.handleActived(params, evnt).then(() => checkValidate("change")).catch((e) => e);
      });
    };
    const handleDefaultSort = () => {
      const { sortConfig } = props;
      if (sortConfig) {
        const sortOpts = computeSortOpts.value;
        let { defaultSort } = sortOpts;
        if (defaultSort) {
          if (!import_xe_utils41.default.isArray(defaultSort)) {
            defaultSort = [defaultSort];
          }
          if (defaultSort.length) {
            (sortConfig.multiple ? defaultSort : defaultSort.slice(0, 1)).forEach((item, index) => {
              const { field, order } = item;
              if (field && order) {
                const column = tableMethods.getColumnByField(field);
                if (column && column.sortable) {
                  column.order = order;
                  column.sortTime = Date.now() + index;
                }
              }
            });
            if (!sortOpts.remote) {
              tablePrivateMethods.handleTableData(true).then(updateStyle);
            }
          }
        }
      }
    };
    const handleDefaultSelectionChecked = () => {
      const { checkboxConfig } = props;
      if (checkboxConfig) {
        const { fullDataRowIdData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkAll, checkRowKeys } = checkboxOpts;
        if (checkAll) {
          handleCheckedAllCheckboxRow(true, true);
        } else if (checkRowKeys) {
          const defSelection = [];
          checkRowKeys.forEach((rowid) => {
            if (fullDataRowIdData[rowid]) {
              defSelection.push(fullDataRowIdData[rowid].row);
            }
          });
          handleCheckedCheckboxRow(defSelection, true, true);
        }
      }
    };
    const handleDefaultRadioChecked = () => {
      const { radioConfig } = props;
      if (radioConfig) {
        const { fullDataRowIdData } = internalData;
        const radioOpts = computeRadioOpts.value;
        const { checkRowKey: rowid, reserve } = radioOpts;
        if (rowid) {
          if (fullDataRowIdData[rowid]) {
            handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
          }
          if (reserve) {
            const rowkey = getRowkey($xetable);
            internalData.radioReserveRow = { [rowkey]: rowid };
          }
        }
      }
    };
    const handleDefaultRowExpand = () => {
      const { expandConfig } = props;
      if (expandConfig) {
        const { fullDataRowIdData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { expandAll, expandRowKeys } = expandOpts;
        if (expandAll) {
          tableMethods.setAllRowExpand(true);
        } else if (expandRowKeys) {
          const defExpandeds = [];
          expandRowKeys.forEach((rowid) => {
            if (fullDataRowIdData[rowid]) {
              defExpandeds.push(fullDataRowIdData[rowid].row);
            }
          });
          tableMethods.setRowExpand(defExpandeds, true);
        }
      }
    };
    const handleRadioReserveRow = (row) => {
      const radioOpts = computeRadioOpts.value;
      if (radioOpts.reserve) {
        internalData.radioReserveRow = row;
      }
    };
    const handleCheckboxReserveRow = (row, checked) => {
      const { checkboxReserveRowMap } = internalData;
      const checkboxOpts = computeCheckboxOpts.value;
      if (checkboxOpts.reserve) {
        const rowid = getRowid($xetable, row);
        if (checked) {
          checkboxReserveRowMap[rowid] = row;
        } else if (checkboxReserveRowMap[rowid]) {
          delete checkboxReserveRowMap[rowid];
        }
      }
    };
    const handleCheckedRadioRow = (row, isForce) => {
      const radioOpts = computeRadioOpts.value;
      const { checkMethod } = radioOpts;
      if (row && (isForce || (!checkMethod || checkMethod({ row })))) {
        reactData.selectRadioRow = row;
        handleRadioReserveRow(row);
      }
      return nextTick();
    };
    const handleCheckedCheckboxRow = (rows, value, isForce) => {
      if (rows && !import_xe_utils41.default.isArray(rows)) {
        rows = [rows];
      }
      rows.forEach((row) => tablePrivateMethods.handleSelectRow({ row }, !!value, isForce));
      return nextTick();
    };
    const handleCheckedAllCheckboxRow = (value, isForce) => {
      const { treeConfig } = props;
      const { selectCheckboxMaps } = reactData;
      const { afterFullData, afterFullRowMaps, checkboxReserveRowMap } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkField, reserve, checkStrictly, checkMethod } = checkboxOpts;
      const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
      const selectRowMaps = {};
      if (!treeConfig) {
        import_xe_utils41.default.each(selectCheckboxMaps, (row, rowid) => {
          if (!afterFullRowMaps[rowid]) {
            selectRowMaps[rowid] = row;
          }
        });
      }
      if (checkStrictly) {
        reactData.isAllSelected = value;
      } else {
        if (checkField) {
          const checkValFn = (row) => {
            if (isForce || (!checkMethod || checkMethod({ row }))) {
              if (value) {
                selectRowMaps[getRowid($xetable, row)] = row;
              }
              import_xe_utils41.default.set(row, checkField, value);
            }
            if (treeConfig && indeterminateField) {
              import_xe_utils41.default.set(row, indeterminateField, false);
            }
          };
          if (treeConfig) {
            import_xe_utils41.default.eachTree(afterFullData, checkValFn, { children: childrenField });
          } else {
            afterFullData.forEach(checkValFn);
          }
        } else {
          if (treeConfig) {
            if (value) {
              import_xe_utils41.default.eachTree(afterFullData, (row) => {
                if (isForce || (!checkMethod || checkMethod({ row }))) {
                  selectRowMaps[getRowid($xetable, row)] = row;
                }
              }, { children: childrenField });
            } else {
              if (!isForce && checkMethod) {
                import_xe_utils41.default.eachTree(afterFullData, (row) => {
                  const rowid = getRowid($xetable, row);
                  if (checkMethod({ row }) ? 0 : selectCheckboxMaps[rowid]) {
                    selectRowMaps[rowid] = row;
                  }
                }, { children: childrenField });
              }
            }
          } else {
            if (value) {
              if (!isForce && checkMethod) {
                afterFullData.forEach((row) => {
                  const rowid = getRowid($xetable, row);
                  if (selectCheckboxMaps[rowid] || checkMethod({ row })) {
                    selectRowMaps[rowid] = row;
                  }
                });
              } else {
                afterFullData.forEach((row) => {
                  selectRowMaps[getRowid($xetable, row)] = row;
                });
              }
            } else {
              if (!isForce && checkMethod) {
                afterFullData.forEach((row) => {
                  const rowid = getRowid($xetable, row);
                  if (checkMethod({ row }) ? 0 : selectCheckboxMaps[rowid]) {
                    selectRowMaps[rowid] = row;
                  }
                });
              }
            }
          }
        }
        if (reserve) {
          if (value) {
            import_xe_utils41.default.each(selectRowMaps, (row, rowid) => {
              checkboxReserveRowMap[rowid] = row;
            });
          } else {
            afterFullData.forEach((row) => handleCheckboxReserveRow(row, false));
          }
        }
        reactData.selectCheckboxMaps = checkField ? {} : selectRowMaps;
      }
      reactData.treeIndeterminateMaps = {};
      internalData.treeIndeterminateRowMaps = {};
      tablePrivateMethods.checkSelectionStatus();
      return nextTick();
    };
    const handleReserveStatus = () => {
      const { treeConfig } = props;
      const { expandColumn, currentRow, selectCheckboxMaps, selectRadioRow, rowExpandedMaps, treeExpandedMaps } = reactData;
      const { fullDataRowIdData, fullAllDataRowIdData, radioReserveRow } = internalData;
      const expandOpts = computeExpandOpts.value;
      const treeOpts = computeTreeOpts.value;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      if (selectRadioRow && !fullAllDataRowIdData[getRowid($xetable, selectRadioRow)]) {
        reactData.selectRadioRow = null;
      }
      if (radioOpts.reserve && radioReserveRow) {
        const rowid = getRowid($xetable, radioReserveRow);
        if (fullDataRowIdData[rowid]) {
          handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
        }
      }
      reactData.selectCheckboxMaps = getRecoverRowMaps(selectCheckboxMaps);
      if (checkboxOpts.reserve) {
        handleCheckedCheckboxRow(handleReserveRow(internalData.checkboxReserveRowMap), true, true);
      }
      if (currentRow && !fullAllDataRowIdData[getRowid($xetable, currentRow)]) {
        reactData.currentRow = null;
      }
      reactData.rowExpandedMaps = expandColumn ? getRecoverRowMaps(rowExpandedMaps) : {};
      if (expandColumn && expandOpts.reserve) {
        tableMethods.setRowExpand(handleReserveRow(internalData.rowExpandedReserveRowMap), true);
      }
      reactData.treeExpandedMaps = treeConfig ? getRecoverRowMaps(treeExpandedMaps) : {};
      if (treeConfig && treeOpts.reserve) {
        tableMethods.setTreeExpand(handleReserveRow(internalData.treeExpandedReserveRowMap), true);
      }
    };
    const handleDefaultTreeExpand = () => {
      const { treeConfig } = props;
      if (treeConfig) {
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { expandAll, expandRowKeys } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (expandAll) {
          tableMethods.setAllTreeExpand(true);
        } else if (expandRowKeys) {
          const defExpandeds = [];
          const rowkey = getRowkey($xetable);
          expandRowKeys.forEach((rowid) => {
            const matchObj = import_xe_utils41.default.findTree(tableFullData, (item) => rowid === import_xe_utils41.default.get(item, rowkey), { children: childrenField });
            if (matchObj) {
              defExpandeds.push(matchObj.item);
            }
          });
          tableMethods.setTreeExpand(defExpandeds, true);
        }
      }
    };
    const handleAsyncTreeExpandChilds = (row) => {
      const treeOpts = computeTreeOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const { transform, loadMethod } = treeOpts;
      const { checkStrictly } = checkboxOpts;
      return new Promise((resolve) => {
        if (loadMethod) {
          const { treeExpandLazyLoadedMaps } = reactData;
          const { fullAllDataRowIdData } = internalData;
          const rowid = getRowid($xetable, row);
          const rest = fullAllDataRowIdData[rowid];
          treeExpandLazyLoadedMaps[rowid] = row;
          loadMethod({ $table: $xetable, row }).then((childRecords) => {
            rest.treeLoaded = true;
            if (treeExpandLazyLoadedMaps[rowid]) {
              delete treeExpandLazyLoadedMaps[rowid];
            }
            if (!import_xe_utils41.default.isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return tableMethods.loadTreeChildren(row, childRecords).then((childRows) => {
                const { treeExpandedMaps } = reactData;
                if (childRows.length && !treeExpandedMaps[rowid]) {
                  treeExpandedMaps[rowid] = row;
                }
                if (!checkStrictly && tableMethods.isCheckedByCheckboxRow(row)) {
                  handleCheckedCheckboxRow(childRows, true);
                }
                return nextTick().then(() => {
                  if (transform) {
                    return tablePrivateMethods.handleTableData();
                  }
                });
              });
            }
          }).catch(() => {
            const { treeExpandLazyLoadedMaps: treeExpandLazyLoadedMaps2 } = reactData;
            rest.treeLoaded = false;
            if (treeExpandLazyLoadedMaps2[rowid]) {
              delete treeExpandLazyLoadedMaps2[rowid];
            }
          }).finally(() => {
            nextTick().then(() => tableMethods.recalculate()).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };
    const handleTreeExpandReserve = (row, expanded) => {
      const { treeExpandedReserveRowMap } = internalData;
      const treeOpts = computeTreeOpts.value;
      if (treeOpts.reserve) {
        const rowid = getRowid($xetable, row);
        if (expanded) {
          treeExpandedReserveRowMap[rowid] = row;
        } else if (treeExpandedReserveRowMap[rowid]) {
          delete treeExpandedReserveRowMap[rowid];
        }
      }
    };
    const handleAsyncRowExpand = (row) => {
      return new Promise((resolve) => {
        const expandOpts = computeExpandOpts.value;
        const { loadMethod } = expandOpts;
        if (loadMethod) {
          const { fullAllDataRowIdData } = internalData;
          const { rowExpandLazyLoadedMaps } = reactData;
          const rowid = getRowid($xetable, row);
          const rest = fullAllDataRowIdData[rowid];
          rowExpandLazyLoadedMaps[rowid] = row;
          loadMethod({ $table: $xetable, row, rowIndex: tableMethods.getRowIndex(row), $rowIndex: tableMethods.getVMRowIndex(row) }).then(() => {
            const { rowExpandedMaps } = reactData;
            rest.expandLoaded = true;
            rowExpandedMaps[rowid] = row;
          }).catch(() => {
            rest.expandLoaded = false;
          }).finally(() => {
            const { rowExpandLazyLoadedMaps: rowExpandLazyLoadedMaps2 } = reactData;
            if (rowExpandLazyLoadedMaps2[rowid]) {
              delete rowExpandLazyLoadedMaps2[rowid];
            }
            nextTick().then(() => tableMethods.recalculate()).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };
    const handleRowExpandReserve = (row, expanded) => {
      const { rowExpandedReserveRowMap } = internalData;
      const expandOpts = computeExpandOpts.value;
      if (expandOpts.reserve) {
        const rowid = getRowid($xetable, row);
        if (expanded) {
          rowExpandedReserveRowMap[rowid] = row;
        } else if (rowExpandedReserveRowMap[rowid]) {
          delete rowExpandedReserveRowMap[rowid];
        }
      }
    };
    const handleDefaultMergeCells = () => {
      const { mergeCells } = props;
      if (mergeCells) {
        tableMethods.setMergeCells(mergeCells);
      }
    };
    const handleDefaultMergeFooterItems = () => {
      const { mergeFooterItems } = props;
      if (mergeFooterItems) {
        tableMethods.setMergeFooterItems(mergeFooterItems);
      }
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollXLoad, scrollYLoad } = reactData;
        const { scrollXStore, scrollYStore } = internalData;
        const sYOpts = computeSYOpts.value;
        const sXOpts = computeSXOpts.value;
        if (scrollXLoad) {
          const { visibleSize: visibleXSize } = computeVirtualX();
          const offsetXSize = sXOpts.oSize ? import_xe_utils41.default.toNumber(sXOpts.oSize) : browse.edge ? 5 : 0;
          scrollXStore.offsetSize = offsetXSize;
          scrollXStore.visibleSize = visibleXSize;
          scrollXStore.endIndex = Math.max(scrollXStore.startIndex + scrollXStore.visibleSize + offsetXSize, scrollXStore.endIndex);
          tablePrivateMethods.updateScrollXData();
        } else {
          tablePrivateMethods.updateScrollXSpace();
        }
        const { rowHeight, visibleSize: visibleYSize } = computeVirtualY();
        scrollYStore.rowHeight = rowHeight;
        if (scrollYLoad) {
          const offsetYSize = sYOpts.oSize ? import_xe_utils41.default.toNumber(sYOpts.oSize) : browse.edge ? 10 : 0;
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);
          tablePrivateMethods.updateScrollYData();
        } else {
          tablePrivateMethods.updateScrollYSpace();
        }
        reactData.rowHeight = rowHeight;
        nextTick(updateStyle);
      });
    };
    const loadTableData = (datas) => {
      const { keepSource, treeConfig } = props;
      const { editStore, scrollYLoad: oldScrollYLoad } = reactData;
      const { scrollYStore, scrollXStore, lastScrollLeft, lastScrollTop } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { transform } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      let treeData = [];
      let fullData = reactive(datas ? datas.slice(0) : []);
      if (treeConfig) {
        if (transform) {
          if (true) {
            if (!treeOpts.rowField) {
              errLog("vxe.error.reqProp", ["tree-config.rowField"]);
            }
            if (!treeOpts.parentField) {
              errLog("vxe.error.reqProp", ["tree-config.parentField"]);
            }
            if (!childrenField) {
              errLog("vxe.error.reqProp", ["tree-config.childrenField"]);
            }
            if (!treeOpts.mapChildrenField) {
              errLog("vxe.error.reqProp", ["tree-config.mapChildrenField"]);
            }
            if (childrenField === treeOpts.mapChildrenField) {
              errLog("vxe.error.errConflicts", ["tree-config.childrenField", "tree-config.mapChildrenField"]);
            }
          }
          treeData = import_xe_utils41.default.toArrayTree(fullData, {
            key: treeOpts.rowField,
            parentKey: treeOpts.parentField,
            children: childrenField,
            mapChildren: treeOpts.mapChildrenField
          });
          fullData = treeData.slice(0);
        } else {
          treeData = fullData.slice(0);
        }
      }
      scrollYStore.startIndex = 0;
      scrollYStore.endIndex = 1;
      scrollXStore.startIndex = 0;
      scrollXStore.endIndex = 1;
      reactData.scrollVMLoading = false;
      editStore.insertMaps = {};
      editStore.removeMaps = {};
      const sYLoad = updateScrollYStatus(fullData);
      reactData.scrollYLoad = sYLoad;
      internalData.tableFullData = fullData;
      internalData.tableFullTreeData = treeData;
      tablePrivateMethods.cacheRowMap(true);
      internalData.tableSynchData = datas;
      if (keepSource) {
        tablePrivateMethods.cacheSourceMap(fullData);
      }
      if (sYLoad) {
        if (!(props.height || props.maxHeight)) {
          errLog("vxe.error.reqProp", ["table.height | table.max-height | table.scroll-y={enabled: false}"]);
        }
        if (!props.showOverflow) {
          errLog("vxe.error.reqProp", ["table.show-overflow"]);
        }
        if (true) {
          if (props.spanMethod) {
            warnLog("vxe.error.scrollErrProp", ["table.span-method"]);
          }
        }
      }
      if ($xetable.clearCellAreas && props.mouseConfig) {
        $xetable.clearCellAreas();
        $xetable.clearCopyCellArea();
      }
      tableMethods.clearMergeCells();
      tableMethods.clearMergeFooterItems();
      tablePrivateMethods.handleTableData(true);
      tableMethods.updateFooter();
      return nextTick().then(() => {
        updateHeight();
        updateStyle();
      }).then(() => {
        computeScrollLoad();
      }).then(() => {
        if (sYLoad) {
          scrollYStore.endIndex = scrollYStore.visibleSize;
        }
        handleReserveStatus();
        tablePrivateMethods.checkSelectionStatus();
        return new Promise((resolve) => {
          nextTick().then(() => tableMethods.recalculate()).then(() => {
            let targetScrollLeft = lastScrollLeft;
            let targetScrollTop = lastScrollTop;
            const sXOpts = computeSXOpts.value;
            const sYOpts = computeSYOpts.value;
            if (sXOpts.scrollToLeftOnChange) {
              targetScrollLeft = 0;
            }
            if (sYOpts.scrollToTopOnChange) {
              targetScrollTop = 0;
            }
            if (oldScrollYLoad === sYLoad) {
              restoreScrollLocation($xetable, targetScrollLeft, targetScrollTop).then(resolve);
            } else {
              setTimeout(() => restoreScrollLocation($xetable, targetScrollLeft, targetScrollTop).then(resolve));
            }
          });
        });
      });
    };
    const handleLoadDefaults = () => {
      handleDefaultSelectionChecked();
      handleDefaultRadioChecked();
      handleDefaultRowExpand();
      handleDefaultTreeExpand();
      handleDefaultMergeCells();
      handleDefaultMergeFooterItems();
      nextTick(() => setTimeout(() => tableMethods.recalculate()));
    };
    const handleInitDefaults = () => {
      handleDefaultSort();
    };
    const handleTableColumn = () => {
      const { scrollXLoad } = reactData;
      const { visibleColumn, scrollXStore, fullColumnIdData } = internalData;
      const tableColumn = scrollXLoad ? visibleColumn.slice(scrollXStore.startIndex, scrollXStore.endIndex) : visibleColumn.slice(0);
      tableColumn.forEach((column, $index) => {
        const colid = column.id;
        const rest = fullColumnIdData[colid];
        if (rest) {
          rest.$index = $index;
        }
      });
      reactData.tableColumn = tableColumn;
    };
    const loadScrollXData = () => {
      const { mergeList, mergeFooterList } = reactData;
      const { scrollXStore } = internalData;
      const { startIndex, endIndex, offsetSize } = scrollXStore;
      const { toVisibleIndex, visibleSize } = computeVirtualX();
      const offsetItem = {
        startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),
        endIndex: toVisibleIndex + visibleSize + offsetSize
      };
      calculateMergerOffserIndex(mergeList.concat(mergeFooterList), offsetItem, "col");
      const { startIndex: offsetStartIndex, endIndex: offsetEndIndex } = offsetItem;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollXStore.startIndex = offsetStartIndex;
          scrollXStore.endIndex = offsetEndIndex;
          tablePrivateMethods.updateScrollXData();
        }
      }
      tableMethods.closeTooltip();
    };
    const getColumnList = (columns) => {
      const result = [];
      columns.forEach((column) => {
        result.push(...column.children && column.children.length ? getColumnList(column.children) : [column]);
      });
      return result;
    };
    const parseColumns = () => {
      const leftList = [];
      const centerList = [];
      const rightList = [];
      const { isGroup, columnStore } = reactData;
      const sXOpts = computeSXOpts.value;
      const { collectColumn, tableFullColumn, scrollXStore, fullColumnIdData } = internalData;
      if (isGroup) {
        const leftGroupList = [];
        const centerGroupList = [];
        const rightGroupList = [];
        import_xe_utils41.default.eachTree(collectColumn, (column, index, items, path, parent) => {
          const isColGroup = hasChildrenList(column);
          if (parent && parent.fixed) {
            column.fixed = parent.fixed;
          }
          if (parent && column.fixed !== parent.fixed) {
            errLog("vxe.error.groupFixed");
          }
          if (isColGroup) {
            column.visible = !!import_xe_utils41.default.findTree(column.children, (subColumn) => hasChildrenList(subColumn) ? false : subColumn.visible);
          } else if (column.visible) {
            if (column.fixed === "left") {
              leftList.push(column);
            } else if (column.fixed === "right") {
              rightList.push(column);
            } else {
              centerList.push(column);
            }
          }
        });
        collectColumn.forEach((column) => {
          if (column.visible) {
            if (column.fixed === "left") {
              leftGroupList.push(column);
            } else if (column.fixed === "right") {
              rightGroupList.push(column);
            } else {
              centerGroupList.push(column);
            }
          }
        });
        reactData.tableGroupColumn = leftGroupList.concat(centerGroupList).concat(rightGroupList);
      } else {
        tableFullColumn.forEach((column) => {
          if (column.visible) {
            if (column.fixed === "left") {
              leftList.push(column);
            } else if (column.fixed === "right") {
              rightList.push(column);
            } else {
              centerList.push(column);
            }
          }
        });
      }
      const visibleColumn = leftList.concat(centerList).concat(rightList);
      const scrollXLoad = !!sXOpts.enabled && sXOpts.gt > -1 && (sXOpts.gt === 0 || sXOpts.gt < tableFullColumn.length);
      reactData.hasFixedColumn = leftList.length > 0 || rightList.length > 0;
      Object.assign(columnStore, { leftList, centerList, rightList });
      if (scrollXLoad) {
        if (true) {
          if (props.spanMethod) {
            warnLog("vxe.error.scrollErrProp", ["span-method"]);
          }
          if (props.footerSpanMethod) {
            warnLog("vxe.error.scrollErrProp", ["footer-span-method"]);
          }
        }
        const { visibleSize } = computeVirtualX();
        scrollXStore.startIndex = 0;
        scrollXStore.endIndex = visibleSize;
        scrollXStore.visibleSize = visibleSize;
      }
      if (visibleColumn.length !== internalData.visibleColumn.length || !internalData.visibleColumn.every((column, index) => column === visibleColumn[index])) {
        tableMethods.clearMergeCells();
        tableMethods.clearMergeFooterItems();
      }
      reactData.scrollXLoad = scrollXLoad;
      visibleColumn.forEach((column, index) => {
        const colid = column.id;
        const rest = fullColumnIdData[colid];
        if (rest) {
          rest._index = index;
        }
      });
      internalData.visibleColumn = visibleColumn;
      handleTableColumn();
      return tableMethods.updateFooter().then(() => {
        return tableMethods.recalculate();
      }).then(() => {
        tableMethods.updateCellAreas();
        return tableMethods.recalculate();
      });
    };
    const initColumnSort = () => {
      const { collectColumn } = internalData;
      collectColumn.forEach((column, index) => {
        const sortIndex = index + 1;
        column.sortNumber = sortIndex;
        column.renderSortNumber = sortIndex;
      });
    };
    const handleColumn = (collectColumn) => {
      internalData.collectColumn = collectColumn;
      const tableFullColumn = getColumnList(collectColumn);
      internalData.tableFullColumn = tableFullColumn;
      initColumnSort();
      restoreCustomStorage();
      cacheColumnMap();
      parseColumns().then(() => {
        if (reactData.scrollXLoad) {
          loadScrollXData();
        }
      });
      tableMethods.clearMergeCells();
      tableMethods.clearMergeFooterItems();
      tablePrivateMethods.handleTableData(true);
      if (true) {
        if ((reactData.scrollXLoad || reactData.scrollYLoad) && reactData.expandColumn) {
          warnLog("vxe.error.scrollErrProp", ["column.type=expand"]);
        }
      }
      return nextTick().then(() => {
        if ($xetoolbar) {
          $xetoolbar.syncUpdate({ collectColumn, $table: $xetable });
        }
        return tableMethods.recalculate();
      });
    };
    const updateScrollYStatus = (fullData) => {
      const { treeConfig } = props;
      const sYOpts = computeSYOpts.value;
      const treeOpts = computeTreeOpts.value;
      const { transform } = treeOpts;
      const allList = fullData || internalData.tableFullData;
      const scrollYLoad = (transform || !treeConfig) && !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt < allList.length);
      reactData.scrollYLoad = scrollYLoad;
      return scrollYLoad;
    };
    const handleBaseTreeExpand = (rows, expanded) => {
      const { treeExpandedMaps, treeExpandLazyLoadedMaps, treeNodeColumn } = reactData;
      const treeTempExpandedMaps = Object.assign({}, treeExpandedMaps);
      const { fullAllDataRowIdData, tableFullData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { reserve, lazy, accordion, toggleMethod } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
      const result = [];
      const columnIndex = tableMethods.getColumnIndex(treeNodeColumn);
      const $columnIndex = tableMethods.getVMColumnIndex(treeNodeColumn);
      let validRows = toggleMethod ? rows.filter((row) => toggleMethod({ $table: $xetable, expanded, column: treeNodeColumn, columnIndex, $columnIndex, row })) : rows;
      if (accordion) {
        validRows = validRows.length ? [validRows[validRows.length - 1]] : [];
        const matchObj = import_xe_utils41.default.findTree(tableFullData, (item) => item === validRows[0], { children: childrenField });
        if (matchObj) {
          matchObj.items.forEach((item) => {
            const rowid = getRowid($xetable, item);
            if (treeTempExpandedMaps[rowid]) {
              delete treeTempExpandedMaps[rowid];
            }
          });
        }
      }
      if (expanded) {
        validRows.forEach((row) => {
          const rowid = getRowid($xetable, row);
          if (!treeTempExpandedMaps[rowid]) {
            const rest = fullAllDataRowIdData[rowid];
            const isLoad = lazy && row[hasChildField] && !rest.treeLoaded && !treeExpandLazyLoadedMaps[rowid];
            if (isLoad) {
              result.push(handleAsyncTreeExpandChilds(row));
            } else {
              if (row[childrenField] && row[childrenField].length) {
                treeTempExpandedMaps[rowid] = row;
              }
            }
          }
        });
      } else {
        validRows.forEach((item) => {
          const rowid = getRowid($xetable, item);
          if (treeTempExpandedMaps[rowid]) {
            delete treeTempExpandedMaps[rowid];
          }
        });
      }
      if (reserve) {
        validRows.forEach((row) => handleTreeExpandReserve(row, expanded));
      }
      reactData.treeExpandedMaps = treeTempExpandedMaps;
      return Promise.all(result).then(() => {
        return tableMethods.recalculate();
      });
    };
    const handleVirtualTreeExpand = (rows, expanded) => {
      return handleBaseTreeExpand(rows, expanded).then(() => {
        handleVirtualTreeToList();
        return tablePrivateMethods.handleTableData();
      }).then(() => {
        return tableMethods.recalculate();
      });
    };
    const loadScrollYData = (evnt) => {
      const { mergeList } = reactData;
      const { scrollYStore } = internalData;
      const { startIndex, endIndex, visibleSize, offsetSize, rowHeight } = scrollYStore;
      const scrollBodyElem = evnt.currentTarget || evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetItem = {
        startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),
        endIndex: toVisibleIndex + visibleSize + offsetSize
      };
      calculateMergerOffserIndex(mergeList, offsetItem, "row");
      const { startIndex: offsetStartIndex, endIndex: offsetEndIndex } = offsetItem;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          tablePrivateMethods.updateScrollYData();
        }
      }
    };
    const createGetRowCacheProp = (prop) => {
      return function(row) {
        const { fullAllDataRowIdData } = internalData;
        if (row) {
          const rowid = getRowid($xetable, row);
          const rest = fullAllDataRowIdData[rowid];
          if (rest) {
            return rest[prop];
          }
        }
        return -1;
      };
    };
    const createGetColumnCacheProp = (prop) => {
      return function(column) {
        const { fullColumnIdData } = internalData;
        if (column) {
          const rest = fullColumnIdData[column.id];
          if (rest) {
            return rest[prop];
          }
        }
        return -1;
      };
    };
    const debounceScrollY = import_xe_utils41.default.debounce(function(evnt) {
      loadScrollYData(evnt);
    }, 20, { leading: false, trailing: true });
    let keyCtxTimeout;
    tableMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $table: $xetable, $grid: $xegrid, $event: evnt }, params));
      },
      /**
       * 重置表格的一切数据状态
       */
      clearAll() {
        return clearTableAllStatus($xetable);
      },
      /**
       * 同步 data 数据（即将废弃）
       * 如果用了该方法，那么组件将不再记录增删改的状态，只能自行实现对应逻辑
       * 对于某些特殊的场景，比如深层树节点元素发生变动时可能会用到
       */
      syncData() {
        warnLog("vxe.error.delFunc", ["syncData", "getData"]);
        return nextTick().then(() => {
          reactData.tableData = [];
          emit("update:data", internalData.tableFullData);
          return nextTick();
        });
      },
      /**
       * 手动处理数据，用于手动排序与筛选
       * 对于手动更改了排序、筛选...等条件后需要重新处理数据时可能会用到
       */
      updateData() {
        const { scrollXLoad, scrollYLoad } = reactData;
        return tablePrivateMethods.handleTableData(true).then(() => {
          tableMethods.updateFooter();
          if (scrollXLoad || scrollYLoad) {
            if (scrollXLoad) {
              tablePrivateMethods.updateScrollXSpace();
            }
            if (scrollYLoad) {
              tablePrivateMethods.updateScrollYSpace();
            }
            return tableMethods.refreshScroll();
          }
        }).then(() => {
          tableMethods.updateCellAreas();
          return tableMethods.recalculate(true);
        }).then(() => {
          setTimeout(() => $xetable.recalculate(), 50);
        });
      },
      /**
       * 重新加载数据，不会清空表格状态
       * @param {Array} datas 数据
       */
      loadData(datas) {
        const { inited, initStatus } = internalData;
        return loadTableData(datas).then(() => {
          internalData.inited = true;
          internalData.initStatus = true;
          if (!initStatus) {
            handleLoadDefaults();
          }
          if (!inited) {
            handleInitDefaults();
          }
          return tableMethods.recalculate();
        });
      },
      /**
       * 重新加载数据，会清空表格状态
       * @param {Array} datas 数据
       */
      reloadData(datas) {
        const { inited } = internalData;
        return tableMethods.clearAll().then(() => {
          internalData.inited = true;
          internalData.initStatus = true;
          return loadTableData(datas);
        }).then(() => {
          handleLoadDefaults();
          if (!inited) {
            handleInitDefaults();
          }
          return tableMethods.recalculate();
        });
      },
      /**
       * 修改行数据
       */
      setRow(rows, record) {
        if (record) {
          let rest = rows;
          if (!import_xe_utils41.default.isArray(rows)) {
            rest = [rows];
          }
          rest.forEach((item) => Object.assign(item, record));
        }
        return nextTick();
      },
      /**
       * 局部加载行数据并恢复到初始状态
       * 对于行数据需要局部更改的场景中可能会用到
       * @param {Row} row 行对象
       * @param {Object} record 新数据
       * @param {String} field 字段名
       */
      reloadRow(row, record, field) {
        const { keepSource } = props;
        const { tableData } = reactData;
        const { tableSourceData } = internalData;
        if (keepSource) {
          const rowIndex = tableMethods.getRowIndex(row);
          const oRow = tableSourceData[rowIndex];
          if (oRow && row) {
            if (field) {
              const newValue = import_xe_utils41.default.get(record || row, field);
              import_xe_utils41.default.set(row, field, newValue);
              import_xe_utils41.default.set(oRow, field, newValue);
            } else {
              const newRecord = import_xe_utils41.default.clone(Object.assign({}, record), true);
              import_xe_utils41.default.destructuring(oRow, Object.assign(row, newRecord));
            }
          }
          reactData.tableData = tableData.slice(0);
        } else {
          if (true) {
            warnLog("vxe.error.reqProp", ["keep-source"]);
          }
        }
        return nextTick();
      },
      /**
       * 用于树结构，给行数据加载子节点
       */
      loadTreeChildren(row, childRecords) {
        const { keepSource } = props;
        const { tableSourceData, fullDataRowIdData, fullAllDataRowIdData, sourceDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const parentRest = fullAllDataRowIdData[getRowid($xetable, row)];
        const parentLevel = parentRest ? parentRest.level : 0;
        return tableMethods.createData(childRecords).then((rows) => {
          if (keepSource) {
            const rowid = getRowid($xetable, row);
            const matchObj = import_xe_utils41.default.findTree(tableSourceData, (item) => rowid === getRowid($xetable, item), { children: childrenField });
            if (matchObj) {
              matchObj.item[childrenField] = import_xe_utils41.default.clone(rows, true);
            }
            rows.forEach((childRow) => {
              const rowid2 = getRowid($xetable, childRow);
              sourceDataRowIdData[rowid2] = import_xe_utils41.default.clone(childRow, true);
            });
          }
          import_xe_utils41.default.eachTree(rows, (childRow, index, items, path, parent, nodes) => {
            const rowid = getRowid($xetable, childRow);
            const parentRow = parent || parentRest.row;
            const rest = { row: childRow, rowid, seq: -1, index, _index: -1, $index: -1, items, parent: parentRow, level: parentLevel + nodes.length };
            fullDataRowIdData[rowid] = rest;
            fullAllDataRowIdData[rowid] = rest;
          }, { children: childrenField });
          row[childrenField] = rows;
          if (transform) {
            row[mapChildrenField] = rows;
          }
          updateAfterDataIndex();
          return rows;
        });
      },
      /**
       * 加载列配置
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnInfo} columns 列配置
       */
      loadColumn(columns) {
        const collectColumn = import_xe_utils41.default.mapTree(columns, (column) => reactive(cell_default.createColumn($xetable, column)));
        return handleColumn(collectColumn);
      },
      /**
       * 加载列配置并恢复到初始状态
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnInfo} columns 列配置
       */
      reloadColumn(columns) {
        return tableMethods.clearAll().then(() => {
          return tableMethods.loadColumn(columns);
        });
      },
      /**
       * 根据 tr 元素获取对应的 row 信息
       * @param {Element} tr 元素
       */
      getRowNode(tr) {
        if (tr) {
          const { fullAllDataRowIdData } = internalData;
          const rowid = tr.getAttribute("rowid");
          if (rowid) {
            const rest = fullAllDataRowIdData[rowid];
            if (rest) {
              return { rowid: rest.rowid, item: rest.row, index: rest.index, items: rest.items, parent: rest.parent };
            }
          }
        }
        return null;
      },
      /**
       * 根据 th/td 元素获取对应的 column 信息
       * @param {Element} cell 元素
       */
      getColumnNode(cell) {
        if (cell) {
          const { fullColumnIdData } = internalData;
          const colid = cell.getAttribute("colid");
          if (colid) {
            const rest = fullColumnIdData[colid];
            if (rest) {
              return { colid: rest.colid, item: rest.column, index: rest.index, items: rest.items, parent: rest.parent };
            }
          }
        }
        return null;
      },
      /**
       * 根据 row 获取序号
       * @param {Row} row 行对象
       */
      getRowSeq: createGetRowCacheProp("seq"),
      /**
       * 根据 row 获取相对于 data 中的索引
       * @param {Row} row 行对象
       */
      getRowIndex: createGetRowCacheProp("index"),
      /**
       * 根据 row 获取相对于当前数据中的索引
       * @param {Row} row 行对象
       */
      getVTRowIndex: createGetRowCacheProp("_index"),
      /**
       * 根据 row 获取渲染中的虚拟索引
       * @param {Row} row 行对象
       */
      getVMRowIndex: createGetRowCacheProp("$index"),
      /**
       * 根据 column 获取相对于 columns 中的索引
       * @param {ColumnInfo} column 列配置
       */
      getColumnIndex: createGetColumnCacheProp("index"),
      /**
       * 根据 column 获取相对于当前表格列中的索引
       * @param {ColumnInfo} column 列配置
       */
      getVTColumnIndex: createGetColumnCacheProp("_index"),
      /**
       * 根据 column 获取渲染中的虚拟索引
       * @param {ColumnInfo} column 列配置
       */
      getVMColumnIndex: createGetColumnCacheProp("$index"),
      /**
       * 创建 data 对象
       * 对于某些特殊场景可能会用到，会自动对数据的字段名进行检测，如果不存在就自动定义
       * @param {Array} records 新数据
       */
      createData(records) {
        return nextTick().then(() => {
          return reactive(tablePrivateMethods.defineField(records));
        });
      },
      /**
       * 创建 Row|Rows 对象
       * 对于某些特殊场景需要对数据进行手动插入时可能会用到
       * @param {Array/Object} records 新数据
       */
      createRow(records) {
        const isArr = import_xe_utils41.default.isArray(records);
        if (!isArr) {
          records = [records || {}];
        }
        return tableMethods.createData(records).then((rows) => isArr ? rows : rows[0]);
      },
      /**
       * 还原数据
       * 如果不传任何参数，则还原整个表格
       * 如果传 row 则还原一行
       * 如果传 rows 则还原多行
       * 如果还额外传了 field 则还原指定的单元格数据
       */
      revertData(rows, field) {
        const { keepSource } = props;
        const { tableSourceData, sourceDataRowIdData } = internalData;
        if (!keepSource) {
          if (true) {
            warnLog("vxe.error.reqProp", ["keep-source"]);
          }
          return nextTick();
        }
        let targetRows = rows;
        if (rows) {
          if (!import_xe_utils41.default.isArray(rows)) {
            targetRows = [rows];
          }
        } else {
          targetRows = import_xe_utils41.default.toArray($xetable.getUpdateRecords());
        }
        if (targetRows.length) {
          targetRows.forEach((row) => {
            if (!tableMethods.isInsertByRow(row)) {
              const rowid = getRowid($xetable, row);
              const oRow = sourceDataRowIdData[rowid];
              if (oRow && row) {
                if (field) {
                  import_xe_utils41.default.set(row, field, import_xe_utils41.default.clone(import_xe_utils41.default.get(oRow, field), true));
                } else {
                  import_xe_utils41.default.destructuring(row, import_xe_utils41.default.clone(oRow, true));
                }
              }
            }
          });
        }
        if (rows) {
          return nextTick();
        }
        return tableMethods.reloadData(tableSourceData);
      },
      /**
       * 清空单元格内容
       * 如果不创参数，则清空整个表格内容
       * 如果传 row 则清空一行内容
       * 如果传 rows 则清空多行内容
       * 如果还额外传了 field 则清空指定单元格内容
       * @param {Array/Row} rows 行数据
       * @param {String} field 字段名
       */
      clearData(rows, field) {
        const { tableFullData, visibleColumn } = internalData;
        if (!arguments.length) {
          rows = tableFullData;
        } else if (rows && !import_xe_utils41.default.isArray(rows)) {
          rows = [rows];
        }
        if (field) {
          rows.forEach((row) => import_xe_utils41.default.set(row, field, null));
        } else {
          rows.forEach((row) => {
            visibleColumn.forEach((column) => {
              if (column.field) {
                setCellValue(row, column, null);
              }
            });
          });
        }
        return nextTick();
      },
      /**
       * 检查是否为临时行数据
       * @param {Row} row 行对象
       */
      isInsertByRow(row) {
        const { editStore } = reactData;
        const rowid = getRowid($xetable, row);
        return editStore.insertMaps[rowid];
      },
      /**
       * 删除所有新增的临时数据
       * @returns
       */
      removeInsertRow() {
        const { editStore } = reactData;
        editStore.insertMaps = {};
        return $xetable.remove($xetable.getInsertRecords());
      },
      /**
       * 检查行或列数据是否发生改变
       * @param {Row} row 行对象
       * @param {String} field 字段名
       */
      isUpdateByRow(row, field) {
        const { keepSource } = props;
        const { tableFullColumn, fullDataRowIdData, sourceDataRowIdData } = internalData;
        if (keepSource) {
          const rowid = getRowid($xetable, row);
          if (!fullDataRowIdData[rowid]) {
            return false;
          }
          const oRow = sourceDataRowIdData[rowid];
          if (oRow) {
            if (arguments.length > 1) {
              return !eqCellValue(oRow, row, field);
            }
            for (let index = 0, len = tableFullColumn.length; index < len; index++) {
              const property = tableFullColumn[index].field;
              if (property && !eqCellValue(oRow, row, property)) {
                return true;
              }
            }
          }
        }
        return false;
      },
      /**
       * 获取表格的可视列，也可以指定索引获取列
       * @param {Number} columnIndex 索引
       */
      getColumns(columnIndex) {
        const columns = internalData.visibleColumn;
        return import_xe_utils41.default.isUndefined(columnIndex) ? columns.slice(0) : columns[columnIndex];
      },
      /**
       * 根据列的唯一主键获取列
       * @param {String} colid 列主键
       */
      getColumnById(colid) {
        const fullColumnIdData = internalData.fullColumnIdData;
        return colid && fullColumnIdData[colid] ? fullColumnIdData[colid].column : null;
      },
      /**
       * 根据列的字段名获取列
       * @param {String} field 字段名
       */
      getColumnByField(field) {
        const fullColumnFieldData = internalData.fullColumnFieldData;
        return field && fullColumnFieldData[field] ? fullColumnFieldData[field].column : null;
      },
      /**
       * 获取当前表格的列
       * 收集到的全量列、全量表头列、处理条件之后的全量表头列、当前渲染中的表头列
       */
      getTableColumn() {
        return {
          collectColumn: internalData.collectColumn.slice(0),
          fullColumn: internalData.tableFullColumn.slice(0),
          visibleColumn: internalData.visibleColumn.slice(0),
          tableColumn: reactData.tableColumn.slice(0)
        };
      },
      /**
       * 获取数据，和 data 的行为一致，也可以指定索引获取数据
       */
      getData(rowIndex) {
        const tableSynchData = props.data || internalData.tableSynchData;
        return import_xe_utils41.default.isUndefined(rowIndex) ? tableSynchData.slice(0) : tableSynchData[rowIndex];
      },
      /**
       * 用于多选行，获取已选中的数据
       */
      getCheckboxRecords(isFull) {
        const { treeConfig } = props;
        const { tableFullData, afterFullData, afterTreeFullData, tableFullTreeData, fullDataRowIdData, afterFullRowMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const { checkField } = checkboxOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let rowList = [];
        const currTableData = isFull ? transform ? tableFullTreeData : tableFullData : transform ? afterTreeFullData : afterFullData;
        if (checkField) {
          if (treeConfig) {
            rowList = import_xe_utils41.default.filterTree(currTableData, (row) => import_xe_utils41.default.get(row, checkField), { children: transform ? mapChildrenField : childrenField });
          } else {
            rowList = currTableData.filter((row) => import_xe_utils41.default.get(row, checkField));
          }
        } else {
          const { selectCheckboxMaps } = reactData;
          import_xe_utils41.default.each(selectCheckboxMaps, (row, rowid) => {
            if (isFull) {
              if (fullDataRowIdData[rowid]) {
                rowList.push(fullDataRowIdData[rowid].row);
              }
            } else {
              if (afterFullRowMaps[rowid]) {
                rowList.push(afterFullRowMaps[rowid]);
              }
            }
          });
        }
        return rowList;
      },
      /**
       * 只对 tree-config 有效，获取行的父级
       */
      getParentRow(rowOrRowid) {
        const { treeConfig } = props;
        const { fullDataRowIdData } = internalData;
        if (rowOrRowid && treeConfig) {
          let rowid;
          if (import_xe_utils41.default.isString(rowOrRowid)) {
            rowid = rowOrRowid;
          } else {
            rowid = getRowid($xetable, rowOrRowid);
          }
          if (rowid) {
            const rest = fullDataRowIdData[rowid];
            return rest ? rest.parent : null;
          }
        }
        return null;
      },
      /**
       * 根据行的唯一主键获取行
       * @param {String/Number} rowid 行主键
       */
      getRowById(cellValue) {
        const { fullDataRowIdData } = internalData;
        const rowid = import_xe_utils41.default.eqNull(cellValue) ? "" : encodeURIComponent(cellValue || "");
        return fullDataRowIdData[rowid] ? fullDataRowIdData[rowid].row : null;
      },
      /**
       * 根据行获取行的唯一主键
       * @param {Row} row 行对象
       */
      getRowid(row) {
        return getRowid($xetable, row);
      },
      /**
       * 获取处理后的表格数据
       * 如果存在筛选条件，继续处理
       * 如果存在排序，继续处理
       */
      getTableData() {
        const { tableData, footerTableData } = reactData;
        const { tableFullData, afterFullData, tableFullTreeData } = internalData;
        return {
          fullData: props.treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0),
          visibleData: afterFullData.slice(0),
          tableData: tableData.slice(0),
          footerData: footerTableData.slice(0)
        };
      },
      /**
       * 设置为固定列
       */
      setColumnFixed(fieldOrColumn, fixed) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        const targetColumn = getRootColumn($xetable, column);
        const isMaxFixedColumn = computeIsMaxFixedColumn.value;
        const columnOpts = computeColumnOpts.value;
        const { maxFixedSize } = columnOpts;
        if (targetColumn && targetColumn.fixed !== fixed) {
          if (!targetColumn.fixed && isMaxFixedColumn) {
            if (VXETable.modal) {
              VXETable.modal.message({
                status: "error",
                content: conf_default.i18n("vxe.table.maxFixedCol", [maxFixedSize])
              });
            }
            return nextTick();
          }
          import_xe_utils41.default.eachTree([targetColumn], (column2) => {
            column2.fixed = fixed;
          });
          tablePrivateMethods.saveCustomFixed();
          return tableMethods.refreshColumn();
        }
        return nextTick();
      },
      /**
       * 取消指定固定列
       */
      clearColumnFixed(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        const targetColumn = getRootColumn($xetable, column);
        if (targetColumn && targetColumn.fixed) {
          import_xe_utils41.default.eachTree([targetColumn], (column2) => {
            column2.fixed = null;
          });
          tablePrivateMethods.saveCustomFixed();
          return tableMethods.refreshColumn();
        }
        return nextTick();
      },
      /**
       * 隐藏指定列
       */
      hideColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column && column.visible) {
          column.visible = false;
          return tablePrivateMethods.handleCustom();
        }
        return nextTick();
      },
      /**
       * 显示指定列
       */
      showColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column && !column.visible) {
          column.visible = true;
          return tablePrivateMethods.handleCustom();
        }
        return nextTick();
      },
      setColumnWidth(fieldOrColumn, width) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column) {
          const colWidth = import_xe_utils41.default.toInteger(width);
          let rdWidth = colWidth;
          if (isScale(width)) {
            const tableBody = refTableBody.value;
            const bodyElem = tableBody ? tableBody.$el : null;
            const bodyWidth = bodyElem ? bodyElem.clientWidth - 1 : 0;
            rdWidth = Math.floor(colWidth * bodyWidth);
          }
          column.renderWidth = rdWidth;
        }
        return nextTick();
      },
      getColumnWidth(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column) {
          return column.renderWidth;
        }
        return 0;
      },
      /**
       * 手动重置列的显示隐藏、列宽拖动的状态、固定列、排序列；
       * 如果为 true 则重置所有状态
       * 如果已关联工具栏，则会同步更新
       */
      resetCustom(options) {
        const { collectColumn } = internalData;
        const customOpts = computeCustomOpts.value;
        const { checkMethod } = customOpts;
        const opts = Object.assign({
          visible: true,
          resizable: options === true,
          fixed: options === true,
          sort: options === true
        }, options);
        import_xe_utils41.default.eachTree(collectColumn, (column) => {
          if (opts.resizable) {
            column.resizeWidth = 0;
          }
          if (opts.fixed) {
            column.fixed = column.defaultFixed;
          }
          if (opts.sort) {
            column.renderSortNumber = column.sortNumber;
          }
          if (!checkMethod || checkMethod({ column })) {
            column.visible = column.defaultVisible;
          }
        });
        if (opts.resizable) {
          tablePrivateMethods.saveCustomResizable(true);
        }
        if (opts.sort) {
          tablePrivateMethods.saveCustomSort(true);
        }
        if (opts.fixed) {
          tablePrivateMethods.saveCustomFixed();
        }
        return tablePrivateMethods.handleCustom();
      },
      resetColumn(options) {
        warnLog("vxe.error.delFunc", ["resetColumn", "resetCustom"]);
        return $xetable.resetCustom(options);
      },
      /**
       * 刷新列信息
       * 将固定的列左边、右边分别靠边
       * 如果传 true 则会检查列顺序并排序
       */
      refreshColumn(resiveOrder) {
        if (resiveOrder) {
          const columnList = import_xe_utils41.default.orderBy(internalData.collectColumn, "renderSortNumber");
          internalData.collectColumn = columnList;
          const tableFullColumn = getColumnList(columnList);
          internalData.tableFullColumn = tableFullColumn;
          cacheColumnMap();
        }
        return parseColumns().then(() => {
          return tableMethods.refreshScroll();
        }).then(() => {
          return tableMethods.recalculate();
        });
      },
      /**
       * 刷新滚动操作，手动同步滚动相关位置（对于某些特殊的操作，比如滚动条错位、固定列不同步）
       */
      refreshScroll() {
        const { lastScrollLeft, lastScrollTop } = internalData;
        const tableBody = refTableBody.value;
        const tableFooter = refTableFooter.value;
        const leftBody = refTableLeftBody.value;
        const rightBody = refTableRightBody.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        const leftBodyElem = leftBody ? leftBody.$el : null;
        const rightBodyElem = rightBody ? rightBody.$el : null;
        const tableFooterElem = tableFooter ? tableFooter.$el : null;
        return new Promise((resolve) => {
          if (lastScrollLeft || lastScrollTop) {
            return restoreScrollLocation($xetable, lastScrollLeft, lastScrollTop).then().then(() => {
              setTimeout(resolve, 30);
            });
          }
          setScrollTop(tableBodyElem, lastScrollTop);
          setScrollTop(leftBodyElem, lastScrollTop);
          setScrollTop(rightBodyElem, lastScrollTop);
          setScrollLeft(tableFooterElem, lastScrollLeft);
          setTimeout(resolve, 30);
        });
      },
      /**
       * 计算单元格列宽，动态分配可用剩余空间
       * 支持 width=? width=?px width=?% min-width=? min-width=?px min-width=?%
       */
      recalculate(refull) {
        autoCellWidth();
        if (refull === true) {
          return computeScrollLoad().then(() => {
            autoCellWidth();
            return computeScrollLoad();
          });
        }
        return computeScrollLoad();
      },
      openTooltip(target, content) {
        const $commTip = refCommTooltip.value;
        if ($commTip) {
          return $commTip.open(target, content);
        }
        return nextTick();
      },
      /**
       * 关闭 tooltip
       */
      closeTooltip() {
        const { tooltipStore } = reactData;
        const $tooltip = refTooltip.value;
        const $commTip = refCommTooltip.value;
        if (tooltipStore.visible) {
          Object.assign(tooltipStore, {
            row: null,
            column: null,
            content: null,
            visible: false
          });
          if ($tooltip) {
            $tooltip.close();
          }
        }
        if ($commTip) {
          $commTip.close();
        }
        return nextTick();
      },
      /**
       * 判断列头复选框是否被选中
       */
      isAllCheckboxChecked() {
        return reactData.isAllSelected;
      },
      /**
       * 判断列头复选框是否被半选
       */
      isAllCheckboxIndeterminate() {
        return !reactData.isAllSelected && reactData.isIndeterminate;
      },
      /**
       * 获取复选框半选状态的行数据
       */
      getCheckboxIndeterminateRecords(isFull) {
        const { treeConfig } = props;
        const { fullDataRowIdData } = internalData;
        const { treeIndeterminateMaps } = reactData;
        if (treeConfig) {
          const fullRest = [];
          const defRest = [];
          import_xe_utils41.default.each(treeIndeterminateMaps, (item, rowid) => {
            if (item) {
              fullRest.push(item);
              if (fullDataRowIdData[rowid]) {
                defRest.push(item);
              }
            }
          });
          if (isFull) {
            return fullRest;
          }
          return defRest;
        }
        return [];
      },
      /**
       * 用于多选行，设置行为选中状态，第二个参数为选中与否
       * @param {Array/Row} rows 行数据
       * @param {Boolean} value 是否选中
       */
      setCheckboxRow(rows, value) {
        return handleCheckedCheckboxRow(rows, value, true);
      },
      isCheckedByCheckboxRow(row) {
        const { selectCheckboxMaps } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        if (checkField) {
          return import_xe_utils41.default.get(row, checkField);
        }
        return !!selectCheckboxMaps[getRowid($xetable, row)];
      },
      isIndeterminateByCheckboxRow(row) {
        const { treeIndeterminateMaps } = reactData;
        return !!treeIndeterminateMaps[getRowid($xetable, row)] && !tableMethods.isCheckedByCheckboxRow(row);
      },
      /**
       * 多选，切换某一行的选中状态
       */
      toggleCheckboxRow(row) {
        const { selectCheckboxMaps } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        const value = checkField ? !import_xe_utils41.default.get(row, checkField) : !selectCheckboxMaps[getRowid($xetable, row)];
        tablePrivateMethods.handleSelectRow({ row }, value, true);
        return nextTick();
      },
      /**
       * 用于多选行，设置所有行的选中状态
       * @param {Boolean} value 是否选中
       */
      setAllCheckboxRow(value) {
        return handleCheckedAllCheckboxRow(value, true);
      },
      /**
       * 获取单选框保留选中的行
       */
      getRadioReserveRecord(isFull) {
        const { treeConfig } = props;
        const { fullDataRowIdData, radioReserveRow, afterFullData } = internalData;
        const radioOpts = computeRadioOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (radioOpts.reserve && radioReserveRow) {
          const rowid = getRowid($xetable, radioReserveRow);
          if (isFull) {
            if (!fullDataRowIdData[rowid]) {
              return radioReserveRow;
            }
          } else {
            const rowkey = getRowkey($xetable);
            if (treeConfig) {
              const matchObj = import_xe_utils41.default.findTree(afterFullData, (row) => rowid === import_xe_utils41.default.get(row, rowkey), { children: childrenField });
              if (matchObj) {
                return radioReserveRow;
              }
            } else {
              if (!afterFullData.some((row) => rowid === import_xe_utils41.default.get(row, rowkey))) {
                return radioReserveRow;
              }
            }
          }
        }
        return null;
      },
      clearRadioReserve() {
        internalData.radioReserveRow = null;
        return nextTick();
      },
      /**
       * 获取复选框保留选中的行
       */
      getCheckboxReserveRecords(isFull) {
        const { treeConfig } = props;
        const { afterFullData, fullDataRowIdData, checkboxReserveRowMap } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const reserveSelection = [];
        if (checkboxOpts.reserve) {
          const afterFullIdMaps = {};
          if (treeConfig) {
            import_xe_utils41.default.eachTree(afterFullData, (row) => {
              afterFullIdMaps[getRowid($xetable, row)] = 1;
            }, { children: childrenField });
          } else {
            afterFullData.forEach((row) => {
              afterFullIdMaps[getRowid($xetable, row)] = 1;
            });
          }
          import_xe_utils41.default.each(checkboxReserveRowMap, (oldRow, oldRowid) => {
            if (oldRow) {
              if (isFull) {
                if (!fullDataRowIdData[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              } else {
                if (!afterFullIdMaps[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              }
            }
          });
        }
        return reserveSelection;
      },
      clearCheckboxReserve() {
        internalData.checkboxReserveRowMap = {};
        return nextTick();
      },
      /**
       * 多选，切换所有行的选中状态
       */
      toggleAllCheckboxRow() {
        tablePrivateMethods.triggerCheckAllEvent(null, !reactData.isAllSelected);
        return nextTick();
      },
      /**
       * 用于多选行，手动清空用户的选择
       * 清空行为不管是否被禁用还是保留记录，都将彻底清空选中状态
       */
      clearCheckboxRow() {
        const { treeConfig } = props;
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, reserve } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        if (checkField) {
          const handleClearChecked = (item) => {
            if (treeConfig && indeterminateField) {
              import_xe_utils41.default.set(item, indeterminateField, false);
            }
            import_xe_utils41.default.set(item, checkField, false);
          };
          if (treeConfig) {
            import_xe_utils41.default.eachTree(tableFullData, handleClearChecked, { children: childrenField });
          } else {
            tableFullData.forEach(handleClearChecked);
          }
        }
        if (reserve) {
          tableFullData.forEach((row) => handleCheckboxReserveRow(row, false));
        }
        reactData.isAllSelected = false;
        reactData.isIndeterminate = false;
        reactData.selectCheckboxMaps = {};
        reactData.treeIndeterminateMaps = {};
        return nextTick();
      },
      /**
       * 用于当前行，设置某一行为高亮状态
       * @param {Row} row 行对象
       */
      setCurrentRow(row) {
        const rowOpts = computeRowOpts.value;
        const el = refElem.value;
        tableMethods.clearCurrentRow();
        reactData.currentRow = row;
        if (rowOpts.isCurrent || props.highlightCurrentRow) {
          if (el) {
            import_xe_utils41.default.arrayEach(el.querySelectorAll(`[rowid="${getRowid($xetable, row)}"]`), (elem) => addClass(elem, "row--current"));
          }
        }
        return nextTick();
      },
      isCheckedByRadioRow(row) {
        return $xetable.eqRow(reactData.selectRadioRow, row);
      },
      /**
       * 用于单选行，设置某一行为选中状态
       * @param {Row} row 行对象
       */
      setRadioRow(row) {
        return handleCheckedRadioRow(row, true);
      },
      /**
       * 用于当前行，手动清空当前高亮的状态
       */
      clearCurrentRow() {
        const el = refElem.value;
        reactData.currentRow = null;
        internalData.hoverRow = null;
        if (el) {
          import_xe_utils41.default.arrayEach(el.querySelectorAll(".row--current"), (elem) => removeClass(elem, "row--current"));
        }
        return nextTick();
      },
      /**
       * 用于单选行，手动清空用户的选择
       */
      clearRadioRow() {
        reactData.selectRadioRow = null;
        return nextTick();
      },
      /**
       * 用于当前行，获取当前行的数据
       */
      getCurrentRecord() {
        const rowOpts = computeRowOpts.value;
        return rowOpts.isCurrent || props.highlightCurrentRow ? reactData.currentRow : null;
      },
      /**
       * 用于单选行，获取当已选中的数据
       */
      getRadioRecord(isFull) {
        const { fullDataRowIdData, afterFullRowMaps } = internalData;
        const { selectRadioRow } = reactData;
        if (selectRadioRow) {
          const rowid = getRowid($xetable, selectRadioRow);
          if (isFull) {
            if (fullDataRowIdData[rowid]) {
              return selectRadioRow;
            }
          } else {
            if (afterFullRowMaps[rowid]) {
              return selectRadioRow;
            }
          }
        }
        return null;
      },
      getCurrentColumn() {
        const columnOpts = computeColumnOpts.value;
        return columnOpts.isCurrent || props.highlightCurrentColumn ? reactData.currentColumn : null;
      },
      /**
       * 用于当前列，设置某列行为高亮状态
       */
      setCurrentColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column) {
          tableMethods.clearCurrentColumn();
          reactData.currentColumn = column;
        }
        return nextTick();
      },
      /**
       * 用于当前列，手动清空当前高亮的状态
       */
      clearCurrentColumn() {
        reactData.currentColumn = null;
        return nextTick();
      },
      setPendingRow(rows, status) {
        const pendingMaps = Object.assign({}, reactData.pendingRowMaps);
        const pendingList = [...reactData.pendingRowList];
        if (rows && !import_xe_utils41.default.isArray(rows)) {
          rows = [rows];
        }
        if (status) {
          rows.forEach((row) => {
            const rowid = getRowid($xetable, row);
            if (rowid && !pendingMaps[rowid]) {
              pendingList.push(row);
              pendingMaps[rowid] = row;
            }
          });
        } else {
          rows.forEach((row) => {
            const rowid = getRowid($xetable, row);
            if (rowid && pendingMaps[rowid]) {
              const pendingIndex = $xetable.findRowIndexOf(pendingList, row);
              if (pendingIndex > -1) {
                pendingList.splice(pendingIndex, 1);
              }
              delete pendingMaps[rowid];
            }
          });
        }
        reactData.pendingRowMaps = pendingMaps;
        reactData.pendingRowList = pendingList;
        return nextTick();
      },
      togglePendingRow(rows) {
        const pendingMaps = Object.assign({}, reactData.pendingRowMaps);
        const pendingList = [...reactData.pendingRowList];
        if (rows && !import_xe_utils41.default.isArray(rows)) {
          rows = [rows];
        }
        rows.forEach((row) => {
          const rowid = getRowid($xetable, row);
          if (rowid) {
            if (pendingMaps[rowid]) {
              const pendingIndex = $xetable.findRowIndexOf(pendingList, row);
              if (pendingIndex > -1) {
                pendingList.splice(pendingIndex, 1);
              }
              delete pendingMaps[rowid];
            } else {
              pendingList.push(row);
              pendingMaps[rowid] = row;
            }
          }
        });
        reactData.pendingRowMaps = pendingMaps;
        reactData.pendingRowList = pendingList;
        return nextTick();
      },
      hasPendingByRow(row) {
        const { pendingRowMaps } = reactData;
        const rowid = getRowid($xetable, row);
        return !!pendingRowMaps[rowid];
      },
      getPendingRecords() {
        const { pendingRowList } = reactData;
        return pendingRowList.slice(0);
      },
      clearPendingRow() {
        reactData.pendingRowMaps = {};
        reactData.pendingRowList = [];
        return nextTick();
      },
      sort(sortConfs, sortOrder) {
        const sortOpts = computeSortOpts.value;
        const { multiple, remote, orders } = sortOpts;
        if (sortConfs) {
          if (import_xe_utils41.default.isString(sortConfs)) {
            sortConfs = [
              { field: sortConfs, order: sortOrder }
            ];
          }
        }
        if (!import_xe_utils41.default.isArray(sortConfs)) {
          sortConfs = [sortConfs];
        }
        if (sortConfs.length) {
          if (!multiple) {
            clearAllSort();
          }
          (multiple ? sortConfs : [sortConfs[0]]).forEach((confs, index) => {
            let { field, order } = confs;
            let column = field;
            if (import_xe_utils41.default.isString(field)) {
              column = tableMethods.getColumnByField(field);
            }
            if (column && column.sortable) {
              if (orders.indexOf(order) === -1) {
                order = getNextSortOrder(column);
              }
              if (column.order !== order) {
                column.order = order;
              }
              column.sortTime = Date.now() + index;
            }
          });
          if (!remote) {
            tablePrivateMethods.handleTableData(true);
          }
          return nextTick().then(() => {
            tableMethods.updateCellAreas();
            return updateStyle();
          });
        }
        return nextTick();
      },
      /**
       * 清空指定列的排序条件
       * 如果为空则清空所有列的排序条件
       * @param {String} fieldOrColumn 列或字段名
       */
      clearSort(fieldOrColumn) {
        const sortOpts = computeSortOpts.value;
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xetable, fieldOrColumn);
          if (column) {
            column.order = null;
          }
        } else {
          clearAllSort();
        }
        if (!sortOpts.remote) {
          tablePrivateMethods.handleTableData(true);
        }
        return nextTick().then(updateStyle);
      },
      isSort(fieldOrColumn) {
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xetable, fieldOrColumn);
          return column ? column.sortable && !!column.order : false;
        }
        return tableMethods.getSortColumns().length > 0;
      },
      getSortColumns() {
        const sortOpts = computeSortOpts.value;
        const { multiple, chronological } = sortOpts;
        const sortList = [];
        const { tableFullColumn } = internalData;
        tableFullColumn.forEach((column) => {
          const { field, order } = column;
          if (column.sortable && order) {
            sortList.push({ column, field, property: field, order, sortTime: column.sortTime });
          }
        });
        if (multiple && chronological && sortList.length > 1) {
          return import_xe_utils41.default.orderBy(sortList, "sortTime");
        }
        return sortList;
      },
      /**
       * 关闭筛选
       * @param {Event} evnt 事件
       */
      closeFilter() {
        const { filterStore } = reactData;
        const { column, visible } = filterStore;
        Object.assign(filterStore, {
          isAllSelected: false,
          isIndeterminate: false,
          options: [],
          visible: false
        });
        if (visible) {
          $xetable.dispatchEvent("filter-visible", { column, property: column.field, field: column.field, filterList: $xetable.getCheckedFilters(), visible: false }, null);
        }
        return nextTick();
      },
      /**
       * 判断指定列是否为筛选状态，如果为空则判断所有列
       * @param {String} fieldOrColumn 字段名
       */
      isActiveFilterByColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column) {
          return column.filters && column.filters.some((option) => option.checked);
        }
        return $xetable.getCheckedFilters().length > 0;
      },
      isFilter(fieldOrColumn) {
        return tableMethods.isActiveFilterByColumn(fieldOrColumn);
      },
      /**
       * 判断展开行是否懒加载完成
       * @param {Row} row 行对象
       */
      isRowExpandLoaded(row) {
        const { fullAllDataRowIdData } = internalData;
        const rest = fullAllDataRowIdData[getRowid($xetable, row)];
        return rest && !!rest.expandLoaded;
      },
      clearRowExpandLoaded(row) {
        const { rowExpandLazyLoadedMaps } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { lazy } = expandOpts;
        const rowid = getRowid($xetable, row);
        const rest = fullAllDataRowIdData[rowid];
        if (lazy && rest) {
          rest.expandLoaded = false;
          delete rowExpandLazyLoadedMaps[rowid];
        }
        return nextTick();
      },
      /**
       * 重新懒加载展开行，并展开内容
       * @param {Row} row 行对象
       */
      reloadRowExpand(row) {
        const { rowExpandLazyLoadedMaps } = reactData;
        const expandOpts = computeExpandOpts.value;
        const { lazy } = expandOpts;
        const rowid = getRowid($xetable, row);
        if (lazy && !rowExpandLazyLoadedMaps[rowid]) {
          tableMethods.clearRowExpandLoaded(row).then(() => handleAsyncRowExpand(row));
        }
        return nextTick();
      },
      reloadExpandContent(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["reloadExpandContent", "reloadRowExpand"]);
        }
        return tableMethods.reloadRowExpand(row);
      },
      /**
       * 切换展开行
       */
      toggleRowExpand(row) {
        return tableMethods.setRowExpand(row, !tableMethods.isRowExpandByRow(row));
      },
      /**
       * 设置所有行的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllRowExpand(expanded) {
        const treeOpts = computeTreeOpts.value;
        const { tableFullData, tableFullTreeData } = internalData;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let expandedRows = [];
        if (props.treeConfig) {
          import_xe_utils41.default.eachTree(tableFullTreeData, (row) => {
            expandedRows.push(row);
          }, { children: childrenField });
        } else {
          expandedRows = tableFullData;
        }
        return tableMethods.setRowExpand(expandedRows, expanded);
      },
      /**
       * 设置展开行，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setRowExpand(rows, expanded) {
        const { rowExpandedMaps, rowExpandLazyLoadedMaps, expandColumn: column } = reactData;
        const { fullAllDataRowIdData } = internalData;
        let rExpandedMaps = Object.assign({}, rowExpandedMaps);
        const expandOpts = computeExpandOpts.value;
        const { reserve, lazy, accordion, toggleMethod } = expandOpts;
        const lazyRests = [];
        const columnIndex = tableMethods.getColumnIndex(column);
        const $columnIndex = tableMethods.getVMColumnIndex(column);
        if (rows) {
          if (!import_xe_utils41.default.isArray(rows)) {
            rows = [rows];
          }
          if (accordion) {
            rExpandedMaps = {};
            rows = rows.slice(rows.length - 1, rows.length);
          }
          const validRows = toggleMethod ? rows.filter((row) => toggleMethod({ $table: $xetable, expanded, column, columnIndex, $columnIndex, row, rowIndex: tableMethods.getRowIndex(row), $rowIndex: tableMethods.getVMRowIndex(row) })) : rows;
          if (expanded) {
            validRows.forEach((row) => {
              const rowid = getRowid($xetable, row);
              if (!rExpandedMaps[rowid]) {
                const rest = fullAllDataRowIdData[rowid];
                const isLoad = lazy && !rest.expandLoaded && !rowExpandLazyLoadedMaps[rowid];
                if (isLoad) {
                  lazyRests.push(handleAsyncRowExpand(row));
                } else {
                  rExpandedMaps[rowid] = row;
                }
              }
            });
          } else {
            validRows.forEach((item) => {
              const rowid = getRowid($xetable, item);
              if (rExpandedMaps[rowid]) {
                delete rExpandedMaps[rowid];
              }
            });
          }
          if (reserve) {
            validRows.forEach((row) => handleRowExpandReserve(row, expanded));
          }
        }
        reactData.rowExpandedMaps = rExpandedMaps;
        return Promise.all(lazyRests).then(() => tableMethods.recalculate());
      },
      /**
       * 判断行是否为展开状态
       * @param {Row} row 行对象
       */
      isRowExpandByRow(row) {
        const { rowExpandedMaps } = reactData;
        const rowid = getRowid($xetable, row);
        return !!rowExpandedMaps[rowid];
      },
      isExpandByRow(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["isExpandByRow", "isRowExpandByRow"]);
        }
        return tableMethods.isRowExpandByRow(row);
      },
      /**
       * 手动清空展开行状态，数据会恢复成未展开的状态
       */
      clearRowExpand() {
        const { tableFullData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { reserve } = expandOpts;
        const expList = tableMethods.getRowExpandRecords();
        reactData.rowExpandedMaps = {};
        if (reserve) {
          tableFullData.forEach((row) => handleRowExpandReserve(row, false));
        }
        return nextTick().then(() => {
          if (expList.length) {
            tableMethods.recalculate();
          }
        });
      },
      clearRowExpandReserve() {
        internalData.rowExpandedReserveRowMap = {};
        return nextTick();
      },
      getRowExpandRecords() {
        const rest = [];
        import_xe_utils41.default.each(reactData.rowExpandedMaps, (item) => {
          if (item) {
            rest.push(item);
          }
        });
        return rest;
      },
      getTreeExpandRecords() {
        const rest = [];
        import_xe_utils41.default.each(reactData.treeExpandedMaps, (item) => {
          if (item) {
            rest.push(item);
          }
        });
        return rest;
      },
      /**
       * 判断树节点是否懒加载完成
       * @param {Row} row 行对象
       */
      isTreeExpandLoaded(row) {
        const { fullAllDataRowIdData } = internalData;
        const rest = fullAllDataRowIdData[getRowid($xetable, row)];
        return rest && !!rest.treeLoaded;
      },
      clearTreeExpandLoaded(row) {
        const { treeExpandedMaps } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, lazy } = treeOpts;
        const rowid = getRowid($xetable, row);
        const rest = fullAllDataRowIdData[rowid];
        if (lazy && rest) {
          rest.treeLoaded = false;
          if (treeExpandedMaps[rowid]) {
            delete treeExpandedMaps[rowid];
          }
        }
        if (transform) {
          handleVirtualTreeToList();
          return tablePrivateMethods.handleTableData();
        }
        return nextTick();
      },
      /**
       * 重新懒加载树节点，并展开该节点
       * @param {Row} row 行对象
       */
      reloadTreeExpand(row) {
        const { treeExpandLazyLoadedMaps } = reactData;
        const treeOpts = computeTreeOpts.value;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const { transform, lazy } = treeOpts;
        const rowid = getRowid($xetable, row);
        if (lazy && row[hasChildField] && !treeExpandLazyLoadedMaps[rowid]) {
          tableMethods.clearTreeExpandLoaded(row).then(() => {
            return handleAsyncTreeExpandChilds(row);
          }).then(() => {
            if (transform) {
              handleVirtualTreeToList();
              return tablePrivateMethods.handleTableData();
            }
          }).then(() => {
            return tableMethods.recalculate();
          });
        }
        return nextTick();
      },
      reloadTreeChilds(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["reloadTreeChilds", "reloadTreeExpand"]);
        }
        return tableMethods.reloadTreeExpand(row);
      },
      /**
       * 切换/展开树节点
       */
      toggleTreeExpand(row) {
        return tableMethods.setTreeExpand(row, !tableMethods.isTreeExpandByRow(row));
      },
      /**
       * 设置所有树节点的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllTreeExpand(expanded) {
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, lazy } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const expandeds = [];
        import_xe_utils41.default.eachTree(tableFullData, (row) => {
          const rowChildren = row[childrenField];
          if (lazy || rowChildren && rowChildren.length) {
            expandeds.push(row);
          }
        }, { children: childrenField });
        return tableMethods.setTreeExpand(expandeds, expanded).then(() => {
          if (transform) {
            handleVirtualTreeToList();
            return tableMethods.recalculate();
          }
        });
      },
      /**
       * 设置展开树形节点，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setTreeExpand(rows, expanded) {
        const treeOpts = computeTreeOpts.value;
        const { transform } = treeOpts;
        if (rows) {
          if (!import_xe_utils41.default.isArray(rows)) {
            rows = [rows];
          }
          if (rows.length) {
            if (transform) {
              return handleVirtualTreeExpand(rows, expanded);
            } else {
              return handleBaseTreeExpand(rows, expanded);
            }
          }
        }
        return nextTick();
      },
      /**
       * 判断行是否为树形节点展开状态
       * @param {Row} row 行对象
       */
      isTreeExpandByRow(row) {
        const { treeExpandedMaps } = reactData;
        return !!treeExpandedMaps[getRowid($xetable, row)];
      },
      /**
       * 手动清空树形节点的展开状态，数据会恢复成未展开的状态
       */
      clearTreeExpand() {
        const { tableFullTreeData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const { transform, reserve } = treeOpts;
        const expList = tableMethods.getTreeExpandRecords();
        reactData.treeExpandedMaps = {};
        if (reserve) {
          import_xe_utils41.default.eachTree(tableFullTreeData, (row) => handleTreeExpandReserve(row, false), { children: childrenField });
        }
        return tablePrivateMethods.handleTableData().then(() => {
          if (transform) {
            handleVirtualTreeToList();
            return tablePrivateMethods.handleTableData();
          }
        }).then(() => {
          if (expList.length) {
            return tableMethods.recalculate();
          }
        });
      },
      clearTreeExpandReserve() {
        internalData.treeExpandedReserveRowMap = {};
        return nextTick();
      },
      /**
       * 获取表格的滚动状态
       */
      getScroll() {
        const { scrollXLoad, scrollYLoad } = reactData;
        const tableBody = refTableBody.value;
        const bodyElem = tableBody.$el;
        return {
          virtualX: scrollXLoad,
          virtualY: scrollYLoad,
          scrollTop: bodyElem.scrollTop,
          scrollLeft: bodyElem.scrollLeft
        };
      },
      /**
       * 如果有滚动条，则滚动到对应的位置
       * @param {Number} scrollLeft 左距离
       * @param {Number} scrollTop 上距离
       */
      scrollTo(scrollLeft, scrollTop) {
        const tableBody = refTableBody.value;
        const tableFooter = refTableFooter.value;
        const rightBody = refTableRightBody.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        const rightBodyElem = rightBody ? rightBody.$el : null;
        const tableFooterElem = tableFooter ? tableFooter.$el : null;
        if (import_xe_utils41.default.isNumber(scrollLeft)) {
          setScrollLeft(tableFooterElem || tableBodyElem, scrollLeft);
        }
        if (import_xe_utils41.default.isNumber(scrollTop)) {
          setScrollTop(rightBodyElem || tableBodyElem, scrollTop);
        }
        if (reactData.scrollXLoad || reactData.scrollYLoad) {
          return new Promise((resolve) => {
            setTimeout(() => {
              nextTick(() => {
                resolve();
              });
            }, 50);
          });
        }
        return nextTick();
      },
      /**
       * 如果有滚动条，则滚动到对应的行
       * @param {Row} row 行对象
       * @param {ColumnInfo} fieldOrColumn 列配置
       */
      scrollToRow(row, fieldOrColumn) {
        const rest = [];
        if (row) {
          if (props.treeConfig) {
            rest.push(tablePrivateMethods.scrollToTreeRow(row));
          } else {
            rest.push(rowToVisible($xetable, row));
          }
        }
        if (fieldOrColumn) {
          rest.push(tableMethods.scrollToColumn(fieldOrColumn));
        }
        return Promise.all(rest);
      },
      /**
       * 如果有滚动条，则滚动到对应的列
       */
      scrollToColumn(fieldOrColumn) {
        const { fullColumnIdData } = internalData;
        const column = handleFieldOrColumn($xetable, fieldOrColumn);
        if (column && fullColumnIdData[column.id]) {
          return colToVisible($xetable, column);
        }
        return nextTick();
      },
      /**
       * 手动清除滚动相关信息，还原到初始状态
       */
      clearScroll() {
        const { scrollXStore, scrollYStore } = internalData;
        const tableBody = refTableBody.value;
        const tableFooter = refTableFooter.value;
        const rightBody = refTableRightBody.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        const rightBodyElem = rightBody ? rightBody.$el : null;
        const tableFooterElem = tableFooter ? tableFooter.$el : null;
        if (rightBodyElem) {
          restoreScrollListener(rightBodyElem);
          rightBodyElem.scrollTop = 0;
        }
        if (tableFooterElem) {
          tableFooterElem.scrollLeft = 0;
        }
        if (tableBodyElem) {
          restoreScrollListener(tableBodyElem);
          tableBodyElem.scrollTop = 0;
          tableBodyElem.scrollLeft = 0;
        }
        scrollXStore.startIndex = 0;
        scrollYStore.startIndex = 0;
        return nextTick();
      },
      /**
       * 更新表尾合计
       */
      updateFooter() {
        const { showFooter, footerData, footerMethod } = props;
        const { visibleColumn, afterFullData } = internalData;
        let footData = [];
        if (showFooter && footerData && footerData.length) {
          footData = footerData.slice(0);
        } else if (showFooter && footerMethod) {
          footData = visibleColumn.length ? footerMethod({ columns: visibleColumn, data: afterFullData, $table: $xetable, $grid: $xegrid }) : [];
        }
        reactData.footerTableData = footData;
        return nextTick();
      },
      /**
       * 更新列状态 updateStatus({ row, column }, cellValue)
       * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一列编辑状态
       * 如果单元格配置了校验规则，则会进行校验
       */
      updateStatus(slotParams, cellValue) {
        const customVal = !import_xe_utils41.default.isUndefined(cellValue);
        return nextTick().then(() => {
          const { editRules } = props;
          const { validStore } = reactData;
          const tableBody = refTableBody.value;
          if (slotParams && tableBody && editRules) {
            const { row, column } = slotParams;
            const type = "change";
            if ($xetable.hasCellRules) {
              if ($xetable.hasCellRules(type, row, column)) {
                const cell = tablePrivateMethods.getCell(row, column);
                if (cell) {
                  return $xetable.validCellRules(type, row, column, cellValue).then(() => {
                    if (customVal && validStore.visible) {
                      setCellValue(row, column, cellValue);
                    }
                    $xetable.clearValidate(row, column);
                  }).catch(({ rule }) => {
                    if (customVal) {
                      setCellValue(row, column, cellValue);
                    }
                    $xetable.showValidTooltip({ rule, row, column, cell });
                  });
                }
              }
            }
          }
        });
      },
      /**
       * 设置合并单元格
       * @param {TableMergeConfig[]} merges { row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }
       */
      setMergeCells(merges) {
        if (props.spanMethod) {
          errLog("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        }
        setMerges(merges, reactData.mergeList, internalData.afterFullData);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          return updateStyle();
        });
      },
      /**
       * 移除单元格合并
       * @param {TableMergeConfig[]} merges 多个或数组 [{row:Row|number, col:ColumnInfo|number}]
       */
      removeMergeCells(merges) {
        if (props.spanMethod) {
          errLog("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        }
        const rest = removeMerges(merges, reactData.mergeList, internalData.afterFullData);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          updateStyle();
          return rest;
        });
      },
      /**
       * 获取所有被合并的单元格
       */
      getMergeCells() {
        return reactData.mergeList.slice(0);
      },
      /**
       * 清除所有单元格合并
       */
      clearMergeCells() {
        reactData.mergeList = [];
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      setMergeFooterItems(merges) {
        if (props.footerSpanMethod) {
          errLog("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]);
        }
        setMerges(merges, reactData.mergeFooterList);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          return updateStyle();
        });
      },
      removeMergeFooterItems(merges) {
        if (props.footerSpanMethod) {
          errLog("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]);
        }
        const rest = removeMerges(merges, reactData.mergeFooterList);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          updateStyle();
          return rest;
        });
      },
      /**
       * 获取所有被合并的表尾
       */
      getMergeFooterItems() {
        return reactData.mergeFooterList.slice(0);
      },
      /**
       * 清除所有表尾合并
       */
      clearMergeFooterItems() {
        reactData.mergeFooterList = [];
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      updateCellAreas() {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        if (mouseConfig && mouseOpts.area && $xetable.handleUpdateCellAreas) {
          return $xetable.handleUpdateCellAreas();
        }
        return nextTick();
      },
      focus() {
        internalData.isActivated = true;
        return nextTick();
      },
      blur() {
        internalData.isActivated = false;
        return nextTick();
      },
      /**
       * 连接工具栏
       * @param $toolbar
       */
      connect($toolbar) {
        if ($toolbar) {
          $xetoolbar = $toolbar;
          $xetoolbar.syncUpdate({ collectColumn: internalData.collectColumn, $table: $xetable });
        } else {
          errLog("vxe.error.barUnableLink");
        }
        return nextTick();
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { editStore, ctxMenuStore, filterStore, customStore } = reactData;
      const { mouseConfig, editRules } = props;
      const el = refElem.value;
      const editOpts = computeEditOpts.value;
      const validOpts = computeValidOpts.value;
      const areaOpts = computeAreaOpts.value;
      const { actived } = editStore;
      const $validTooltip = refValidTooltip.value;
      const tableFilter = refTableFilter.value;
      const tableCustom = refTableCustom.value;
      const tableMenu = refTableMenu.value;
      if (tableFilter) {
        if (getEventTargetNode(evnt, el, "vxe-cell--filter").flag) {
        } else if (getEventTargetNode(evnt, tableFilter.$el).flag) {
        } else {
          if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
            tablePrivateMethods.preventEvent(evnt, "event.clearFilter", filterStore.args, tableMethods.closeFilter);
          }
        }
      }
      if (tableCustom) {
        if (customStore.btnEl === evnt.target || getEventTargetNode(evnt, document.body, "vxe-toolbar-custom-target").flag) {
        } else if (getEventTargetNode(evnt, tableCustom.$el).flag) {
        } else {
          if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
            tablePrivateMethods.preventEvent(evnt, "event.clearCustom", {}, () => {
              if ($xetable.closeCustom) {
                $xetable.closeCustom();
              }
            });
          }
        }
      }
      if (actived.row) {
        if (!(editOpts.autoClear === false)) {
          const cell = actived.args.cell;
          if (!cell || !getEventTargetNode(evnt, cell).flag) {
            if ($validTooltip && getEventTargetNode(evnt, $validTooltip.$el).flag) {
            } else if (!internalData._lastCallTime || internalData._lastCallTime + 50 < Date.now()) {
              if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
                tablePrivateMethods.preventEvent(evnt, "event.clearEdit", actived.args, () => {
                  let isClear;
                  if (editOpts.mode === "row") {
                    const rowTargetNode = getEventTargetNode(evnt, el, "vxe-body--row");
                    const rowNodeRest = rowTargetNode.flag ? tableMethods.getRowNode(rowTargetNode.targetElem) : null;
                    isClear = rowNodeRest ? !$xetable.eqRow(rowNodeRest.item, actived.args.row) : false;
                  } else {
                    isClear = !getEventTargetNode(evnt, el, "col--edit").flag;
                  }
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el, "vxe-header--row").flag;
                  }
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el, "vxe-footer--row").flag;
                  }
                  if (!isClear && props.height && !reactData.overflowY) {
                    const bodyWrapperElem = evnt.target;
                    if (hasClass(bodyWrapperElem, "vxe-table--body-wrapper")) {
                      isClear = evnt.offsetY < bodyWrapperElem.clientHeight;
                    }
                  }
                  if (isClear || // 如果点击了当前表格之外
                  !getEventTargetNode(evnt, el).flag) {
                    setTimeout(() => $xetable.clearEdit(evnt));
                  }
                });
              }
            }
          }
        }
      } else if (mouseConfig) {
        if (!getEventTargetNode(evnt, el).flag && !($xegrid && getEventTargetNode(evnt, $xegrid.getRefMaps().refElem.value).flag) && !(tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) && !($xetoolbar && getEventTargetNode(evnt, $xetoolbar.getRefMaps().refElem.value).flag)) {
          if ($xetable.clearSelected) {
            $xetable.clearSelected();
          }
          if (areaOpts.autoClear) {
            if ($xetable.clearCellAreas) {
              if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-areas-clear").flag) {
                tablePrivateMethods.preventEvent(evnt, "event.clearAreas", {}, () => {
                  $xetable.clearCellAreas();
                  $xetable.clearCopyCellArea();
                });
              }
            }
          }
        }
      }
      if ($xetable.closeMenu) {
        if (ctxMenuStore.visible && tableMenu && !getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
          $xetable.closeMenu();
        }
      }
      const isActivated = getEventTargetNode(evnt, $xegrid ? $xegrid.getRefMaps().refElem.value : el).flag;
      if (!isActivated && editRules && validOpts.autoClear) {
        reactData.validErrorMaps = {};
      }
      internalData.isActivated = isActivated;
    };
    const handleGlobalBlurEvent = () => {
      tableMethods.closeFilter();
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
    };
    const handleGlobalMousewheelEvent = () => {
      tableMethods.closeTooltip();
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
    };
    const keydownEvent = (evnt) => {
      const { mouseConfig, keyboardConfig } = props;
      const { filterStore, ctxMenuStore, editStore } = reactData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
      if (isEsc) {
        tablePrivateMethods.preventEvent(evnt, "event.keydown", null, () => {
          tableMethods.dispatchEvent("keydown-start", {}, evnt);
          if (keyboardConfig && mouseConfig && mouseOpts.area && $xetable.handleKeyboardEvent) {
            $xetable.handleKeyboardEvent(evnt);
          } else if (actived.row || filterStore.visible || ctxMenuStore.visible) {
            evnt.stopPropagation();
            if ($xetable.closeMenu) {
              $xetable.closeMenu();
            }
            tableMethods.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              if (actived.row) {
                const params = actived.args;
                $xetable.clearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => $xetable.handleSelected(params, evnt));
                }
              }
            }
          }
          tableMethods.dispatchEvent("keydown", {}, evnt);
          tableMethods.dispatchEvent("keydown-end", {}, evnt);
        });
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      if (internalData.isActivated) {
        tablePrivateMethods.preventEvent(evnt, "event.keydown", null, () => {
          const { mouseConfig, keyboardConfig, treeConfig, editConfig, highlightCurrentRow } = props;
          const { ctxMenuStore, editStore, currentRow } = reactData;
          const isMenu = computeIsMenu.value;
          const bodyMenu = computeBodyMenu.value;
          const keyboardOpts = computeKeyboardOpts.value;
          const mouseOpts = computeMouseOpts.value;
          const editOpts = computeEditOpts.value;
          const treeOpts = computeTreeOpts.value;
          const menuList = computeMenuList.value;
          const rowOpts = computeRowOpts.value;
          const { selected, actived } = editStore;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const keyCode = evnt.keyCode;
          const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
          const isBack = hasEventKey(evnt, EVENT_KEYS.BACKSPACE);
          const isTab = hasEventKey(evnt, EVENT_KEYS.TAB);
          const isEnter = hasEventKey(evnt, EVENT_KEYS.ENTER);
          const isSpacebar = hasEventKey(evnt, EVENT_KEYS.SPACEBAR);
          const isLeftArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_LEFT);
          const isUpArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_UP);
          const isRightArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_RIGHT);
          const isDwArrow = hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN);
          const isDel = hasEventKey(evnt, EVENT_KEYS.DELETE);
          const isF2 = hasEventKey(evnt, EVENT_KEYS.F2);
          const isContextMenu = hasEventKey(evnt, EVENT_KEYS.CONTEXT_MENU);
          const hasMetaKey = evnt.metaKey;
          const hasCtrlKey = evnt.ctrlKey;
          const hasShiftKey = evnt.shiftKey;
          const isAltKey = evnt.altKey;
          const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
          const operCtxMenu = isMenu && ctxMenuStore.visible && (isEnter || isSpacebar || operArrow);
          const isEditStatus = isEnableConf(editConfig) && actived.column && actived.row;
          let params;
          if (operCtxMenu) {
            evnt.preventDefault();
            if (ctxMenuStore.showChild && hasChildrenList(ctxMenuStore.selected)) {
              $xetable.moveCtxMenu(evnt, ctxMenuStore, "selectChild", isLeftArrow, false, ctxMenuStore.selected.children);
            } else {
              $xetable.moveCtxMenu(evnt, ctxMenuStore, "selected", isRightArrow, true, menuList);
            }
          } else if (keyboardConfig && mouseConfig && mouseOpts.area && $xetable.handleKeyboardEvent) {
            $xetable.handleKeyboardEvent(evnt);
          } else if (isEsc) {
            if ($xetable.closeMenu) {
              $xetable.closeMenu();
            }
            tableMethods.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              if (actived.row) {
                const params2 = actived.args;
                $xetable.clearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => $xetable.handleSelected(params2, evnt));
                }
              }
            }
          } else if (isSpacebar && keyboardConfig && keyboardOpts.isChecked && selected.row && selected.column && (selected.column.type === "checkbox" || selected.column.type === "radio")) {
            evnt.preventDefault();
            if (selected.column.type === "checkbox") {
              tablePrivateMethods.handleToggleCheckRowEvent(evnt, selected.args);
            } else {
              tablePrivateMethods.triggerRadioRowEvent(evnt, selected.args);
            }
          } else if (isF2 && isEnableConf(editConfig)) {
            if (!isEditStatus) {
              if (selected.row && selected.column) {
                evnt.preventDefault();
                $xetable.handleActived(selected.args, evnt);
              }
            }
          } else if (isContextMenu) {
            internalData._keyCtx = selected.row && selected.column && bodyMenu.length;
            clearTimeout(keyCtxTimeout);
            keyCtxTimeout = setTimeout(() => {
              internalData._keyCtx = false;
            }, 1e3);
          } else if (isEnter && !isAltKey && keyboardConfig && keyboardOpts.isEnter && (selected.row || actived.row || treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow)) {
            if (hasCtrlKey) {
              if (actived.row) {
                params = actived.args;
                $xetable.clearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => $xetable.handleSelected(params, evnt));
                }
              }
            } else {
              if (selected.row || actived.row) {
                const targetArgs = selected.row ? selected.args : actived.args;
                if (hasShiftKey) {
                  if (keyboardOpts.enterToTab) {
                    $xetable.moveTabSelected(targetArgs, hasShiftKey, evnt);
                  } else {
                    $xetable.moveSelected(targetArgs, isLeftArrow, true, isRightArrow, false, evnt);
                  }
                } else {
                  if (keyboardOpts.enterToTab) {
                    $xetable.moveTabSelected(targetArgs, hasShiftKey, evnt);
                  } else {
                    $xetable.moveSelected(targetArgs, isLeftArrow, false, isRightArrow, true, evnt);
                  }
                }
              } else if (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
                const childrens = currentRow[childrenField];
                if (childrens && childrens.length) {
                  evnt.preventDefault();
                  const targetRow = childrens[0];
                  params = {
                    $table: $xetable,
                    row: targetRow,
                    rowIndex: tableMethods.getRowIndex(targetRow),
                    $rowIndex: tableMethods.getVMRowIndex(targetRow)
                  };
                  tableMethods.setTreeExpand(currentRow, true).then(() => tableMethods.scrollToRow(targetRow)).then(() => tablePrivateMethods.triggerCurrentRowEvent(evnt, params));
                }
              }
            }
          } else if (operArrow && keyboardConfig && keyboardOpts.isArrow) {
            if (!isEditStatus) {
              if (selected.row && selected.column) {
                $xetable.moveSelected(selected.args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt);
              } else if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {
                $xetable.moveCurrentRow(isUpArrow, isDwArrow, evnt);
              }
            }
          } else if (isTab && keyboardConfig && keyboardOpts.isTab) {
            if (selected.row || selected.column) {
              $xetable.moveTabSelected(selected.args, hasShiftKey, evnt);
            } else if (actived.row || actived.column) {
              $xetable.moveTabSelected(actived.args, hasShiftKey, evnt);
            }
          } else if (keyboardConfig && isEnableConf(editConfig) && (isDel || (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow ? isBack && keyboardOpts.isArrow : isBack))) {
            if (!isEditStatus) {
              const { delMethod, backMethod } = keyboardOpts;
              if (keyboardOpts.isDel && (selected.row || selected.column)) {
                const delPaqrams = {
                  row: selected.row,
                  rowIndex: tableMethods.getRowIndex(selected.row),
                  column: selected.column,
                  columnIndex: tableMethods.getColumnIndex(selected.column),
                  $table: $xetable
                };
                if (delMethod) {
                  delMethod(delPaqrams);
                } else {
                  setCellValue(selected.row, selected.column, null);
                }
                if (isBack) {
                  if (backMethod) {
                    backMethod({
                      row: selected.row,
                      rowIndex: tableMethods.getRowIndex(selected.row),
                      column: selected.column,
                      columnIndex: tableMethods.getColumnIndex(selected.column),
                      $table: $xetable
                    });
                  } else {
                    $xetable.handleActived(selected.args, evnt);
                  }
                } else if (isDel) {
                  tableMethods.updateFooter();
                }
                $xetable.dispatchEvent("cell-delete-value", delPaqrams, evnt);
              } else if (isBack && keyboardOpts.isArrow && treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
                const { parent: parentRow } = import_xe_utils41.default.findTree(internalData.afterFullData, (item) => item === currentRow, { children: childrenField });
                if (parentRow) {
                  evnt.preventDefault();
                  params = {
                    $table: $xetable,
                    row: parentRow,
                    rowIndex: tableMethods.getRowIndex(parentRow),
                    $rowIndex: tableMethods.getVMRowIndex(parentRow)
                  };
                  tableMethods.setTreeExpand(parentRow, false).then(() => tableMethods.scrollToRow(parentRow)).then(() => tablePrivateMethods.triggerCurrentRowEvent(evnt, params));
                }
              }
            }
          } else if (keyboardConfig && isEnableConf(editConfig) && keyboardOpts.isEdit && !hasCtrlKey && !hasMetaKey && (isSpacebar || keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 96 && keyCode <= 111 || keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222)) {
            const { editMethod } = keyboardOpts;
            if (selected.column && selected.row && isEnableConf(selected.column.editRender)) {
              const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
              if (!beforeEditMethod || beforeEditMethod(Object.assign(Object.assign({}, selected.args), { $table: $xetable, $grid: $xegrid }))) {
                if (editMethod) {
                  editMethod({
                    row: selected.row,
                    rowIndex: tableMethods.getRowIndex(selected.row),
                    column: selected.column,
                    columnIndex: tableMethods.getColumnIndex(selected.column),
                    $table: $xetable,
                    $grid: $xegrid
                  });
                } else {
                  setCellValue(selected.row, selected.column, null);
                  $xetable.handleActived(selected.args, evnt);
                }
                const afterEditMethod = editOpts.afterEditMethod;
                if (afterEditMethod) {
                  nextTick(() => {
                    afterEditMethod({
                      row: selected.row,
                      rowIndex: tableMethods.getRowIndex(selected.row),
                      column: selected.column,
                      columnIndex: tableMethods.getColumnIndex(selected.column),
                      $table: $xetable,
                      $grid: $xegrid
                    });
                  });
                }
              }
            }
          }
          tableMethods.dispatchEvent("keydown", {}, evnt);
        });
      }
    };
    const handleGlobalPasteEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handlePasteCellAreaEvent) {
            $xetable.handlePasteCellAreaEvent(evnt);
          }
        }
        tableMethods.dispatchEvent("paste", {}, evnt);
      }
    };
    const handleGlobalCopyEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handleCopyCellAreaEvent) {
            $xetable.handleCopyCellAreaEvent(evnt);
          }
        }
        tableMethods.dispatchEvent("copy", {}, evnt);
      }
    };
    const handleGlobalCutEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xetable.handleCutCellAreaEvent) {
            $xetable.handleCutCellAreaEvent(evnt);
          }
        }
        tableMethods.dispatchEvent("cut", {}, evnt);
      }
    };
    const handleGlobalResizeEvent = () => {
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
      tableMethods.updateCellAreas();
      tableMethods.recalculate(true);
    };
    const handleTargetEnterEvent = (isClear) => {
      const $tooltip = refTooltip.value;
      clearTimeout(internalData.tooltipTimeout);
      if (isClear) {
        tableMethods.closeTooltip();
      } else {
        if ($tooltip) {
          $tooltip.setActived(true);
        }
      }
    };
    const handleTooltip = (evnt, cell, overflowElem, tipElem, params) => {
      params.cell = cell;
      const { tooltipStore } = reactData;
      const tooltipOpts = computeTooltipOpts.value;
      const { column, row } = params;
      const { showAll, contentMethod } = tooltipOpts;
      const customContent = contentMethod ? contentMethod(params) : null;
      const useCustom = contentMethod && !import_xe_utils41.default.eqNull(customContent);
      const content = useCustom ? customContent : import_xe_utils41.default.toString(column.type === "html" ? overflowElem.innerText : overflowElem.textContent).trim();
      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      if (content && (showAll || useCustom || isCellOverflow)) {
        Object.assign(tooltipStore, {
          row,
          column,
          visible: true
        });
        nextTick(() => {
          const $tooltip = refTooltip.value;
          if ($tooltip) {
            $tooltip.open(isCellOverflow ? overflowElem : tipElem || overflowElem, formatText(content));
          }
        });
      }
      return nextTick();
    };
    tablePrivateMethods = {
      getSetupOptions() {
        return conf_default;
      },
      updateAfterDataIndex,
      callSlot(slotFunc, params) {
        if (slotFunc) {
          if ($xegrid) {
            return $xegrid.callSlot(slotFunc, params);
          }
          if (import_xe_utils41.default.isFunction(slotFunc)) {
            return getSlotVNs(slotFunc(params));
          }
        }
        return [];
      },
      /**
       * 获取父容器元素
       */
      getParentElem() {
        const el = refElem.value;
        if ($xegrid) {
          const gridEl = $xegrid.getRefMaps().refElem.value;
          return gridEl ? gridEl.parentNode : null;
        }
        return el ? el.parentNode : null;
      },
      /**
       * 获取父容器的高度
       */
      getParentHeight() {
        const { height } = props;
        const el = refElem.value;
        if (el) {
          const parentElem = el.parentNode;
          const parentPaddingSize = height === "100%" || height === "auto" ? getPaddingTopBottomSize(parentElem) : 0;
          return Math.floor($xegrid ? $xegrid.getParentHeight() : import_xe_utils41.default.toNumber(getComputedStyle(parentElem).height) - parentPaddingSize);
        }
        return 0;
      },
      /**
       * 获取需要排除的高度
       * 但渲染表格高度时，需要排除工具栏或分页等相关组件的高度
       * 如果存在表尾合计滚动条，则需要排除滚动条高度
       */
      getExcludeHeight() {
        return $xegrid ? $xegrid.getExcludeHeight() : 0;
      },
      /**
       * 定义行数据中的列属性，如果不存在则定义
       * @param {Row} records 行数据
       */
      defineField(records) {
        const { treeConfig } = props;
        const expandOpts = computeExpandOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const rowkey = getRowkey($xetable);
        if (!import_xe_utils41.default.isArray(records)) {
          records = [records];
        }
        return records.map((record) => {
          internalData.tableFullColumn.forEach((column) => {
            const { field, editRender } = column;
            if (field && !import_xe_utils41.default.has(record, field) && !record[field]) {
              let cellValue = null;
              if (editRender) {
                const { defaultValue } = editRender;
                if (import_xe_utils41.default.isFunction(defaultValue)) {
                  cellValue = defaultValue({ column });
                } else if (!import_xe_utils41.default.isUndefined(defaultValue)) {
                  cellValue = defaultValue;
                }
              }
              import_xe_utils41.default.set(record, field, cellValue);
            }
          });
          const otherFields = [radioOpts.labelField, checkboxOpts.checkField, checkboxOpts.labelField, expandOpts.labelField];
          otherFields.forEach((key) => {
            if (key && eqEmptyValue(import_xe_utils41.default.get(record, key))) {
              import_xe_utils41.default.set(record, key, null);
            }
          });
          if (treeConfig && treeOpts.lazy && import_xe_utils41.default.isUndefined(record[childrenField])) {
            record[childrenField] = null;
          }
          if (eqEmptyValue(import_xe_utils41.default.get(record, rowkey))) {
            import_xe_utils41.default.set(record, rowkey, getRowUniqueId());
          }
          return record;
        });
      },
      handleTableData(force) {
        const { scrollYLoad } = reactData;
        const { scrollYStore, fullDataRowIdData } = internalData;
        let fullList = internalData.afterFullData;
        if (force) {
          updateAfterFullData();
          fullList = handleVirtualTreeToList();
        }
        const tableData = scrollYLoad ? fullList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullList.slice(0);
        tableData.forEach((row, $index) => {
          const rowid = getRowid($xetable, row);
          const rest = fullDataRowIdData[rowid];
          if (rest) {
            rest.$index = $index;
          }
        });
        reactData.tableData = tableData;
        return nextTick();
      },
      /**
       * 更新数据行的 Map
       * 牺牲数据组装的耗时，用来换取使用过程中的流畅
       */
      cacheRowMap(isSource) {
        const { treeConfig } = props;
        const treeOpts = computeTreeOpts.value;
        const { fullAllDataRowIdData, tableFullData, tableFullTreeData } = internalData;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const rowkey = getRowkey($xetable);
        const isLazy = treeConfig && treeOpts.lazy;
        const fullAllDataRowIdMaps = {};
        const fullDataRowIdMaps = {};
        const handleRow = (row, index, items, path, parent, nodes) => {
          let rowid = getRowid($xetable, row);
          const seq = treeConfig && path ? toTreePathSeq(path) : index + 1;
          const level = nodes ? nodes.length - 1 : 0;
          if (eqEmptyValue(rowid)) {
            rowid = getRowUniqueId();
            import_xe_utils41.default.set(row, rowkey, rowid);
          }
          if (isLazy && row[hasChildField] && import_xe_utils41.default.isUndefined(row[childrenField])) {
            row[childrenField] = null;
          }
          let cacheItem = fullAllDataRowIdData[rowid];
          if (!cacheItem) {
            cacheItem = { row, rowid, seq, index: -1, _index: -1, $index: -1, items, parent, level };
          }
          if (isSource) {
            cacheItem.index = treeConfig && parent ? -1 : index;
            fullDataRowIdMaps[rowid] = cacheItem;
          }
          fullAllDataRowIdMaps[rowid] = cacheItem;
        };
        if (isSource) {
          internalData.fullDataRowIdData = fullDataRowIdMaps;
        }
        internalData.fullAllDataRowIdData = fullAllDataRowIdMaps;
        if (treeConfig) {
          import_xe_utils41.default.eachTree(tableFullTreeData, handleRow, { children: childrenField });
        } else {
          tableFullData.forEach(handleRow);
        }
      },
      cacheSourceMap(fullData) {
        const { treeConfig } = props;
        const treeOpts = computeTreeOpts.value;
        let { sourceDataRowIdData } = internalData;
        const sourceData = import_xe_utils41.default.clone(fullData, true);
        const rowkey = getRowkey($xetable);
        sourceDataRowIdData = internalData.sourceDataRowIdData = {};
        const handleSourceRow = (row) => {
          let rowid = getRowid($xetable, row);
          if (eqEmptyValue(rowid)) {
            rowid = getRowUniqueId();
            import_xe_utils41.default.set(row, rowkey, rowid);
          }
          sourceDataRowIdData[rowid] = row;
        };
        if (treeConfig) {
          const childrenField = treeOpts.children || treeOpts.childrenField;
          import_xe_utils41.default.eachTree(sourceData, handleSourceRow, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });
        } else {
          sourceData.forEach(handleSourceRow);
        }
        internalData.tableSourceData = sourceData;
      },
      /**
       * 指定列宽的列进行拆分
       */
      analyColumnWidth() {
        const { tableFullColumn } = internalData;
        const columnOpts = computeColumnOpts.value;
        const { width: defaultWidth, minWidth: defaultMinWidth } = columnOpts;
        const resizeList = [];
        const pxList = [];
        const pxMinList = [];
        const scaleList = [];
        const scaleMinList = [];
        const autoList = [];
        tableFullColumn.forEach((column) => {
          if (defaultWidth && !column.width) {
            column.width = defaultWidth;
          }
          if (defaultMinWidth && !column.minWidth) {
            column.minWidth = defaultMinWidth;
          }
          if (column.visible) {
            if (column.resizeWidth) {
              resizeList.push(column);
            } else if (isPx(column.width)) {
              pxList.push(column);
            } else if (isScale(column.width)) {
              scaleList.push(column);
            } else if (isPx(column.minWidth)) {
              pxMinList.push(column);
            } else if (isScale(column.minWidth)) {
              scaleMinList.push(column);
            } else {
              autoList.push(column);
            }
          }
        });
        Object.assign(reactData.columnStore, { resizeList, pxList, pxMinList, scaleList, scaleMinList, autoList });
      },
      saveCustomResizable(isReset) {
        const { id, customConfig } = props;
        const customOpts = computeCustomOpts.value;
        const { collectColumn } = internalData;
        const { storage } = customOpts;
        const isAllStorage = storage === true;
        const storageOpts = isAllStorage ? {} : Object.assign({}, storage || {});
        const isResizable = isAllStorage || storageOpts.resizable;
        if (customConfig && isResizable) {
          const columnWidthStorageMap = getCustomStorageMap(resizableStorageKey);
          let columnWidthStorage;
          if (!id) {
            errLog("vxe.error.reqProp", ["id"]);
            return;
          }
          if (!isReset) {
            columnWidthStorage = import_xe_utils41.default.isPlainObject(columnWidthStorageMap[id]) ? columnWidthStorageMap[id] : {};
            import_xe_utils41.default.eachTree(collectColumn, (column) => {
              if (column.resizeWidth) {
                const colKey = column.getKey();
                if (colKey) {
                  columnWidthStorage[colKey] = column.renderWidth;
                }
              }
            });
          }
          columnWidthStorageMap[id] = import_xe_utils41.default.isEmpty(columnWidthStorage) ? void 0 : columnWidthStorage;
          localStorage.setItem(resizableStorageKey, import_xe_utils41.default.toJSONString(columnWidthStorageMap));
        }
      },
      saveCustomSort(isReset) {
        const { id, customConfig } = props;
        const customOpts = computeCustomOpts.value;
        const { collectColumn } = internalData;
        const { storage } = customOpts;
        const isAllStorage = storage === true;
        const storageOpts = isAllStorage ? {} : Object.assign({}, storage || {});
        const isSort = isAllStorage || storageOpts.sort;
        if (customConfig && isSort) {
          const columnSortStorageMap = getCustomStorageMap(sortStorageKey);
          let columnWidthStorage;
          if (!id) {
            errLog("vxe.error.reqProp", ["id"]);
            return;
          }
          if (!isReset) {
            columnWidthStorage = import_xe_utils41.default.isPlainObject(columnSortStorageMap[id]) ? columnSortStorageMap[id] : {};
            collectColumn.forEach((column) => {
              if (column.sortNumber !== column.renderSortNumber) {
                const colKey = column.getKey();
                if (colKey) {
                  columnWidthStorage[colKey] = column.renderSortNumber;
                }
              }
            });
          }
          columnSortStorageMap[id] = import_xe_utils41.default.isEmpty(columnWidthStorage) ? void 0 : columnWidthStorage;
          localStorage.setItem(sortStorageKey, import_xe_utils41.default.toJSONString(columnSortStorageMap));
        }
      },
      saveCustomFixed() {
        const { id, customConfig } = props;
        const { collectColumn } = internalData;
        const customOpts = computeCustomOpts.value;
        const { storage } = customOpts;
        const isAllStorage = storage === true;
        const storageOpts = isAllStorage ? {} : Object.assign({}, storage || {});
        const isCustomFixed = isAllStorage || storageOpts.fixed;
        if (customConfig && isCustomFixed) {
          const columnFixedStorageMap = getCustomStorageMap(fixedStorageKey);
          const colFixeds = [];
          if (!id) {
            errLog("vxe.error.reqProp", ["id"]);
            return;
          }
          import_xe_utils41.default.eachTree(collectColumn, (column) => {
            if (column.fixed && column.fixed !== column.defaultFixed) {
              const colKey = column.getKey();
              if (colKey) {
                colFixeds.push(`${colKey}|${column.fixed}`);
              }
            }
          });
          columnFixedStorageMap[id] = colFixeds.join(",") || void 0;
          localStorage.setItem(fixedStorageKey, import_xe_utils41.default.toJSONString(columnFixedStorageMap));
        }
      },
      saveCustomVisible() {
        const { id, customConfig } = props;
        const { collectColumn } = internalData;
        const customOpts = computeCustomOpts.value;
        const { checkMethod, storage } = customOpts;
        const isAllStorage = storage === true;
        const storageOpts = isAllStorage ? {} : Object.assign({}, storage || {});
        const isCustomVisible = isAllStorage || storageOpts.visible;
        if (customConfig && isCustomVisible) {
          const columnVisibleStorageMap = getCustomStorageMap(visibleStorageKey);
          const colHides = [];
          const colShows = [];
          if (!id) {
            errLog("vxe.error.reqProp", ["id"]);
            return;
          }
          import_xe_utils41.default.eachTree(collectColumn, (column) => {
            if (!checkMethod || checkMethod({ column })) {
              if (!column.visible && column.defaultVisible) {
                const colKey = column.getKey();
                if (colKey) {
                  colHides.push(colKey);
                }
              } else if (column.visible && !column.defaultVisible) {
                const colKey = column.getKey();
                if (colKey) {
                  colShows.push(colKey);
                }
              }
            }
          });
          columnVisibleStorageMap[id] = [colHides.join(",")].concat(colShows.length ? [colShows.join(",")] : []).join("|") || void 0;
          localStorage.setItem(visibleStorageKey, import_xe_utils41.default.toJSONString(columnVisibleStorageMap));
        }
      },
      handleCustom() {
        const { mouseConfig } = props;
        if (mouseConfig) {
          if ($xetable.clearSelected) {
            $xetable.clearSelected();
          }
          if ($xetable.clearCellAreas) {
            $xetable.clearCellAreas();
            $xetable.clearCopyCellArea();
          }
        }
        tablePrivateMethods.saveCustomVisible();
        tablePrivateMethods.saveCustomSort();
        tablePrivateMethods.analyColumnWidth();
        return tableMethods.refreshColumn(true);
      },
      handleUpdateDataQueue() {
        reactData.upDataFlag++;
      },
      handleRefreshColumnQueue() {
        reactData.reColumnFlag++;
      },
      preventEvent(evnt, type, args, next, end) {
        let evntList = VXETable.interceptor.get(type);
        if (!evntList.length && type === "event.clearEdit") {
          evntList = VXETable.interceptor.get("event.clearActived");
          if (true) {
            if (evntList.length) {
              warnLog("vxe.error.delEvent", ["event.clearActived", "event.clearEdit"]);
            }
          }
        }
        let rest;
        if (!evntList.some((func) => func(Object.assign({ $grid: $xegrid, $table: $xetable, $event: evnt }, args)) === false)) {
          if (next) {
            rest = next();
          }
        }
        if (end) {
          end();
        }
        return rest;
      },
      checkSelectionStatus() {
        const { treeConfig } = props;
        const { selectCheckboxMaps, treeIndeterminateMaps } = reactData;
        const { afterFullData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkStrictly, checkMethod } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        if (!checkStrictly) {
          const disableRows = [];
          const checkRows = [];
          let isAllResolve = false;
          let isAllSelected = false;
          let isIndeterminate = false;
          if (checkField) {
            isAllResolve = afterFullData.every(checkMethod ? (row) => {
              if (!checkMethod({ row })) {
                disableRows.push(row);
                return true;
              }
              if (import_xe_utils41.default.get(row, checkField)) {
                checkRows.push(row);
                return true;
              }
              return false;
            } : (row) => import_xe_utils41.default.get(row, checkField));
            isAllSelected = isAllResolve && afterFullData.length !== disableRows.length;
            if (treeConfig) {
              if (indeterminateField) {
                isIndeterminate = !isAllSelected && afterFullData.some((row) => import_xe_utils41.default.get(row, checkField) || import_xe_utils41.default.get(row, indeterminateField) || !!treeIndeterminateMaps[getRowid($xetable, row)]);
              } else {
                isIndeterminate = !isAllSelected && afterFullData.some((row) => import_xe_utils41.default.get(row, checkField) || !!treeIndeterminateMaps[getRowid($xetable, row)]);
              }
            } else {
              if (indeterminateField) {
                isIndeterminate = !isAllSelected && afterFullData.some((row) => import_xe_utils41.default.get(row, checkField) || import_xe_utils41.default.get(row, indeterminateField));
              } else {
                isIndeterminate = !isAllSelected && afterFullData.some((row) => import_xe_utils41.default.get(row, checkField));
              }
            }
          } else {
            isAllResolve = afterFullData.every(checkMethod ? (row) => {
              if (!checkMethod({ row })) {
                disableRows.push(row);
                return true;
              }
              if (selectCheckboxMaps[getRowid($xetable, row)]) {
                checkRows.push(row);
                return true;
              }
              return false;
            } : (row) => selectCheckboxMaps[getRowid($xetable, row)]);
            isAllSelected = isAllResolve && afterFullData.length !== disableRows.length;
            if (treeConfig) {
              isIndeterminate = !isAllSelected && afterFullData.some((row) => {
                const itemRid = getRowid($xetable, row);
                return treeIndeterminateMaps[itemRid] || selectCheckboxMaps[itemRid];
              });
            } else {
              isIndeterminate = !isAllSelected && afterFullData.some((row) => selectCheckboxMaps[getRowid($xetable, row)]);
            }
          }
          reactData.isAllSelected = isAllSelected;
          reactData.isIndeterminate = isIndeterminate;
        }
      },
      /**
       * 多选，行选中事件
       * value 选中true 不选false 半选-1
       */
      handleSelectRow({ row }, value, isForce) {
        const { treeConfig } = props;
        const { selectCheckboxMaps, treeIndeterminateMaps } = reactData;
        const selectRowMaps = Object.assign({}, selectCheckboxMaps);
        const { afterFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkStrictly, checkMethod } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        const rowid = getRowid($xetable, row);
        if (checkField) {
          if (treeConfig && !checkStrictly) {
            if (value === -1) {
              if (!treeIndeterminateMaps[rowid]) {
                if (indeterminateField) {
                  import_xe_utils41.default.set(row, indeterminateField, true);
                }
                treeIndeterminateMaps[rowid] = row;
              }
              import_xe_utils41.default.set(row, checkField, false);
            } else {
              import_xe_utils41.default.eachTree([row], (item) => {
                if ($xetable.eqRow(item, row) || (isForce || (!checkMethod || checkMethod({ row: item })))) {
                  import_xe_utils41.default.set(item, checkField, value);
                  if (indeterminateField) {
                    import_xe_utils41.default.set(row, indeterminateField, false);
                  }
                  delete treeIndeterminateMaps[getRowid($xetable, item)];
                  handleCheckboxReserveRow(row, value);
                }
              }, { children: childrenField });
            }
            const matchObj = import_xe_utils41.default.findTree(afterFullData, (item) => $xetable.eqRow(item, row), { children: childrenField });
            if (matchObj && matchObj.parent) {
              let parentStatus;
              const vItems = [];
              const vItemMaps = {};
              if (!isForce && checkMethod) {
                matchObj.items.forEach((item) => {
                  if (checkMethod({ row: item })) {
                    const itemRid = getRowid($xetable, item);
                    vItemMaps[itemRid] = item;
                    vItems.push(item);
                  }
                });
              } else {
                matchObj.items.forEach((item) => {
                  const itemRid = getRowid($xetable, item);
                  vItemMaps[itemRid] = item;
                  vItems.push(item);
                });
              }
              const indeterminatesItem = import_xe_utils41.default.find(matchObj.items, (item) => !!treeIndeterminateMaps[getRowid($xetable, item)]);
              if (indeterminatesItem) {
                parentStatus = -1;
              } else {
                const selectItems = [];
                matchObj.items.forEach((item) => {
                  if (import_xe_utils41.default.get(item, checkField)) {
                    selectItems.push(item);
                  }
                });
                parentStatus = selectItems.filter((item) => vItemMaps[getRowid($xetable, item)]).length === vItems.length ? true : selectItems.length || value === -1 ? -1 : false;
              }
              reactData.selectCheckboxMaps = selectRowMaps;
              return tablePrivateMethods.handleSelectRow({ row: matchObj.parent }, parentStatus, isForce);
            }
          } else {
            if (isForce || (!checkMethod || checkMethod({ row }))) {
              import_xe_utils41.default.set(row, checkField, value);
              handleCheckboxReserveRow(row, value);
            }
          }
        } else {
          if (treeConfig && !checkStrictly) {
            if (value === -1) {
              if (!treeIndeterminateMaps[rowid]) {
                if (indeterminateField) {
                  import_xe_utils41.default.set(row, indeterminateField, true);
                }
                treeIndeterminateMaps[rowid] = row;
              }
              if (selectRowMaps[rowid]) {
                delete selectRowMaps[rowid];
              }
            } else {
              import_xe_utils41.default.eachTree([row], (item) => {
                const itemRid = getRowid($xetable, item);
                if ($xetable.eqRow(item, row) || (isForce || (!checkMethod || checkMethod({ row: item })))) {
                  if (value) {
                    selectRowMaps[itemRid] = item;
                  } else {
                    if (selectRowMaps[itemRid]) {
                      delete selectRowMaps[itemRid];
                    }
                  }
                  if (indeterminateField) {
                    import_xe_utils41.default.set(row, indeterminateField, false);
                  }
                  delete treeIndeterminateMaps[getRowid($xetable, item)];
                  handleCheckboxReserveRow(row, value);
                }
              }, { children: childrenField });
            }
            const matchObj = import_xe_utils41.default.findTree(afterFullData, (item) => $xetable.eqRow(item, row), { children: childrenField });
            if (matchObj && matchObj.parent) {
              let parentStatus;
              const vItems = [];
              const vItemMaps = {};
              if (!isForce && checkMethod) {
                matchObj.items.forEach((item) => {
                  if (checkMethod({ row: item })) {
                    const itemRid = getRowid($xetable, item);
                    vItemMaps[itemRid] = item;
                    vItems.push(item);
                  }
                });
              } else {
                matchObj.items.forEach((item) => {
                  const itemRid = getRowid($xetable, item);
                  vItemMaps[itemRid] = item;
                  vItems.push(item);
                });
              }
              const indeterminatesItem = import_xe_utils41.default.find(matchObj.items, (item) => !!treeIndeterminateMaps[getRowid($xetable, item)]);
              if (indeterminatesItem) {
                parentStatus = -1;
              } else {
                const selectItems = [];
                matchObj.items.forEach((item) => {
                  const itemRid = getRowid($xetable, item);
                  if (selectRowMaps[itemRid]) {
                    selectItems.push(item);
                  }
                });
                parentStatus = selectItems.filter((item) => vItemMaps[getRowid($xetable, item)]).length === vItems.length ? true : selectItems.length || value === -1 ? -1 : false;
              }
              reactData.selectCheckboxMaps = selectRowMaps;
              return tablePrivateMethods.handleSelectRow({ row: matchObj.parent }, parentStatus, isForce);
            }
          } else {
            if (isForce || (!checkMethod || checkMethod({ row }))) {
              if (value) {
                if (!selectRowMaps[rowid]) {
                  selectRowMaps[rowid] = row;
                }
              } else {
                if (selectRowMaps[rowid]) {
                  delete selectRowMaps[rowid];
                }
              }
              handleCheckboxReserveRow(row, value);
            }
          }
        }
        reactData.selectCheckboxMaps = selectRowMaps;
        tablePrivateMethods.checkSelectionStatus();
      },
      triggerHeaderTitleEvent(evnt, iconParams, params) {
        const tipContent = iconParams.content || iconParams.message;
        if (tipContent) {
          const { tooltipStore } = reactData;
          const { column } = params;
          const content = getFuncText(tipContent);
          handleTargetEnterEvent(true);
          tooltipStore.row = null;
          tooltipStore.column = column;
          tooltipStore.visible = true;
          nextTick(() => {
            const $tooltip = refTooltip.value;
            if ($tooltip) {
              $tooltip.open(evnt.currentTarget, content);
            }
          });
        }
      },
      /**
       * 触发表头 tooltip 事件
       */
      triggerHeaderTooltipEvent(evnt, params) {
        const { tooltipStore } = reactData;
        const { column } = params;
        const titleElem = evnt.currentTarget;
        handleTargetEnterEvent(true);
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          handleTooltip(evnt, titleElem, titleElem, null, params);
        }
      },
      /**
       * 触发单元格 tooltip 事件
       */
      triggerBodyTooltipEvent(evnt, params) {
        const { editConfig } = props;
        const { editStore } = reactData;
        const { tooltipStore } = reactData;
        const editOpts = computeEditOpts.value;
        const { actived } = editStore;
        const { row, column } = params;
        const cell = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column || tooltipStore.row !== row);
        if (column.editRender && isEnableConf(editConfig)) {
          if (editOpts.mode === "row" && actived.row === row) {
            return;
          }
          if (actived.row === row && actived.column === column) {
            return;
          }
        }
        if (tooltipStore.column !== column || tooltipStore.row !== row || !tooltipStore.visible) {
          let overflowElem;
          let tipElem;
          if (column.treeNode) {
            overflowElem = cell.querySelector(".vxe-tree-cell");
            if (column.type === "html") {
              tipElem = cell.querySelector(".vxe-cell--html");
            }
          } else {
            tipElem = cell.querySelector(column.type === "html" ? ".vxe-cell--html" : ".vxe-cell--label");
          }
          handleTooltip(evnt, cell, overflowElem || cell.children[0], tipElem, params);
        }
      },
      /**
       * 触发表尾 tooltip 事件
       */
      triggerFooterTooltipEvent(evnt, params) {
        const { column } = params;
        const { tooltipStore } = reactData;
        const cell = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column || !!tooltipStore.row);
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          handleTooltip(evnt, cell, cell.querySelector(".vxe-cell--item") || cell.children[0], null, params);
        }
      },
      handleTargetLeaveEvent() {
        const tooltipOpts = computeTooltipOpts.value;
        let $tooltip = refTooltip.value;
        if ($tooltip) {
          $tooltip.setActived(false);
        }
        if (tooltipOpts.enterable) {
          internalData.tooltipTimeout = setTimeout(() => {
            $tooltip = refTooltip.value;
            if ($tooltip && !$tooltip.isActived()) {
              tableMethods.closeTooltip();
            }
          }, tooltipOpts.leaveDelay);
        } else {
          tableMethods.closeTooltip();
        }
      },
      triggerHeaderCellClickEvent(evnt, params) {
        const { _lastResizeTime } = internalData;
        const sortOpts = computeSortOpts.value;
        const columnOpts = computeColumnOpts.value;
        const { column } = params;
        const cell = evnt.currentTarget;
        const triggerResizable = _lastResizeTime && _lastResizeTime > Date.now() - 300;
        const triggerSort = getEventTargetNode(evnt, cell, "vxe-cell--sort").flag;
        const triggerFilter = getEventTargetNode(evnt, cell, "vxe-cell--filter").flag;
        if (sortOpts.trigger === "cell" && !(triggerResizable || triggerSort || triggerFilter)) {
          tablePrivateMethods.triggerSortEvent(evnt, column, getNextSortOrder(column));
        }
        tableMethods.dispatchEvent("header-cell-click", Object.assign({ triggerResizable, triggerSort, triggerFilter, cell }, params), evnt);
        if (columnOpts.isCurrent || props.highlightCurrentColumn) {
          tableMethods.setCurrentColumn(column);
        }
      },
      triggerHeaderCellDblclickEvent(evnt, params) {
        tableMethods.dispatchEvent("header-cell-dblclick", Object.assign({ cell: evnt.currentTarget }, params), evnt);
      },
      /**
       * 列点击事件
       * 如果是单击模式，则激活为编辑状态
       * 如果是双击模式，则单击后选中状态
       */
      triggerCellClickEvent(evnt, params) {
        const { highlightCurrentRow, editConfig } = props;
        const { editStore } = reactData;
        const expandOpts = computeExpandOpts.value;
        const editOpts = computeEditOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const keyboardOpts = computeKeyboardOpts.value;
        const rowOpts = computeRowOpts.value;
        const { actived, focused } = editStore;
        const { row, column } = params;
        const { type, treeNode } = column;
        const isRadioType = type === "radio";
        const isCheckboxType = type === "checkbox";
        const isExpandType = type === "expand";
        const cell = evnt.currentTarget;
        const triggerRadio = isRadioType && getEventTargetNode(evnt, cell, "vxe-cell--radio").flag;
        const triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, "vxe-tree--btn-wrapper").flag;
        const triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, "vxe-table--expanded").flag;
        params = Object.assign({ cell, triggerRadio, triggerCheckbox, triggerTreeNode, triggerExpandNode }, params);
        if (!triggerCheckbox && !triggerRadio) {
          if (!triggerExpandNode && (expandOpts.trigger === "row" || isExpandType && expandOpts.trigger === "cell")) {
            tablePrivateMethods.triggerRowExpandEvent(evnt, params);
          }
          if (treeOpts.trigger === "row" || treeNode && treeOpts.trigger === "cell") {
            tablePrivateMethods.triggerTreeExpandEvent(evnt, params);
          }
        }
        if (!triggerTreeNode) {
          if (!triggerExpandNode) {
            if (rowOpts.isCurrent || highlightCurrentRow) {
              if (!triggerCheckbox && !triggerRadio) {
                tablePrivateMethods.triggerCurrentRowEvent(evnt, params);
              }
            }
            if (!triggerRadio && (radioOpts.trigger === "row" || isRadioType && radioOpts.trigger === "cell")) {
              tablePrivateMethods.triggerRadioRowEvent(evnt, params);
            }
            if (!triggerCheckbox && (checkboxOpts.trigger === "row" || isCheckboxType && checkboxOpts.trigger === "cell")) {
              tablePrivateMethods.handleToggleCheckRowEvent(evnt, params);
            }
          }
          if (isEnableConf(editConfig)) {
            if (keyboardOpts.arrowCursorLock && evnt && editOpts.mode === "cell" && evnt.target && /^input|textarea$/i.test(evnt.target.tagName)) {
              focused.column = column;
              focused.row = row;
            }
            if (editOpts.trigger === "manual") {
              if (actived.args && actived.row === row && column !== actived.column) {
                handleChangeCell(evnt, params);
              }
            } else if (!actived.args || row !== actived.row || column !== actived.column) {
              if (editOpts.trigger === "click") {
                handleChangeCell(evnt, params);
              } else if (editOpts.trigger === "dblclick") {
                if (editOpts.mode === "row" && actived.row === row) {
                  handleChangeCell(evnt, params);
                }
              }
            }
          }
        }
        tableMethods.dispatchEvent("cell-click", params, evnt);
      },
      /**
       * 列双击点击事件
       * 如果是双击模式，则激活为编辑状态
       */
      triggerCellDblclickEvent(evnt, params) {
        const { editConfig } = props;
        const { editStore } = reactData;
        const editOpts = computeEditOpts.value;
        const { actived } = editStore;
        const cell = evnt.currentTarget;
        params = Object.assign({ cell }, params);
        if (isEnableConf(editConfig) && editOpts.trigger === "dblclick") {
          if (!actived.args || evnt.currentTarget !== actived.args.cell) {
            if (editOpts.mode === "row") {
              checkValidate("blur").catch((e) => e).then(() => {
                $xetable.handleActived(params, evnt).then(() => checkValidate("change")).catch((e) => e);
              });
            } else if (editOpts.mode === "cell") {
              $xetable.handleActived(params, evnt).then(() => checkValidate("change")).catch((e) => e);
            }
          }
        }
        tableMethods.dispatchEvent("cell-dblclick", params, evnt);
      },
      handleToggleCheckRowEvent(evnt, params) {
        const { selectCheckboxMaps } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        const { row } = params;
        let value = false;
        if (checkField) {
          value = !import_xe_utils41.default.get(row, checkField);
        } else {
          value = !selectCheckboxMaps[getRowid($xetable, row)];
        }
        if (evnt) {
          tablePrivateMethods.triggerCheckRowEvent(evnt, params, value);
        } else {
          tablePrivateMethods.handleSelectRow(params, value);
        }
      },
      triggerCheckRowEvent(evnt, params, value) {
        const checkboxOpts = computeCheckboxOpts.value;
        const { row } = params;
        const { afterFullData } = internalData;
        const { checkMethod } = checkboxOpts;
        if (checkboxOpts.isShiftKey && evnt.shiftKey && !props.treeConfig) {
          const checkboxRecords = tableMethods.getCheckboxRecords();
          if (checkboxRecords.length) {
            const firstRow = checkboxRecords[0];
            const _rowIndex = tableMethods.getVTRowIndex(row);
            const _firstRowIndex = tableMethods.getVTRowIndex(firstRow);
            if (_rowIndex !== _firstRowIndex) {
              tableMethods.setAllCheckboxRow(false);
              const rangeRows = _rowIndex < _firstRowIndex ? afterFullData.slice(_rowIndex, _firstRowIndex + 1) : afterFullData.slice(_firstRowIndex, _rowIndex + 1);
              handleCheckedCheckboxRow(rangeRows, true, false);
              tableMethods.dispatchEvent("checkbox-range-select", Object.assign({ rangeRecords: rangeRows }, params), evnt);
              return;
            }
          }
        }
        if (!checkMethod || checkMethod({ row })) {
          tablePrivateMethods.handleSelectRow(params, value);
          tableMethods.dispatchEvent("checkbox-change", Object.assign({
            records: tableMethods.getCheckboxRecords(),
            reserves: tableMethods.getCheckboxReserveRecords(),
            indeterminates: tableMethods.getCheckboxIndeterminateRecords(),
            checked: value
          }, params), evnt);
        }
      },
      /**
       * 多选，选中所有事件
       */
      triggerCheckAllEvent(evnt, value) {
        handleCheckedAllCheckboxRow(value);
        if (evnt) {
          tableMethods.dispatchEvent("checkbox-all", {
            records: tableMethods.getCheckboxRecords(),
            reserves: tableMethods.getCheckboxReserveRecords(),
            indeterminates: tableMethods.getCheckboxIndeterminateRecords(),
            checked: value
          }, evnt);
        }
      },
      /**
       * 单选，行选中事件
       */
      triggerRadioRowEvent(evnt, params) {
        const { selectRadioRow: oldValue } = reactData;
        const { row } = params;
        const radioOpts = computeRadioOpts.value;
        let newValue = row;
        let isChange = oldValue !== newValue;
        if (isChange) {
          handleCheckedRadioRow(newValue);
        } else if (!radioOpts.strict) {
          isChange = oldValue === newValue;
          if (isChange) {
            newValue = null;
            tableMethods.clearRadioRow();
          }
        }
        if (isChange) {
          tableMethods.dispatchEvent("radio-change", Object.assign({ oldValue, newValue }, params), evnt);
        }
      },
      triggerCurrentRowEvent(evnt, params) {
        const { currentRow: oldValue } = reactData;
        const { row: newValue } = params;
        const isChange = oldValue !== newValue;
        tableMethods.setCurrentRow(newValue);
        if (isChange) {
          tableMethods.dispatchEvent("current-change", Object.assign({ oldValue, newValue }, params), evnt);
        }
      },
      /**
       * 展开行事件
       */
      triggerRowExpandEvent(evnt, params) {
        const { rowExpandLazyLoadedMaps, expandColumn: column } = reactData;
        const expandOpts = computeExpandOpts.value;
        const { row } = params;
        const { lazy } = expandOpts;
        const rowid = getRowid($xetable, row);
        if (!lazy || !rowExpandLazyLoadedMaps[rowid]) {
          const expanded = !tableMethods.isRowExpandByRow(row);
          const columnIndex = tableMethods.getColumnIndex(column);
          const $columnIndex = tableMethods.getVMColumnIndex(column);
          tableMethods.setRowExpand(row, expanded);
          tableMethods.dispatchEvent("toggle-row-expand", {
            expanded,
            column,
            columnIndex,
            $columnIndex,
            row,
            rowIndex: tableMethods.getRowIndex(row),
            $rowIndex: tableMethods.getVMRowIndex(row)
          }, evnt);
        }
      },
      /**
       * 展开树节点事件
       */
      triggerTreeExpandEvent(evnt, params) {
        const { treeExpandLazyLoadedMaps } = reactData;
        const treeOpts = computeTreeOpts.value;
        const { row, column } = params;
        const { lazy } = treeOpts;
        const rowid = getRowid($xetable, row);
        if (!lazy || !treeExpandLazyLoadedMaps[rowid]) {
          const expanded = !tableMethods.isTreeExpandByRow(row);
          const columnIndex = tableMethods.getColumnIndex(column);
          const $columnIndex = tableMethods.getVMColumnIndex(column);
          tableMethods.setTreeExpand(row, expanded);
          tableMethods.dispatchEvent("toggle-tree-expand", { expanded, column, columnIndex, $columnIndex, row }, evnt);
        }
      },
      /**
       * 点击排序事件
       */
      triggerSortEvent(evnt, column, order) {
        const { mouseConfig } = props;
        const sortOpts = computeSortOpts.value;
        const mouseOpts = computeMouseOpts.value;
        const { field, sortable } = column;
        if (sortable) {
          if (!order || column.order === order) {
            tableMethods.clearSort(sortOpts.multiple ? column : null);
          } else {
            tableMethods.sort({ field, order });
          }
          const params = { $table: $xetable, $event: evnt, column, field, property: field, order: column.order, sortList: tableMethods.getSortColumns(), sortTime: column.sortTime };
          if (mouseConfig && mouseOpts.area && $xetable.handleSortEvent) {
            $xetable.handleSortEvent(evnt, params);
          }
          tableMethods.dispatchEvent("sort-change", params, evnt);
        }
      },
      /**
       * 横向 X 可视渲染事件处理
       */
      triggerScrollXEvent() {
        loadScrollXData();
      },
      /**
       * 纵向 Y 可视渲染事件处理
       */
      triggerScrollYEvent(evnt) {
        const { scrollYStore } = internalData;
        const { adaptive, offsetSize, visibleSize } = scrollYStore;
        if (isWebkit && adaptive && offsetSize * 2 + visibleSize <= 40) {
          loadScrollYData(evnt);
        } else {
          debounceScrollY(evnt);
        }
      },
      /**
       * 对于树形结构中，可以直接滚动到指定深层节点中
       * 对于某些特定的场景可能会用到，比如定位到某一节点
       * @param {Row} row 行对象
       */
      scrollToTreeRow(row) {
        const { treeConfig } = props;
        const { tableFullData } = internalData;
        const rests = [];
        if (treeConfig) {
          const treeOpts = computeTreeOpts.value;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const matchObj = import_xe_utils41.default.findTree(tableFullData, (item) => $xetable.eqRow(item, row), { children: childrenField });
          if (matchObj) {
            const nodes = matchObj.nodes;
            nodes.forEach((row2, index) => {
              if (index < nodes.length - 1 && !tableMethods.isTreeExpandByRow(row2)) {
                rests.push(tableMethods.setTreeExpand(row2, true));
              }
            });
          }
        }
        return Promise.all(rests).then(() => rowToVisible($xetable, row));
      },
      updateScrollYStatus,
      // 更新横向 X 可视渲染上下剩余空间大小
      updateScrollXSpace() {
        const { isGroup, scrollXLoad, scrollbarWidth } = reactData;
        const { visibleColumn, scrollXStore, elemStore, tableWidth } = internalData;
        const tableHeader = refTableHeader.value;
        const tableBody = refTableBody.value;
        const tableFooter = refTableFooter.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        if (tableBodyElem) {
          const tableHeaderElem = tableHeader ? tableHeader.$el : null;
          const tableFooterElem = tableFooter ? tableFooter.$el : null;
          const headerElem = tableHeaderElem ? tableHeaderElem.querySelector(".vxe-table--header") : null;
          const bodyElem = tableBodyElem.querySelector(".vxe-table--body");
          const footerElem = tableFooterElem ? tableFooterElem.querySelector(".vxe-table--footer") : null;
          const leftSpaceWidth = visibleColumn.slice(0, scrollXStore.startIndex).reduce((previous, column) => previous + column.renderWidth, 0);
          let marginLeft = "";
          if (scrollXLoad) {
            marginLeft = `${leftSpaceWidth}px`;
          }
          if (headerElem) {
            headerElem.style.marginLeft = isGroup ? "" : marginLeft;
          }
          bodyElem.style.marginLeft = marginLeft;
          if (footerElem) {
            footerElem.style.marginLeft = marginLeft;
          }
          const containerList = ["main"];
          containerList.forEach((name) => {
            const layoutList = ["header", "body", "footer"];
            layoutList.forEach((layout) => {
              const xSpaceRef = elemStore[`${name}-${layout}-xSpace`];
              const xSpaceElem = xSpaceRef ? xSpaceRef.value : null;
              if (xSpaceElem) {
                xSpaceElem.style.width = scrollXLoad ? `${tableWidth + (layout === "header" ? scrollbarWidth : 0)}px` : "";
              }
            });
          });
          nextTick(updateStyle);
        }
      },
      // 更新纵向 Y 可视渲染上下剩余空间大小
      updateScrollYSpace() {
        const { scrollYLoad } = reactData;
        const { scrollYStore, elemStore, afterFullData } = internalData;
        const { startIndex, rowHeight } = scrollYStore;
        const bodyHeight = afterFullData.length * rowHeight;
        const topSpaceHeight = Math.max(0, startIndex * rowHeight);
        const containerList = ["main", "left", "right"];
        let marginTop = "";
        let ySpaceHeight = "";
        if (scrollYLoad) {
          marginTop = `${topSpaceHeight}px`;
          ySpaceHeight = `${bodyHeight}px`;
        }
        containerList.forEach((name) => {
          const layoutList = ["header", "body", "footer"];
          const tableRef = elemStore[`${name}-body-table`];
          const tableElem = tableRef ? tableRef.value : null;
          if (tableElem) {
            tableElem.style.marginTop = marginTop;
          }
          layoutList.forEach((layout) => {
            const ySpaceRef = elemStore[`${name}-${layout}-ySpace`];
            const ySpaceElem = ySpaceRef ? ySpaceRef.value : null;
            if (ySpaceElem) {
              ySpaceElem.style.height = ySpaceHeight;
            }
          });
        });
        nextTick(updateStyle);
      },
      updateScrollXData() {
        nextTick(() => {
          handleTableColumn();
          tablePrivateMethods.updateScrollXSpace();
        });
      },
      updateScrollYData() {
        nextTick(() => {
          tablePrivateMethods.handleTableData();
          tablePrivateMethods.updateScrollYSpace();
        });
      },
      /**
       * 处理固定列的显示状态
       */
      checkScrolling() {
        const leftContainerElem = refLeftContainer.value;
        const rightContainerElem = refRightContainer.value;
        const tableBody = refTableBody.value;
        const bodyElem = tableBody ? tableBody.$el : null;
        if (bodyElem) {
          if (leftContainerElem) {
            if (bodyElem.scrollLeft > 0) {
              addClass(leftContainerElem, "scrolling--middle");
            } else {
              removeClass(leftContainerElem, "scrolling--middle");
            }
          }
          if (rightContainerElem) {
            if (bodyElem.clientWidth < bodyElem.scrollWidth - Math.ceil(bodyElem.scrollLeft)) {
              addClass(rightContainerElem, "scrolling--middle");
            } else {
              removeClass(rightContainerElem, "scrolling--middle");
            }
          }
        }
      },
      updateZindex() {
        if (props.zIndex) {
          internalData.tZindex = props.zIndex;
        } else if (internalData.tZindex < getLastZIndex()) {
          internalData.tZindex = nextZIndex();
        }
      },
      handleCheckedCheckboxRow,
      /**
       * 行 hover 事件
       */
      triggerHoverEvent(evnt, { row }) {
        tablePrivateMethods.setHoverRow(row);
      },
      setHoverRow(row) {
        const rowid = getRowid($xetable, row);
        const el = refElem.value;
        tablePrivateMethods.clearHoverRow();
        if (el) {
          import_xe_utils41.default.arrayEach(el.querySelectorAll(`[rowid="${rowid}"]`), (elem) => addClass(elem, "row--hover"));
        }
        internalData.hoverRow = row;
      },
      clearHoverRow() {
        const el = refElem.value;
        if (el) {
          import_xe_utils41.default.arrayEach(el.querySelectorAll(".vxe-body--row.row--hover"), (elem) => removeClass(elem, "row--hover"));
        }
        internalData.hoverRow = null;
      },
      getCell(row, column) {
        const rowid = getRowid($xetable, row);
        const tableBody = refTableBody.value;
        const leftBody = refTableLeftBody.value;
        const rightBody = refTableRightBody.value;
        let bodyElem;
        if (column) {
          if (column.fixed) {
            if (column.fixed === "left") {
              if (leftBody) {
                bodyElem = leftBody.$el;
              }
            } else {
              if (rightBody) {
                bodyElem = rightBody.$el;
              }
            }
          }
          if (!bodyElem) {
            bodyElem = tableBody.$el;
          }
          if (bodyElem) {
            return bodyElem.querySelector(`.vxe-body--row[rowid="${rowid}"] .${column.id}`);
          }
        }
        return null;
      },
      getCellLabel(row, column) {
        const formatter = column.formatter;
        const cellValue = getCellValue(row, column);
        let cellLabel = cellValue;
        if (formatter) {
          let formatData;
          const { fullAllDataRowIdData } = internalData;
          const rowid = getRowid($xetable, row);
          const colid = column.id;
          const rest = fullAllDataRowIdData[rowid];
          if (rest) {
            formatData = rest.formatData;
            if (!formatData) {
              formatData = fullAllDataRowIdData[rowid].formatData = {};
            }
            if (rest && formatData[colid]) {
              if (formatData[colid].value === cellValue) {
                return formatData[colid].label;
              }
            }
          }
          const formatParams = { cellValue, row, rowIndex: tableMethods.getRowIndex(row), column, columnIndex: tableMethods.getColumnIndex(column) };
          if (import_xe_utils41.default.isString(formatter)) {
            const gFormatOpts = VXETable.formats.get(formatter);
            const tcFormatMethod = gFormatOpts ? gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod : null;
            cellLabel = tcFormatMethod ? tcFormatMethod(formatParams) : "";
          } else if (import_xe_utils41.default.isArray(formatter)) {
            const gFormatOpts = VXETable.formats.get(formatter[0]);
            const tcFormatMethod = gFormatOpts ? gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod : null;
            cellLabel = tcFormatMethod ? tcFormatMethod(formatParams, ...formatter.slice(1)) : "";
          } else {
            cellLabel = formatter(formatParams);
          }
          if (formatData) {
            formatData[colid] = { value: cellValue, label: cellLabel };
          }
        }
        return cellLabel;
      },
      findRowIndexOf(list, row) {
        return row ? import_xe_utils41.default.findIndexOf(list, (item) => $xetable.eqRow(item, row)) : -1;
      },
      eqRow(row1, row2) {
        if (row1 && row2) {
          if (row1 === row2) {
            return true;
          }
          return getRowid($xetable, row1) === getRowid($xetable, row2);
        }
        return false;
      }
    };
    if (true) {
      "openExport,openPrint,exportData,openImport,importData,saveFile,readFile,importByFile,print".split(",").forEach((name) => {
        $xetable[name] = function() {
          errLog("vxe.error.reqModule", ["VxeTableExportModule"]);
        };
      });
      "clearValidate,fullValidate,validate".split(",").forEach((name) => {
        $xetable[name] = function() {
          errLog("vxe.error.reqModule", ["VxeTableValidatorModule"]);
        };
      });
    }
    Object.assign($xetable, tableMethods, tablePrivateMethods);
    const renderFixed = (fixedType) => {
      const { showHeader, showFooter } = props;
      const { tableData, tableColumn, tableGroupColumn, columnStore, footerTableData } = reactData;
      const isFixedLeft = fixedType === "left";
      const fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
      return h("div", {
        ref: isFixedLeft ? refLeftContainer : refRightContainer,
        class: `vxe-table--fixed-${fixedType}-wrapper`
      }, [
        showHeader ? h(header_default, {
          ref: isFixedLeft ? refTableLeftHeader : refTableRightHeader,
          fixedType,
          tableData,
          tableColumn,
          tableGroupColumn,
          fixedColumn
        }) : createCommentVNode(),
        h(body_default, {
          ref: isFixedLeft ? refTableLeftBody : refTableRightBody,
          fixedType,
          tableData,
          tableColumn,
          fixedColumn
        }),
        showFooter ? h(footer_default, {
          ref: isFixedLeft ? refTableLeftFooter : refTableRightFooter,
          footerTableData,
          tableColumn,
          fixedColumn,
          fixedType
        }) : createCommentVNode()
      ]);
    };
    const renderEmptyContenet = () => {
      const emptyOpts = computeEmptyOpts.value;
      const params = { $table: $xetable };
      if (slots.empty) {
        return slots.empty(params);
      } else {
        const compConf = emptyOpts.name ? VXETable.renderer.get(emptyOpts.name) : null;
        const renderTableEmptyView = compConf ? compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (renderTableEmptyView) {
          return getSlotVNs(renderTableEmptyView(emptyOpts, params));
        }
      }
      return getFuncText(props.emptyText) || conf_default.i18n("vxe.table.emptyText");
    };
    function handleUupdateResize() {
      const el = refElem.value;
      if (el && el.clientWidth && el.clientHeight) {
        tableMethods.recalculate();
      }
    }
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      const { inited, initStatus } = internalData;
      loadTableData(props.data || []).then(() => {
        const { scrollXLoad, scrollYLoad, expandColumn } = reactData;
        internalData.inited = true;
        internalData.initStatus = true;
        if (!initStatus) {
          handleLoadDefaults();
        }
        if (!inited) {
          handleInitDefaults();
        }
        if (true) {
          if ((scrollXLoad || scrollYLoad) && expandColumn) {
            warnLog("vxe.error.scrollErrProp", ["column.type=expand"]);
          }
        }
        tableMethods.recalculate();
      });
    });
    const staticColumnFlag = ref(0);
    watch(() => reactData.staticColumns.length, () => {
      staticColumnFlag.value++;
    });
    watch(() => reactData.staticColumns, () => {
      staticColumnFlag.value++;
    });
    watch(staticColumnFlag, () => {
      handleColumn(reactData.staticColumns);
    });
    const tableColumnFlag = ref(0);
    watch(() => reactData.tableColumn.length, () => {
      tableColumnFlag.value++;
    });
    watch(() => reactData.tableColumn, () => {
      tableColumnFlag.value++;
    });
    watch(tableColumnFlag, () => {
      tablePrivateMethods.analyColumnWidth();
    });
    watch(() => reactData.upDataFlag, () => {
      nextTick(() => {
        tableMethods.updateData();
      });
    });
    watch(() => reactData.reColumnFlag, () => {
      nextTick(() => {
        tableMethods.refreshColumn();
      });
    });
    watch(() => props.showHeader, () => {
      nextTick(() => {
        tableMethods.recalculate(true).then(() => tableMethods.refreshScroll());
      });
    });
    watch(() => props.showFooter, () => {
      nextTick(() => {
        tableMethods.recalculate(true).then(() => tableMethods.refreshScroll());
      });
    });
    const footFlag = ref(0);
    watch(() => props.footerData ? props.footerData.length : -1, () => {
      footFlag.value++;
    });
    watch(() => props.footerData, () => {
      footFlag.value++;
    });
    watch(footFlag, () => {
      tableMethods.updateFooter();
    });
    watch(() => props.height, () => {
      nextTick(() => tableMethods.recalculate(true));
    });
    watch(() => props.maxHeight, () => {
      nextTick(() => tableMethods.recalculate(true));
    });
    watch(() => props.syncResize, (value) => {
      if (value) {
        handleUupdateResize();
        nextTick(() => {
          handleUupdateResize();
          setTimeout(() => handleUupdateResize());
        });
      }
    });
    const mergeCellFlag = ref(0);
    watch(() => props.mergeCells ? props.mergeCells.length : -1, () => {
      mergeCellFlag.value++;
    });
    watch(() => props.mergeCells, () => {
      mergeCellFlag.value++;
    });
    watch(mergeCellFlag, () => {
      tableMethods.clearMergeCells();
      nextTick(() => {
        if (props.mergeCells) {
          tableMethods.setMergeCells(props.mergeCells);
        }
      });
    });
    const mergeFooterItemFlag = ref(0);
    watch(() => props.mergeFooterItems ? props.mergeFooterItems.length : -1, () => {
      mergeFooterItemFlag.value++;
    });
    watch(() => props.mergeFooterItems, () => {
      mergeFooterItemFlag.value++;
    });
    watch(mergeFooterItemFlag, () => {
      tableMethods.clearMergeFooterItems();
      nextTick(() => {
        if (props.mergeFooterItems) {
          tableMethods.setMergeFooterItems(props.mergeFooterItems);
        }
      });
    });
    VXETable.hooks.forEach((options) => {
      const { setupTable } = options;
      if (setupTable) {
        const hookRest = setupTable($xetable);
        if (hookRest && import_xe_utils41.default.isObject(hookRest)) {
          Object.assign($xetable, hookRest);
        }
      }
    });
    tablePrivateMethods.preventEvent(null, "created", { $table: $xetable });
    let resizeObserver;
    onActivated(() => {
      tableMethods.recalculate().then(() => tableMethods.refreshScroll());
      tablePrivateMethods.preventEvent(null, "activated", { $table: $xetable });
    });
    onDeactivated(() => {
      internalData.isActivated = false;
      tablePrivateMethods.preventEvent(null, "deactivated", { $table: $xetable });
    });
    onMounted(() => {
      nextTick(() => {
        const { data, treeConfig, showOverflow } = props;
        const { scrollXStore, scrollYStore } = internalData;
        const sYOpts = computeSYOpts.value;
        const editOpts = computeEditOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const expandOpts = computeExpandOpts.value;
        const rowOpts = computeRowOpts.value;
        if (true) {
          if (props.rowId) {
            warnLog("vxe.error.delProp", ["row-id", "row-config.keyField"]);
          }
          if (props.rowKey) {
            warnLog("vxe.error.delProp", ["row-key", "row-config.useKey"]);
          }
          if (props.columnKey) {
            warnLog("vxe.error.delProp", ["column-id", "column-config.useKey"]);
          }
          if (!(props.rowId || rowOpts.keyField) && (checkboxOpts.reserve || checkboxOpts.checkRowKeys || radioOpts.reserve || radioOpts.checkRowKey || expandOpts.expandRowKeys || treeOpts.expandRowKeys)) {
            warnLog("vxe.error.reqProp", ["row-config.keyField"]);
          }
          if (props.editConfig && (editOpts.showStatus || editOpts.showUpdateStatus || editOpts.showInsertStatus) && !props.keepSource) {
            warnLog("vxe.error.reqProp", ["keep-source"]);
          }
          if (treeConfig && (treeOpts.showLine || treeOpts.line) && (!(props.rowKey || rowOpts.useKey) || !showOverflow)) {
            warnLog("vxe.error.reqProp", ["row-config.useKey | show-overflow"]);
          }
          if (treeConfig && props.stripe) {
            warnLog("vxe.error.noTree", ["stripe"]);
          }
          if (props.showFooter && !(props.footerMethod || props.footerData)) {
            warnLog("vxe.error.reqProp", ["footer-data | footer-method"]);
          }
          const { exportConfig, importConfig } = props;
          const exportOpts = computeExportOpts.value;
          const importOpts = computeImportOpts.value;
          if (importConfig && importOpts.types && !importOpts.importMethod && !import_xe_utils41.default.includeArrays(VXETable.globalConfs.importTypes, importOpts.types)) {
            warnLog("vxe.error.errProp", [`export-config.types=${importOpts.types.join(",")}`, importOpts.types.filter((type) => import_xe_utils41.default.includes(VXETable.globalConfs.importTypes, type)).join(",") || VXETable.globalConfs.importTypes.join(",")]);
          }
          if (exportConfig && exportOpts.types && !exportOpts.exportMethod && !import_xe_utils41.default.includeArrays(VXETable.globalConfs.exportTypes, exportOpts.types)) {
            warnLog("vxe.error.errProp", [`export-config.types=${exportOpts.types.join(",")}`, exportOpts.types.filter((type) => import_xe_utils41.default.includes(VXETable.globalConfs.exportTypes, type)).join(",") || VXETable.globalConfs.exportTypes.join(",")]);
          }
        }
        if (true) {
          const customOpts = computeCustomOpts.value;
          const mouseOpts = computeMouseOpts.value;
          const rowOpts2 = computeRowOpts.value;
          if (!props.id && props.customConfig && (customOpts.storage === true || customOpts.storage && customOpts.storage.resizable || customOpts.storage && customOpts.storage.visible)) {
            errLog("vxe.error.reqProp", ["id"]);
          }
          if (props.treeConfig && checkboxOpts.range) {
            errLog("vxe.error.noTree", ["checkbox-config.range"]);
          }
          if (rowOpts2.height && !props.showOverflow) {
            warnLog("vxe.error.notProp", ["table.show-overflow"]);
          }
          if (!$xetable.handleUpdateCellAreas) {
            if (props.clipConfig) {
              warnLog("vxe.error.notProp", ["clip-config"]);
            }
            if (props.fnrConfig) {
              warnLog("vxe.error.notProp", ["fnr-config"]);
            }
            if (mouseOpts.area) {
              errLog("vxe.error.notProp", ["mouse-config.area"]);
              return;
            }
          }
          if (props.treeConfig && treeOpts.children) {
            warnLog("vxe.error.delProp", ["tree-config.children", "tree-config.childrenField"]);
          }
          if (props.treeConfig && treeOpts.line) {
            warnLog("vxe.error.delProp", ["tree-config.line", "tree-config.showLine"]);
          }
          if (mouseOpts.area && mouseOpts.selected) {
            warnLog("vxe.error.errConflicts", ["mouse-config.area", "mouse-config.selected"]);
          }
          if (mouseOpts.area && checkboxOpts.range) {
            warnLog("vxe.error.errConflicts", ["mouse-config.area", "checkbox-config.range"]);
          }
          if (props.treeConfig && mouseOpts.area) {
            errLog("vxe.error.noTree", ["mouse-config.area"]);
          }
          if (props.editConfig && editOpts.activeMethod) {
            warnLog("vxe.error.delProp", ["edit-config.activeMethod", "edit-config.beforeEditMethod"]);
          }
          if (props.treeConfig && checkboxOpts.isShiftKey) {
            errLog("vxe.error.errConflicts", ["tree-config", "checkbox-config.isShiftKey"]);
          }
          if (checkboxOpts.halfField) {
            warnLog("vxe.error.delProp", ["checkbox-config.halfField", "checkbox-config.indeterminateField"]);
          }
        }
        if (true) {
          if (props.editConfig && !$xetable.insert) {
            errLog("vxe.error.reqModule", ["Edit"]);
          }
          if (props.editRules && !$xetable.validate) {
            errLog("vxe.error.reqModule", ["Validator"]);
          }
          if ((checkboxOpts.range || props.keyboardConfig || props.mouseConfig) && !$xetable.triggerCellMousedownEvent) {
            errLog("vxe.error.reqModule", ["Keyboard"]);
          }
          if ((props.printConfig || props.importConfig || props.exportConfig) && !$xetable.exportData) {
            errLog("vxe.error.reqModule", ["Export"]);
          }
        }
        Object.assign(scrollYStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0,
          adaptive: sYOpts.adaptive !== false
        });
        Object.assign(scrollXStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0
        });
        loadTableData(data || []).then(() => {
          if (data && data.length) {
            internalData.inited = true;
            internalData.initStatus = true;
            handleLoadDefaults();
            handleInitDefaults();
          }
          updateStyle();
        });
        if (props.autoResize) {
          const resizeOpts = computeResizeleOpts.value;
          const { refreshDelay } = resizeOpts;
          const el = refElem.value;
          const parentEl = tablePrivateMethods.getParentElem();
          const handleOptimizeResize = refreshDelay ? import_xe_utils41.default.throttle(() => tableMethods.recalculate(true), refreshDelay, { leading: true, trailing: true }) : null;
          resizeObserver = createResizeEvent(handleOptimizeResize ? () => {
            if (props.autoResize) {
              requestAnimationFrame(handleOptimizeResize);
            }
          } : () => {
            if (props.autoResize) {
              tableMethods.recalculate(true);
            }
          });
          if (el) {
            resizeObserver.observe(el);
          }
          if (parentEl) {
            resizeObserver.observe(parentEl);
          }
        }
      });
      GlobalEvent.on($xetable, "paste", handleGlobalPasteEvent);
      GlobalEvent.on($xetable, "copy", handleGlobalCopyEvent);
      GlobalEvent.on($xetable, "cut", handleGlobalCutEvent);
      GlobalEvent.on($xetable, "mousedown", handleGlobalMousedownEvent);
      GlobalEvent.on($xetable, "blur", handleGlobalBlurEvent);
      GlobalEvent.on($xetable, "mousewheel", handleGlobalMousewheelEvent);
      GlobalEvent.on($xetable, "keydown", handleGlobalKeydownEvent);
      GlobalEvent.on($xetable, "resize", handleGlobalResizeEvent);
      if ($xetable.handleGlobalContextmenuEvent) {
        GlobalEvent.on($xetable, "contextmenu", $xetable.handleGlobalContextmenuEvent);
      }
      tablePrivateMethods.preventEvent(null, "mounted", { $table: $xetable });
    });
    onBeforeUnmount(() => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      tableMethods.closeFilter();
      if ($xetable.closeMenu) {
        $xetable.closeMenu();
      }
      tablePrivateMethods.preventEvent(null, "beforeUnmount", { $table: $xetable });
    });
    onUnmounted(() => {
      GlobalEvent.off($xetable, "paste");
      GlobalEvent.off($xetable, "copy");
      GlobalEvent.off($xetable, "cut");
      GlobalEvent.off($xetable, "mousedown");
      GlobalEvent.off($xetable, "blur");
      GlobalEvent.off($xetable, "mousewheel");
      GlobalEvent.off($xetable, "keydown");
      GlobalEvent.off($xetable, "resize");
      GlobalEvent.off($xetable, "contextmenu");
      tablePrivateMethods.preventEvent(null, "unmounted", { $table: $xetable });
    });
    const renderVN = () => {
      const { loading, stripe, showHeader, height, treeConfig, mouseConfig, showFooter, highlightCell, highlightHoverRow, highlightHoverColumn, editConfig, editRules } = props;
      const { isGroup, overflowX, overflowY, scrollXLoad, scrollYLoad, scrollbarHeight, tableData, tableColumn, tableGroupColumn, footerTableData, initStore, columnStore, filterStore, customStore } = reactData;
      const { leftList, rightList } = columnStore;
      const loadingSlot = slots.loading;
      const tipConfig = computeTipConfig.value;
      const validOpts = computeValidOpts.value;
      const treeOpts = computeTreeOpts.value;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const vSize = computeSize.value;
      const tableBorder = computeTableBorder.value;
      const mouseOpts = computeMouseOpts.value;
      const validTipOpts = computeValidTipOpts.value;
      const loadingOpts = computeLoadingOpts.value;
      const isMenu = computeIsMenu.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-table", "vxe-table--render-default", `tid_${xID}`, `border--${tableBorder}`, {
          [`size--${vSize}`]: vSize,
          [`valid-msg--${validOpts.msgMode}`]: !!editRules,
          "vxe-editable": !!editConfig,
          "old-cell-valid": editRules && conf_default.cellVaildMode === "obsolete",
          "cell--highlight": highlightCell,
          "cell--selected": mouseConfig && mouseOpts.selected,
          "cell--area": mouseConfig && mouseOpts.area,
          "row--highlight": rowOpts.isHover || highlightHoverRow,
          "column--highlight": columnOpts.isHover || highlightHoverColumn,
          "is--header": showHeader,
          "is--footer": showFooter,
          "is--group": isGroup,
          "is--tree-line": treeConfig && (treeOpts.showLine || treeOpts.line),
          "is--fixed-left": leftList.length,
          "is--fixed-right": rightList.length,
          "is--animat": !!props.animat,
          "is--round": props.round,
          "is--stripe": !treeConfig && stripe,
          "is--loading": loading,
          "is--empty": !loading && !tableData.length,
          "is--scroll-y": overflowY,
          "is--scroll-x": overflowX,
          "is--virtual-x": scrollXLoad,
          "is--virtual-y": scrollYLoad
        }],
        onKeydown: keydownEvent
      }, [
        /**
         * 隐藏列
         */
        h("div", {
          class: "vxe-table-slots"
        }, slots.default ? slots.default({}) : []),
        h("div", {
          class: "vxe-table--render-wrapper"
        }, [
          h("div", {
            class: "vxe-table--main-wrapper"
          }, [
            /**
             * 表头
             */
            showHeader ? h(header_default, {
              ref: refTableHeader,
              tableData,
              tableColumn,
              tableGroupColumn
            }) : createCommentVNode(),
            /**
             * 表体
             */
            h(body_default, {
              ref: refTableBody,
              tableData,
              tableColumn
            }),
            /**
             * 表尾
             */
            showFooter ? h(footer_default, {
              ref: refTableFooter,
              footerTableData,
              tableColumn
            }) : createCommentVNode()
          ]),
          h("div", {
            class: "vxe-table--fixed-wrapper"
          }, [
            /**
             * 左侧固定区域
             */
            leftList && leftList.length && overflowX ? renderFixed("left") : createCommentVNode(),
            /**
             * 右侧固定区域
             */
            rightList && rightList.length && overflowX ? renderFixed("right") : createCommentVNode()
          ])
        ]),
        /**
         * 空数据
         */
        h("div", {
          ref: refEmptyPlaceholder,
          class: "vxe-table--empty-placeholder"
        }, [
          h("div", {
            class: "vxe-table--empty-content"
          }, renderEmptyContenet())
        ]),
        /**
         * 边框线
         */
        h("div", {
          class: "vxe-table--border-line"
        }),
        /**
         * 列宽线
         */
        h("div", {
          ref: refCellResizeBar,
          class: "vxe-table--resizable-bar",
          style: overflowX ? {
            "padding-bottom": `${scrollbarHeight}px`
          } : null
        }),
        /**
         * 加载中
         */
        h(loading_default2, {
          class: "vxe-table--loading",
          modelValue: loading,
          icon: loadingOpts.icon,
          text: loadingOpts.text
        }, loadingSlot ? {
          default: () => loadingSlot({ $table: $xetable, $grid: $xegrid })
        } : {}),
        /**
         * 自定义列
         */
        initStore.custom ? h(resolveComponent("vxe-table-custom-panel"), {
          ref: refTableCustom,
          customStore
        }) : createCommentVNode(),
        /**
         * 筛选
         */
        initStore.filter ? h(resolveComponent("vxe-table-filter-panel"), {
          ref: refTableFilter,
          filterStore
        }) : createCommentVNode(),
        /**
         * 导入
         */
        initStore.import && props.importConfig ? h(resolveComponent("vxe-table-import-panel"), {
          defaultOptions: reactData.importParams,
          storeData: reactData.importStore
        }) : createCommentVNode(),
        /**
         * 导出/导出
         */
        initStore.export && (props.exportConfig || props.printConfig) ? h(resolveComponent("vxe-table-export-panel"), {
          defaultOptions: reactData.exportParams,
          storeData: reactData.exportStore
        }) : createCommentVNode(),
        /**
         * 快捷菜单
         */
        isMenu ? h(resolveComponent("vxe-table-menu-panel"), {
          ref: refTableMenu
        }) : createCommentVNode(),
        /**
         * 通用提示
         */
        hasUseTooltip ? h(resolveComponent("vxe-tooltip"), {
          ref: refCommTooltip,
          isArrow: false,
          enterable: false
        }) : createCommentVNode(),
        /**
         * 工具提示
         */
        hasUseTooltip ? h(resolveComponent("vxe-tooltip"), Object.assign({ ref: refTooltip }, tipConfig)) : createCommentVNode(),
        /**
         * 校验提示
         */
        hasUseTooltip && props.editRules && validOpts.showMessage && (validOpts.message === "default" ? !height : validOpts.message === "tooltip") ? h(resolveComponent("vxe-tooltip"), Object.assign({ ref: refValidTooltip, class: [{
          "old-cell-valid": editRules && conf_default.cellVaildMode === "obsolete"
        }, "vxe-table--valid-error"] }, validOpts.message === "tooltip" || tableData.length === 1 ? validTipOpts : {})) : createCommentVNode()
      ]);
    };
    $xetable.renderVN = renderVN;
    provide("xecolgroup", null);
    provide("$xetable", $xetable);
    return $xetable;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/table/index.js
var VxeTable = Object.assign(table_default, {
  install: function(app) {
    app.component(table_default.name, table_default);
  }
});
var Table = VxeTable;
dynamicApp.component(table_default.name, table_default);
var table_default2 = VxeTable;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/pager/src/pager.js
var import_xe_utils42 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/select/index.js
var VxeSelect = Object.assign(select_default, {
  install: function(app) {
    app.component(select_default.name, select_default);
  }
});
var Select = VxeSelect;
dynamicApp.component(select_default.name, select_default);
var select_default2 = VxeSelect;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/pager/src/pager.js
var pager_default = defineComponent({
  name: "VxePager",
  props: {
    size: { type: String, default: () => conf_default.pager.size || conf_default.size },
    // 自定义布局
    layouts: { type: Array, default: () => conf_default.pager.layouts || ["PrevJump", "PrevPage", "Jump", "PageCount", "NextPage", "NextJump", "Sizes", "Total"] },
    // 当前页
    currentPage: { type: Number, default: 1 },
    // 加载中
    loading: Boolean,
    // 每页大小
    pageSize: { type: Number, default: () => conf_default.pager.pageSize || 10 },
    // 总条数
    total: { type: Number, default: 0 },
    // 显示页码按钮的数量
    pagerCount: { type: Number, default: () => conf_default.pager.pagerCount || 7 },
    // 每页大小选项列表
    pageSizes: { type: Array, default: () => conf_default.pager.pageSizes || [10, 15, 20, 50, 100] },
    // 列对其方式
    align: { type: String, default: () => conf_default.pager.align },
    // 带边框
    border: { type: Boolean, default: () => conf_default.pager.border },
    // 带背景颜色
    background: { type: Boolean, default: () => conf_default.pager.background },
    // 配套的样式
    perfect: { type: Boolean, default: () => conf_default.pager.perfect },
    // 当只有一页时隐藏
    autoHidden: { type: Boolean, default: () => conf_default.pager.autoHidden },
    transfer: { type: Boolean, default: () => conf_default.pager.transfer },
    className: [String, Function],
    // 自定义图标
    iconPrevPage: String,
    iconJumpPrev: String,
    iconJumpNext: String,
    iconNextPage: String,
    iconJumpMore: String,
    iconHomePage: String,
    iconEndPage: String
  },
  emits: [
    "update:pageSize",
    "update:currentPage",
    "page-change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils42.default.uniqueId();
    const computeSize = useSize(props);
    const $xegrid = inject("$xegrid", null);
    const reactData = reactive({
      inpCurrPage: props.currentPage
    });
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xepager = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    let pagerMethods = {};
    let pagerPrivateMethods = {};
    const getPageCount = (total, size) => {
      return Math.max(Math.ceil(total / size), 1);
    };
    const computePageCount = computed(() => {
      return getPageCount(props.total, props.pageSize);
    });
    const jumpPageEvent = (evnt, currentPage) => {
      emit("update:currentPage", currentPage);
      if (evnt && currentPage !== props.currentPage) {
        pagerMethods.dispatchEvent("page-change", { type: "current", pageSize: props.pageSize, currentPage }, evnt);
      }
    };
    const changeCurrentPage = (currentPage, evnt) => {
      emit("update:currentPage", currentPage);
      if (evnt && currentPage !== props.currentPage) {
        pagerMethods.dispatchEvent("page-change", { type: "current", pageSize: props.pageSize, currentPage }, evnt);
      }
    };
    const triggerJumpEvent = (evnt) => {
      const inputElem = evnt.target;
      const inpValue = import_xe_utils42.default.toInteger(inputElem.value);
      const pageCount = computePageCount.value;
      const current = inpValue <= 0 ? 1 : inpValue >= pageCount ? pageCount : inpValue;
      const currPage = import_xe_utils42.default.toValueString(current);
      inputElem.value = currPage;
      reactData.inpCurrPage = currPage;
      changeCurrentPage(current, evnt);
    };
    const computeNumList = computed(() => {
      const { pagerCount } = props;
      const pageCount = computePageCount.value;
      const len = pageCount > pagerCount ? pagerCount - 2 : pagerCount;
      const rest = [];
      for (let index = 0; index < len; index++) {
        rest.push(index);
      }
      return rest;
    });
    const computeOffsetNumber = computed(() => {
      return Math.floor((props.pagerCount - 2) / 2);
    });
    const computeSizeList = computed(() => {
      return props.pageSizes.map((item) => {
        if (import_xe_utils42.default.isNumber(item)) {
          return {
            value: item,
            label: `${conf_default.i18n("vxe.pager.pagesize", [item])}`
          };
        }
        return Object.assign({ value: "", label: "" }, item);
      });
    });
    const handleHomePage = (evnt) => {
      const { currentPage } = props;
      if (currentPage > 1) {
        changeCurrentPage(1, evnt);
      }
    };
    const handleEndPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        changeCurrentPage(pageCount, evnt);
      }
    };
    const handlePrevPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage > 1) {
        changeCurrentPage(Math.min(pageCount, Math.max(currentPage - 1, 1)), evnt);
      }
    };
    const handleNextPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        changeCurrentPage(Math.min(pageCount, currentPage + 1), evnt);
      }
    };
    const handlePrevJump = (evnt) => {
      const numList = computeNumList.value;
      changeCurrentPage(Math.max(props.currentPage - numList.length, 1), evnt);
    };
    const handleNextJump = (evnt) => {
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      changeCurrentPage(Math.min(props.currentPage + numList.length, pageCount), evnt);
    };
    const pageSizeEvent = (params) => {
      const { value } = params;
      const pageSize = import_xe_utils42.default.toNumber(value);
      const pageCount = getPageCount(props.total, pageSize);
      let currentPage = props.currentPage;
      if (currentPage > pageCount) {
        currentPage = pageCount;
        emit("update:currentPage", pageCount);
      }
      emit("update:pageSize", pageSize);
      pagerMethods.dispatchEvent("page-change", { type: "size", pageSize, currentPage });
    };
    const jumpInputEvent = (evnt) => {
      const inputElem = evnt.target;
      reactData.inpCurrPage = inputElem.value;
    };
    const jumpKeydownEvent = (evnt) => {
      if (hasEventKey(evnt, EVENT_KEYS.ENTER)) {
        triggerJumpEvent(evnt);
      } else if (hasEventKey(evnt, EVENT_KEYS.ARROW_UP)) {
        evnt.preventDefault();
        handleNextPage(evnt);
      } else if (hasEventKey(evnt, EVENT_KEYS.ARROW_DOWN)) {
        evnt.preventDefault();
        handlePrevPage(evnt);
      }
    };
    const renderHomePage = () => {
      return h("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: conf_default.i18n("vxe.pager.homePageTitle"),
        onClick: handleHomePage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconHomePage || conf_default.icon.PAGER_HOME]
        })
      ]);
    };
    const renderPrevPage = () => {
      return h("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: conf_default.i18n("vxe.pager.prevPageTitle"),
        onClick: handlePrevPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconPrevPage || conf_default.icon.PAGER_PREV_PAGE]
        })
      ]);
    };
    const renderPrevJump = (tagName) => {
      return h(tagName || "button", {
        class: ["vxe-pager--jump-prev", {
          "is--fixed": !tagName,
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: conf_default.i18n("vxe.pager.prevJumpTitle"),
        onClick: handlePrevJump
      }, [
        tagName ? h("i", {
          class: ["vxe-pager--jump-more-icon", props.iconJumpMore || conf_default.icon.PAGER_JUMP_MORE]
        }) : null,
        h("i", {
          class: ["vxe-pager--jump-icon", props.iconJumpPrev || conf_default.icon.PAGER_JUMP_PREV]
        })
      ]);
    };
    const renderNextJump = (tagName) => {
      const pageCount = computePageCount.value;
      return h(tagName || "button", {
        class: ["vxe-pager--jump-next", {
          "is--fixed": !tagName,
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: conf_default.i18n("vxe.pager.nextJumpTitle"),
        onClick: handleNextJump
      }, [
        tagName ? h("i", {
          class: ["vxe-pager--jump-more-icon", props.iconJumpMore || conf_default.icon.PAGER_JUMP_MORE]
        }) : null,
        h("i", {
          class: ["vxe-pager--jump-icon", props.iconJumpNext || conf_default.icon.PAGER_JUMP_NEXT]
        })
      ]);
    };
    const renderNextPage = () => {
      const pageCount = computePageCount.value;
      return h("button", {
        class: ["vxe-pager--next-btn", {
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: conf_default.i18n("vxe.pager.nextPageTitle"),
        onClick: handleNextPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconNextPage || conf_default.icon.PAGER_NEXT_PAGE]
        })
      ]);
    };
    const renderEndPage = () => {
      const pageCount = computePageCount.value;
      return h("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: conf_default.i18n("vxe.pager.endPageTitle"),
        onClick: handleEndPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconEndPage || conf_default.icon.PAGER_END]
        })
      ]);
    };
    const renderNumber = (showJump) => {
      const { currentPage, pagerCount } = props;
      const nums = [];
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      const offsetNumber = computeOffsetNumber.value;
      const isOv = pageCount > pagerCount;
      const isLt = isOv && currentPage > offsetNumber + 1;
      const isGt = isOv && currentPage < pageCount - offsetNumber;
      let startNumber = 1;
      if (isOv) {
        if (currentPage >= pageCount - offsetNumber) {
          startNumber = Math.max(pageCount - numList.length + 1, 1);
        } else {
          startNumber = Math.max(currentPage - offsetNumber, 1);
        }
      }
      if (showJump && isLt) {
        nums.push(h("button", {
          class: "vxe-pager--num-btn",
          type: "button",
          onClick: (evnt) => jumpPageEvent(evnt, 1)
        }, 1), renderPrevJump("span"));
      }
      numList.forEach((item, index) => {
        const number = startNumber + index;
        if (number <= pageCount) {
          nums.push(h("button", {
            key: number,
            class: ["vxe-pager--num-btn", {
              "is--active": currentPage === number
            }],
            type: "button",
            onClick: (evnt) => jumpPageEvent(evnt, number)
          }, number));
        }
      });
      if (showJump && isGt) {
        nums.push(renderNextJump("button"), h("button", {
          class: "vxe-pager--num-btn",
          type: "button",
          onClick: (evnt) => jumpPageEvent(evnt, pageCount)
        }, pageCount));
      }
      return h("span", {
        class: "vxe-pager--btn-wrapper"
      }, nums);
    };
    const renderJumpNumber = () => {
      return renderNumber(true);
    };
    const renderSizes = () => {
      const sizeList = computeSizeList.value;
      return h(select_default2, {
        class: "vxe-pager--sizes",
        modelValue: props.pageSize,
        placement: "top",
        transfer: props.transfer,
        options: sizeList,
        onChange: pageSizeEvent
      });
    };
    const renderJump = (isFull) => {
      return h("span", {
        class: "vxe-pager--jump"
      }, [
        isFull ? h("span", {
          class: "vxe-pager--goto-text"
        }, conf_default.i18n("vxe.pager.goto")) : null,
        h("input", {
          class: "vxe-pager--goto",
          value: reactData.inpCurrPage,
          type: "text",
          autocomplete: "off",
          onInput: jumpInputEvent,
          onKeydown: jumpKeydownEvent,
          onBlur: triggerJumpEvent
        }),
        isFull ? h("span", {
          class: "vxe-pager--classifier-text"
        }, conf_default.i18n("vxe.pager.pageClassifier")) : null
      ]);
    };
    const renderFullJump = () => {
      return renderJump(true);
    };
    const renderPageCount = () => {
      const pageCount = computePageCount.value;
      return h("span", {
        class: "vxe-pager--count"
      }, [
        h("span", {
          class: "vxe-pager--separator"
        }),
        h("span", pageCount)
      ]);
    };
    const renderTotal = () => {
      return h("span", {
        class: "vxe-pager--total"
      }, conf_default.i18n("vxe.pager.total", [props.total]));
    };
    pagerMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $pager: $xepager, $event: evnt }, params));
      },
      homePage() {
        handleHomePage();
        return nextTick();
      },
      endPage() {
        handleEndPage();
        return nextTick();
      },
      prevPage() {
        handlePrevPage();
        return nextTick();
      },
      nextPage() {
        handleNextPage();
        return nextTick();
      },
      prevJump() {
        handlePrevJump();
        return nextTick();
      },
      nextJump() {
        handleNextJump();
        return nextTick();
      }
    };
    pagerPrivateMethods = {
      handlePrevPage,
      handleNextPage,
      handlePrevJump,
      handleNextJump
    };
    Object.assign($xepager, pagerMethods, pagerPrivateMethods);
    watch(() => props.currentPage, (value) => {
      reactData.inpCurrPage = value;
    });
    const renderVN = () => {
      const { align, layouts, className } = props;
      const childNodes = [];
      const vSize = computeSize.value;
      const pageCount = computePageCount.value;
      if (slots.left) {
        childNodes.push(h("span", {
          class: "vxe-pager--left-wrapper"
        }, slots.left({ $grid: $xegrid })));
      }
      layouts.forEach((name) => {
        let renderFn;
        switch (name) {
          case "Home":
            renderFn = renderHomePage;
            break;
          case "PrevJump":
            renderFn = renderPrevJump;
            break;
          case "PrevPage":
            renderFn = renderPrevPage;
            break;
          case "Number":
            renderFn = renderNumber;
            break;
          case "JumpNumber":
            renderFn = renderJumpNumber;
            break;
          case "NextPage":
            renderFn = renderNextPage;
            break;
          case "NextJump":
            renderFn = renderNextJump;
            break;
          case "End":
            renderFn = renderEndPage;
            break;
          case "Sizes":
            renderFn = renderSizes;
            break;
          case "FullJump":
            renderFn = renderFullJump;
            break;
          case "Jump":
            renderFn = renderJump;
            break;
          case "PageCount":
            renderFn = renderPageCount;
            break;
          case "Total":
            renderFn = renderTotal;
            break;
        }
        if (renderFn) {
          childNodes.push(renderFn());
        } else {
          if (true) {
            errLog("vxe.error.notProp", [`layouts -> ${name}`]);
          }
        }
      });
      if (slots.right) {
        childNodes.push(h("span", {
          class: "vxe-pager--right-wrapper"
        }, slots.right({ $grid: $xegrid })));
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-pager", className ? import_xe_utils42.default.isFunction(className) ? className({ $pager: $xepager }) : className : "", {
          [`size--${vSize}`]: vSize,
          [`align--${align}`]: align,
          "is--border": props.border,
          "is--background": props.background,
          "is--perfect": props.perfect,
          "is--hidden": props.autoHidden && pageCount === 1,
          "is--loading": props.loading
        }]
      }, [
        h("div", {
          class: "vxe-pager--wrapper"
        }, childNodes)
      ]);
    };
    $xepager.renderVN = renderVN;
    return $xepager;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/pager/index.js
var VxePager = Object.assign(pager_default, {
  install: function(app) {
    app.component(pager_default.name, pager_default);
  }
});
var Pager = VxePager;
dynamicApp.component(pager_default.name, pager_default);
var pager_default2 = VxePager;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/toolbar/src/toolbar.js
var import_xe_utils43 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/button/index.js
var VxeButton = Object.assign(button_default, {
  install(app) {
    app.component(button_default.name, button_default);
  }
});
var Button = VxeButton;
dynamicApp.component(button_default.name, button_default);
var button_default3 = VxeButton;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/toolbar/src/toolbar.js
var toolbar_default = defineComponent({
  name: "VxeToolbar",
  props: {
    loading: Boolean,
    refresh: [Boolean, Object],
    import: [Boolean, Object],
    export: [Boolean, Object],
    print: [Boolean, Object],
    zoom: [Boolean, Object],
    custom: [Boolean, Object],
    buttons: { type: Array, default: () => conf_default.toolbar.buttons },
    tools: { type: Array, default: () => conf_default.toolbar.tools },
    perfect: { type: Boolean, default: () => conf_default.toolbar.perfect },
    size: { type: String, default: () => conf_default.toolbar.size || conf_default.size },
    className: [String, Function]
  },
  emits: [
    "button-click",
    "tool-click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils43.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      isRefresh: false,
      columns: []
    });
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xetoolbar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let toolbarMethods = {};
    const $xegrid = inject("$xegrid", null);
    let $xetable;
    const connectFlag = ref(0);
    const computeRefreshOpts = computed(() => {
      return Object.assign({}, conf_default.toolbar.refresh, props.refresh);
    });
    const computeImportOpts = computed(() => {
      return Object.assign({}, conf_default.toolbar.import, props.import);
    });
    const computeExportOpts = computed(() => {
      return Object.assign({}, conf_default.toolbar.export, props.export);
    });
    const computePrintOpts = computed(() => {
      return Object.assign({}, conf_default.toolbar.print, props.print);
    });
    const computeZoomOpts = computed(() => {
      return Object.assign({}, conf_default.toolbar.zoom, props.zoom);
    });
    const computeCustomOpts = computed(() => {
      return Object.assign({}, conf_default.toolbar.custom, props.custom);
    });
    const computeTableCustomOpts = computed(() => {
      if (connectFlag.value || $xetable) {
        if ($xetable) {
          const { computeCustomOpts: computeCustomOpts2 } = $xetable.getComputeMaps();
          return computeCustomOpts2.value;
        }
      }
      return {};
    });
    const computeTrigger = computed(() => {
      const tableCustomOpts = computeTableCustomOpts.value;
      return tableCustomOpts.trigger;
    });
    const checkTable = () => {
      if ($xetable) {
        return true;
      }
      errLog("vxe.error.barUnableLink");
    };
    const handleClickSettingEvent = ({ $event }) => {
      if ($xetable) {
        if ($xetable.triggerCustomEvent) {
          $xetable.triggerCustomEvent($event);
        } else {
          errLog("vxe.error.reqModule", ["VxeTableCustomModule"]);
        }
      }
    };
    const handleMouseenterSettingEvent = ({ $event }) => {
      if ($xetable) {
        $xetable.customOpenEvent($event);
      } else {
        errLog("vxe.error.reqModule", ["VxeTableCustomModule"]);
      }
    };
    const handleMouseleaveSettingEvent = ({ $event }) => {
      const { customStore } = $xetable.reactData;
      customStore.activeBtn = false;
      setTimeout(() => {
        if (!customStore.activeBtn && !customStore.activeWrapper) {
          $xetable.customColseEvent($event);
        }
      }, 350);
    };
    const refreshEvent = (evnt) => {
      const { isRefresh } = reactData;
      const refreshOpts = computeRefreshOpts.value;
      if (!isRefresh) {
        const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
        if (queryMethod) {
          reactData.isRefresh = true;
          try {
            Promise.resolve(queryMethod({})).catch((e) => e).then(() => {
              reactData.isRefresh = false;
            });
          } catch (e) {
            reactData.isRefresh = false;
          }
        } else if ($xegrid) {
          reactData.isRefresh = true;
          $xegrid.triggerToolbarCommitEvent({ code: refreshOpts.code || "reload" }, evnt).catch((e) => e).then(() => {
            reactData.isRefresh = false;
          });
        }
      }
    };
    const zoomEvent = (evnt) => {
      if ($xegrid) {
        $xegrid.triggerZoomEvent(evnt);
      }
    };
    const btnEvent = (evnt, item) => {
      const { code } = item;
      if (code) {
        if ($xegrid) {
          $xegrid.triggerToolbarBtnEvent(item, evnt);
        } else {
          const gCommandOpts = VXETable.commands.get(code);
          const params = { code, button: item, $table: $xetable, $grid: $xegrid, $event: evnt };
          if (gCommandOpts) {
            if (gCommandOpts.commandMethod) {
              gCommandOpts.commandMethod(params);
            } else {
              if (true) {
                errLog("vxe.error.notCommands", [code]);
              }
            }
          }
          $xetoolbar.dispatchEvent("button-click", params, evnt);
        }
      }
    };
    const tolEvent = (evnt, item) => {
      const { code } = item;
      if (code) {
        if ($xegrid) {
          $xegrid.triggerToolbarTolEvent(item, evnt);
        } else {
          const gCommandOpts = VXETable.commands.get(code);
          const params = { code, tool: item, $table: $xetable, $grid: $xegrid, $event: evnt };
          if (gCommandOpts) {
            if (gCommandOpts.commandMethod) {
              gCommandOpts.commandMethod(params);
            } else {
              if (true) {
                errLog("vxe.error.notCommands", [code]);
              }
            }
          }
          $xetoolbar.dispatchEvent("tool-click", params, evnt);
        }
      }
    };
    const importEvent = () => {
      if (checkTable()) {
        $xetable.openImport();
      }
    };
    const exportEvent = () => {
      if (checkTable()) {
        $xetable.openExport();
      }
    };
    const printEvent = () => {
      if (checkTable()) {
        $xetable.openPrint();
      }
    };
    const renderDropdowns = (item, isBtn) => {
      const { dropdowns } = item;
      const downVNs = [];
      if (dropdowns) {
        return dropdowns.map((child, index) => {
          if (child.visible === false) {
            return createCommentVNode();
          }
          return h(button_default3, {
            key: index,
            disabled: child.disabled,
            loading: child.loading,
            type: child.type,
            icon: child.icon,
            circle: child.circle,
            round: child.round,
            status: child.status,
            content: child.name,
            onClick: (evnt) => isBtn ? btnEvent(evnt, child) : tolEvent(evnt, child)
          });
        });
      }
      return downVNs;
    };
    const renderBtns = () => {
      const { buttons } = props;
      const buttonsSlot = slots.buttons;
      if (buttonsSlot) {
        return getSlotVNs(buttonsSlot({ $grid: $xegrid, $table: $xetable }));
      }
      const btnVNs = [];
      if (buttons) {
        buttons.forEach((item) => {
          const { dropdowns, buttonRender } = item;
          if (item.visible !== false) {
            const compConf = buttonRender ? VXETable.renderer.get(buttonRender.name) : null;
            if (buttonRender && compConf && compConf.renderToolbarButton) {
              const toolbarButtonClassName = compConf.toolbarButtonClassName;
              const params = { $grid: $xegrid, $table: $xetable, button: item };
              btnVNs.push(h("span", {
                class: ["vxe-button--item", toolbarButtonClassName ? import_xe_utils43.default.isFunction(toolbarButtonClassName) ? toolbarButtonClassName(params) : toolbarButtonClassName : ""]
              }, getSlotVNs(compConf.renderToolbarButton(buttonRender, params))));
            } else {
              btnVNs.push(h(button_default3, {
                disabled: item.disabled,
                loading: item.loading,
                type: item.type,
                icon: item.icon,
                circle: item.circle,
                round: item.round,
                status: item.status,
                content: item.name,
                destroyOnClose: item.destroyOnClose,
                placement: item.placement,
                transfer: item.transfer,
                onClick: (evnt) => btnEvent(evnt, item)
              }, dropdowns && dropdowns.length ? {
                dropdowns: () => renderDropdowns(item, true)
              } : {}));
            }
          }
        });
      }
      return btnVNs;
    };
    const renderRightTools = () => {
      const { tools } = props;
      const toolsSlot = slots.tools;
      if (toolsSlot) {
        return getSlotVNs(toolsSlot({ $grid: $xegrid, $table: $xetable }));
      }
      const btnVNs = [];
      if (tools) {
        tools.forEach((item, tIndex) => {
          const { dropdowns, toolRender } = item;
          if (item.visible !== false) {
            const rdName = toolRender ? toolRender.name : null;
            const compConf = toolRender ? VXETable.renderer.get(rdName) : null;
            if (toolRender && compConf && compConf.renderToolbarTool) {
              const toolbarToolClassName = compConf.toolbarToolClassName;
              const params = { $grid: $xegrid, $table: $xetable, tool: item };
              btnVNs.push(h("span", {
                key: rdName,
                class: ["vxe-tool--item", toolbarToolClassName ? import_xe_utils43.default.isFunction(toolbarToolClassName) ? toolbarToolClassName(params) : toolbarToolClassName : ""]
              }, getSlotVNs(compConf.renderToolbarTool(toolRender, params))));
            } else {
              btnVNs.push(h(button_default3, {
                key: tIndex,
                disabled: item.disabled,
                loading: item.loading,
                type: item.type,
                icon: item.icon,
                circle: item.circle,
                round: item.round,
                status: item.status,
                content: item.name,
                destroyOnClose: item.destroyOnClose,
                placement: item.placement,
                transfer: item.transfer,
                onClick: (evnt) => tolEvent(evnt, item)
              }, dropdowns && dropdowns.length ? {
                dropdowns: () => renderDropdowns(item, false)
              } : {}));
            }
          }
        });
      }
      return btnVNs;
    };
    const renderToolImport = () => {
      const importOpts = computeImportOpts.value;
      return h(button_default3, {
        key: "import",
        circle: true,
        icon: importOpts.icon || conf_default.icon.TOOLBAR_TOOLS_IMPORT,
        title: conf_default.i18n("vxe.toolbar.import"),
        onClick: importEvent
      });
    };
    const renderToolExport = () => {
      const exportOpts = computeExportOpts.value;
      return h(button_default3, {
        key: "export",
        circle: true,
        icon: exportOpts.icon || conf_default.icon.TOOLBAR_TOOLS_EXPORT,
        title: conf_default.i18n("vxe.toolbar.export"),
        onClick: exportEvent
      });
    };
    const renderToolPrint = () => {
      const printOpts = computePrintOpts.value;
      return h(button_default3, {
        key: "print",
        circle: true,
        icon: printOpts.icon || conf_default.icon.TOOLBAR_TOOLS_PRINT,
        title: conf_default.i18n("vxe.toolbar.print"),
        onClick: printEvent
      });
    };
    const renderToolRefresh = () => {
      const refreshOpts = computeRefreshOpts.value;
      return h(button_default3, {
        key: "refresh",
        circle: true,
        icon: reactData.isRefresh ? refreshOpts.iconLoading || conf_default.icon.TOOLBAR_TOOLS_REFRESH_LOADING : refreshOpts.icon || conf_default.icon.TOOLBAR_TOOLS_REFRESH,
        title: conf_default.i18n("vxe.toolbar.refresh"),
        onClick: refreshEvent
      });
    };
    const renderToolZoom = () => {
      const zoomOpts = computeZoomOpts.value;
      return $xegrid ? h(button_default3, {
        key: "zoom",
        circle: true,
        icon: $xegrid.isMaximized() ? zoomOpts.iconOut || conf_default.icon.TOOLBAR_TOOLS_MINIMIZE : zoomOpts.iconIn || conf_default.icon.TOOLBAR_TOOLS_FULLSCREEN,
        title: conf_default.i18n(`vxe.toolbar.zoom${$xegrid.isMaximized() ? "Out" : "In"}`),
        onClick: zoomEvent
      }) : createCommentVNode();
    };
    const renderToolCustom = () => {
      const customOpts = computeCustomOpts.value;
      const btnTrigger = computeTrigger.value;
      const customBtnOns = {};
      if (btnTrigger === "manual") {
      } else if (btnTrigger === "hover") {
        customBtnOns.onMouseenter = handleMouseenterSettingEvent;
        customBtnOns.onMouseleave = handleMouseleaveSettingEvent;
      } else {
        customBtnOns.onClick = handleClickSettingEvent;
      }
      return h(button_default3, Object.assign({ key: "custom", circle: true, icon: customOpts.icon || conf_default.icon.TOOLBAR_TOOLS_CUSTOM, title: conf_default.i18n("vxe.toolbar.custom"), className: "vxe-toolbar-custom-target" }, customBtnOns));
    };
    toolbarMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $toolbar: $xetoolbar, $event: evnt }, params));
      },
      syncUpdate(params) {
        const { collectColumn } = params;
        $xetable = params.$table;
        reactData.columns = collectColumn;
        connectFlag.value++;
      }
    };
    Object.assign($xetoolbar, toolbarMethods);
    nextTick(() => {
      const { refresh } = props;
      const refreshOpts = computeRefreshOpts.value;
      const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
      if (refresh && !$xegrid && !queryMethod) {
        warnLog("vxe.error.notFunc", ["queryMethod"]);
      }
      const customOpts = computeCustomOpts.value;
      if (true) {
        if (customOpts.isFooter) {
          warnLog("vxe.error.delProp", ["toolbar.custom.isFooter", "table.custom-config.showFooter"]);
        }
        if (customOpts.showFooter) {
          warnLog("vxe.error.delProp", ["toolbar.custom.showFooter", "table.custom-config.showFooter"]);
        }
        if (customOpts.immediate) {
          warnLog("vxe.error.delProp", ["toolbar.custom.immediate", "table.custom-config.immediate"]);
        }
        if (customOpts.trigger) {
          warnLog("vxe.error.delProp", ["toolbar.custom.trigger", "table.custom-config.trigger"]);
        }
      }
    });
    const renderVN = () => {
      const { perfect, loading, refresh, zoom, custom, className } = props;
      const vSize = computeSize.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-toolbar", className ? import_xe_utils43.default.isFunction(className) ? className({ $toolbar: $xetoolbar }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--perfect": perfect,
          "is--loading": loading
        }]
      }, [
        h("div", {
          class: "vxe-buttons--wrapper"
        }, renderBtns()),
        h("div", {
          class: "vxe-tools--wrapper"
        }, renderRightTools()),
        h("div", {
          class: "vxe-tools--operate"
        }, [
          props.import ? renderToolImport() : createCommentVNode(),
          props.export ? renderToolExport() : createCommentVNode(),
          props.print ? renderToolPrint() : createCommentVNode(),
          refresh ? renderToolRefresh() : createCommentVNode(),
          zoom && $xegrid ? renderToolZoom() : createCommentVNode(),
          custom ? renderToolCustom() : createCommentVNode()
        ])
      ]);
    };
    $xetoolbar.renderVN = renderVN;
    return $xetoolbar;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/toolbar/index.js
var VxeToolbar = Object.assign(toolbar_default, {
  install: function(app) {
    app.component(toolbar_default.name, toolbar_default);
  }
});
var Toolbar = VxeToolbar;
dynamicApp.component(toolbar_default.name, toolbar_default);
var toolbar_default2 = VxeToolbar;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/form.js
var import_xe_utils47 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/util.js
var import_xe_utils45 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/itemInfo.js
var import_xe_utils44 = __toESM(require_xe_utils());
var ItemInfo = class {
  constructor($xeform, item) {
    Object.assign(this, {
      id: import_xe_utils44.default.uniqueId("item_"),
      title: item.title,
      field: item.field,
      span: item.span,
      align: item.align,
      titleAlign: item.titleAlign,
      titleWidth: item.titleWidth,
      titleColon: item.titleColon,
      titleAsterisk: item.titleAsterisk,
      titlePrefix: item.titlePrefix,
      titleSuffix: item.titleSuffix,
      titleOverflow: item.titleOverflow,
      showTitle: item.showTitle,
      resetValue: item.resetValue,
      visibleMethod: item.visibleMethod,
      visible: item.visible,
      folding: item.folding,
      collapseNode: item.collapseNode,
      className: item.className,
      contentClassName: item.contentClassName,
      contentStyle: item.contentStyle,
      titleClassName: item.titleClassName,
      titleStyle: item.titleStyle,
      itemRender: item.itemRender,
      rules: item.rules,
      // 渲染属性
      showError: false,
      errRule: null,
      slots: item.slots,
      children: []
    });
  }
  update(name, value) {
    this[name] = value;
  }
};

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/util.js
function isFormItem(item) {
  return item instanceof ItemInfo;
}
function createItem($xeform, _vm) {
  return isFormItem(_vm) ? _vm : new ItemInfo($xeform, _vm);
}
function handleFieldOrItem($xeform, fieldOrItem) {
  if (fieldOrItem) {
    return import_xe_utils45.default.isString(fieldOrItem) ? $xeform.getItemByField(fieldOrItem) : fieldOrItem;
  }
  return null;
}
function isHiddenItem($xeform, formItem) {
  const { reactData } = $xeform;
  const { collapseAll } = reactData;
  const { folding, visible } = formItem;
  return visible === false || folding && collapseAll;
}
function isActivetem($xeform, formItem) {
  let { visibleMethod, itemRender, visible, field } = formItem;
  if (visible === false) {
    return visible;
  }
  const compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;
  if (!visibleMethod && compConf && compConf.itemVisibleMethod) {
    visibleMethod = compConf.itemVisibleMethod;
  }
  if (!visibleMethod) {
    return true;
  }
  const { data } = $xeform.props;
  return visibleMethod({ data, field, property: field, item: formItem, $form: $xeform, $grid: $xeform.xegrid });
}
function watchItem(props, formItem) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      formItem.update(name, value);
    });
  });
}
function assemItem($xeform, el, formItem, formGather) {
  const { reactData } = $xeform;
  const { staticItems } = reactData;
  const parentElem = el.parentNode;
  const parentItem = formGather ? formGather.formItem : null;
  const parentItems = parentItem ? parentItem.children : staticItems;
  if (parentElem) {
    parentItems.splice(import_xe_utils45.default.arrayIndexOf(parentElem.children, el), 0, formItem);
    reactData.staticItems = staticItems.slice(0);
  }
}
function destroyItem($xeform, formItem) {
  const { reactData } = $xeform;
  const { staticItems } = reactData;
  const index = import_xe_utils45.default.findIndexOf(staticItems, (item) => item.id === formItem.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  reactData.staticItems = staticItems.slice(0);
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/tooltip/index.js
var VxeTooltip = Object.assign(tooltip_default, {
  install: function(app) {
    VXETable.tooltip = true;
    app.component(tooltip_default.name, tooltip_default);
  }
});
var Tooltip = VxeTooltip;
dynamicApp.component(tooltip_default.name, tooltip_default);
var tooltip_default2 = VxeTooltip;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/form-config-item.js
var import_xe_utils46 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/render.js
function renderPrefixIcon(titlePrefix) {
  return h("span", {
    class: "vxe-form--item-title-prefix"
  }, [
    h("i", {
      class: titlePrefix.icon || conf_default.icon.FORM_PREFIX
    })
  ]);
}
function renderSuffixIcon(titleSuffix) {
  return h("span", {
    class: "vxe-form--item-title-suffix"
  }, [
    h("i", {
      class: titleSuffix.icon || conf_default.icon.FORM_SUFFIX
    })
  ]);
}
function renderTitle($xeform, item) {
  const { data } = $xeform.props;
  const { computeTooltipOpts } = $xeform.getComputeMaps();
  const { slots, field, itemRender, titlePrefix, titleSuffix } = item;
  const tooltipOpts = computeTooltipOpts.value;
  const compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;
  const params = { data, field, property: field, item, $form: $xeform, $grid: $xeform.xegrid };
  const titleSlot = slots ? slots.title : null;
  const contVNs = [];
  const titVNs = [];
  if (titlePrefix) {
    titVNs.push(titlePrefix.content || titlePrefix.message ? h(tooltip_default2, Object.assign(Object.assign(Object.assign({}, tooltipOpts), titlePrefix), { content: getFuncText(titlePrefix.content || titlePrefix.message) }), {
      default: () => renderPrefixIcon(titlePrefix)
    }) : renderPrefixIcon(titlePrefix));
  }
  titVNs.push(h("span", {
    class: "vxe-form--item-title-label"
  }, compConf && compConf.renderItemTitle ? getSlotVNs(compConf.renderItemTitle(itemRender, params)) : titleSlot ? $xeform.callSlot(titleSlot, params) : getFuncText(item.title)));
  contVNs.push(h("div", {
    class: "vxe-form--item-title-content"
  }, titVNs));
  const fixVNs = [];
  if (titleSuffix) {
    fixVNs.push(titleSuffix.content || titleSuffix.message ? h(tooltip_default2, Object.assign(Object.assign(Object.assign({}, tooltipOpts), titleSuffix), { content: getFuncText(titleSuffix.content || titleSuffix.message) }), {
      default: () => renderSuffixIcon(titleSuffix)
    }) : renderSuffixIcon(titleSuffix));
  }
  contVNs.push(h("div", {
    class: "vxe-form--item-title-postfix"
  }, fixVNs));
  return contVNs;
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/form-config-item.js
var VxeFormConfigItem = defineComponent({
  name: "VxeFormConfigItem",
  props: {
    itemConfig: Object
  },
  setup(props) {
    const $xeform = inject("$xeform", {});
    const xeformiteminfo = { itemConfig: props.itemConfig };
    provide("$xeformiteminfo", xeformiteminfo);
    provide("$xeformgather", null);
    const renderVN = () => {
      const { reactData } = $xeform;
      const { data, rules, span: allSpan, align: allAlign, titleAlign: allTitleAlign, titleWidth: allTitleWidth, titleColon: allTitleColon, titleAsterisk: allTitleAsterisk, titleOverflow: allTitleOverflow, vertical: allVertical } = $xeform.props;
      const { computeValidOpts } = $xeform.getComputeMaps();
      const item = props.itemConfig;
      const { collapseAll } = reactData;
      const validOpts = computeValidOpts.value;
      const { slots, title, visible, folding, field, collapseNode, itemRender, showError, errRule, className, titleOverflow, vertical, children, showTitle, contentClassName, contentStyle, titleClassName, titleStyle } = item;
      const compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;
      const itemClassName = compConf ? compConf.itemClassName : "";
      const itemStyle = compConf ? compConf.itemStyle : null;
      const itemContentClassName = compConf ? compConf.itemContentClassName : "";
      const itemContentStyle = compConf ? compConf.itemContentStyle : null;
      const itemTitleClassName = compConf ? compConf.itemTitleClassName : "";
      const itemTitleStyle = compConf ? compConf.itemTitleStyle : null;
      const defaultSlot = slots ? slots.default : null;
      const titleSlot = slots ? slots.title : null;
      const span = item.span || allSpan;
      const align = item.align || allAlign;
      const titleAlign = import_xe_utils46.default.eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
      const titleWidth = import_xe_utils46.default.eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
      const titleColon = import_xe_utils46.default.eqNull(item.titleColon) ? allTitleColon : item.titleColon;
      const titleAsterisk = import_xe_utils46.default.eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
      const itemOverflow = import_xe_utils46.default.isUndefined(titleOverflow) || import_xe_utils46.default.isNull(titleOverflow) ? allTitleOverflow : titleOverflow;
      const itemVertical = import_xe_utils46.default.isUndefined(vertical) || import_xe_utils46.default.isNull(vertical) ? allVertical : vertical;
      const ovEllipsis = itemOverflow === "ellipsis";
      const ovTitle = itemOverflow === "title";
      const ovTooltip = itemOverflow === true || itemOverflow === "tooltip";
      const hasEllipsis = ovTitle || ovTooltip || ovEllipsis;
      const params = { data, field, property: field, item, $form: $xeform, $grid: $xeform.xegrid };
      if (visible === false) {
        return createCommentVNode();
      }
      let isRequired = false;
      if (rules) {
        const itemRules = rules[field];
        if (itemRules) {
          isRequired = itemRules.some((rule) => rule.required);
        }
      }
      const isGather = children && children.length > 0;
      if (isGather) {
        const childVNs = children.map((childItem, index) => {
          return h(VxeFormConfigItem, {
            key: index,
            itemConfig: childItem
          });
        });
        return childVNs.length ? h("div", {
          class: ["vxe-form--gather vxe-form--item-row", item.id, span ? `vxe-form--item-col_${span} is--span` : "", className ? import_xe_utils46.default.isFunction(className) ? className(params) : className : ""]
        }, childVNs) : createCommentVNode();
      }
      let contentVNs = [];
      if (defaultSlot) {
        contentVNs = $xeform.callSlot(defaultSlot, params);
      } else if (compConf && compConf.renderItemContent) {
        contentVNs = getSlotVNs(compConf.renderItemContent(itemRender, params));
      } else if (field) {
        contentVNs = [import_xe_utils46.default.toValueString(import_xe_utils46.default.get(data, field))];
      }
      if (collapseNode) {
        contentVNs.push(h("div", {
          class: "vxe-form--item-trigger-node",
          onClick: $xeform.toggleCollapseEvent
        }, [
          h("span", {
            class: "vxe-form--item-trigger-text"
          }, collapseAll ? conf_default.i18n("vxe.form.unfolding") : conf_default.i18n("vxe.form.folding")),
          h("i", {
            class: ["vxe-form--item-trigger-icon", collapseAll ? conf_default.icon.FORM_FOLDING : conf_default.icon.FORM_UNFOLDING]
          })
        ]));
      }
      if (errRule && validOpts.showMessage) {
        contentVNs.push(h("div", {
          class: "vxe-form--item-valid",
          style: errRule.maxWidth ? {
            width: `${errRule.maxWidth}px`
          } : null
        }, errRule.content));
      }
      const ons = ovTooltip ? {
        onMouseenter(evnt) {
          $xeform.triggerTitleTipEvent(evnt, params);
        },
        onMouseleave: $xeform.handleTitleTipLeaveEvent
      } : {};
      return h("div", {
        class: [
          "vxe-form--item",
          item.id,
          span ? `vxe-form--item-col_${span} is--span` : "",
          className ? import_xe_utils46.default.isFunction(className) ? className(params) : className : "",
          itemClassName ? import_xe_utils46.default.isFunction(itemClassName) ? itemClassName(params) : itemClassName : "",
          {
            "is--title": title,
            "is--colon": titleColon,
            "is--vertical": itemVertical,
            "is--asterisk": titleAsterisk,
            "is--required": isRequired,
            "is--hidden": folding && collapseAll,
            "is--active": isActivetem($xeform, item),
            "is--error": showError
          }
        ],
        style: import_xe_utils46.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        h("div", {
          class: "vxe-form--item-inner"
        }, [
          showTitle !== false && (title || titleSlot) ? h("div", Object.assign({ class: [
            "vxe-form--item-title",
            titleAlign ? `align--${titleAlign}` : "",
            hasEllipsis ? "is--ellipsis" : "",
            itemTitleClassName ? import_xe_utils46.default.isFunction(itemTitleClassName) ? itemTitleClassName(params) : itemTitleClassName : "",
            titleClassName ? import_xe_utils46.default.isFunction(titleClassName) ? titleClassName(params) : titleClassName : ""
          ], style: Object.assign({}, import_xe_utils46.default.isFunction(itemTitleStyle) ? itemTitleStyle(params) : itemTitleStyle, import_xe_utils46.default.isFunction(titleStyle) ? titleStyle(params) : titleStyle, titleWidth ? {
            width: isNaN(titleWidth) ? titleWidth : `${titleWidth}px`
          } : null), title: ovTitle ? getFuncText(title) : null }, ons), renderTitle($xeform, item)) : null,
          h("div", {
            class: [
              "vxe-form--item-content",
              align ? `align--${align}` : "",
              itemContentClassName ? import_xe_utils46.default.isFunction(itemContentClassName) ? itemContentClassName(params) : itemContentClassName : "",
              contentClassName ? import_xe_utils46.default.isFunction(contentClassName) ? contentClassName(params) : contentClassName : ""
            ],
            style: Object.assign({}, import_xe_utils46.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils46.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
          }, contentVNs)
        ])
      ]);
    };
    const $xeformconfigitem = {
      renderVN
    };
    return $xeformconfigitem;
  },
  render() {
    return this.renderVN();
  }
});
var form_config_item_default = VxeFormConfigItem;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/form.js
var Rule2 = class {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.min,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
};
var validErrorRuleValue = (rule, val) => {
  const { type, min, max, pattern } = rule;
  const isNumType = type === "number";
  const numVal = isNumType ? import_xe_utils47.default.toNumber(val) : import_xe_utils47.default.getSize(val);
  if (isNumType && isNaN(val)) {
    return true;
  }
  if (!import_xe_utils47.default.eqNull(min) && numVal < import_xe_utils47.default.toNumber(min)) {
    return true;
  }
  if (!import_xe_utils47.default.eqNull(max) && numVal > import_xe_utils47.default.toNumber(max)) {
    return true;
  }
  if (pattern && !(import_xe_utils47.default.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
    return true;
  }
  return false;
};
function getResetValue(value, resetValue) {
  if (import_xe_utils47.default.isArray(value)) {
    resetValue = [];
  }
  return resetValue;
}
var form_default = defineComponent({
  name: "VxeForm",
  props: {
    collapseStatus: { type: Boolean, default: true },
    loading: Boolean,
    data: Object,
    size: { type: String, default: () => conf_default.form.size || conf_default.size },
    span: { type: [String, Number], default: () => conf_default.form.span },
    align: { type: String, default: () => conf_default.form.align },
    titleAlign: { type: String, default: () => conf_default.form.titleAlign },
    titleWidth: { type: [String, Number], default: () => conf_default.form.titleWidth },
    titleColon: { type: Boolean, default: () => conf_default.form.titleColon },
    titleAsterisk: { type: Boolean, default: () => conf_default.form.titleAsterisk },
    titleOverflow: { type: [Boolean, String], default: null },
    vertical: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    readonly: Boolean,
    items: Array,
    rules: Object,
    preventSubmit: { type: Boolean, default: () => conf_default.form.preventSubmit },
    validConfig: Object,
    tooltipConfig: Object,
    customLayout: { type: Boolean, default: () => conf_default.form.customLayout }
  },
  emits: [
    "update:collapseStatus",
    "collapse",
    "toggle-collapse",
    "submit",
    "submit-invalid",
    "reset"
  ],
  setup(props, context) {
    const hasUseTooltip = VXETable.tooltip;
    const { slots, emit } = context;
    const xID = import_xe_utils47.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      collapseAll: props.collapseStatus,
      staticItems: [],
      formItems: []
    });
    const internalData = reactive({
      tooltipTimeout: null,
      tooltipStore: {
        item: null,
        visible: false
      }
    });
    const $xegrid = inject("$xegrid", null);
    const refElem = ref();
    const refTooltip = ref();
    let formMethods = {};
    const computeValidOpts = computed(() => {
      return Object.assign({}, conf_default.form.validConfig, props.validConfig);
    });
    const computeTooltipOpts = computed(() => {
      return Object.assign({}, conf_default.tooltip, conf_default.form.tooltipConfig, props.tooltipConfig);
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize,
      computeValidOpts,
      computeTooltipOpts
    };
    const $xeform = {
      xID,
      props,
      context,
      reactData,
      xegrid: $xegrid,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils47.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils47.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const loadItem = (list) => {
      if (list.length) {
        if (true) {
          list.forEach((item) => {
            if (item.slots) {
              import_xe_utils47.default.each(item.slots, (func) => {
                if (!import_xe_utils47.default.isFunction(func)) {
                  if (!slots[func]) {
                    errLog("vxe.error.notSlot", [func]);
                  }
                }
              });
            }
          });
        }
      }
      reactData.staticItems = import_xe_utils47.default.mapTree(list, (item) => createItem($xeform, item), { children: "children" });
      return nextTick();
    };
    const getItems = () => {
      const itemList = [];
      import_xe_utils47.default.eachTree(reactData.formItems, (item) => {
        itemList.push(item);
      }, { children: "children" });
      return itemList;
    };
    const getItemByField = (field) => {
      const rest = import_xe_utils47.default.findTree(reactData.formItems, (item) => item.field === field, { children: "children" });
      return rest ? rest.item : null;
    };
    const getCollapseStatus = () => {
      return reactData.collapseAll;
    };
    const toggleCollapse = () => {
      const status = !getCollapseStatus();
      reactData.collapseAll = status;
      emit("update:collapseStatus", status);
      return nextTick();
    };
    const toggleCollapseEvent = (evnt) => {
      toggleCollapse();
      const status = getCollapseStatus();
      formMethods.dispatchEvent("toggle-collapse", { status, collapse: status, data: props.data }, evnt);
      formMethods.dispatchEvent("collapse", { status, collapse: status, data: props.data }, evnt);
    };
    const clearValidate = (fieldOrItem) => {
      if (fieldOrItem) {
        let fields = fieldOrItem;
        if (!import_xe_utils47.default.isArray(fieldOrItem)) {
          fields = [fieldOrItem];
        }
        fields.forEach((field) => {
          if (field) {
            const item = handleFieldOrItem($xeform, field);
            if (item) {
              item.showError = false;
            }
          }
        });
      } else {
        getItems().forEach((item) => {
          item.showError = false;
        });
      }
      return nextTick();
    };
    const reset = () => {
      const { data } = props;
      const itemList = getItems();
      if (data) {
        itemList.forEach((item) => {
          const { field, resetValue, itemRender } = item;
          if (isEnableConf(itemRender)) {
            const compConf = VXETable.renderer.get(itemRender.name);
            if (compConf && compConf.itemResetMethod) {
              compConf.itemResetMethod({ data, field, property: field, item, $form: $xeform, $grid: $xeform.xegrid });
            } else if (field) {
              import_xe_utils47.default.set(data, field, resetValue === null ? getResetValue(import_xe_utils47.default.get(data, field), void 0) : import_xe_utils47.default.clone(resetValue, true));
            }
          }
        });
      }
      return clearValidate();
    };
    const resetEvent = (evnt) => {
      evnt.preventDefault();
      reset();
      formMethods.dispatchEvent("reset", { data: props.data }, evnt);
    };
    const handleFocus = (fields) => {
      const el = refElem.value;
      for (let i = 0; i < fields.length; i++) {
        const property = fields[i];
        const item = getItemByField(property);
        if (item && isEnableConf(item.itemRender)) {
          const { itemRender } = item;
          const compConf = VXETable.renderer.get(itemRender.name);
          let inputElem = null;
          if (!i) {
            scrollToView(el.querySelector(`.${item.id}`));
          }
          if (itemRender.autofocus) {
            inputElem = el.querySelector(`.${item.id} ${itemRender.autofocus}`);
          }
          if (!inputElem && compConf && compConf.autofocus) {
            inputElem = el.querySelector(`.${item.id} ${compConf.autofocus}`);
          }
          if (inputElem) {
            inputElem.focus();
            break;
          }
        }
      }
    };
    const validItemRules = (validType, fields, val) => {
      const { data, rules: formRules } = props;
      const errorMaps = {};
      if (!import_xe_utils47.default.isArray(fields)) {
        fields = [fields];
      }
      return Promise.all(fields.map((property) => {
        const errorRules = [];
        const syncVailds = [];
        if (property && formRules) {
          const rules = import_xe_utils47.default.get(formRules, property);
          if (rules) {
            const itemValue = import_xe_utils47.default.isUndefined(val) ? import_xe_utils47.default.get(data, property) : val;
            rules.forEach((rule) => {
              const { type, trigger, required, validator } = rule;
              if (validType === "all" || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    itemValue,
                    rule,
                    rules,
                    data,
                    field: property,
                    property,
                    $form: $xeform
                  };
                  let customValid;
                  if (import_xe_utils47.default.isString(validator)) {
                    const gvItem = VXETable.validators.get(validator);
                    if (gvItem) {
                      if (gvItem.itemValidatorMethod) {
                        customValid = gvItem.itemValidatorMethod(validParams);
                      } else {
                        if (true) {
                          warnLog("vxe.error.notValidators", [validator]);
                        }
                      }
                    } else {
                      if (true) {
                        errLog("vxe.error.notValidators", [validator]);
                      }
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (import_xe_utils47.default.isError(customValid)) {
                      errorRules.push(new Rule2({ type: "custom", trigger, content: customValid.message, rule: new Rule2(rule) }));
                    } else if (customValid.catch) {
                      syncVailds.push(customValid.catch((e) => {
                        errorRules.push(new Rule2({ type: "custom", trigger, content: e ? e.message : rule.content || rule.message, rule: new Rule2(rule) }));
                      }));
                    }
                  }
                } else {
                  const isArrType = type === "array";
                  const isArrVal = import_xe_utils47.default.isArray(itemValue);
                  let hasEmpty = true;
                  if (isArrType || isArrVal) {
                    hasEmpty = !isArrVal || !itemValue.length;
                  } else if (import_xe_utils47.default.isString(itemValue)) {
                    hasEmpty = eqEmptyValue(itemValue.trim());
                  } else {
                    hasEmpty = eqEmptyValue(itemValue);
                  }
                  if (required ? hasEmpty || validErrorRuleValue(rule, itemValue) : !hasEmpty && validErrorRuleValue(rule, itemValue)) {
                    errorRules.push(new Rule2(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncVailds).then(() => {
          if (errorRules.length) {
            errorMaps[property] = errorRules.map((rule) => {
              return {
                $form: $xeform,
                rule,
                data,
                field: property,
                property
              };
            });
          }
        });
      })).then(() => {
        if (!import_xe_utils47.default.isEmpty(errorMaps)) {
          return Promise.reject(errorMaps);
        }
      });
    };
    let showErrTime;
    const beginValidate = (itemList, type, callback) => {
      const { data, rules: formRules } = props;
      const validOpts = computeValidOpts.value;
      const validRest = {};
      const validFields = [];
      const itemValids = [];
      clearTimeout(showErrTime);
      if (data && formRules) {
        itemList.forEach((item) => {
          const { field } = item;
          if (field && !isHiddenItem($xeform, item) && isActivetem($xeform, item)) {
            itemValids.push(validItemRules(type || "all", field).then(() => {
              item.errRule = null;
            }).catch((errorMaps) => {
              const rest = errorMaps[field];
              if (!validRest[field]) {
                validRest[field] = [];
              }
              validRest[field].push(rest);
              validFields.push(field);
              item.errRule = rest[0].rule;
              return Promise.reject(rest);
            }));
          }
        });
        return Promise.all(itemValids).then(() => {
          if (callback) {
            callback();
          }
        }).catch(() => {
          return new Promise((resolve) => {
            showErrTime = window.setTimeout(() => {
              itemList.forEach((item) => {
                if (item.errRule) {
                  item.showError = true;
                }
              });
            }, 20);
            if (validOpts.autoPos !== false) {
              nextTick(() => {
                handleFocus(validFields);
              });
            }
            if (callback) {
              callback(validRest);
              resolve();
            } else {
              resolve(validRest);
            }
          });
        });
      }
      if (callback) {
        callback();
      }
      return Promise.resolve();
    };
    const validate = (callback) => {
      clearValidate();
      return beginValidate(getItems(), "", callback);
    };
    const validateField = (fieldOrItem, callback) => {
      let fields = [];
      if (import_xe_utils47.default.isArray(fieldOrItem)) {
        fields = fieldOrItem;
      } else {
        fields = [fieldOrItem];
      }
      return beginValidate(fields.map((field) => handleFieldOrItem($xeform, field)), "", callback);
    };
    const submitEvent = (evnt) => {
      evnt.preventDefault();
      if (!props.preventSubmit) {
        clearValidate();
        beginValidate(getItems()).then((errMap) => {
          if (errMap) {
            formMethods.dispatchEvent("submit-invalid", { data: props.data, errMap }, evnt);
          } else {
            formMethods.dispatchEvent("submit", { data: props.data }, evnt);
          }
        });
      }
    };
    const closeTooltip = () => {
      const { tooltipStore } = internalData;
      const $tooltip = refTooltip.value;
      if (tooltipStore.visible) {
        Object.assign(tooltipStore, {
          item: null,
          visible: false
        });
        if ($tooltip) {
          $tooltip.close();
        }
      }
      return nextTick();
    };
    const triggerTitleTipEvent = (evnt, params) => {
      const { item } = params;
      const { tooltipStore } = internalData;
      const $tooltip = refTooltip.value;
      const overflowElem = evnt.currentTarget.children[0];
      const content = (overflowElem.textContent || "").trim();
      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      clearTimeout(internalData.tooltipTimeout);
      if (tooltipStore.item !== item) {
        closeTooltip();
      }
      if (content && isCellOverflow) {
        Object.assign(tooltipStore, {
          item,
          visible: true
        });
        if ($tooltip) {
          $tooltip.open(overflowElem, content);
        }
      }
    };
    const handleTitleTipLeaveEvent = () => {
      const tooltipOpts = computeTooltipOpts.value;
      let $tooltip = refTooltip.value;
      if ($tooltip) {
        $tooltip.setActived(false);
      }
      if (tooltipOpts.enterable) {
        internalData.tooltipTimeout = setTimeout(() => {
          $tooltip = refTooltip.value;
          if ($tooltip && !$tooltip.isActived()) {
            closeTooltip();
          }
        }, tooltipOpts.leaveDelay);
      } else {
        closeTooltip();
      }
    };
    const triggerItemEvent = (evnt, field, itemValue) => {
      if (field) {
        return validItemRules(evnt ? ["blur"].includes(evnt.type) ? "blur" : "change" : "all", field, itemValue).then(() => {
          clearValidate(field);
        }).catch((errorMaps) => {
          const rest = errorMaps[field];
          const item = getItemByField(field);
          if (rest && item) {
            item.showError = true;
            item.errRule = rest[0].rule;
          }
        });
      }
      return nextTick();
    };
    const updateStatus = (scope, itemValue) => {
      const { field } = scope;
      return triggerItemEvent(new Event("change"), field, itemValue);
    };
    formMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $form: $xeform, $grid: $xegrid, $event: evnt }, params));
      },
      reset,
      validate,
      validateField,
      clearValidate,
      updateStatus,
      toggleCollapse,
      getItems,
      getItemByField,
      closeTooltip
    };
    const formPrivateMethods = {
      callSlot,
      triggerItemEvent,
      toggleCollapseEvent,
      triggerTitleTipEvent,
      handleTitleTipLeaveEvent
    };
    Object.assign($xeform, formMethods, formPrivateMethods);
    const staticItemFlag = ref(0);
    watch(() => reactData.staticItems.length, () => {
      staticItemFlag.value++;
    });
    watch(() => reactData.staticItems, () => {
      staticItemFlag.value++;
    });
    watch(staticItemFlag, () => {
      reactData.formItems = reactData.staticItems;
    });
    const itemFlag = ref(0);
    watch(() => props.items ? props.items.length : -1, () => {
      itemFlag.value++;
    });
    watch(() => props.items, () => {
      itemFlag.value++;
    });
    watch(itemFlag, () => {
      loadItem(props.items || []);
    });
    watch(() => props.collapseStatus, (value) => {
      reactData.collapseAll = !!value;
    });
    const renderVN = () => {
      const { loading, className, data, customLayout } = props;
      const { formItems } = reactData;
      const vSize = computeSize.value;
      const tooltipOpts = computeTooltipOpts.value;
      const defaultSlot = slots.default;
      return h("form", {
        ref: refElem,
        class: ["vxe-form", className ? import_xe_utils47.default.isFunction(className) ? className({ items: formItems, data, $form: $xeform }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading
        }],
        onSubmit: submitEvent,
        onReset: resetEvent
      }, [
        h("div", {
          class: "vxe-form--wrapper vxe-form--item-row"
        }, customLayout ? defaultSlot ? defaultSlot({}) : [] : formItems.map((item, index) => {
          return h(form_config_item_default, {
            key: index,
            itemConfig: item
          });
        })),
        h("div", {
          class: "vxe-form-slots",
          ref: "hideItem"
        }, customLayout ? [] : defaultSlot ? defaultSlot({}) : []),
        /**
         * 加载中
         */
        h(loading_default2, {
          class: "vxe-form--loading",
          modelValue: loading
        }),
        /**
         * 工具提示
         */
        hasUseTooltip ? h(tooltip_default2, Object.assign({ ref: refTooltip }, tooltipOpts)) : createCommentVNode()
      ]);
    };
    $xeform.renderVN = renderVN;
    if (props.items) {
      loadItem(props.items);
    }
    provide("$xeform", $xeform);
    provide("$xeformgather", null);
    provide("$xeformitem", null);
    provide("$xeformiteminfo", null);
    return $xeform;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/index.js
var VxeForm = Object.assign(form_default, {
  install(app) {
    app.component(form_default.name, form_default);
  }
});
var Form = VxeForm;
dynamicApp.component(form_default.name, form_default);
var form_default2 = VxeForm;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/grid/src/grid.js
var tableComponentPropKeys = Object.keys(props_default);
var tableComponentMethodKeys = ["clearAll", "syncData", "updateData", "loadData", "reloadData", "reloadRow", "loadColumn", "reloadColumn", "getRowNode", "getColumnNode", "getRowIndex", "getVTRowIndex", "getVMRowIndex", "getColumnIndex", "getVTColumnIndex", "getVMColumnIndex", "createData", "createRow", "revertData", "clearData", "isInsertByRow", "isUpdateByRow", "getColumns", "getColumnById", "getColumnByField", "getTableColumn", "getData", "getCheckboxRecords", "getParentRow", "getRowSeq", "getRowById", "getRowid", "getTableData", "setColumnFixed", "clearColumnFixed", "setColumnWidth", "getColumnWidth", "hideColumn", "showColumn", "resetColumn", "refreshColumn", "refreshScroll", "recalculate", "closeTooltip", "isAllCheckboxChecked", "isAllCheckboxIndeterminate", "getCheckboxIndeterminateRecords", "setCheckboxRow", "isCheckedByCheckboxRow", "isIndeterminateByCheckboxRow", "toggleCheckboxRow", "setAllCheckboxRow", "getRadioReserveRecord", "clearRadioReserve", "getCheckboxReserveRecords", "clearCheckboxReserve", "toggleAllCheckboxRow", "clearCheckboxRow", "setCurrentRow", "isCheckedByRadioRow", "setRadioRow", "clearCurrentRow", "clearRadioRow", "getCurrentRecord", "getRadioRecord", "getCurrentColumn", "setCurrentColumn", "clearCurrentColumn", "setPendingRow", "togglePendingRow", "getPendingRecords", "clearPendingRow", "sort", "clearSort", "isSort", "getSortColumns", "closeFilter", "isFilter", "isActiveFilterByColumn", "isRowExpandLoaded", "clearRowExpandLoaded", "reloadRowExpand", "reloadRowExpand", "toggleRowExpand", "setAllRowExpand", "setRowExpand", "isExpandByRow", "isRowExpandByRow", "clearRowExpand", "clearRowExpandReserve", "getRowExpandRecords", "getTreeExpandRecords", "isTreeExpandLoaded", "clearTreeExpandLoaded", "reloadTreeExpand", "reloadTreeChilds", "toggleTreeExpand", "setAllTreeExpand", "setTreeExpand", "isTreeExpandByRow", "clearTreeExpand", "clearTreeExpandReserve", "getScroll", "scrollTo", "scrollToRow", "scrollToColumn", "clearScroll", "updateFooter", "updateStatus", "setMergeCells", "removeInsertRow", "removeMergeCells", "getMergeCells", "clearMergeCells", "setMergeFooterItems", "removeMergeFooterItems", "getMergeFooterItems", "clearMergeFooterItems", "openTooltip", "focus", "blur", "connect"];
var gridComponentEmits = [
  ...emits_default,
  "page-change",
  "form-submit",
  "form-submit-invalid",
  "form-reset",
  "form-collapse",
  "form-toggle-collapse",
  "proxy-query",
  "proxy-delete",
  "proxy-save",
  "toolbar-button-click",
  "toolbar-tool-click",
  "zoom"
];
var grid_default = defineComponent({
  name: "VxeGrid",
  props: Object.assign(Object.assign({}, props_default), { layouts: Array, columns: Array, pagerConfig: Object, proxyConfig: Object, toolbarConfig: Object, formConfig: Object, zoomConfig: Object, size: { type: String, default: () => conf_default.grid.size || conf_default.size } }),
  emits: gridComponentEmits,
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils48.default.uniqueId();
    const instance = getCurrentInstance();
    const computeSize = useSize(props);
    const reactData = reactive({
      tableLoading: false,
      proxyInited: false,
      isZMax: false,
      tableData: [],
      filterData: [],
      formData: {},
      sortData: [],
      tZindex: 0,
      tablePage: {
        total: 0,
        pageSize: conf_default.pager.pageSize || 10,
        currentPage: 1
      }
    });
    const refElem = ref();
    const refTable = ref();
    const refForm = ref();
    const refToolbar = ref();
    const refPager = ref();
    const refFormWrapper = ref();
    const refToolbarWrapper = ref();
    const refTopWrapper = ref();
    const refBottomWrapper = ref();
    const refPagerWrapper = ref();
    const extendTableMethods = (methodKeys) => {
      const funcs = {};
      methodKeys.forEach((name) => {
        funcs[name] = (...args) => {
          const $xetable = refTable.value;
          if ($xetable && $xetable[name]) {
            return $xetable[name](...args);
          }
        };
      });
      return funcs;
    };
    const gridExtendTableMethods = extendTableMethods(tableComponentMethodKeys);
    tableComponentMethodKeys.forEach((name) => {
      gridExtendTableMethods[name] = (...args) => {
        const $xetable = refTable.value;
        if ($xetable && $xetable[name]) {
          return $xetable && $xetable[name](...args);
        }
      };
    });
    const computeProxyOpts = computed(() => {
      return Object.assign({}, conf_default.grid.proxyConfig, props.proxyConfig);
    });
    const computeIsMsg = computed(() => {
      const proxyOpts = computeProxyOpts.value;
      return proxyOpts.message !== false;
    });
    const computePagerOpts = computed(() => {
      return Object.assign({}, conf_default.grid.pagerConfig, props.pagerConfig);
    });
    const computeFormOpts = computed(() => {
      return Object.assign({}, conf_default.grid.formConfig, props.formConfig);
    });
    const computeToolbarOpts = computed(() => {
      return Object.assign({}, conf_default.grid.toolbarConfig, props.toolbarConfig);
    });
    const computeZoomOpts = computed(() => {
      return Object.assign({}, conf_default.grid.zoomConfig, props.zoomConfig);
    });
    const computeStyles = computed(() => {
      return reactData.isZMax ? { zIndex: reactData.tZindex } : null;
    });
    const computeTableExtendProps = computed(() => {
      const rest = {};
      const gridProps = props;
      tableComponentPropKeys.forEach((key) => {
        rest[key] = gridProps[key];
      });
      return rest;
    });
    const refMaps = {
      refElem,
      refTable,
      refForm,
      refToolbar,
      refPager
    };
    const computeMaps = {
      computeProxyOpts,
      computePagerOpts,
      computeFormOpts,
      computeToolbarOpts,
      computeZoomOpts
    };
    const $xegrid = {
      xID,
      props,
      context,
      instance,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    let gridMethods = {};
    const computeTableProps = computed(() => {
      const { seqConfig, pagerConfig, loading, editConfig, proxyConfig } = props;
      const { isZMax, tableLoading, tablePage, tableData } = reactData;
      const tableExtendProps = computeTableExtendProps.value;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      const tableProps = Object.assign({}, tableExtendProps);
      if (isZMax) {
        if (tableExtendProps.maxHeight) {
          tableProps.maxHeight = "100%";
        } else {
          tableProps.height = "100%";
        }
      }
      if (proxyConfig && isEnableConf(proxyOpts)) {
        tableProps.loading = loading || tableLoading;
        tableProps.data = tableData;
        if (pagerConfig && proxyOpts.seq && isEnableConf(pagerOpts)) {
          tableProps.seqConfig = Object.assign({}, seqConfig, { startIndex: (tablePage.currentPage - 1) * tablePage.pageSize });
        }
      }
      if (editConfig) {
        tableProps.editConfig = Object.assign({}, editConfig);
      }
      return tableProps;
    });
    const initToolbar = () => {
      const toolbarOpts = computeToolbarOpts.value;
      if (props.toolbarConfig && isEnableConf(toolbarOpts)) {
        nextTick(() => {
          const $xetable = refTable.value;
          const $xetoolbar = refToolbar.value;
          if ($xetable && $xetoolbar) {
            $xetable.connect($xetoolbar);
          }
        });
      }
    };
    const initPages = () => {
      const { tablePage } = reactData;
      const { pagerConfig } = props;
      const pagerOpts = computePagerOpts.value;
      const { currentPage, pageSize } = pagerOpts;
      if (pagerConfig && isEnableConf(pagerOpts)) {
        if (currentPage) {
          tablePage.currentPage = currentPage;
        }
        if (pageSize) {
          tablePage.pageSize = pageSize;
        }
      }
    };
    const triggerPendingEvent = (code) => {
      const isMsg = computeIsMsg.value;
      const $xetable = refTable.value;
      const selectRecords = $xetable.getCheckboxRecords();
      if (selectRecords.length) {
        $xetable.togglePendingRow(selectRecords);
        gridExtendTableMethods.clearCheckboxRow();
      } else {
        if (isMsg) {
          if (true) {
            if (!VXETable.modal) {
              errLog("vxe.error.reqModule", ["Modal"]);
            }
          }
          VXETable.modal.message({ id: code, content: conf_default.i18n("vxe.grid.selectOneRecord"), status: "warning" });
        }
      }
    };
    const getRespMsg = (rest, defaultMsg) => {
      const proxyOpts = computeProxyOpts.value;
      const resConfigs = proxyOpts.response || proxyOpts.props || {};
      const messageProp = resConfigs.message;
      let msg;
      if (rest && messageProp) {
        msg = import_xe_utils48.default.isFunction(messageProp) ? messageProp({ data: rest, $grid: $xegrid }) : import_xe_utils48.default.get(rest, messageProp);
      }
      return msg || conf_default.i18n(defaultMsg);
    };
    const handleDeleteRow = (code, alertKey, callback) => {
      const isMsg = computeIsMsg.value;
      const selectRecords = gridExtendTableMethods.getCheckboxRecords();
      if (isMsg) {
        if (selectRecords.length) {
          return VXETable.modal.confirm({ id: `cfm_${code}`, content: conf_default.i18n(alertKey), escClosable: true }).then((type) => {
            if (type === "confirm") {
              return callback();
            }
          });
        } else {
          if (true) {
            if (!VXETable.modal) {
              errLog("vxe.error.reqModule", ["Modal"]);
            }
          }
          VXETable.modal.message({ id: `msg_${code}`, content: conf_default.i18n("vxe.grid.selectOneRecord"), status: "warning" });
        }
      } else {
        if (selectRecords.length) {
          callback();
        }
      }
      return Promise.resolve();
    };
    const pageChangeEvent = (params) => {
      const { proxyConfig } = props;
      const { tablePage } = reactData;
      const { currentPage, pageSize } = params;
      const proxyOpts = computeProxyOpts.value;
      tablePage.currentPage = currentPage;
      tablePage.pageSize = pageSize;
      gridMethods.dispatchEvent("page-change", params);
      if (proxyConfig && isEnableConf(proxyOpts)) {
        gridMethods.commitProxy("query").then((rest) => {
          gridMethods.dispatchEvent("proxy-query", rest, params.$event);
        });
      }
    };
    const sortChangeEvent = (params) => {
      const $xetable = refTable.value;
      const { proxyConfig } = props;
      const { computeSortOpts } = $xetable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const sortOpts = computeSortOpts.value;
      if (sortOpts.remote) {
        reactData.sortData = params.sortList;
        if (proxyConfig && isEnableConf(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy("query").then((rest) => {
            gridMethods.dispatchEvent("proxy-query", rest, params.$event);
          });
        }
      }
      gridMethods.dispatchEvent("sort-change", params);
    };
    const filterChangeEvent = (params) => {
      const $xetable = refTable.value;
      const { proxyConfig } = props;
      const { computeFilterOpts } = $xetable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const filterOpts = computeFilterOpts.value;
      if (filterOpts.remote) {
        reactData.filterData = params.filterList;
        if (proxyConfig && isEnableConf(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy("query").then((rest) => {
            gridMethods.dispatchEvent("proxy-query", rest, params.$event);
          });
        }
      }
      gridMethods.dispatchEvent("filter-change", params);
    };
    const submitFormEvent = (params) => {
      const { proxyConfig } = props;
      const proxyOpts = computeProxyOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        gridMethods.commitProxy("reload").then((rest) => {
          gridMethods.dispatchEvent("proxy-query", Object.assign(Object.assign({}, rest), { isReload: true }), params.$event);
        });
      }
      gridMethods.dispatchEvent("form-submit", params);
    };
    const resetFormEvent = (params) => {
      const { proxyConfig } = props;
      const proxyOpts = computeProxyOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        gridMethods.commitProxy("reload").then((rest) => {
          gridMethods.dispatchEvent("proxy-query", Object.assign(Object.assign({}, rest), { isReload: true }), params.$event);
        });
      }
      gridMethods.dispatchEvent("form-reset", params);
    };
    const submitInvalidEvent = (params) => {
      gridMethods.dispatchEvent("form-submit-invalid", params);
    };
    const collapseEvent = (params) => {
      nextTick(() => gridExtendTableMethods.recalculate(true));
      gridMethods.dispatchEvent("form-toggle-collapse", params);
      gridMethods.dispatchEvent("form-collapse", params);
    };
    const handleZoom = (isMax) => {
      const { isZMax } = reactData;
      if (isMax ? !isZMax : isZMax) {
        reactData.isZMax = !isZMax;
        if (reactData.tZindex < getLastZIndex()) {
          reactData.tZindex = nextZIndex();
        }
      }
      return nextTick().then(() => gridExtendTableMethods.recalculate(true)).then(() => reactData.isZMax);
    };
    const getFuncSlot = (optSlots, slotKey) => {
      const funcSlot = optSlots[slotKey];
      if (funcSlot) {
        if (import_xe_utils48.default.isString(funcSlot)) {
          if (slots[funcSlot]) {
            return slots[funcSlot];
          } else {
            if (true) {
              errLog("vxe.error.notSlot", [funcSlot]);
            }
          }
        } else {
          return funcSlot;
        }
      }
      return null;
    };
    const renderForms = () => {
      const { formConfig, proxyConfig } = props;
      const { formData } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      const restVNs = [];
      if (formConfig && isEnableConf(formOpts) || slots.form) {
        let slotVNs = [];
        if (slots.form) {
          slotVNs = slots.form({ $grid: $xegrid });
        } else {
          if (formOpts.items) {
            const formSlots = {};
            if (!formOpts.inited) {
              formOpts.inited = true;
              const beforeItem = proxyOpts.beforeItem;
              if (proxyOpts && beforeItem) {
                formOpts.items.forEach((item) => {
                  beforeItem({ $grid: $xegrid, item });
                });
              }
            }
            formOpts.items.forEach((item) => {
              import_xe_utils48.default.each(item.slots, (func) => {
                if (!import_xe_utils48.default.isFunction(func)) {
                  if (slots[func]) {
                    formSlots[func] = slots[func];
                  }
                }
              });
            });
            slotVNs.push(h(form_default2, Object.assign(Object.assign({ ref: refForm }, Object.assign({}, formOpts, {
              data: proxyConfig && isEnableConf(proxyOpts) && proxyOpts.form ? formData : formOpts.data
            })), { onSubmit: submitFormEvent, onReset: resetFormEvent, onSubmitInvalid: submitInvalidEvent, onCollapse: collapseEvent }), formSlots));
          }
        }
        restVNs.push(h("div", {
          ref: refFormWrapper,
          key: "form",
          class: "vxe-grid--form-wrapper"
        }, slotVNs));
      }
      return restVNs;
    };
    const renderToolbars = () => {
      const { toolbarConfig } = props;
      const toolbarOpts = computeToolbarOpts.value;
      const restVNs = [];
      if (toolbarConfig && isEnableConf(toolbarOpts) || slots.toolbar) {
        let slotVNs = [];
        if (slots.toolbar) {
          slotVNs = slots.toolbar({ $grid: $xegrid });
        } else {
          const toolbarOptSlots = toolbarOpts.slots;
          let buttonsSlot;
          let toolsSlot;
          const toolbarSlots = {};
          if (toolbarOptSlots) {
            buttonsSlot = getFuncSlot(toolbarOptSlots, "buttons");
            toolsSlot = getFuncSlot(toolbarOptSlots, "tools");
            if (buttonsSlot) {
              toolbarSlots.buttons = buttonsSlot;
            }
            if (toolsSlot) {
              toolbarSlots.tools = toolsSlot;
            }
          }
          slotVNs.push(h(toolbar_default2, Object.assign({ ref: refToolbar }, toolbarOpts), toolbarSlots));
        }
        restVNs.push(h("div", {
          ref: refToolbarWrapper,
          key: "toolbar",
          class: "vxe-grid--toolbar-wrapper"
        }, slotVNs));
      }
      return restVNs;
    };
    const renderTops = () => {
      if (slots.top) {
        return [
          h("div", {
            ref: refTopWrapper,
            key: "top",
            class: "vxe-grid--top-wrapper"
          }, slots.top({ $grid: $xegrid }))
        ];
      }
      return [];
    };
    const defaultLayouts = ["Form", "Toolbar", "Top", "Table", "Bottom", "Pager"];
    const renderLayout = () => {
      const { layouts } = props;
      const vns = [];
      const currLayouts = layouts && layouts.length ? layouts : conf_default.grid.layouts || defaultLayouts;
      currLayouts.forEach((name) => {
        switch (name) {
          case "Form":
            vns.push(renderForms());
            break;
          case "Toolbar":
            vns.push(renderToolbars());
            break;
          case "Top":
            vns.push(renderTops());
            break;
          case "Table":
            vns.push(renderTables());
            break;
          case "Bottom":
            vns.push(renderBottoms());
            break;
          case "Pager":
            vns.push(renderPagers());
            break;
          default:
            if (true) {
              errLog("vxe.error.notProp", [`layouts -> ${name}`]);
            }
            break;
        }
      });
      return vns;
    };
    const tableCompEvents = {};
    emits_default.forEach((name) => {
      const type = import_xe_utils48.default.camelCase(`on-${name}`);
      tableCompEvents[type] = (...args) => emit(name, ...args);
    });
    const renderTables = () => {
      const { proxyConfig } = props;
      const tableProps = computeTableProps.value;
      const proxyOpts = computeProxyOpts.value;
      const tableOns = Object.assign({}, tableCompEvents);
      const emptySlot = slots.empty;
      const loadingSlot = slots.loading;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if (proxyOpts.sort) {
          tableOns.onSortChange = sortChangeEvent;
        }
        if (proxyOpts.filter) {
          tableOns.onFilterChange = filterChangeEvent;
        }
      }
      const slotObj = {};
      if (emptySlot) {
        slotObj.empty = () => emptySlot({});
      }
      if (loadingSlot) {
        slotObj.loading = () => loadingSlot({});
      }
      return [
        h(table_default2, Object.assign(Object.assign({ ref: refTable, key: "table" }, tableProps), tableOns), slotObj)
      ];
    };
    const renderBottoms = () => {
      if (slots.bottom) {
        return [
          h("div", {
            ref: refBottomWrapper,
            key: "bottom",
            class: "vxe-grid--bottom-wrapper"
          }, slots.bottom({ $grid: $xegrid }))
        ];
      }
      return [];
    };
    const renderPagers = () => {
      const { proxyConfig, pagerConfig } = props;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      const restVNs = [];
      if (pagerConfig && isEnableConf(pagerOpts) || slots.pager) {
        let slotVNs = [];
        if (slots.pager) {
          slotVNs = slots.pager({ $grid: $xegrid });
        } else {
          const pagerOptSlots = pagerOpts.slots;
          const pagerSlots = {};
          let leftSlot;
          let rightSlot;
          if (pagerOptSlots) {
            leftSlot = getFuncSlot(pagerOptSlots, "left");
            rightSlot = getFuncSlot(pagerOptSlots, "right");
            if (leftSlot) {
              pagerSlots.left = leftSlot;
            }
            if (rightSlot) {
              pagerSlots.right = rightSlot;
            }
          }
          slotVNs.push(h(pager_default2, Object.assign(Object.assign(Object.assign({ ref: refPager }, pagerOpts), proxyConfig && isEnableConf(proxyOpts) ? reactData.tablePage : {}), { onPageChange: pageChangeEvent }), pagerSlots));
        }
        restVNs.push(h("div", {
          ref: refPagerWrapper,
          key: "pager",
          class: "vxe-grid--pager-wrapper"
        }, slotVNs));
      }
      return restVNs;
    };
    const initProxy = () => {
      const { proxyConfig, formConfig } = props;
      const { proxyInited } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if (formConfig && isEnableConf(formOpts) && proxyOpts.form && formOpts.items) {
          const formData = {};
          formOpts.items.forEach((item) => {
            const { field, itemRender } = item;
            if (field) {
              let itemValue = null;
              if (itemRender) {
                const { defaultValue } = itemRender;
                if (import_xe_utils48.default.isFunction(defaultValue)) {
                  itemValue = defaultValue({ item });
                } else if (!import_xe_utils48.default.isUndefined(defaultValue)) {
                  itemValue = defaultValue;
                }
              }
              formData[field] = itemValue;
            }
          });
          reactData.formData = formData;
        }
        if (!proxyInited) {
          reactData.proxyInited = true;
          if (proxyOpts.autoLoad !== false) {
            nextTick().then(() => gridMethods.commitProxy("_init")).then((rest) => {
              gridMethods.dispatchEvent("proxy-query", Object.assign(Object.assign({}, rest), { isInited: true }), new Event("init"));
            });
          }
        }
      }
    };
    gridMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $grid: $xegrid, $event: evnt }, params));
      },
      /**
       * 提交指令，支持 code 或 button
       * @param {String/Object} code 字符串或对象
       */
      commitProxy(proxyTarget, ...args) {
        const { toolbarConfig, pagerConfig, editRules, validConfig } = props;
        const { tablePage, formData } = reactData;
        const isMsg = computeIsMsg.value;
        const proxyOpts = computeProxyOpts.value;
        const pagerOpts = computePagerOpts.value;
        const toolbarOpts = computeToolbarOpts.value;
        const { beforeQuery, afterQuery, beforeDelete, afterDelete, beforeSave, afterSave, ajax = {} } = proxyOpts;
        const resConfigs = proxyOpts.response || proxyOpts.props || {};
        const $xetable = refTable.value;
        let button = null;
        let code = null;
        if (import_xe_utils48.default.isString(proxyTarget)) {
          const { buttons } = toolbarOpts;
          const matchObj = toolbarConfig && isEnableConf(toolbarOpts) && buttons ? import_xe_utils48.default.findTree(buttons, (item) => item.code === proxyTarget, { children: "dropdowns" }) : null;
          button = matchObj ? matchObj.item : null;
          code = proxyTarget;
        } else {
          button = proxyTarget;
          code = button.code;
        }
        const btnParams = button ? button.params : null;
        switch (code) {
          case "insert":
            return $xetable.insert({});
          case "insert_edit":
            return $xetable.insert({}).then(({ row }) => $xetable.setEditRow(row));
          // 已废弃
          case "insert_actived":
            return $xetable.insert({}).then(({ row }) => $xetable.setEditRow(row));
          // 已废弃
          case "mark_cancel":
            triggerPendingEvent(code);
            break;
          case "remove":
            return handleDeleteRow(code, "vxe.grid.removeSelectRecord", () => $xetable.removeCheckboxRow());
          case "import":
            $xetable.importData(btnParams);
            break;
          case "open_import":
            $xetable.openImport(btnParams);
            break;
          case "export":
            $xetable.exportData(btnParams);
            break;
          case "open_export":
            $xetable.openExport(btnParams);
            break;
          case "reset_custom":
            return $xetable.resetColumn(true);
          case "_init":
          case "reload":
          case "query": {
            const ajaxMethods = ajax.query;
            if (ajaxMethods) {
              const isInited = code === "_init";
              const isReload = code === "reload";
              let sortList = [];
              let filterList = [];
              let pageParams = {};
              if (pagerConfig) {
                if (isInited || isReload) {
                  tablePage.currentPage = 1;
                }
                if (isEnableConf(pagerOpts)) {
                  pageParams = Object.assign({}, tablePage);
                }
              }
              if (isInited) {
                const { computeSortOpts } = $xetable.getComputeMaps();
                const sortOpts = computeSortOpts.value;
                let defaultSort = sortOpts.defaultSort;
                if (defaultSort) {
                  if (!import_xe_utils48.default.isArray(defaultSort)) {
                    defaultSort = [defaultSort];
                  }
                  sortList = defaultSort.map((item) => {
                    return {
                      field: item.field,
                      property: item.field,
                      order: item.order
                    };
                  });
                }
                filterList = $xetable.getCheckedFilters();
              } else {
                if (isReload) {
                  $xetable.clearAll();
                } else {
                  sortList = $xetable.getSortColumns();
                  filterList = $xetable.getCheckedFilters();
                }
              }
              const commitParams = {
                code,
                button,
                isInited,
                isReload,
                $grid: $xegrid,
                page: pageParams,
                sort: sortList.length ? sortList[0] : {},
                sorts: sortList,
                filters: filterList,
                form: formData,
                options: ajaxMethods
              };
              reactData.sortData = sortList;
              reactData.filterData = filterList;
              reactData.tableLoading = true;
              const applyArgs = [commitParams].concat(args);
              return Promise.resolve((beforeQuery || ajaxMethods)(...applyArgs)).then((rest) => {
                reactData.tableLoading = false;
                if (rest) {
                  if (pagerConfig && isEnableConf(pagerOpts)) {
                    const totalProp = resConfigs.total;
                    const total = (import_xe_utils48.default.isFunction(totalProp) ? totalProp({ data: rest, $grid: $xegrid }) : import_xe_utils48.default.get(rest, totalProp || "page.total")) || 0;
                    tablePage.total = import_xe_utils48.default.toNumber(total);
                    const resultProp = resConfigs.result;
                    reactData.tableData = (import_xe_utils48.default.isFunction(resultProp) ? resultProp({ data: rest, $grid: $xegrid }) : import_xe_utils48.default.get(rest, resultProp || "result")) || [];
                    const pageCount = Math.max(Math.ceil(total / tablePage.pageSize), 1);
                    if (tablePage.currentPage > pageCount) {
                      tablePage.currentPage = pageCount;
                    }
                  } else {
                    const listProp = resConfigs.list;
                    reactData.tableData = (listProp ? import_xe_utils48.default.isFunction(listProp) ? listProp({ data: rest, $grid: $xegrid }) : import_xe_utils48.default.get(rest, listProp) : rest) || [];
                  }
                } else {
                  reactData.tableData = [];
                }
                if (afterQuery) {
                  afterQuery(...applyArgs);
                }
                return { status: true };
              }).catch(() => {
                reactData.tableLoading = false;
                return { status: false };
              });
            } else {
              if (true) {
                errLog("vxe.error.notFunc", ["proxy-config.ajax.query"]);
              }
            }
            break;
          }
          case "delete": {
            const ajaxMethods = ajax.delete;
            if (ajaxMethods) {
              const selectRecords = gridExtendTableMethods.getCheckboxRecords();
              const removeRecords = selectRecords.filter((row) => !$xetable.isInsertByRow(row));
              const body = { removeRecords };
              const commitParams = { $grid: $xegrid, code, button, body, form: formData, options: ajaxMethods };
              const applyArgs = [commitParams].concat(args);
              if (selectRecords.length) {
                return handleDeleteRow(code, "vxe.grid.deleteSelectRecord", () => {
                  if (!removeRecords.length) {
                    return $xetable.remove(selectRecords);
                  }
                  reactData.tableLoading = true;
                  return Promise.resolve((beforeDelete || ajaxMethods)(...applyArgs)).then((rest) => {
                    reactData.tableLoading = false;
                    $xetable.setPendingRow(removeRecords, false);
                    if (isMsg) {
                      if (true) {
                        if (!VXETable.modal) {
                          errLog("vxe.error.reqModule", ["Modal"]);
                        }
                      }
                      VXETable.modal.message({ content: getRespMsg(rest, "vxe.grid.delSuccess"), status: "success" });
                    }
                    if (afterDelete) {
                      afterDelete(...applyArgs);
                    } else {
                      gridMethods.commitProxy("query");
                    }
                    return { status: true };
                  }).catch((rest) => {
                    reactData.tableLoading = false;
                    if (isMsg) {
                      if (true) {
                        if (!VXETable.modal.message) {
                          errLog("vxe.error.reqModule", ["Modal"]);
                        }
                      }
                      VXETable.modal.message({ id: code, content: getRespMsg(rest, "vxe.grid.operError"), status: "error" });
                    }
                    return { status: false };
                  });
                });
              } else {
                if (isMsg) {
                  if (true) {
                    if (!VXETable.modal) {
                      errLog("vxe.error.reqModule", ["Modal"]);
                    }
                  }
                  VXETable.modal.message({ id: code, content: conf_default.i18n("vxe.grid.selectOneRecord"), status: "warning" });
                }
              }
            } else {
              if (true) {
                errLog("vxe.error.notFunc", ["proxy-config.ajax.delete"]);
              }
            }
            break;
          }
          case "save": {
            const ajaxMethods = ajax.save;
            if (ajaxMethods) {
              const body = $xetable.getRecordset();
              const { insertRecords, removeRecords, updateRecords, pendingRecords } = body;
              const commitParams = { $grid: $xegrid, code, button, body, form: formData, options: ajaxMethods };
              const applyArgs = [commitParams].concat(args);
              if (insertRecords.length) {
                body.pendingRecords = pendingRecords.filter((row) => $xetable.findRowIndexOf(insertRecords, row) === -1);
              }
              if (pendingRecords.length) {
                body.insertRecords = insertRecords.filter((row) => $xetable.findRowIndexOf(pendingRecords, row) === -1);
              }
              let restPromise = Promise.resolve();
              if (editRules) {
                restPromise = $xetable[validConfig && validConfig.msgMode === "full" ? "fullValidate" : "validate"](body.insertRecords.concat(updateRecords));
              }
              return restPromise.then((errMap) => {
                if (errMap) {
                  return;
                }
                if (body.insertRecords.length || removeRecords.length || updateRecords.length || body.pendingRecords.length) {
                  reactData.tableLoading = true;
                  return Promise.resolve((beforeSave || ajaxMethods)(...applyArgs)).then((rest) => {
                    reactData.tableLoading = false;
                    $xetable.clearPendingRow();
                    if (isMsg) {
                      if (true) {
                        if (!VXETable.modal) {
                          errLog("vxe.error.reqModule", ["Modal"]);
                        }
                      }
                      VXETable.modal.message({ content: getRespMsg(rest, "vxe.grid.saveSuccess"), status: "success" });
                    }
                    if (afterSave) {
                      afterSave(...applyArgs);
                    } else {
                      gridMethods.commitProxy("query");
                    }
                    return { status: true };
                  }).catch((rest) => {
                    reactData.tableLoading = false;
                    if (isMsg) {
                      if (true) {
                        if (!VXETable.modal) {
                          errLog("vxe.error.reqModule", ["Modal"]);
                        }
                      }
                      VXETable.modal.message({ id: code, content: getRespMsg(rest, "vxe.grid.operError"), status: "error" });
                    }
                    return { status: false };
                  });
                } else {
                  if (isMsg) {
                    if (true) {
                      if (!VXETable.modal) {
                        errLog("vxe.error.reqModule", ["Modal"]);
                      }
                    }
                    VXETable.modal.message({ id: code, content: conf_default.i18n("vxe.grid.dataUnchanged"), status: "info" });
                  }
                }
              });
            } else {
              if (true) {
                errLog("vxe.error.notFunc", ["proxy-config.ajax.save"]);
              }
            }
            break;
          }
          default: {
            const gCommandOpts = VXETable.commands.get(code);
            if (gCommandOpts) {
              if (gCommandOpts.commandMethod) {
                gCommandOpts.commandMethod({ code, button, $grid: $xegrid, $table: $xetable }, ...args);
              } else {
                if (true) {
                  errLog("vxe.error.notCommands", [code]);
                }
              }
            }
          }
        }
        return nextTick();
      },
      zoom() {
        if (reactData.isZMax) {
          return gridMethods.revert();
        }
        return gridMethods.maximize();
      },
      isMaximized() {
        return reactData.isZMax;
      },
      maximize() {
        return handleZoom(true);
      },
      revert() {
        return handleZoom();
      },
      getFormItems(itemIndex) {
        const formOpts = computeFormOpts.value;
        const { formConfig } = props;
        const { items } = formOpts;
        const itemList = [];
        import_xe_utils48.default.eachTree(formConfig && isEnableConf(formOpts) && items ? items : [], (item) => {
          itemList.push(item);
        }, { children: "children" });
        return import_xe_utils48.default.isUndefined(itemIndex) ? itemList : itemList[itemIndex];
      },
      getProxyInfo() {
        const $xetable = refTable.value;
        if (props.proxyConfig) {
          const { sortData } = reactData;
          return {
            data: reactData.tableData,
            filter: reactData.filterData,
            form: reactData.formData,
            sort: sortData.length ? sortData[0] : {},
            sorts: sortData,
            pager: reactData.tablePage,
            pendingRecords: $xetable ? $xetable.getPendingRecords() : []
          };
        }
        return null;
      }
      // setProxyInfo (options) {
      //   if (props.proxyConfig && options) {
      //     const { pager, form } = options
      //     const proxyOpts = computeProxyOpts.value
      //     if (pager) {
      //       if (pager.currentPage) {
      //         reactData.tablePage.currentPage = Number(pager.currentPage)
      //       }
      //       if (pager.pageSize) {
      //         reactData.tablePage.pageSize = Number(pager.pageSize)
      //       }
      //     }
      //     if (proxyOpts.form && form) {
      //       Object.assign(reactData.formData, form)
      //     }
      //   }
      //   return nextTick()
      // }
    };
    if (true) {
      gridMethods.loadColumn = (columns) => {
        const $xetable = refTable.value;
        import_xe_utils48.default.eachTree(columns, (column) => {
          if (column.slots) {
            import_xe_utils48.default.each(column.slots, (func) => {
              if (!import_xe_utils48.default.isFunction(func)) {
                if (!slots[func]) {
                  errLog("vxe.error.notSlot", [func]);
                }
              }
            });
          }
        });
        if ($xetable) {
          return $xetable.loadColumn(columns);
        }
        return nextTick();
      };
      gridMethods.reloadColumn = (columns) => {
        gridExtendTableMethods.clearAll();
        return gridMethods.loadColumn(columns);
      };
    }
    const gridPrivateMethods = {
      extendTableMethods,
      callSlot(slotFunc, params) {
        if (slotFunc) {
          if (import_xe_utils48.default.isString(slotFunc)) {
            slotFunc = slots[slotFunc] || null;
          }
          if (import_xe_utils48.default.isFunction(slotFunc)) {
            return getSlotVNs(slotFunc(params));
          }
        }
        return [];
      },
      /**
       * 获取需要排除的高度
       */
      getExcludeHeight() {
        const { height } = props;
        const { isZMax } = reactData;
        const el = refElem.value;
        const formWrapper = refFormWrapper.value;
        const toolbarWrapper = refToolbarWrapper.value;
        const topWrapper = refTopWrapper.value;
        const bottomWrapper = refBottomWrapper.value;
        const pagerWrapper = refPagerWrapper.value;
        const parentPaddingSize = isZMax || !(height === "auto" || height === "100%") ? 0 : getPaddingTopBottomSize(el.parentNode);
        return parentPaddingSize + getPaddingTopBottomSize(el) + getOffsetHeight(formWrapper) + getOffsetHeight(toolbarWrapper) + getOffsetHeight(topWrapper) + getOffsetHeight(bottomWrapper) + getOffsetHeight(pagerWrapper);
      },
      getParentHeight() {
        const el = refElem.value;
        if (el) {
          return (reactData.isZMax ? getDomNode().visibleHeight : import_xe_utils48.default.toNumber(getComputedStyle(el.parentNode).height)) - gridPrivateMethods.getExcludeHeight();
        }
        return 0;
      },
      triggerToolbarCommitEvent(params, evnt) {
        const { code } = params;
        return gridMethods.commitProxy(params, evnt).then((rest) => {
          if (code && rest && rest.status && ["query", "reload", "delete", "save"].includes(code)) {
            gridMethods.dispatchEvent(code === "delete" || code === "save" ? `proxy-${code}` : "proxy-query", Object.assign(Object.assign({}, rest), { isReload: code === "reload" }), evnt);
          }
        });
      },
      triggerToolbarBtnEvent(button, evnt) {
        gridPrivateMethods.triggerToolbarCommitEvent(button, evnt);
        gridMethods.dispatchEvent("toolbar-button-click", { code: button.code, button }, evnt);
      },
      triggerToolbarTolEvent(tool, evnt) {
        gridPrivateMethods.triggerToolbarCommitEvent(tool, evnt);
        gridMethods.dispatchEvent("toolbar-tool-click", { code: tool.code, tool, $event: evnt });
      },
      triggerZoomEvent(evnt) {
        gridMethods.zoom();
        gridMethods.dispatchEvent("zoom", { type: reactData.isZMax ? "max" : "revert" }, evnt);
      }
    };
    Object.assign($xegrid, gridExtendTableMethods, gridMethods, gridPrivateMethods);
    const columnFlag = ref(0);
    watch(() => props.columns ? props.columns.length : -1, () => {
      columnFlag.value++;
    });
    watch(() => props.columns, () => {
      columnFlag.value++;
    });
    watch(columnFlag, () => {
      nextTick(() => $xegrid.loadColumn(props.columns || []));
    });
    watch(() => props.toolbarConfig, () => {
      initToolbar();
    });
    watch(() => props.pagerConfig, () => {
      initPages();
    });
    watch(() => props.proxyConfig, () => {
      initProxy();
    });
    const handleGlobalKeydownEvent = (evnt) => {
      const zoomOpts = computeZoomOpts.value;
      const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
      if (isEsc && reactData.isZMax && zoomOpts.escRestore !== false) {
        gridPrivateMethods.triggerZoomEvent(evnt);
      }
    };
    VXETable.hooks.forEach((options) => {
      const { setupGrid } = options;
      if (setupGrid) {
        const hookRest = setupGrid($xegrid);
        if (hookRest && import_xe_utils48.default.isObject(hookRest)) {
          Object.assign($xegrid, hookRest);
        }
      }
    });
    initPages();
    onMounted(() => {
      nextTick(() => {
        const { data, columns, proxyConfig } = props;
        const proxyOpts = computeProxyOpts.value;
        const formOpts = computeFormOpts.value;
        if (isEnableConf(proxyConfig) && (data || proxyOpts.form && formOpts.data)) {
          errLog("vxe.error.errConflicts", ["grid.data", "grid.proxy-config"]);
        }
        if (columns && columns.length) {
          $xegrid.loadColumn(columns);
        }
        initToolbar();
      });
      GlobalEvent.on($xegrid, "keydown", handleGlobalKeydownEvent);
    });
    onUnmounted(() => {
      GlobalEvent.off($xegrid, "keydown");
    });
    nextTick(() => {
      initProxy();
    });
    const renderVN = () => {
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-grid", {
          [`size--${vSize}`]: vSize,
          "is--animat": !!props.animat,
          "is--round": props.round,
          "is--maximize": reactData.isZMax,
          "is--loading": props.loading || reactData.tableLoading
        }],
        style: styles
      }, renderLayout());
    };
    $xegrid.renderVN = renderVN;
    provide("$xegrid", $xegrid);
    return $xegrid;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/grid/index.js
var VxeGrid = Object.assign(grid_default, {
  install(app) {
    app.component(grid_default.name, grid_default);
  }
});
var Grid = VxeGrid;
dynamicApp.component(grid_default.name, grid_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/checkbox/index.js
var VxeCheckbox = Object.assign(checkbox_default, {
  install(app) {
    app.component(checkbox_default.name, checkbox_default);
  }
});
var Checkbox = VxeCheckbox;
dynamicApp.component(checkbox_default.name, checkbox_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/checkbox/src/group.js
var import_xe_utils49 = __toESM(require_xe_utils());
var group_default3 = defineComponent({
  name: "VxeCheckboxGroup",
  props: {
    modelValue: Array,
    options: Array,
    optionProps: Object,
    disabled: Boolean,
    max: { type: [String, Number], default: null },
    size: { type: String, default: () => conf_default.checkboxGroup.size || conf_default.size }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils49.default.uniqueId();
    const computeIsMaximize = computed(() => {
      const { modelValue, max } = props;
      if (max) {
        return (modelValue ? modelValue.length : 0) >= import_xe_utils49.default.toNumber(max);
      }
      return false;
    });
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeDisabledField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || "disabled";
    });
    const computeMaps = {
      computeIsMaximize
    };
    const $xecheckboxgroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const checkboxGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $checkboxGroup: $xecheckboxgroup, $event: evnt }, params));
      }
    };
    const checkboxGroupPrivateMethods = {
      handleChecked(params, evnt) {
        const { checked, label } = params;
        const checklist = props.modelValue || [];
        const checkIndex = checklist.indexOf(label);
        if (checked) {
          if (checkIndex === -1) {
            checklist.push(label);
          }
        } else {
          checklist.splice(checkIndex, 1);
        }
        emit("update:modelValue", checklist);
        $xecheckboxgroup.dispatchEvent("change", Object.assign({ checklist }, params), evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, checklist);
        }
      }
    };
    Object.assign($xecheckboxgroup, checkboxGroupMethods, checkboxGroupPrivateMethods);
    const renderVN = () => {
      const { options } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      return h("div", {
        class: "vxe-checkbox-group"
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item) => {
        return h(checkbox_default, {
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    $xecheckboxgroup.renderVN = renderVN;
    provide("$xecheckboxgroup", $xecheckboxgroup);
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/checkbox-group/index.js
var VxeCheckboxGroup = Object.assign(group_default3, {
  install(app) {
    app.component(group_default3.name, group_default3);
  }
});
var CheckboxGroup = VxeCheckboxGroup;
dynamicApp.component(group_default3.name, group_default3);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/radio/index.js
var VxeRadio = Object.assign(radio_default, {
  install: function(app) {
    app.component(radio_default.name, radio_default);
  }
});
var Radio = VxeRadio;
dynamicApp.component(radio_default.name, radio_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/radio-group/index.js
var VxeRadioGroup = Object.assign(group_default, {
  install: function(app) {
    app.component(group_default.name, group_default);
  }
});
var RadioGroup = VxeRadioGroup;
dynamicApp.component(group_default.name, group_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/radio-button/index.js
var VxeRadioButton = Object.assign(button_default2, {
  install: function(app) {
    app.component(button_default2.name, button_default2);
  }
});
var RadioButton = VxeRadioButton;
dynamicApp.component(button_default2.name, button_default2);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/input/index.js
var VxeInput = Object.assign(input_default, {
  install(app) {
    app.component(input_default.name, input_default);
  }
});
var Input = VxeInput;
dynamicApp.component(input_default.name, input_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/textarea/src/textarea.js
var import_xe_utils50 = __toESM(require_xe_utils());
var autoTxtElem;
var textarea_default = defineComponent({
  name: "VxeTextarea",
  props: {
    modelValue: [String, Number],
    className: String,
    immediate: { type: Boolean, default: true },
    name: String,
    readonly: Boolean,
    disabled: Boolean,
    placeholder: {
      type: String,
      default: () => import_xe_utils50.default.eqNull(conf_default.textarea.placeholder) ? conf_default.i18n("vxe.base.pleaseInput") : conf_default.textarea.placeholder
    },
    maxlength: [String, Number],
    rows: { type: [String, Number], default: 2 },
    cols: { type: [String, Number], default: null },
    showWordCount: Boolean,
    countMethod: Function,
    autosize: [Boolean, Object],
    form: String,
    resize: { type: String, default: () => conf_default.textarea.resize },
    size: { type: String, default: () => conf_default.textarea.size || conf_default.size }
  },
  emits: [
    "update:modelValue",
    "input",
    "keydown",
    "keyup",
    "click",
    "change",
    "focus",
    "blur"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils50.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      inputValue: props.modelValue
    });
    const refElem = ref();
    const refTextarea = ref();
    const refMaps = {
      refElem,
      refTextarea
    };
    const $xetextarea = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let textareaMethods = {};
    const computeInputCount = computed(() => {
      return import_xe_utils50.default.getSize(reactData.inputValue);
    });
    const computeIsCountError = computed(() => {
      const inputCount = computeInputCount.value;
      return props.maxlength && inputCount > import_xe_utils50.default.toNumber(props.maxlength);
    });
    const computeSizeOpts = computed(() => {
      return Object.assign({ minRows: 1, maxRows: 10 }, conf_default.textarea.autosize, props.autosize);
    });
    const updateAutoTxt = () => {
      const { size, autosize } = props;
      const { inputValue } = reactData;
      if (autosize) {
        if (!autoTxtElem) {
          autoTxtElem = document.createElement("div");
        }
        if (!autoTxtElem.parentNode) {
          document.body.appendChild(autoTxtElem);
        }
        const textElem = refTextarea.value;
        const textStyle = getComputedStyle(textElem);
        autoTxtElem.className = ["vxe-textarea--autosize", size ? `size--${size}` : ""].join(" ");
        autoTxtElem.style.width = `${textElem.clientWidth}px`;
        autoTxtElem.style.padding = textStyle.padding;
        autoTxtElem.innerText = ("" + (inputValue || "　")).replace(/\n$/, "\n　");
      }
    };
    const handleResize = () => {
      if (props.autosize) {
        nextTick(() => {
          const sizeOpts = computeSizeOpts.value;
          const { minRows, maxRows } = sizeOpts;
          const textElem = refTextarea.value;
          const sizeHeight = autoTxtElem.clientHeight;
          const textStyle = getComputedStyle(textElem);
          const lineHeight = import_xe_utils50.default.toNumber(textStyle.lineHeight);
          const paddingTop = import_xe_utils50.default.toNumber(textStyle.paddingTop);
          const paddingBottom = import_xe_utils50.default.toNumber(textStyle.paddingBottom);
          const borderTopWidth = import_xe_utils50.default.toNumber(textStyle.borderTopWidth);
          const borderBottomWidth = import_xe_utils50.default.toNumber(textStyle.borderBottomWidth);
          const intervalHeight = paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
          const rowNum = (sizeHeight - intervalHeight) / lineHeight;
          const textRows = rowNum && /[0-9]/.test("" + rowNum) ? rowNum : Math.floor(rowNum) + 1;
          let vaildRows = textRows;
          if (textRows < minRows) {
            vaildRows = minRows;
          } else if (textRows > maxRows) {
            vaildRows = maxRows;
          }
          textElem.style.height = `${vaildRows * lineHeight + intervalHeight}px`;
        });
      }
    };
    const triggerEvent3 = (evnt) => {
      const value = reactData.inputValue;
      $xetextarea.dispatchEvent(evnt.type, { value }, evnt);
    };
    const emitUpdate = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      if (import_xe_utils50.default.toValueString(props.modelValue) !== value) {
        textareaMethods.dispatchEvent("change", { value }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, value);
        }
      }
    };
    const inputEvent = (evnt) => {
      const { immediate } = props;
      const textElem = evnt.target;
      const value = textElem.value;
      reactData.inputValue = value;
      if (immediate) {
        emitUpdate(value, evnt);
      }
      $xetextarea.dispatchEvent("input", { value }, evnt);
      handleResize();
    };
    const changeEvent = (evnt) => {
      const { immediate } = props;
      if (immediate) {
        triggerEvent3(evnt);
      } else {
        emitUpdate(reactData.inputValue, evnt);
      }
    };
    const blurEvent = (evnt) => {
      const { immediate } = props;
      const { inputValue } = reactData;
      if (!immediate) {
        emitUpdate(inputValue, evnt);
      }
      $xetextarea.dispatchEvent("blur", { value: inputValue }, evnt);
    };
    textareaMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $textarea: $xetextarea, $event: evnt }, params));
      },
      focus() {
        const textElem = refTextarea.value;
        textElem.focus();
        return nextTick();
      },
      blur() {
        const textElem = refTextarea.value;
        textElem.blur();
        return nextTick();
      }
    };
    Object.assign($xetextarea, textareaMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      updateAutoTxt();
    });
    nextTick(() => {
      const { autosize } = props;
      if (autosize) {
        updateAutoTxt();
        handleResize();
      }
    });
    const renderVN = () => {
      const { className, resize, placeholder, disabled, maxlength, autosize, showWordCount, countMethod, rows, cols } = props;
      const { inputValue } = reactData;
      const vSize = computeSize.value;
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-textarea", className, {
          [`size--${vSize}`]: vSize,
          "is--autosize": autosize,
          "is--count": showWordCount,
          "is--disabled": disabled,
          "def--rows": !import_xe_utils50.default.eqNull(rows),
          "def--cols": !import_xe_utils50.default.eqNull(cols)
        }]
      }, [
        h("textarea", {
          ref: refTextarea,
          class: "vxe-textarea--inner",
          value: inputValue,
          name: props.name,
          placeholder: placeholder ? getFuncText(placeholder) : null,
          maxlength,
          readonly: props.readonly,
          disabled,
          rows,
          cols,
          style: resize ? {
            resize
          } : null,
          onInput: inputEvent,
          onChange: changeEvent,
          onKeydown: triggerEvent3,
          onKeyup: triggerEvent3,
          onClick: triggerEvent3,
          onFocus: triggerEvent3,
          onBlur: blurEvent
        }),
        showWordCount ? h("span", {
          class: ["vxe-textarea--count", {
            "is--error": isCountError
          }]
        }, countMethod ? `${countMethod({ value: inputValue })}` : `${inputCount}${maxlength ? `/${maxlength}` : ""}`) : null
      ]);
    };
    $xetextarea.renderVN = renderVN;
    return $xetextarea;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/textarea/index.js
var VxeTextarea = Object.assign(textarea_default, {
  install: function(app) {
    app.component(textarea_default.name, textarea_default);
  }
});
var Textarea = VxeTextarea;
dynamicApp.component(textarea_default.name, textarea_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/button/src/group.js
var import_xe_utils51 = __toESM(require_xe_utils());
var group_default4 = defineComponent({
  name: "VxeButtonGroup",
  props: {
    options: Array,
    mode: String,
    status: String,
    round: Boolean,
    circle: Boolean,
    className: [String, Function],
    disabled: Boolean,
    size: { type: String, default: () => conf_default.buttonGroup.size || conf_default.size }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils51.default.uniqueId();
    const computeMaps = {};
    const $xebuttongroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const buttonGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $buttonGroup: $xebuttongroup, $event: evnt }, params));
      }
    };
    const buttonGroupPrivateMethods = {
      handleClick(params, evnt) {
        const { options } = props;
        const { name } = params;
        const option = options ? options.find((item) => item.name === name) : null;
        buttonGroupMethods.dispatchEvent("click", Object.assign(Object.assign({}, params), { option }), evnt);
      }
    };
    Object.assign($xebuttongroup, buttonGroupMethods, buttonGroupPrivateMethods);
    const renderVN = () => {
      const { className, options } = props;
      const defaultSlot = slots.default;
      return h("div", {
        class: ["vxe-button-group", className ? import_xe_utils51.default.isFunction(className) ? className({ $buttonGroup: $xebuttongroup }) : className : ""]
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item, index) => {
        return h(button_default, Object.assign({ key: index }, item));
      }) : []);
    };
    $xebuttongroup.renderVN = renderVN;
    provide("$xebuttongroup", $xebuttongroup);
    return renderVN;
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/button-group/index.js
var VxeButtonGroup = Object.assign(group_default4, {
  install(app) {
    app.component(group_default4.name, group_default4);
  }
});
var ButtonGroup = VxeButtonGroup;
dynamicApp.component(group_default4.name, group_default4);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/modal/index.js
var import_xe_utils52 = __toESM(require_xe_utils());
function openModal(options) {
  checkDynamic();
  return new Promise((resolve) => {
    if (options && options.id && allActiveModals.some((comp) => comp.props.id === options.id)) {
      resolve("exist");
    } else {
      const _onHide = options.onHide;
      const modalOpts = Object.assign(options, {
        key: import_xe_utils52.default.uniqueId(),
        modelValue: true,
        onHide(params) {
          const modalList = dynamicStore.modals;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.modals = modalList.filter((item) => item.key !== modalOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.modals.push(modalOpts);
    }
  });
}
function getModal(id) {
  return import_xe_utils52.default.find(allActiveModals, ($modal) => $modal.props.id === id);
}
function closeModal(id) {
  const modals = id ? [getModal(id)] : allActiveModals;
  const restPromises = [];
  modals.forEach(($modal) => {
    if ($modal) {
      restPromises.push($modal.close());
    }
  });
  return Promise.all(restPromises);
}
function handleOpen(defOpts, content, title, options) {
  let opts;
  if (import_xe_utils52.default.isObject(content)) {
    opts = content;
  } else {
    opts = { content: import_xe_utils52.default.toValueString(content), title };
  }
  return openModal(Object.assign(Object.assign(Object.assign({}, defOpts), options), opts));
}
function openAlert(content, title, options) {
  return handleOpen({
    type: "alert",
    showFooter: true
  }, content, title, options);
}
function openConfirm(content, title, options) {
  return handleOpen({
    type: "confirm",
    status: "question",
    showFooter: true
  }, content, title, options);
}
function openMessage(content, options) {
  return handleOpen({
    type: "message",
    mask: false,
    lockView: false,
    showHeader: false
  }, content, "", options);
}
var ModalController = {
  get: getModal,
  close: closeModal,
  open: openModal,
  alert: openAlert,
  confirm: openConfirm,
  message: openMessage
};
var modal = ModalController;
var VxeModal = Object.assign(modal_default, {
  install: function(app) {
    app.component(modal_default.name, modal_default);
    VXETable.modal = ModalController;
  }
});
var Modal = VxeModal;
dynamicApp.component(modal_default.name, modal_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/drawer/index.js
var import_xe_utils54 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/drawer/src/modal.js
var import_xe_utils53 = __toESM(require_xe_utils());
var allActiveDrawers = [];
var modal_default2 = defineComponent({
  name: "VxeDrawer",
  props: {
    modelValue: Boolean,
    id: String,
    title: String,
    loading: { type: Boolean, default: null },
    className: String,
    position: [String, Object],
    lockView: { type: Boolean, default: () => conf_default.drawer.lockView },
    lockScroll: Boolean,
    mask: { type: Boolean, default: () => conf_default.drawer.mask },
    maskClosable: { type: Boolean, default: () => conf_default.drawer.maskClosable },
    escClosable: { type: Boolean, default: () => conf_default.drawer.escClosable },
    showHeader: { type: Boolean, default: () => conf_default.drawer.showHeader },
    showFooter: { type: Boolean, default: () => conf_default.drawer.showFooter },
    showClose: { type: Boolean, default: () => conf_default.drawer.showClose },
    content: [Number, String],
    showCancelButton: { type: Boolean, default: null },
    cancelButtonText: { type: String, default: () => conf_default.drawer.cancelButtonText },
    showConfirmButton: { type: Boolean, default: () => conf_default.drawer.showConfirmButton },
    confirmButtonText: { type: String, default: () => conf_default.drawer.confirmButtonText },
    destroyOnClose: { type: Boolean, default: () => conf_default.drawer.destroyOnClose },
    showTitleOverflow: { type: Boolean, default: () => conf_default.drawer.showTitleOverflow },
    width: [Number, String],
    height: [Number, String],
    zIndex: Number,
    transfer: { type: Boolean, default: () => conf_default.drawer.transfer },
    size: { type: String, default: () => conf_default.drawer.size || conf_default.size },
    beforeHideMethod: { type: Function, default: () => conf_default.drawer.beforeHideMethod },
    slots: Number
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils53.default.uniqueId();
    const computeSize = useSize(props);
    const refElem = ref();
    const refDrawerBox = ref();
    const refConfirmBtn = ref();
    const refCancelBtn = ref();
    const reactData = reactive({
      inited: false,
      visible: false,
      contentVisible: false,
      drawerZIndex: 0,
      firstOpen: true
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeDrawer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getBox = () => {
      const boxElem = refDrawerBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const { width, height } = props;
      const boxElem = getBox();
      boxElem.style.width = `${width ? isNaN(width) ? width : `${width}px` : ""}`;
      boxElem.style.height = `${height ? isNaN(height) ? height : `${height}px` : ""}`;
      return nextTick();
    };
    const updateZindex = () => {
      const { zIndex } = props;
      const { drawerZIndex } = reactData;
      if (zIndex) {
        reactData.drawerZIndex = zIndex;
      } else if (drawerZIndex < getLastZIndex()) {
        reactData.drawerZIndex = nextZIndex();
      }
    };
    const updatePosition = () => {
      return nextTick().then(() => {
      });
    };
    const closeDrawer2 = (type) => {
      const { beforeHideMethod } = props;
      const { visible } = reactData;
      const params = { type };
      if (visible) {
        Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then((rest) => {
          if (!import_xe_utils53.default.isError(rest)) {
            reactData.contentVisible = false;
            import_xe_utils53.default.remove(allActiveDrawers, (item) => item === $xeDrawer);
            drawerMethods.dispatchEvent("before-hide", params);
            setTimeout(() => {
              reactData.visible = false;
              emit("update:modelValue", false);
              drawerMethods.dispatchEvent("hide", params);
            }, 200);
          }
        }).catch((e) => e);
      }
      return nextTick();
    };
    const closeEvent = (evnt) => {
      const type = "close";
      drawerMethods.dispatchEvent(type, { type }, evnt);
      closeDrawer2(type);
    };
    const confirmEvent = (evnt) => {
      const type = "confirm";
      drawerMethods.dispatchEvent(type, { type }, evnt);
      closeDrawer2(type);
    };
    const cancelEvent = (evnt) => {
      const type = "cancel";
      drawerMethods.dispatchEvent(type, { type }, evnt);
      closeDrawer2(type);
    };
    const openDrawer2 = () => {
      const { showFooter } = props;
      const { inited, visible } = reactData;
      if (!inited) {
        reactData.inited = true;
      }
      if (!visible) {
        recalculate();
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveDrawers.push($xeDrawer);
        setTimeout(() => {
          reactData.contentVisible = true;
          nextTick(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = "";
            const params = { type };
            emit("update:modelValue", true);
            drawerMethods.dispatchEvent("show", params);
          });
        }, 10);
        nextTick(() => {
          const { firstOpen } = reactData;
          if (firstOpen) {
            updatePosition().then(() => {
              setTimeout(() => updatePosition(), 20);
            });
          }
          if (firstOpen) {
            reactData.firstOpen = false;
          }
        });
      }
      return nextTick();
    };
    const drawerMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $drawer: $xeDrawer, $event: evnt }, params));
      },
      open: openDrawer2,
      close() {
        return closeDrawer2("close");
      },
      getBox
    };
    const selfClickEvent = (evnt) => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = "mask";
        closeDrawer2(type);
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const isEsc = hasEventKey(evnt, EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastDrawer = import_xe_utils53.default.max(allActiveDrawers, (item) => item.reactData.drawerZIndex);
        if (lastDrawer) {
          setTimeout(() => {
            if (lastDrawer === $xeDrawer && lastDrawer.props.escClosable) {
              closeDrawer2("exit");
            }
          }, 10);
        }
      }
    };
    const boxMousedownEvent = () => {
      const { drawerZIndex } = reactData;
      if (allActiveDrawers.some((comp) => comp.reactData.visible && comp.reactData.drawerZIndex > drawerZIndex)) {
        updateZindex();
      }
    };
    const formDesignPrivateMethods = {};
    Object.assign($xeDrawer, drawerMethods, formDesignPrivateMethods);
    const renderTitles = () => {
      const { slots: propSlots = {}, showClose, title } = props;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      const titVNs = [
        h("div", {
          class: "vxe-drawer--header-title"
        }, titleSlot ? getSlotVNs(titleSlot({ $drawer: $xeDrawer })) : title ? getFuncText(title) : conf_default.i18n("vxe.alert.title"))
      ];
      const rightVNs = [];
      if (cornerSlot) {
        rightVNs.push(h("span", {
          class: "vxe-drawer--corner-wrapper"
        }, getSlotVNs(cornerSlot({ $drawer: $xeDrawer }))));
      }
      if (showClose) {
        rightVNs.push(h("i", {
          class: ["vxe-drawer--close-btn", "trigger--btn", conf_default.icon.MODAL_CLOSE],
          title: conf_default.i18n("vxe.drawer.close"),
          onClick: closeEvent
        }));
      }
      titVNs.push(h("div", {
        class: "vxe-drawer--header-right"
      }, rightVNs));
      return titVNs;
    };
    const renderHeader = () => {
      const { slots: propSlots = {}, showTitleOverflow } = props;
      const headerSlot = slots.header || propSlots.header;
      const headVNs = [];
      if (props.showHeader) {
        headVNs.push(h("div", {
          class: ["vxe-drawer--header", {
            "is--ellipsis": showTitleOverflow
          }]
        }, headerSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(headerSlot({ $drawer: $xeDrawer })) : renderTitles()));
      }
      return headVNs;
    };
    const renderBody = () => {
      const { slots: propSlots = {}, content } = props;
      const defaultSlot = slots.default || propSlots.default;
      return [
        h("div", {
          class: "vxe-drawer--body"
        }, [
          h("div", {
            class: "vxe-drawer--content"
          }, defaultSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(defaultSlot({ $drawer: $xeDrawer })) : getFuncText(content)),
          h(loading_default2, {
            class: "vxe-drawer--loading",
            modelValue: props.loading
          })
        ])
      ];
    };
    const renderBtns = () => {
      const { showCancelButton, showConfirmButton } = props;
      const btnVNs = [];
      if (showCancelButton) {
        btnVNs.push(h(button_default, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || conf_default.i18n("vxe.button.cancel"),
          onClick: cancelEvent
        }));
      }
      if (showConfirmButton) {
        btnVNs.push(h(button_default, {
          key: 2,
          ref: refConfirmBtn,
          status: "primary",
          content: props.confirmButtonText || conf_default.i18n("vxe.button.confirm"),
          onClick: confirmEvent
        }));
      }
      return btnVNs;
    };
    const renderFooter = () => {
      const { slots: propSlots = {} } = props;
      const footerSlot = slots.footer || propSlots.footer;
      const footVNs = [];
      if (props.showFooter) {
        footVNs.push(h("div", {
          class: "vxe-drawer--footer"
        }, footerSlot ? !reactData.inited || props.destroyOnClose && !reactData.visible ? [] : getSlotVNs(footerSlot({ $drawer: $xeDrawer })) : renderBtns()));
      }
      return footVNs;
    };
    const renderVN = () => {
      const { className, position, loading, lockScroll, lockView, mask } = props;
      const { inited, contentVisible, visible } = reactData;
      const vSize = computeSize.value;
      return h(Teleport, {
        to: "body",
        disabled: props.transfer ? !inited : true
      }, [
        h("div", {
          ref: refElem,
          class: ["vxe-drawer--wrapper", `pos--${position}`, className || "", {
            [`size--${vSize}`]: vSize,
            "lock--scroll": lockScroll,
            "lock--view": lockView,
            "is--mask": mask,
            "is--visible": contentVisible,
            "is--active": visible,
            "is--loading": loading
          }],
          style: {
            zIndex: reactData.drawerZIndex
          },
          onClick: selfClickEvent
        }, [
          h("div", {
            ref: refDrawerBox,
            class: "vxe-drawer--box",
            onMousedown: boxMousedownEvent
          }, renderHeader().concat(renderBody(), renderFooter()))
        ])
      ]);
    };
    $xeDrawer.renderVN = renderVN;
    watch(() => props.width, recalculate);
    watch(() => props.height, recalculate);
    watch(() => props.modelValue, (value) => {
      if (value) {
        openDrawer2();
      } else {
        closeDrawer2("model");
      }
    });
    onMounted(() => {
      nextTick(() => {
        if (props.modelValue) {
          openDrawer2();
        }
        recalculate();
      });
      if (props.escClosable) {
        GlobalEvent.on($xeDrawer, "keydown", handleGlobalKeydownEvent);
      }
    });
    onUnmounted(() => {
      GlobalEvent.off($xeDrawer, "keydown");
    });
    return $xeDrawer;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/drawer/index.js
function openDrawer(options) {
  checkDynamic();
  return new Promise((resolve) => {
    if (options && options.id && allActiveDrawers.some((comp) => comp.props.id === options.id)) {
      resolve("exist");
    } else {
      const _onHide = options.onHide;
      const drawerOpts = Object.assign(options, {
        key: import_xe_utils54.default.uniqueId(),
        modelValue: true,
        onHide(params) {
          const drawerList = dynamicStore.drawers;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.drawers = drawerList.filter((item) => item.key !== drawerOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.drawers.push(drawerOpts);
    }
  });
}
function getDrawer(id) {
  return import_xe_utils54.default.find(allActiveDrawers, ($drawer) => $drawer.props.id === id);
}
function closeDrawer(id) {
  const drawers = id ? [getDrawer(id)] : allActiveDrawers;
  const restPromises = [];
  drawers.forEach(($drawer) => {
    if ($drawer) {
      restPromises.push($drawer.close());
    }
  });
  return Promise.all(restPromises);
}
var DrawerController = {
  get: getDrawer,
  close: closeDrawer,
  open: openDrawer
};
var drawer = DrawerController;
var VxeDrawer = Object.assign(modal_default2, {
  install: function(app) {
    app.component(modal_default2.name, modal_default2);
    VXETable.drawer = DrawerController;
  }
});
dynamicApp.component(modal_default2.name, modal_default2);
var Drawer = VxeDrawer;

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/form-item.js
var import_xe_utils55 = __toESM(require_xe_utils());
var formItemProps = {
  title: String,
  field: String,
  span: [String, Number],
  align: String,
  titleAlign: {
    type: String,
    default: null
  },
  titleWidth: {
    type: [String, Number],
    default: null
  },
  titleColon: {
    type: Boolean,
    default: null
  },
  titleAsterisk: {
    type: Boolean,
    default: null
  },
  showTitle: {
    type: Boolean,
    default: true
  },
  vertical: {
    type: Boolean,
    default: null
  },
  className: [String, Function],
  contentClassName: [String, Function],
  contentStyle: [Object, Function],
  titleClassName: [String, Function],
  titleStyle: [Object, Function],
  titleOverflow: {
    type: [Boolean, String],
    default: null
  },
  titlePrefix: Object,
  titleSuffix: Object,
  resetValue: { default: null },
  visibleMethod: Function,
  visible: { type: Boolean, default: null },
  folding: Boolean,
  collapseNode: Boolean,
  itemRender: Object,
  rules: Array
};
var form_item_default = defineComponent({
  name: "VxeFormItem",
  props: formItemProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xeform = inject("$xeform", {});
    const formGather = inject("$xeformgather", null);
    const formItem = reactive(createItem($xeform, props));
    const xeformitem = { formItem };
    const xeformiteminfo = { itemConfig: formItem };
    formItem.slots = slots;
    provide("$xeformiteminfo", xeformiteminfo);
    provide("$xeformitem", xeformitem);
    provide("$xeformgather", null);
    watchItem(props, formItem);
    onMounted(() => {
      assemItem($xeform, refElem.value, formItem, formGather);
    });
    onUnmounted(() => {
      destroyItem($xeform, formItem);
    });
    const renderItem = ($xeform2, item) => {
      const { props: props2, reactData } = $xeform2;
      const { data, rules, titleAlign: allTitleAlign, titleWidth: allTitleWidth, titleColon: allTitleColon, titleAsterisk: allTitleAsterisk, titleOverflow: allTitleOverflow, vertical: allVertical } = props2;
      const { collapseAll } = reactData;
      const { computeValidOpts } = $xeform2.getComputeMaps();
      const validOpts = computeValidOpts.value;
      const { slots: slots2, title, visible, folding, field, collapseNode, itemRender, showError, errRule, className, titleOverflow, vertical, showTitle, contentClassName, contentStyle, titleClassName, titleStyle } = item;
      const compConf = isEnableConf(itemRender) ? VXETable.renderer.get(itemRender.name) : null;
      const itemClassName = compConf ? compConf.itemClassName : "";
      const itemStyle = compConf ? compConf.itemStyle : null;
      const itemContentClassName = compConf ? compConf.itemContentClassName : "";
      const itemContentStyle = compConf ? compConf.itemContentStyle : null;
      const itemTitleClassName = compConf ? compConf.itemTitleClassName : "";
      const itemTitleStyle = compConf ? compConf.itemTitleStyle : null;
      const defaultSlot = slots2 ? slots2.default : null;
      const titleSlot = slots2 ? slots2.title : null;
      const span = item.span || props2.span;
      const align = item.align || props2.align;
      const titleAlign = import_xe_utils55.default.eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
      const titleWidth = import_xe_utils55.default.eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
      const titleColon = import_xe_utils55.default.eqNull(item.titleColon) ? allTitleColon : item.titleColon;
      const titleAsterisk = import_xe_utils55.default.eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
      const itemOverflow = import_xe_utils55.default.isUndefined(titleOverflow) || import_xe_utils55.default.isNull(titleOverflow) ? allTitleOverflow : titleOverflow;
      const itemVertical = import_xe_utils55.default.isUndefined(vertical) || import_xe_utils55.default.isNull(vertical) ? allVertical : vertical;
      const ovEllipsis = itemOverflow === "ellipsis";
      const ovTitle = itemOverflow === "title";
      const ovTooltip = itemOverflow === true || itemOverflow === "tooltip";
      const hasEllipsis = ovTitle || ovTooltip || ovEllipsis;
      const params = { data, field, property: field, item, $form: $xeform2, $grid: $xeform2.xegrid };
      let isRequired = false;
      if (visible === false) {
        return createCommentVNode();
      }
      if (rules) {
        const itemRules = rules[field];
        if (itemRules) {
          isRequired = itemRules.some((rule) => rule.required);
        }
      }
      let contentVNs = [];
      if (defaultSlot) {
        contentVNs = $xeform2.callSlot(defaultSlot, params);
      } else if (compConf && compConf.renderItemContent) {
        contentVNs = getSlotVNs(compConf.renderItemContent(itemRender, params));
      } else if (field) {
        contentVNs = [`${import_xe_utils55.default.get(data, field)}`];
      }
      if (collapseNode) {
        contentVNs.push(h("div", {
          class: "vxe-form--item-trigger-node",
          onClick: $xeform2.toggleCollapseEvent
        }, [
          h("span", {
            class: "vxe-form--item-trigger-text"
          }, collapseAll ? conf_default.i18n("vxe.form.unfolding") : conf_default.i18n("vxe.form.folding")),
          h("i", {
            class: ["vxe-form--item-trigger-icon", collapseAll ? conf_default.icon.FORM_FOLDING : conf_default.icon.FORM_UNFOLDING]
          })
        ]));
      }
      if (errRule && validOpts.showMessage) {
        contentVNs.push(h("div", {
          class: "vxe-form--item-valid",
          style: errRule.maxWidth ? {
            width: `${errRule.maxWidth}px`
          } : null
        }, errRule.message));
      }
      const ons = ovTooltip ? {
        onMouseenter(evnt) {
          $xeform2.triggerTitleTipEvent(evnt, params);
        },
        onMouseleave: $xeform2.handleTitleTipLeaveEvent
      } : {};
      return h("div", {
        ref: refElem,
        class: [
          "vxe-form--item",
          item.id,
          span ? `vxe-form--item-col--${span} is--span` : "",
          className ? import_xe_utils55.default.isFunction(className) ? className(params) : className : "",
          itemClassName ? import_xe_utils55.default.isFunction(itemClassName) ? itemClassName(params) : itemClassName : "",
          {
            "is--title": title,
            "is--colon": titleColon,
            "is--vertical": itemVertical,
            "is--asterisk": titleAsterisk,
            "is--required": isRequired,
            "is--hidden": folding && collapseAll,
            "is--active": isActivetem($xeform2, item),
            "is--error": showError
          }
        ],
        style: import_xe_utils55.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        h("div", {
          class: "vxe-form--item-inner"
        }, [
          showTitle !== false && (title || titleSlot) ? h("div", Object.assign({ class: [
            "vxe-form--item-title",
            titleAlign ? `align--${titleAlign}` : "",
            hasEllipsis ? "is--ellipsis" : "",
            itemTitleClassName ? import_xe_utils55.default.isFunction(itemTitleClassName) ? itemTitleClassName(params) : itemTitleClassName : "",
            titleClassName ? import_xe_utils55.default.isFunction(titleClassName) ? titleClassName(params) : titleClassName : ""
          ], style: Object.assign({}, import_xe_utils55.default.isFunction(itemTitleStyle) ? itemTitleStyle(params) : itemTitleStyle, import_xe_utils55.default.isFunction(titleStyle) ? titleStyle(params) : titleStyle, titleWidth ? {
            width: isNaN(titleWidth) ? titleWidth : `${titleWidth}px`
          } : null), title: ovTitle ? getFuncText(title) : null }, ons), renderTitle($xeform2, item)) : null,
          h("div", {
            class: [
              "vxe-form--item-content",
              align ? `align--${align}` : "",
              itemContentClassName ? import_xe_utils55.default.isFunction(itemContentClassName) ? itemContentClassName(params) : itemContentClassName : "",
              contentClassName ? import_xe_utils55.default.isFunction(contentClassName) ? contentClassName(params) : contentClassName : ""
            ],
            style: Object.assign({}, import_xe_utils55.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils55.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
          }, contentVNs)
        ])
      ]);
    };
    const renderVN = () => {
      const formProps = $xeform ? $xeform.props : null;
      return formProps && formProps.customLayout ? renderItem($xeform, formItem) : h("div", {
        ref: refElem
      });
    };
    const $xeformitem = {
      renderVN
    };
    return $xeformitem;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form-item/index.js
var VxeFormItem = Object.assign(form_item_default, {
  install(app) {
    app.component(form_item_default.name, form_item_default);
  }
});
var FormItem = VxeFormItem;
dynamicApp.component(form_item_default.name, form_item_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form/src/form-gather.js
var import_xe_utils56 = __toESM(require_xe_utils());
var form_gather_default = defineComponent({
  name: "VxeFormGather",
  props: formItemProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xeform = inject("$xeform", {});
    const formGather = inject("$xeformgather", null);
    const formItem = reactive(createItem($xeform, props));
    const xeformitem = { formItem };
    const xeformiteminfo = { itemConfig: formItem };
    formItem.children = [];
    provide("$xeformiteminfo", xeformiteminfo);
    provide("$xeformgather", xeformitem);
    provide("$xeformitem", null);
    watchItem(props, formItem);
    onMounted(() => {
      assemItem($xeform, refElem.value, formItem, formGather);
    });
    onUnmounted(() => {
      destroyItem($xeform, formItem);
    });
    const renderVN = () => {
      const { className, field } = props;
      const span = props.span || ($xeform ? $xeform.props.span : null);
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-form--gather vxe-form--item-row", formItem.id, span ? `vxe-form--item-col_${span} is--span` : "", className ? import_xe_utils56.default.isFunction(className) ? className({ $form: $xeform, data: $xeform ? $xeform.props.data : {}, item: formItem, field, property: field }) : className : ""]
      }, defaultSlot ? defaultSlot() : []);
    };
    const $xeformgather = {
      renderVN
    };
    return $xeformgather;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/form-gather/index.js
var VxeFormGather = Object.assign(form_gather_default, {
  install(app) {
    app.component(form_gather_default.name, form_gather_default);
  }
});
var FormGather = VxeFormGather;
dynamicApp.component(form_gather_default.name, form_gather_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/select/src/util.js
var import_xe_utils58 = __toESM(require_xe_utils());

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/select/src/optionInfo.js
var import_xe_utils57 = __toESM(require_xe_utils());
var OptionInfo = class {
  constructor($xeselect, _vm) {
    Object.assign(this, {
      id: import_xe_utils57.default.uniqueId("option_"),
      value: _vm.value,
      label: _vm.label,
      visible: _vm.visible,
      className: _vm.className,
      disabled: _vm.disabled
    });
  }
  update(name, value) {
    this[name] = value;
  }
};

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/select/src/util.js
function isOption(option) {
  return option instanceof OptionInfo;
}
function createOption($xeselect, _vm) {
  return isOption(_vm) ? _vm : new OptionInfo($xeselect, _vm);
}
function watchOption(props, option) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      option.update(name, value);
    });
  });
}
function assemOption($xeselect, el, option, optgroup) {
  const { reactData } = $xeselect;
  const { staticOptions } = reactData;
  const parentElem = el.parentNode;
  const parentOption = optgroup ? optgroup.option : null;
  const parentCols = parentOption ? parentOption.options : staticOptions;
  if (parentElem && parentCols) {
    parentCols.splice(import_xe_utils58.default.arrayIndexOf(parentElem.children, el), 0, option);
    reactData.staticOptions = staticOptions.slice(0);
  }
}
function destroyOption($xeselect, option) {
  const { reactData } = $xeselect;
  const { staticOptions } = reactData;
  const matchObj = import_xe_utils58.default.findTree(staticOptions, (item) => item.id === option.id, { children: "options" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticOptions = staticOptions.slice(0);
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/select/src/optgroup.js
var optgroup_default = defineComponent({
  name: "VxeOptgroup",
  props: {
    label: { type: [String, Number, Boolean], default: "" },
    visible: { type: Boolean, default: null },
    className: [String, Function],
    disabled: Boolean
  },
  setup(props, { slots }) {
    const elem = ref();
    const $xeselect = inject("$xeselect", {});
    const option = createOption($xeselect, props);
    const xeoption = { option };
    option.options = [];
    provide("xeoptgroup", xeoption);
    watchOption(props, option);
    onMounted(() => {
      assemOption($xeselect, elem.value, option);
    });
    onUnmounted(() => {
      destroyOption($xeselect, option);
    });
    return () => {
      return h("div", {
        ref: elem
      }, slots.default ? slots.default() : []);
    };
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/optgroup/index.js
var VxeOptgroup = Object.assign(optgroup_default, {
  install: function(app) {
    app.component(optgroup_default.name, optgroup_default);
  }
});
var Optgroup = VxeOptgroup;
dynamicApp.component(optgroup_default.name, optgroup_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/select/src/option.js
var option_default = defineComponent({
  name: "VxeOption",
  props: {
    value: null,
    label: { type: [String, Number, Boolean], default: "" },
    visible: { type: Boolean, default: null },
    className: [String, Function],
    disabled: Boolean
  },
  setup(props, { slots }) {
    const elem = ref();
    const $xeselect = inject("$xeselect", {});
    const optgroup = inject("xeoptgroup", null);
    const option = createOption($xeselect, props);
    option.slots = slots;
    watchOption(props, option);
    onMounted(() => {
      assemOption($xeselect, elem.value, option, optgroup);
    });
    onUnmounted(() => {
      destroyOption($xeselect, option);
    });
    return () => {
      return h("div", {
        ref: elem
      });
    };
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/option/index.js
var VxeOption = Object.assign(option_default, {
  install: function(app) {
    app.component(option_default.name, option_default);
  }
});
var Option = VxeOption;
dynamicApp.component(option_default.name, option_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/switch/src/switch.js
var import_xe_utils59 = __toESM(require_xe_utils());
var switch_default = defineComponent({
  name: "VxeSwitch",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: Boolean,
    size: { type: String, default: () => conf_default.switch.size || conf_default.size },
    openLabel: String,
    closeLabel: String,
    openValue: { type: [String, Number, Boolean], default: true },
    closeValue: { type: [String, Number, Boolean], default: false },
    openIcon: String,
    closeIcon: String,
    openActiveIcon: String,
    closeActiveIcon: String
  },
  emits: [
    "update:modelValue",
    "change",
    "focus",
    "blur"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeform = inject("$xeform", null);
    const $xeformiteminfo = inject("$xeformiteminfo", null);
    const xID = import_xe_utils59.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      isActivated: false,
      hasAnimat: false,
      offsetLeft: 0
    });
    const $xeswitch = {
      xID,
      props,
      context,
      reactData
    };
    const refButton = ref();
    let switchMethods = {};
    const computeOnShowLabel = computed(() => {
      return getFuncText(props.openLabel);
    });
    const computeOffShowLabel = computed(() => {
      return getFuncText(props.closeLabel);
    });
    const computeIsChecked = computed(() => {
      return props.modelValue === props.openValue;
    });
    let _atimeout;
    const clickEvent = (evnt) => {
      if (!props.disabled) {
        const isChecked = computeIsChecked.value;
        clearTimeout(_atimeout);
        const value = isChecked ? props.closeValue : props.openValue;
        reactData.hasAnimat = true;
        emit("update:modelValue", value);
        switchMethods.dispatchEvent("change", { value }, evnt);
        if ($xeform && $xeformiteminfo) {
          $xeform.triggerItemEvent(evnt, $xeformiteminfo.itemConfig.field, value);
        }
        _atimeout = setTimeout(() => {
          reactData.hasAnimat = false;
        }, 400);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      switchMethods.dispatchEvent("focus", { value: props.modelValue }, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      switchMethods.dispatchEvent("blur", { value: props.modelValue }, evnt);
    };
    switchMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $switch: $xeswitch, $event: evnt }, params));
      },
      focus() {
        const btnElem = refButton.value;
        reactData.isActivated = true;
        btnElem.focus();
        return nextTick();
      },
      blur() {
        const btnElem = refButton.value;
        btnElem.blur();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xeswitch, switchMethods);
    const renderVN = () => {
      const { disabled, openIcon, closeIcon, openActiveIcon, closeActiveIcon } = props;
      const isChecked = computeIsChecked.value;
      const vSize = computeSize.value;
      const onShowLabel = computeOnShowLabel.value;
      const offShowLabel = computeOffShowLabel.value;
      return h("div", {
        class: ["vxe-switch", isChecked ? "is--on" : "is--off", {
          [`size--${vSize}`]: vSize,
          "is--disabled": disabled,
          "is--animat": reactData.hasAnimat
        }]
      }, [
        h("button", {
          ref: refButton,
          class: "vxe-switch--button",
          type: "button",
          disabled,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent
        }, [
          h("span", {
            class: "vxe-switch--label vxe-switch--label-on"
          }, [
            openIcon ? h("i", {
              class: ["vxe-switch--label-icon", openIcon]
            }) : createCommentVNode(),
            onShowLabel
          ]),
          h("span", {
            class: "vxe-switch--label vxe-switch--label-off"
          }, [
            closeIcon ? h("i", {
              class: ["vxe-switch--label-icon", closeIcon]
            }) : createCommentVNode(),
            offShowLabel
          ]),
          h("span", {
            class: "vxe-switch--icon"
          }, openActiveIcon || closeActiveIcon ? [
            h("i", {
              class: isChecked ? openActiveIcon : closeActiveIcon
            })
          ] : [])
        ])
      ]);
    };
    $xeswitch.renderVN = renderVN;
    return $xeswitch;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/switch/index.js
var VxeSwitch = Object.assign(switch_default, {
  install: function(app) {
    app.component(switch_default.name, switch_default);
  }
});
var Switch = VxeSwitch;
dynamicApp.component(switch_default.name, switch_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/list/src/list.js
var import_xe_utils60 = __toESM(require_xe_utils());
var list_default = defineComponent({
  name: "VxeList",
  props: {
    data: Array,
    height: [Number, String],
    maxHeight: [Number, String],
    loading: Boolean,
    className: [String, Function],
    size: { type: String, default: () => conf_default.list.size || conf_default.size },
    autoResize: { type: Boolean, default: () => conf_default.list.autoResize },
    syncResize: [Boolean, String, Number],
    scrollY: Object
  },
  emits: [
    "scroll"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils60.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      scrollYLoad: false,
      bodyHeight: 0,
      rowHeight: 0,
      topSpaceHeight: 0,
      items: []
    });
    const refElem = ref();
    const refVirtualWrapper = ref();
    const refVirtualBody = ref();
    const internalData = {
      fullData: [],
      lastScrollLeft: 0,
      lastScrollTop: 0,
      scrollYStore: {
        startIndex: 0,
        endIndex: 0,
        visibleSize: 0,
        offsetSize: 0,
        rowHeight: 0
      }
    };
    const refMaps = {
      refElem
    };
    const $xelist = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let listMethods = {};
    const computeSYOpts = computed(() => {
      return Object.assign({}, conf_default.list.scrollY, props.scrollY);
    });
    const computeStyles = computed(() => {
      const { height, maxHeight } = props;
      const style = {};
      if (height) {
        style.height = `${isNaN(height) ? height : `${height}px`}`;
      } else if (maxHeight) {
        style.height = "auto";
        style.maxHeight = `${isNaN(maxHeight) ? maxHeight : `${maxHeight}px`}`;
      }
      return style;
    });
    const updateYSpace = () => {
      const { scrollYLoad } = reactData;
      const { scrollYStore, fullData } = internalData;
      reactData.bodyHeight = scrollYLoad ? fullData.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const handleData = () => {
      const { scrollYLoad } = reactData;
      const { fullData, scrollYStore } = internalData;
      reactData.items = scrollYLoad ? fullData.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullData.slice(0);
      return nextTick();
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollYLoad } = reactData;
        const { scrollYStore } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const sYOpts = computeSYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (sYOpts.sItem) {
            firstItemElem = virtualBodyElem.querySelector(sYOpts.sItem);
          }
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, Math.ceil(scrollBodyElem.clientHeight / rowHeight));
          const offsetYSize = sYOpts.oSize ? import_xe_utils60.default.toNumber(sYOpts.oSize) : browse.edge ? 10 : 0;
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
        reactData.rowHeight = rowHeight;
      });
    };
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
      }
      return nextTick();
    };
    const scrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (import_xe_utils60.default.isNumber(scrollLeft)) {
        scrollBodyElem.scrollLeft = scrollLeft;
      }
      if (import_xe_utils60.default.isNumber(scrollTop)) {
        scrollBodyElem.scrollTop = scrollTop;
      }
      if (reactData.scrollYLoad) {
        return new Promise((resolve) => {
          setTimeout(() => {
            nextTick(() => {
              resolve();
            });
          }, 50);
        });
      }
      return nextTick();
    };
    const refreshScroll = () => {
      const { lastScrollLeft, lastScrollTop } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    const recalculate = () => {
      const el = refElem.value;
      if (el.clientWidth && el.clientHeight) {
        return computeScrollLoad();
      }
      return Promise.resolve();
    };
    const loadYData = (evnt) => {
      const { scrollYStore } = internalData;
      const { startIndex, endIndex, visibleSize, offsetSize, rowHeight } = scrollYStore;
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const scrollEvent = (evnt) => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      listMethods.dispatchEvent("scroll", { scrollLeft, scrollTop, isX, isY }, evnt);
    };
    listMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $list: $xelist, $event: evnt }, params));
      },
      /**
       * 加载数据
       * @param {Array} datas 数据
       */
      loadData(datas) {
        const { scrollYStore } = internalData;
        const sYOpts = computeSYOpts.value;
        const fullData = datas || [];
        Object.assign(scrollYStore, {
          startIndex: 0,
          endIndex: 1,
          visibleSize: 0
        });
        internalData.fullData = fullData;
        reactData.scrollYLoad = !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt <= fullData.length);
        handleData();
        return computeScrollLoad().then(() => {
          refreshScroll();
        });
      },
      /**
       * 重新加载数据
       * @param {Array} datas 数据
       */
      reloadData(datas) {
        clearScroll();
        return listMethods.loadData(datas);
      },
      recalculate,
      scrollTo,
      refreshScroll,
      clearScroll
    };
    Object.assign($xelist, listMethods);
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      listMethods.loadData(props.data || []);
    });
    watch(() => props.syncResize, (value) => {
      if (value) {
        recalculate();
        nextTick(() => setTimeout(() => recalculate()));
      }
    });
    onActivated(() => {
      recalculate().then(() => refreshScroll());
    });
    let resizeObserver;
    nextTick(() => {
      GlobalEvent.on($xelist, "resize", () => {
        recalculate();
      });
      if (props.autoResize) {
        const el = refElem.value;
        resizeObserver = createResizeEvent(() => recalculate());
        resizeObserver.observe(el);
      }
      listMethods.loadData(props.data || []);
    });
    onUnmounted(() => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      GlobalEvent.off($xelist, "resize");
    });
    const renderVN = () => {
      const { className, loading } = props;
      const { bodyHeight, topSpaceHeight, items } = reactData;
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-list", className ? import_xe_utils60.default.isFunction(className) ? className({ $list: $xelist }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading
        }]
      }, [
        h("div", {
          ref: refVirtualWrapper,
          class: "vxe-list--virtual-wrapper",
          style: styles,
          onScroll: scrollEvent
        }, [
          h("div", {
            class: "vxe-list--y-space",
            style: {
              height: bodyHeight ? `${bodyHeight}px` : ""
            }
          }),
          h("div", {
            ref: refVirtualBody,
            class: "vxe-list--body",
            style: {
              marginTop: topSpaceHeight ? `${topSpaceHeight}px` : ""
            }
          }, slots.default ? slots.default({ items, $list: $xelist }) : [])
        ]),
        /**
         * 加载中
         */
        h(loading_default2, {
          class: "vxe-list--loading",
          modelValue: loading
        })
      ]);
    };
    $xelist.renderVN = renderVN;
    return $xelist;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/list/index.js
var VxeList = Object.assign(list_default, {
  install(app) {
    app.component(list_default.name, list_default);
  }
});
var List = VxeList;
dynamicApp.component(list_default.name, list_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/pulldown/src/pulldown.js
var import_xe_utils61 = __toESM(require_xe_utils());
var pulldown_default = defineComponent({
  name: "VxePulldown",
  props: {
    modelValue: Boolean,
    disabled: Boolean,
    placement: String,
    size: { type: String, default: () => conf_default.size },
    className: [String, Function],
    popupClassName: [String, Function],
    destroyOnClose: Boolean,
    transfer: Boolean
  },
  emits: [
    "update:modelValue",
    "hide-panel"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils61.default.uniqueId();
    const computeSize = useSize(props);
    const reactData = reactive({
      inited: false,
      panelIndex: 0,
      panelStyle: null,
      panelPlacement: null,
      visiblePanel: false,
      animatVisible: false,
      isActivated: false
    });
    const refElem = ref();
    const refPulldowContent = ref();
    const refPulldowPnanel = ref();
    const refMaps = {
      refElem
    };
    const $xepulldown = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let pulldownMethods = {};
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const isPanelVisible = () => {
      return reactData.visiblePanel;
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { transfer, placement } = props;
        const { panelIndex, visiblePanel } = reactData;
        if (visiblePanel) {
          const targetElem = refPulldowContent.value;
          const panelElem = refPulldowPnanel.value;
          if (panelElem && targetElem) {
            const targetHeight = targetElem.offsetHeight;
            const targetWidth = targetElem.offsetWidth;
            const panelHeight = panelElem.offsetHeight;
            const panelWidth = panelElem.offsetWidth;
            const marginSize = 5;
            const panelStyle = {
              zIndex: panelIndex
            };
            const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(targetElem);
            let panelPlacement = "bottom";
            if (transfer) {
              let left = boundingLeft;
              let top = boundingTop + targetHeight;
              if (placement === "top") {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              } else if (!placement) {
                if (top + panelHeight + marginSize > visibleHeight) {
                  panelPlacement = "top";
                  top = boundingTop - panelHeight;
                }
                if (top < marginSize) {
                  panelPlacement = "bottom";
                  top = boundingTop + targetHeight;
                }
              }
              if (left + panelWidth + marginSize > visibleWidth) {
                left -= left + panelWidth + marginSize - visibleWidth;
              }
              if (left < marginSize) {
                left = marginSize;
              }
              Object.assign(panelStyle, {
                left: `${left}px`,
                top: `${top}px`,
                minWidth: `${targetWidth}px`
              });
            } else {
              if (placement === "top") {
                panelPlacement = "top";
                panelStyle.bottom = `${targetHeight}px`;
              } else if (!placement) {
                if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                  if (boundingTop - targetHeight - panelHeight > marginSize) {
                    panelPlacement = "top";
                    panelStyle.bottom = `${targetHeight}px`;
                  }
                }
              }
            }
            reactData.panelStyle = panelStyle;
            reactData.panelPlacement = panelPlacement;
          }
        }
        return nextTick();
      });
    };
    let hidePanelTimeout;
    const showPanel = () => {
      if (!reactData.inited) {
        reactData.inited = true;
      }
      return new Promise((resolve) => {
        if (!props.disabled) {
          clearTimeout(hidePanelTimeout);
          reactData.isActivated = true;
          reactData.animatVisible = true;
          setTimeout(() => {
            reactData.visiblePanel = true;
            emit("update:modelValue", true);
            updatePlacement();
            setTimeout(() => {
              resolve(updatePlacement());
            }, 40);
          }, 10);
          updateZindex();
        } else {
          nextTick(() => {
            resolve();
          });
        }
      });
    };
    const hidePanel = () => {
      reactData.visiblePanel = false;
      emit("update:modelValue", false);
      return new Promise((resolve) => {
        if (reactData.animatVisible) {
          hidePanelTimeout = window.setTimeout(() => {
            reactData.animatVisible = false;
            nextTick(() => {
              resolve();
            });
          }, 350);
        } else {
          nextTick(() => {
            resolve();
          });
        }
      });
    };
    const togglePanel = () => {
      if (reactData.visiblePanel) {
        return hidePanel();
      }
      return showPanel();
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      const panelElem = refPulldowPnanel.value;
      if (!disabled) {
        if (visiblePanel) {
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            pulldownMethods.dispatchEvent("hide-panel", {}, evnt);
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      const el = refElem.value;
      const panelElem = refPulldowPnanel.value;
      if (!disabled) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hidePanel();
          pulldownMethods.dispatchEvent("hide-panel", {}, evnt);
        }
      }
    };
    const handleGlobalBlurEvent = (evnt) => {
      if (reactData.visiblePanel) {
        reactData.isActivated = false;
        hidePanel();
        pulldownMethods.dispatchEvent("hide-panel", {}, evnt);
      }
    };
    pulldownMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, Object.assign({ $pulldown: $xepulldown, $event: evnt }, params));
      },
      isPanelVisible,
      togglePanel,
      showPanel,
      hidePanel
    };
    Object.assign($xepulldown, pulldownMethods);
    watch(() => props.modelValue, (value) => {
      if (value) {
        showPanel();
      } else {
        hidePanel();
      }
    });
    nextTick(() => {
      GlobalEvent.on($xepulldown, "mousewheel", handleGlobalMousewheelEvent);
      GlobalEvent.on($xepulldown, "mousedown", handleGlobalMousedownEvent);
      GlobalEvent.on($xepulldown, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      GlobalEvent.off($xepulldown, "mousewheel");
      GlobalEvent.off($xepulldown, "mousedown");
      GlobalEvent.off($xepulldown, "blur");
    });
    const renderVN = () => {
      const { className, popupClassName, destroyOnClose, transfer, disabled } = props;
      const { inited, isActivated, animatVisible, visiblePanel, panelStyle, panelPlacement } = reactData;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const dropdownSlot = slots.dropdown;
      return h("div", {
        ref: refElem,
        class: ["vxe-pulldown", className ? import_xe_utils61.default.isFunction(className) ? className({ $pulldown: $xepulldown }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visivle": visiblePanel,
          "is--disabled": disabled,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          ref: refPulldowContent,
          class: "vxe-pulldown--content"
        }, defaultSlot ? defaultSlot({ $pulldown: $xepulldown }) : []),
        h(Teleport, {
          to: "body",
          disabled: transfer ? !inited : true
        }, [
          h("div", {
            ref: refPulldowPnanel,
            class: ["vxe-table--ignore-clear vxe-pulldown--panel", popupClassName ? import_xe_utils61.default.isFunction(popupClassName) ? popupClassName({ $pulldown: $xepulldown }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": transfer,
              "animat--leave": animatVisible,
              "animat--enter": visiblePanel
            }],
            placement: panelPlacement,
            style: panelStyle
          }, dropdownSlot ? [
            h("div", {
              class: "vxe-pulldown--panel-wrapper"
            }, !inited || destroyOnClose && !visiblePanel && !animatVisible ? [] : [
              headerSlot ? h("div", {
                class: "vxe-pulldown--panel-header"
              }, headerSlot({ $pulldown: $xepulldown })) : createCommentVNode(),
              h("div", {
                class: "vxe-pulldown--panel-body"
              }, dropdownSlot({ $pulldown: $xepulldown })),
              footerSlot ? h("div", {
                class: "vxe-pulldown--panel-footer"
              }, footerSlot({ $pulldown: $xepulldown })) : createCommentVNode()
            ])
          ] : [])
        ])
      ]);
    };
    $xepulldown.renderVN = renderVN;
    return $xepulldown;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/pulldown/index.js
var VxePulldown = Object.assign(pulldown_default, {
  install: function(app) {
    app.component(pulldown_default.name, pulldown_default);
  }
});
var Pulldown = VxePulldown;
dynamicApp.component(pulldown_default.name, pulldown_default);

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/locale/lang/zh-CN.js
var zh_CN_default = {
  vxe: {
    base: {
      pleaseInput: "请输入",
      pleaseSelect: "请选择",
      comma: "，",
      fullStop: "。"
    },
    loading: {
      text: "加载中..."
    },
    error: {
      downErr: "下载失败",
      groupFixed: "如果使用分组表头，冻结列必须按组设置",
      groupMouseRange: '分组表头与 "{0}" 不能同时使用，这可能会出现错误',
      groupTag: '分组列头应该使用 "{0}" 而不是 "{1}"，这可能会出现错误',
      scrollErrProp: '启用虚拟滚动后不支持该参数 "{0}"',
      errConflicts: '参数 "{0}" 与 "{1}" 有冲突',
      unableInsert: "无法插入到指定位置，请检查参数是否正确",
      useErr: '安装 "{0}" 模块时发生错误，可能顺序不正确，依赖的模块需要在 Table 之前安装',
      barUnableLink: "工具栏无法关联表格",
      expandContent: '展开行的插槽应该是 "content"，请检查是否正确',
      reqComp: '缺少 "{0}" 组件，请检查是否正确安装。 https://vxeui.com/#/start/useGlobal',
      reqModule: '缺少 "{0}" 模块',
      reqProp: '缺少必要的 "{0}" 参数，这可能会导致出现错误',
      emptyProp: '参数 "{0}" 不允许为空',
      errProp: '不支持的参数 "{0}"，可能为 "{1}"',
      colRepet: 'column.{0}="{1}" 重复了，这可能会导致某些功能无法使用',
      notFunc: '方法 "{0}" 不存在',
      errFunc: '参数 "{0}" 不是一个方法',
      notValidators: '全局校验 "{0}" 不存在',
      notFormats: '全局格式化 "{0}" 不存在',
      notCommands: '全局指令 "{0}" 不存在',
      notSlot: '插槽 "{0}" 不存在',
      noTree: '树结构不支持 "{0}"',
      notProp: '不支持的参数 "{0}"',
      checkProp: '当数据量过大时可能会导致复选框卡顿，建议设置参数 "{0}" 提升渲染速度',
      coverProp: '"{0}" 的参数 "{1}" 重复定义，这可能会出现错误',
      uniField: '字段名 "{0}" 重复定义，这可能会出现错误',
      delFunc: '方法 "{0}" 已废弃，请使用 "{1}"',
      delProp: '参数 "{0}" 已废弃，请使用 "{1}"',
      delEvent: '事件 "{0}" 已废弃，请使用 "{1}"',
      removeProp: '参数 "{0}" 已废弃，不建议使用，这可能会导致出现错误',
      errFormat: '全局的格式化内容应该使用 "VXETable.formats" 定义，挂载 "formatter={0}" 的方式已不建议使用',
      notType: '不支持的文件类型 "{0}"',
      notExp: "该浏览器不支持导入/导出功能",
      impFields: "导入失败，请检查字段名和数据格式是否正确",
      treeNotImp: "树表格不支持导入"
    },
    table: {
      emptyText: "暂无数据",
      allTitle: "全选/取消",
      seqTitle: "序号",
      actionTitle: "操作",
      confirmFilter: "筛选",
      resetFilter: "重置",
      allFilter: "全部",
      sortAsc: "升序：最低到最高",
      sortDesc: "降序：最高到最低",
      filter: "对所选的列启用筛选",
      impSuccess: "成功导入 {0} 条记录",
      expLoading: "正在导出中",
      expSuccess: "导出成功",
      expFilename: "导出_{0}",
      expOriginFilename: "导出_源_{0}",
      customTitle: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customClose: "关闭",
      customCancel: "取消",
      customRestore: "恢复默认",
      maxFixedCol: "最大冻结列的数量不能超过 {0} 个"
    },
    grid: {
      selectOneRecord: "请至少选择一条记录！",
      deleteSelectRecord: "您确定要删除所选记录吗？",
      removeSelectRecord: "您确定要移除所选记录吗？",
      dataUnchanged: "数据未改动！",
      delSuccess: "成功删除所选记录！",
      saveSuccess: "保存成功！",
      operError: "发生错误，操作失败！"
    },
    select: {
      search: "搜索",
      loadingText: "加载中",
      emptyText: "暂无数据"
    },
    pager: {
      goto: "前往",
      gotoTitle: "页数",
      pagesize: "{0}条/页",
      total: "共 {0} 条记录",
      pageClassifier: "页",
      homePage: "首页",
      homePageTitle: "首页",
      prevPage: "上一页",
      prevPageTitle: "上一页",
      nextPage: "下一页",
      nextPageTitle: "下一页",
      prevJump: "向上跳页",
      prevJumpTitle: "向上跳页",
      nextJump: "向下跳页",
      nextJumpTitle: "向下跳页",
      endPage: "末页",
      endPageTitle: "末页"
    },
    alert: {
      title: "系统提示"
    },
    button: {
      confirm: "确认",
      cancel: "取消"
    },
    filter: {
      search: "搜索"
    },
    custom: {
      cstmTitle: "列设置",
      cstmRestore: "恢复默认",
      cstmCancel: "取消",
      cstmConfirm: "确定",
      cstmConfirmRestore: "请确认是否恢复成默认列配置？",
      cstmDragTarget: "移动目标：{0}",
      setting: {
        colSort: "排序",
        sortHelpTip: "点击并拖动图标可以调整列的排序",
        colTitle: "标题",
        colResizable: "列宽（像素）",
        colVisible: "是否显示",
        colFixed: "冻结列",
        colFixedMax: "冻结列（最多 {0} 列）",
        fixedLeft: "左侧",
        fixedUnset: "不设置",
        fixedRight: "右侧"
      }
    },
    import: {
      modes: {
        covering: "覆盖方式（直接覆盖表格数据）",
        insert: "底部追加（在表格的底部追加新数据）",
        insertTop: "顶部追加（在表格的顶部追加新数据）",
        insertBottom: "底部追加（在表格的底部追加新数据）"
      },
      impTitle: "导入数据",
      impFile: "文件名",
      impSelect: "选择文件",
      impType: "文件类型",
      impOpts: "参数设置",
      impMode: "导入模式",
      impConfirm: "导入",
      impCancel: "取消"
    },
    export: {
      types: {
        csv: "CSV (逗号分隔)(*.csv)",
        html: "网页(*.html)",
        xml: "XML 数据(*.xml)",
        txt: "文本文件(制表符分隔)(*.txt)",
        xls: "Excel 97-2003 工作簿(*.xls)",
        xlsx: "Excel 工作簿(*.xlsx)",
        pdf: "PDF (*.pdf)"
      },
      modes: {
        current: "当前数据（当前页的数据）",
        selected: "选中数据（当前页选中的数据）",
        all: "全量数据（包括所有分页的数据）"
      },
      printTitle: "打印数据",
      expTitle: "导出数据",
      expName: "文件名",
      expNamePlaceholder: "请输入文件名",
      expSheetName: "标题",
      expSheetNamePlaceholder: "请输入标题",
      expType: "保存类型",
      expMode: "选择数据",
      expCurrentColumn: "全部字段",
      expColumn: "选择字段",
      expOpts: "参数设置",
      expOptHeader: "表头",
      expHeaderTitle: "是否需要表头",
      expOptFooter: "表尾",
      expFooterTitle: "是否需要表尾",
      expOptColgroup: "分组表头",
      expColgroupTitle: "如果存在，则支持带有分组结构的表头",
      expOptMerge: "合并",
      expMergeTitle: "如果存在，则支持带有合并结构的单元格",
      expOptAllExpand: "展开层级",
      expAllExpandTitle: "如果存在，则支持将带有层级结构的数据全部展开",
      expOptUseStyle: "样式",
      expUseStyleTitle: "如果存在，则支持带样式的单元格",
      expOptOriginal: "源数据",
      expOriginalTitle: "如果为源数据，则支持导入到表格中",
      expPrint: "打印",
      expConfirm: "导出",
      expCancel: "取消"
    },
    modal: {
      errTitle: "错误提示",
      zoomMin: "最小化",
      zoomIn: "最大化",
      zoomOut: "还原",
      close: "关闭",
      miniMaxSize: "最小化窗口的数量不能超过 {0} 个",
      footPropErr: "show-footer 仅用于启用表尾，需配合 show-confirm-button | show-cancel-button | 插槽使用"
    },
    drawer: {
      close: "关闭"
    },
    form: {
      folding: "收起",
      unfolding: "展开"
    },
    toolbar: {
      import: "导入",
      export: "导出",
      print: "打印",
      refresh: "刷新",
      zoomIn: "全屏",
      zoomOut: "还原",
      custom: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customRestore: "重置",
      fixedLeft: "冻结在左侧",
      fixedRight: "冻结在右侧",
      cancelFixed: "取消冻结列"
    },
    input: {
      date: {
        m1: "01 月",
        m2: "02 月",
        m3: "03 月",
        m4: "04 月",
        m5: "05 月",
        m6: "06 月",
        m7: "07 月",
        m8: "08 月",
        m9: "09 月",
        m10: "10 月",
        m11: "11 月",
        m12: "12 月",
        quarterLabel: "{0} 年",
        monthLabel: "{0} 年",
        dayLabel: "{0} 年 {1}",
        labelFormat: {
          date: "yyyy-MM-dd",
          time: "HH:mm:ss",
          datetime: "yyyy-MM-dd HH:mm:ss",
          week: "yyyy 年第 WW 周",
          month: "yyyy-MM",
          quarter: "yyyy 年第 q 季度",
          year: "yyyy"
        },
        weeks: {
          w: "周",
          w0: "周日",
          w1: "周一",
          w2: "周二",
          w3: "周三",
          w4: "周四",
          w5: "周五",
          w6: "周六"
        },
        months: {
          m0: "一月",
          m1: "二月",
          m2: "三月",
          m3: "四月",
          m4: "五月",
          m5: "六月",
          m6: "七月",
          m7: "八月",
          m8: "九月",
          m9: "十月",
          m10: "十一月",
          m11: "十二月"
        },
        quarters: {
          q1: "第一季度",
          q2: "第二季度",
          q3: "第三季度",
          q4: "第四季度"
        }
      }
    },
    imagePreview: {
      popupTitle: "预览",
      operBtn: {
        zoomOut: "缩小",
        zoomIn: "放大",
        pctFull: "等比例缩放",
        pct11: "显示原始尺寸",
        rotateLeft: "向左旋转",
        rotateRight: "向右旋转",
        print: "点击打印图片",
        download: "点击下载图片"
      }
    },
    upload: {
      fileBtnText: "点击或拖拽上传",
      imgBtnText: "点击或拖拽上传",
      dragPlaceholder: "请把文件拖放到这个区域即可上传",
      imgSizeHint: "单张{0}",
      imgCountHint: "最多{0}张",
      fileTypeHint: "支持 {0} 文件类型",
      fileSizeHint: "单个文件大小不超过{0}",
      fileCountHint: "最多可上传{0}个文件",
      overCountErr: "最多只能选择{0}个文件！",
      overCountExtraErr: "已超出最大数量{0}个，超出的{1}个文件将被忽略！",
      overSizeErr: "文件大小最大不能超过{0}！",
      reUpload: "重新上传",
      uploadProgress: "上传中 {0}%",
      uploadErr: "上传失败",
      uploadSuccess: "上传成功",
      moreBtnText: "更多（{0}）",
      viewItemTitle: "点击查看",
      morePopup: {
        readTitle: "查看列表",
        imageTitle: "上传图片",
        fileTitle: "上传文件"
      }
    },
    formDesign: {
      formName: "表单名称",
      defFormTitle: "未命名的表单",
      widgetPropTab: "控件属性",
      widgetFormTab: "表单属性",
      error: {
        wdFormUni: "该类型的控件在表单中只允许添加一个",
        wdSubUni: "该类型的控件在子表中只允许添加一个"
      },
      styleSetting: {
        btn: "样式设置",
        title: "表单的样式设置",
        layoutTitle: "控件布局",
        verticalLayout: "上下布局",
        horizontalLayout: "横向布局",
        styleTitle: "标题样式",
        boldTitle: "标题加粗",
        fontBold: "加粗",
        fontNormal: "常规",
        colonTitle: "显示冒号",
        colonVisible: "显示",
        colonHidden: "隐藏",
        alignTitle: "对齐方式",
        widthTitle: "标题宽度",
        alignLeft: "居左",
        alignRight: "居右",
        unitPx: "像素",
        unitPct: "百分比"
      },
      widget: {
        group: {
          base: "基础控件",
          layout: "布局控件",
          system: "系统控件",
          module: "模块控件",
          chart: "图表控件",
          advanced: "高级控件"
        },
        copyTitle: "副本_{0}",
        component: {
          input: "输入框",
          textarea: "文本域",
          select: "下拉选择",
          row: "一行多列",
          title: "标题",
          text: "文本",
          subtable: "子表",
          VxeSwitch: "是/否",
          VxeInput: "输入框",
          VxeNumberInput: "数字",
          VxeDatePicker: "日期",
          VxeTextarea: "文本域",
          VxeSelect: "下拉选择",
          VxeTreeSelect: "树形选择",
          VxeRadioGroup: "单选框",
          VxeCheckboxGroup: "复选框",
          VxeUploadFile: "文件",
          VxeUploadImage: "图片"
        }
      },
      widgetProp: {
        name: "控件名称",
        placeholder: "提示语",
        required: "必填校验",
        multiple: "允许多选",
        displaySetting: {
          name: "显示设置",
          pc: "电脑端",
          mobile: "手机端",
          visible: "显示",
          hidden: "隐藏"
        },
        dataSource: {
          name: "数据源",
          defValue: "选项{0}",
          addOption: "添加选项",
          batchEditOption: "批量编辑",
          batchEditTip: "每行对应一个选项，支持从表格、Excel、WPS 中直接复制粘贴。",
          batchEditSubTip: "每行对应一个选项，如果是分组，子项可以是空格或制表键开头，支持从表格、Excel、WPS 中直接复制粘贴。",
          buildOption: "生成选项"
        },
        rowProp: {
          colSize: "列数",
          col2: "两列",
          col3: "三列",
          col4: "四列",
          col6: "六列",
          layout: "布局"
        },
        textProp: {
          name: "内容",
          alignTitle: "对齐方式",
          alignLeft: "居左",
          alignCenter: "居中",
          alignRight: "居右",
          colorTitle: "字体颜色",
          sizeTitle: "字体大小",
          boldTitle: "字体加粗",
          fontNormal: "常规",
          fontBold: "加粗"
        },
        subtableProp: {
          seqTitle: "序号",
          showSeq: "显示序号",
          showCheckbox: "允许多选",
          errSubDrag: "子表不支持该控件，请使用其他控件",
          colPlace: "将控件拖拽进来"
        },
        uploadProp: {
          limitFileCount: "文件数量限制",
          limitFileSize: "文件大小限制",
          multiFile: "允许上传多个文件",
          limitImgCount: "图片数量限制",
          limitImgSize: "图片大小限制",
          multiImg: "允许上传多张图片"
        }
      }
    },
    listDesign: {
      fieldSettingTab: "字段设置",
      listSettingTab: "参数设置",
      searchTitle: "查询条件",
      listTitle: "列表字段",
      searchField: "查询字段",
      listField: "列表字段",
      activeBtn: {
        ActionButtonUpdate: "编辑",
        ActionButtonDelete: "删除"
      },
      search: {
        addBtn: "编辑",
        emptyText: "未配置查询条件",
        editPopupTitle: "编辑查询字段"
      },
      searchPopup: {
        colTitle: "标题",
        saveBtn: "保存"
      }
    },
    text: {
      copySuccess: "已复制到剪贴板",
      copyError: "当前环境不支持该操作"
    },
    countdown: {
      formats: {
        yyyy: "年",
        MM: "月",
        dd: "天",
        HH: "时",
        mm: "分",
        ss: "秒"
      }
    },
    /**
     * 扩展插件
     */
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: "无法对合并单元格进行该操作",
          multiErr: "无法对多重选择区域进行该操作",
          extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
          pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作",
          cpInvalidErr: "该操作无法进行，您选择的区域中存在被禁止的列（{0}）"
        },
        fnr: {
          title: "查找和替换",
          findLabel: "查找",
          replaceLabel: "替换",
          findTitle: "查找内容：",
          replaceTitle: "替换为：",
          tabs: {
            find: "查找",
            replace: "替换"
          },
          filter: {
            re: "正则表达式",
            whole: "全词匹配",
            sensitive: "区分大小写"
          },
          btns: {
            findNext: "查找下一个",
            findAll: "查找全部",
            replace: "替换",
            replaceAll: "替换全部",
            cancel: "取消"
          },
          header: {
            seq: "#",
            cell: "单元格",
            value: "值"
          },
          empty: "(空值)",
          reError: "无效的正则表达式",
          recordCount: "已找到 {0} 个单元格",
          notCell: "找不到匹配的单元格",
          replaceSuccess: "成功替换 {0} 个单元格"
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧"
        },
        cases: {
          equal: "等于",
          gt: "大于",
          lt: "小于",
          begin: "开头是",
          endin: "结尾是",
          include: "包含",
          isSensitive: "区分大小写"
        }
      },
      filterCombination: {
        menus: {
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        cases: {
          equal: "等于",
          unequal: "不等于",
          gt: "大于",
          ge: "大于或等于",
          lt: "小于",
          le: "小于或等于",
          begin: "开头是",
          notbegin: "开头不是",
          endin: "结尾是",
          notendin: "结尾不是",
          include: "包含",
          exclude: "不包含",
          between: "介于",
          custom: "自定义筛选",
          insensitive: "不区分大小写",
          isSensitive: "区分大小写"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    },
    /**
     * 以下废弃
     * @deprecated
     */
    pro: {
      area: {
        mergeErr: "无法对合并单元格进行该操作",
        multiErr: "无法对多重选择区域进行该操作",
        extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
        pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作"
      },
      fnr: {
        title: "查找和替换",
        findLabel: "查找",
        replaceLabel: "替换",
        findTitle: "查找内容：",
        replaceTitle: "替换为：",
        tabs: {
          find: "查找",
          replace: "替换"
        },
        filter: {
          re: "正则表达式",
          whole: "全词匹配",
          sensitive: "区分大小写"
        },
        btns: {
          findNext: "查找下一个",
          findAll: "查找全部",
          replace: "替换",
          replaceAll: "替换全部",
          cancel: "取消"
        },
        header: {
          seq: "#",
          cell: "单元格",
          value: "值"
        },
        empty: "(空值)",
        reError: "无效的正则表达式",
        recordCount: "已找到 {0} 个单元格",
        notCell: "找不到匹配的单元格",
        replaceSuccess: "成功替换 {0} 个单元格"
      }
    },
    renderer: {
      search: "搜索",
      cases: {
        equal: "等于",
        unequal: "不等于",
        gt: "大于",
        ge: "大于或等于",
        lt: "小于",
        le: "小于或等于",
        begin: "开头是",
        notbegin: "开头不是",
        endin: "结尾是",
        notendin: "结尾不是",
        include: "包含",
        exclude: "不包含",
        between: "介于",
        custom: "自定义筛选",
        insensitive: "不区分大小写",
        isSensitive: "区分大小写"
      },
      combination: {
        menus: {
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "锁定列",
          fixedGroup: "锁定组",
          cancelFixed: "取消锁定",
          fixedLeft: "锁定左侧",
          fixedRight: "锁定右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    }
  }
};

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/all.js
var components2 = [
  // 功能模块
  VxeTableFilterModule,
  VxeTableMenuModule,
  VxeTableEditModule,
  VxeTableExportModule,
  VxeTableKeyboardModule,
  VxeTableValidatorModule,
  VxeTableCustomModule,
  // 可选组件
  VxeIcon,
  VxeColumn,
  VxeColgroup,
  VxeGrid,
  VxeToolbar,
  VxePager,
  VxeCheckbox,
  VxeCheckboxGroup,
  VxeRadio,
  VxeRadioGroup,
  VxeRadioButton,
  VxeInput,
  VxeTextarea,
  VxeButton,
  VxeButtonGroup,
  VxeModal,
  VxeDrawer,
  VxeTooltip,
  VxeForm,
  VxeFormItem,
  VxeFormGather,
  VxeSelect,
  VxeOptgroup,
  VxeOption,
  VxeSwitch,
  VxeList,
  VxePulldown,
  // 核心
  VxeTable
];
setConfig({
  i18n: (key, args) => import_xe_utils62.default.toFormatString(import_xe_utils62.default.get(zh_CN_default, key), args)
});
function install(app, options) {
  if (import_xe_utils62.default.isPlainObject(options)) {
    setConfig(options);
    if (options.theme) {
      setTheme(options.theme);
    }
  }
  components2.forEach((component2) => component2.install(app));
}

// node_modules/.pnpm/vxe-table@4.6.25_vue@3.5.17_typescript@5.8.3_/node_modules/vxe-table/es/index.esm.js
var index_esm_default2 = all_exports;
export {
  Button,
  ButtonGroup,
  Checkbox,
  CheckboxGroup,
  Colgroup,
  Column,
  Custom,
  Drawer,
  Edit,
  Export,
  Filter,
  Form,
  FormGather,
  FormItem,
  Grid,
  Icon,
  Input,
  Keyboard,
  List,
  Menu,
  Modal,
  Optgroup,
  Option,
  Pager,
  Pulldown,
  Radio,
  RadioButton,
  RadioGroup,
  Select,
  Switch,
  Table,
  Textarea,
  Toolbar,
  Tooltip,
  VXETable,
  Validator,
  VxeButton,
  VxeButtonGroup,
  VxeCheckbox,
  VxeCheckboxGroup,
  VxeColgroup,
  VxeColumn,
  VxeDrawer,
  VxeForm,
  VxeFormGather,
  VxeFormItem,
  VxeGrid,
  VxeIcon,
  VxeInput,
  VxeList,
  VxeModal,
  VxeOptgroup,
  VxeOption,
  VxePager,
  VxePulldown,
  VxeRadio,
  VxeRadioButton,
  VxeRadioGroup,
  VxeSelect,
  VxeSwitch,
  VxeTable,
  VxeTableCustomModule,
  VxeTableEditModule,
  VxeTableExportModule,
  VxeTableFilterModule,
  VxeTableKeyboardModule,
  VxeTableMenuModule,
  VxeTableValidatorModule,
  VxeTextarea,
  VxeToolbar,
  VxeTooltip,
  VxeUI,
  _t,
  commands,
  component,
  config,
  index_esm_default2 as default,
  drawer,
  formats,
  getComponent,
  globalConfs,
  globalStore,
  hooks,
  install,
  interceptor,
  menus,
  modal,
  print,
  readLocalFile as readFile,
  renderer,
  saveLocalFile as saveFile,
  setConfig,
  setIcon,
  setup,
  t,
  tableVersion,
  use,
  v,
  validators,
  version
};
//# sourceMappingURL=vxe-table.js.map
