import { LogLevel, MockHttpItem, MockOptions, MockServerPluginOptions, MockWebsocketItem, ServerBuildOption } from "./types-DpbHkRjL.cjs";
import { CorsOptions } from "cors";
import { Server } from "node:http";
import { Alias, Connect } from "vite";
import { FSWatcher } from "chokidar";
import EventEmitter from "node:events";
import { Http2SecureServer } from "node:http2";

//#region src/core/logger.d.ts
interface Logger {
  debug: (msg: string, level?: boolean | LogLevel) => void;
  info: (msg: string, level?: boolean | LogLevel) => void;
  warn: (msg: string, level?: boolean | LogLevel) => void;
  error: (msg: string, level?: boolean | LogLevel) => void;
}
declare const logLevels: Record<LogLevel, number>;
declare function createLogger(prefix: string, defaultLevel?: LogLevel): Logger;
//#endregion
//#region src/core/resolvePluginOptions.d.ts
type ResolvedMockServerPluginOptions = Required<Omit<MockServerPluginOptions, "build" | "cors" | "wsPrefix" | "prefix">> & {
  context: string;
  logger: Logger;
  alias: Alias[];
  define: Record<string, any>;
  proxies: string[];
  wsProxies: string[];
  build: false | ServerBuildOption;
  cors: false | CorsOptions;
};
//#endregion
//#region src/core/mockCompiler.d.ts
/**
* mock配置加载器
*/
declare class MockCompiler extends EventEmitter {
  options: ResolvedMockServerPluginOptions;
  moduleCache: Map<string, MockOptions | MockHttpItem | MockWebsocketItem>;
  moduleDeps: Map<string, Set<string>>;
  cwd: string;
  mockWatcher: FSWatcher;
  depsWatcher: FSWatcher;
  moduleType: "cjs" | "esm";
  private _mockData;
  constructor(options: ResolvedMockServerPluginOptions);
  get mockData(): Record<string, MockOptions>;
  run(): void;
  private watchMockEntry;
  /**
  * 监听 mock文件依赖的本地文件变动，
  * mock依赖文件更新，mock文件也一并更新
  */
  private watchDeps;
  close(): void;
  private updateMockList;
  private updateModuleDeps;
  private loadMock;
}
//#endregion
//#region src/core/baseMiddleware.d.ts
interface BaseMiddlewareOptions {
  formidableOptions: MockServerPluginOptions["formidableOptions"];
  cookiesOptions: MockServerPluginOptions["cookiesOptions"];
  bodyParserOptions: MockServerPluginOptions["bodyParserOptions"];
  proxies: string[];
  logger: Logger;
  priority: MockServerPluginOptions["priority"];
}
declare function baseMiddleware(compiler: MockCompiler, {
  formidableOptions,
  bodyParserOptions,
  proxies,
  cookiesOptions,
  logger,
  priority
}: BaseMiddlewareOptions): Connect.NextHandleFunction;
//#endregion
//#region src/core/transform.d.ts
type MockRawData = MockOptions | MockHttpItem | MockWebsocketItem | Record<string, MockOptions | MockHttpItem | MockWebsocketItem>;
declare function transformRawData(raw: MockRawData, __filepath__: string): MockOptions | MockHttpItem | MockWebsocketItem;
declare function transformMockData(mockList: Map<string, MockHttpItem | MockWebsocketItem | MockOptions> | (MockHttpItem | MockWebsocketItem | MockOptions)[]): Record<string, MockOptions>;
declare function sortByValidator(mocks: MockOptions): (MockHttpItem | MockWebsocketItem)[];
//#endregion
//#region src/core/ws.d.ts
/**
* mock websocket
*/
declare function mockWebSocket(compiler: MockCompiler, server: Server | Http2SecureServer | null, {
  wsProxies: proxies,
  cookiesOptions,
  logger
}: ResolvedMockServerPluginOptions): void;
//#endregion
export { BaseMiddlewareOptions, Logger, baseMiddleware, createLogger, logLevels, mockWebSocket, sortByValidator, transformMockData, transformRawData };